commit_id,repo,filename,partition,PL,label,diff,commit_date,msg,MOD_DIFF,BPE_MOD_DIFF,ADD_DIFF,REM_DIFF,LOC_ADD,LOC_DEL,LOC_MOD,commit_repo,fix_list
7a29c8f38677d1c7474c979836562488f6bbadec,php/php-src,ext/fileinfo/libmagic/cdf.c,train,C,1,"['@@ -0,0 +1,1111 @@\n+/*-\n+ * Copyright (c) 2008 Christos Zoulas\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS\n+ * ``AS IS\'\' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS\n+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+/*\n+ * Parse composite document files, the format used in Microsoft Office\n+ * document files before they switched to zipped xml.\n+ * Info from: http://sc.openoffice.org/compdocfileformat.pdf\n+ */\n+\n+#include ""file.h""\n+\n+#ifndef lint\n+FILE_RCSID(""@(#)$File: cdf.c,v 1.17 2009/02/03 20:27:51 christos Exp $"")\n+#endif\n+\n+#include <assert.h>\n+#ifdef CDF_DEBUG\n+#include <err.h>\n+#endif\n+#include <stdlib.h>\n+\n+#ifdef PHP_WIN32\n+#include ""win32/unistd.h""\n+#else\n+#include <unistd.h>\n+#endif\n+\n+#include <string.h>\n+#include <time.h>\n+#include <ctype.h>\n+\n+#ifndef EFTYPE\n+#define EFTYPE EINVAL\n+#endif\n+\n+#include ""cdf.h""\n+\n+#ifndef __arraycount\n+#define __arraycount(a) (sizeof(a) / sizeof(a[0]))\n+#endif\n+\n+#ifdef CDF_DEBUG\n+#define DPRINTF(a) printf a\n+#else\n+#define DPRINTF(a)\n+#endif\n+\n+static union {\n+\tchar s[4];\n+\tuint32_t u;\n+} cdf_bo;\n+\n+#define NEED_SWAP\t(cdf_bo.u == (uint32_t)0x01020304)\n+\n+#define CDF_TOLE8(x)\t(NEED_SWAP ? cdf_tole8(x) : (uint64_t)(x))\n+#define CDF_TOLE4(x)\t(NEED_SWAP ? cdf_tole4(x) : (uint32_t)(x))\n+#define CDF_TOLE2(x)\t(NEED_SWAP ? cdf_tole2(x) : (uint16_t)(x))\n+\n+/*\n+ * swap a short\n+ */\n+uint16_t\n+cdf_tole2(uint16_t sv)\n+{\n+\tuint16_t rv;\n+\tuint8_t *s = (uint8_t *)(void *)&sv; \n+\tuint8_t *d = (uint8_t *)(void *)&rv; \n+\td[0] = s[1];\n+\td[1] = s[0];\n+\treturn rv;\n+}\n+\n+/*\n+ * swap an int\n+ */\n+uint32_t\n+cdf_tole4(uint32_t sv)\n+{\n+\tuint32_t rv;\n+\tuint8_t *s = (uint8_t *)(void *)&sv; \n+\tuint8_t *d = (uint8_t *)(void *)&rv; \n+\td[0] = s[3];\n+\td[1] = s[2];\n+\td[2] = s[1];\n+\td[3] = s[0];\n+\treturn rv;\n+}\n+\n+/*\n+ * swap a quad\n+ */\n+uint64_t\n+cdf_tole8(uint64_t sv)\n+{\n+\tuint64_t rv;\n+\tuint8_t *s = (uint8_t *)(void *)&sv; \n+\tuint8_t *d = (uint8_t *)(void *)&rv; \n+\td[0] = s[7];\n+\td[1] = s[6];\n+\td[2] = s[5];\n+\td[3] = s[4];\n+\td[4] = s[3];\n+\td[5] = s[2];\n+\td[6] = s[1];\n+\td[7] = s[0];\n+\treturn rv;\n+}\n+\n+#define CDF_UNPACK(a)\t\\\n+    (void)memcpy(&(a), &buf[len], sizeof(a)), len += sizeof(a)\n+#define CDF_UNPACKA(a)\t\\\n+    (void)memcpy((a), &buf[len], sizeof(a)), len += sizeof(a)\n+\n+void\n+cdf_swap_header(cdf_header_t *h)\n+{\n+\tsize_t i;\n+\n+\th->h_magic = CDF_TOLE8(h->h_magic);\n+\th->h_uuid[0] = CDF_TOLE8(h->h_uuid[0]);\n+\th->h_uuid[1] = CDF_TOLE8(h->h_uuid[1]);\n+\th->h_revision = CDF_TOLE2(h->h_revision);\n+\th->h_version = CDF_TOLE2(h->h_version);\n+\th->h_byte_order = CDF_TOLE2(h->h_byte_order);\n+\th->h_sec_size_p2 = CDF_TOLE2(h->h_sec_size_p2);\n+\th->h_short_sec_size_p2 = CDF_TOLE2(h->h_short_sec_size_p2);\n+\th->h_num_sectors_in_sat = CDF_TOLE4(h->h_num_sectors_in_sat);\n+\th->h_secid_first_directory = CDF_TOLE4(h->h_secid_first_directory);\n+\th->h_min_size_standard_stream =\n+\t    CDF_TOLE4(h->h_min_size_standard_stream);\n+\th->h_secid_first_sector_in_short_sat =\n+\t    CDF_TOLE4(h->h_secid_first_sector_in_short_sat);\n+\th->h_num_sectors_in_short_sat =\n+\t    CDF_TOLE4(h->h_num_sectors_in_short_sat);\n+\th->h_secid_first_sector_in_master_sat =\n+\t    CDF_TOLE4(h->h_secid_first_sector_in_master_sat);\n+\th->h_num_sectors_in_master_sat =\n+\t    CDF_TOLE4(h->h_num_sectors_in_master_sat);\n+\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n+\t\th->h_master_sat[i] = CDF_TOLE4(h->h_master_sat[i]);\n+}\n+\n+void\n+cdf_unpack_header(cdf_header_t *h, char *buf)\n+{\n+\tsize_t i;\n+\tsize_t len = 0;\n+\n+\tCDF_UNPACK(h->h_magic);\n+\tCDF_UNPACKA(h->h_uuid);\n+\tCDF_UNPACK(h->h_revision);\n+\tCDF_UNPACK(h->h_version);\n+\tCDF_UNPACK(h->h_byte_order);\n+\tCDF_UNPACK(h->h_sec_size_p2);\n+\tCDF_UNPACK(h->h_short_sec_size_p2);\n+\tCDF_UNPACKA(h->h_unused0);\n+\tCDF_UNPACK(h->h_num_sectors_in_sat);\n+\tCDF_UNPACK(h->h_secid_first_directory);\n+\tCDF_UNPACKA(h->h_unused1);\n+\tCDF_UNPACK(h->h_min_size_standard_stream);\n+\tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);\n+\tCDF_UNPACK(h->h_num_sectors_in_short_sat);\n+\tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);\n+\tCDF_UNPACK(h->h_num_sectors_in_master_sat);\n+\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n+\t\tCDF_UNPACK(h->h_master_sat[i]);\n+}\n+\n+void\n+cdf_swap_dir(cdf_directory_t *d)\n+{\n+\td->d_namelen = CDF_TOLE2(d->d_namelen);\n+\td->d_left_child = CDF_TOLE4(d->d_left_child);\n+\td->d_right_child = CDF_TOLE4(d->d_right_child);\n+\td->d_storage = CDF_TOLE4(d->d_storage);\n+\td->d_storage_uuid[0] = CDF_TOLE8(d->d_storage_uuid[0]);\n+\td->d_storage_uuid[1] = CDF_TOLE8(d->d_storage_uuid[1]);\n+\td->d_flags = CDF_TOLE4(d->d_flags);\n+\td->d_created = CDF_TOLE8(d->d_created);\n+\td->d_modified = CDF_TOLE8(d->d_modified);\n+\td->d_stream_first_sector = CDF_TOLE4(d->d_stream_first_sector);\n+\td->d_size = CDF_TOLE4(d->d_size);\n+}\n+\n+void\n+cdf_swap_class(cdf_classid_t *d)\n+{\n+\td->cl_dword = CDF_TOLE4(d->cl_dword);\n+\td->cl_word[0] = CDF_TOLE2(d->cl_word[0]);\n+\td->cl_word[1] = CDF_TOLE2(d->cl_word[1]);\n+}\n+\n+void\n+cdf_unpack_dir(cdf_directory_t *d, char *buf)\n+{\n+\tsize_t len = 0;\n+\n+\tCDF_UNPACKA(d->d_name);\n+\tCDF_UNPACK(d->d_namelen);\n+\tCDF_UNPACK(d->d_type);\n+\tCDF_UNPACK(d->d_color);\n+\tCDF_UNPACK(d->d_left_child);\n+\tCDF_UNPACK(d->d_right_child);\n+\tCDF_UNPACK(d->d_storage);\n+\tCDF_UNPACKA(d->d_storage_uuid);\n+\tCDF_UNPACK(d->d_flags);\n+\tCDF_UNPACK(d->d_created);\n+\tCDF_UNPACK(d->d_modified);\n+\tCDF_UNPACK(d->d_stream_first_sector);\n+\tCDF_UNPACK(d->d_size);\n+\tCDF_UNPACK(d->d_unused0);\n+}\n+\n+int\n+cdf_read_header(int fd, cdf_header_t *h)\n+{\n+\tchar buf[512];\n+\t(void)memcpy(cdf_bo.s, ""\\01\\02\\03\\04"", 4);\n+\tif (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1)\n+\t\treturn -1;\n+\tif (read(fd, buf, sizeof(buf)) != sizeof(buf))\n+\t\treturn -1;\n+\tcdf_unpack_header(h, buf);\n+\tcdf_swap_header(h);\n+\tif (h->h_magic != CDF_MAGIC) {\n+\t\tDPRINTF((""Bad magic 0x%x != 0x$x\\n"", h->h_magic, CDF_MAGIC));\n+\t\terrno = EFTYPE;\n+\t\treturn -1;\n+\t}\n+\treturn 0;\n+}\n+\n+\n+ssize_t\n+cdf_read_sector(int fd, void *buf, size_t offs, size_t len,\n+    const cdf_header_t *h, cdf_secid_t id)\n+{\n+\tassert((size_t)CDF_SEC_SIZE(h) == len);\n+\tif (lseek(fd, (off_t)CDF_SEC_POS(h, id), SEEK_SET) == (off_t)-1)\n+\t\treturn -1;\n+\treturn read(fd, ((char *)buf) + offs, len);\n+}\n+\n+ssize_t\n+cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n+    size_t len, const cdf_header_t *h, cdf_secid_t id)\n+{\n+\tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);\n+\t(void)memcpy(((char *)buf) + offs,\n+\t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);\n+\treturn len;\n+}\n+\n+/*\n+ * Read the sector allocation table.\n+ */\n+int\n+cdf_read_sat(int fd, cdf_header_t *h, cdf_sat_t *sat)\n+{\n+\tsize_t i, j, k;\n+\tsize_t ss = CDF_SEC_SIZE(h);\n+\tcdf_secid_t *msa, mid;\n+\n+\tfor (i = 0; i < __arraycount(h->h_master_sat); i++)\n+\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n+\t\t\tbreak;\n+\n+\tsat->sat_len = (h->h_num_sectors_in_master_sat + i);\n+\tif ((sat->sat_tab = calloc(sat->sat_len, ss)) == NULL)\n+\t\treturn -1;\n+\n+\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n+\t\tif (h->h_master_sat[i] < 0)\n+\t\t\tbreak;\n+\t\tif (cdf_read_sector(fd, sat->sat_tab, ss * i, ss, h,\n+\t\t    h->h_master_sat[i]) != (ssize_t)ss) {\n+\t\t\tDPRINTF((""Reading sector %d"", h->h_master_sat[i]));\n+\t\t\tgoto out1;\n+\t\t}\n+\t}\n+\n+\tif ((msa = calloc(1, ss)) == NULL)\n+\t\tgoto out1;\n+\n+\tmid = h->h_secid_first_sector_in_master_sat;\n+\tfor (j = 0; j < h->h_num_sectors_in_master_sat; j++) {\n+\t\tif (j >= CDF_LOOP_LIMIT) {\n+\t\t\tDPRINTF((""Reading master sector loop limit""));\n+\t\t\terrno = EFTYPE;\n+\t\t\tgoto out2;\n+\t\t}\n+\t\tif (cdf_read_sector(fd, msa, 0, ss, h, mid) != (ssize_t)ss) {\n+\t\t\tDPRINTF((""Reading master sector %d"", mid));\n+\t\t\tgoto out2;\n+\t\t}\n+\t\tfor (k = 0; k < (ss / sizeof(mid)) - 1; k++, i++)\n+\t\t\tif (cdf_read_sector(fd, sat->sat_tab, ss * i, ss, h,\n+\t\t\t    CDF_TOLE4(msa[k])) != (ssize_t)ss) {\n+\t\t\t\tDPRINTF((""Reading sector %d"",\n+\t\t\t\t    CDF_TOLE4(msa[k])));\n+\t\t\t\tgoto out2;\n+\t\t\t}\n+\t\tmid = CDF_TOLE4(msa[(ss / sizeof(mid)) - 1]);\n+\t}\n+\tfree(msa);\n+\treturn 0;\n+out2:\n+\tfree(msa);\n+out1:\n+\tfree(sat->sat_tab);\n+\treturn -1;\n+}\n+\n+size_t\n+cdf_count_chain(const cdf_header_t *h, const cdf_sat_t *sat,\n+    cdf_secid_t sid)\n+{\n+\tsize_t i, j, s = CDF_SEC_SIZE(h) / sizeof(cdf_secid_t);\n+\tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * s);\n+\n+\tDPRINTF((""Chain:""));\n+\tfor (j = i = 0; sid >= 0; i++, j++) {\n+\t\tDPRINTF(("" %d"", sid));\n+\t\tif (j >= CDF_LOOP_LIMIT) {\n+\t\t\tDPRINTF((""Counting chain loop limit""));\n+\t\t\terrno = EFTYPE;\n+\t\t\treturn (size_t)-1;\n+\t\t}\n+\t\tif (sid > maxsector) {\n+\t\t\tDPRINTF((""Sector %d > %d\\n"", sid, maxsector));\n+\t\t\terrno = EFTYPE;\n+\t\t\treturn (size_t)-1;\n+\t\t}\n+\t\tsid = CDF_TOLE4(sat->sat_tab[sid]);\n+\t}\n+\tDPRINTF((""\\n""));\n+\treturn i;\n+}\n+\n+int\n+cdf_read_long_sector_chain(int fd, const cdf_header_t *h, const cdf_sat_t *sat,\n+    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n+{\n+\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n+\tssize_t nr;\n+\tscn->sst_len = cdf_count_chain(h, sat, sid);\n+\tscn->sst_dirlen = len;\n+\n+\tif (scn->sst_len == (size_t)-1)\n+\t\treturn -1;\n+\n+\tscn->sst_tab = calloc(scn->sst_len, ss);\n+\tif (scn->sst_tab == NULL)\n+\t\treturn -1;\n+\n+\tfor (j = i = 0; sid >= 0; i++, j++) {\n+\t\tif ((nr = cdf_read_sector(fd, scn->sst_tab, i * ss, ss, h,\n+\t\t    sid)) != (ssize_t)ss) {\n+\t\t\tif (i == scn->sst_len - 1 && nr > 0) {\n+\t\t\t\t/* Last sector might be truncated */\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t\tDPRINTF((""Reading long sector chain %d"", sid));\n+\t\t\tgoto out;\n+\t\t}\n+\t\tsid = CDF_TOLE4(sat->sat_tab[sid]);\n+\t\tif (j >= CDF_LOOP_LIMIT) {\n+\t\t\tDPRINTF((""Read long sector chain loop limit""));\n+\t\t\terrno = EFTYPE;\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\treturn 0;\n+out:\n+\tfree(scn->sst_tab);\n+\treturn (size_t)-1;\n+}\n+\n+int\n+cdf_read_short_sector_chain(const cdf_header_t *h,\n+    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n+    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n+{\n+\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n+\tscn->sst_len = cdf_count_chain(h, ssat, sid);\n+\tscn->sst_dirlen = len;\n+\n+\tif (scn->sst_len == (size_t)-1)\n+\t\treturn -1;\n+\n+\tscn->sst_tab = calloc(scn->sst_len, ss);\n+\tif (scn->sst_tab == NULL)\n+\t\treturn -1;\n+\n+\tfor (j = i = 0; sid >= 0; i++, j++) {\n+\t\tif (j >= CDF_LOOP_LIMIT) {\n+\t\t\tDPRINTF((""Read short sector chain loop limit""));\n+\t\t\terrno = EFTYPE;\n+\t\t\tgoto out;\n+\t\t}\n+\t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,\n+\t\t    sid) != (ssize_t)ss) {\n+\t\t\tDPRINTF((""Reading short sector chain %d"", sid));\n+\t\t\tgoto out;\n+\t\t}\n+\t\tsid = CDF_TOLE4(ssat->sat_tab[sid]);\n+\t}\n+\treturn 0;\n+out:\n+\tfree(scn->sst_tab);\n+\treturn (size_t)-1;\n+}\n+\n+int\n+cdf_read_sector_chain(int fd, const cdf_header_t *h, const cdf_sat_t *sat,\n+    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n+    cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n+{\n+\n+\tif (len < h->h_min_size_standard_stream)\n+\t\treturn cdf_read_short_sector_chain(h, ssat, sst, sid, len,\n+\t\t    scn);\n+\telse\n+\t\treturn cdf_read_long_sector_chain(fd, h, sat, sid, len, scn);\n+}\n+\n+int\n+cdf_read_dir(int fd, const cdf_header_t *h, const cdf_sat_t *sat,\n+    cdf_dir_t *dir)\n+{\n+\tsize_t i, j;\n+\tsize_t ss = CDF_SEC_SIZE(h), ns, nd;\n+\tchar *buf;\n+\tcdf_secid_t sid = h->h_secid_first_directory;\n+\n+\tns = cdf_count_chain(h, sat, sid);\n+\tif (ns == (size_t)-1)\n+\t\treturn -1;\n+\n+\tnd = ss / CDF_DIRECTORY_SIZE;\n+\n+\tdir->dir_len = ns * nd;\n+\tdir->dir_tab = calloc(dir->dir_len, sizeof(dir->dir_tab[0]));\n+\tif (dir->dir_tab == NULL)\n+\t\treturn -1;\n+\n+\tif ((buf = malloc(ss)) == NULL) {\n+\t\tfree(dir->dir_tab);\n+\t\treturn -1;\n+\t}\n+\n+\tfor (j = i = 0; i < ns; i++, j++) {\n+\t\tif (j >= CDF_LOOP_LIMIT) {\n+\t\t\tDPRINTF((""Read dir loop limit""));\n+\t\t\terrno = EFTYPE;\n+\t\t\tgoto out;\n+\t\t}\n+\t\tif (cdf_read_sector(fd, buf, 0, ss, h, sid) != (ssize_t)ss) {\n+\t\t\tDPRINTF((""Reading directory sector %d"", sid));\n+\t\t\tgoto out;\n+\t\t}\n+\t\tfor (j = 0; j < nd; j++) {\n+\t\t\tcdf_unpack_dir(&dir->dir_tab[i * nd + j],\n+\t\t\t    &buf[j * CDF_DIRECTORY_SIZE]);\n+\t\t}\n+\t\tsid = CDF_TOLE4(sat->sat_tab[sid]);\n+\t}\n+\tif (NEED_SWAP)\n+\t\tfor (i = 0; i < dir->dir_len; i++)\n+\t\t\tcdf_swap_dir(&dir->dir_tab[i]);\n+\tfree(buf);\n+\treturn 0;\n+out:\n+\tfree(dir->dir_tab);\n+\tfree(buf);\n+\treturn -1;\n+}\n+\n+\n+int\n+cdf_read_ssat(int fd, const cdf_header_t *h, const cdf_sat_t *sat,\n+    cdf_sat_t *ssat)\n+{\n+\tsize_t i, j;\n+\tsize_t ss = CDF_SEC_SIZE(h);\n+\tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;\n+\n+\tssat->sat_len = cdf_count_chain(h, sat, sid);\n+\tif (ssat->sat_len == (size_t)-1)\n+\t\treturn -1;\n+\n+\tssat->sat_tab = calloc(ssat->sat_len, ss);\n+\tif (ssat->sat_tab == NULL)\n+\t\treturn -1;\n+\n+\tfor (j = i = 0; sid >= 0; i++, j++) {\n+\t\tif (j >= CDF_LOOP_LIMIT) {\n+\t\t\tDPRINTF((""Read short sat sector loop limit""));\n+\t\t\terrno = EFTYPE;\n+\t\t\tgoto out;\n+\t\t}\n+\t\tif (cdf_read_sector(fd, ssat->sat_tab, i * ss, ss, h, sid) !=\n+\t\t    (ssize_t)ss) {\n+\t\t\tDPRINTF((""Reading short sat sector %d"", sid));\n+\t\t\tgoto out;\n+\t\t}\n+\t\tsid = CDF_TOLE4(sat->sat_tab[sid]);\n+\t}\n+\treturn 0;\n+out:\n+\tfree(ssat->sat_tab);\n+\treturn -1;\n+}\n+\n+int\n+cdf_read_short_stream(int fd, const cdf_header_t *h, const cdf_sat_t *sat,\n+    const cdf_dir_t *dir, cdf_stream_t *scn)\n+{\n+\tsize_t i;\n+\tconst cdf_directory_t *d;\n+\n+\tfor (i = 0; i < dir->dir_len; i++)\n+\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)\n+\t\t\tbreak;\n+\n+\tif (i == dir->dir_len) {\n+\t\tDPRINTF((""Cannot find root storage node\\n""));\n+\t\terrno = EFTYPE;\n+\t\treturn -1;\n+\t}\n+\td = &dir->dir_tab[i];\n+\n+\t/* If the it is not there, just fake it; some docs don\'t have it */\n+\tif (d->d_stream_first_sector < 0) {\n+\t\tscn->sst_tab = NULL;\n+\t\tscn->sst_len = 0;\n+\t\treturn 0;\n+\t}\n+\n+\treturn  cdf_read_long_sector_chain(fd, h, sat,\n+\t    d->d_stream_first_sector, d->d_size, scn);\n+}\n+\n+static int\n+cdf_namecmp(const char *d, const uint16_t *s, size_t l)\n+{\n+\tfor (; l--; d++, s++)\n+\t\tif (*d != CDF_TOLE2(*s))\n+\t\t\treturn (unsigned char)*d - CDF_TOLE2(*s);\n+\treturn 0;\n+}\n+\n+int\n+cdf_read_summary_info(int fd, const cdf_header_t *h,\n+    const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,\n+    const cdf_dir_t *dir, cdf_stream_t *scn)\n+{\n+\tsize_t i;\n+\tconst cdf_directory_t *d;\n+\tstatic const char name[] = ""\\05SummaryInformation"";\n+\n+\tfor (i = 0; i < dir->dir_len; i++)\n+\t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_USER_STREAM &&\n+\t\t    cdf_namecmp(name, dir->dir_tab[i].d_name, sizeof(name))\n+\t\t    == 0)\n+\t\t\tbreak;\n+\n+\tif (i == dir->dir_len) {\n+\t\tDPRINTF((""Cannot find summary information section\\n""));\n+\t\terrno = EFTYPE;\n+\t\treturn -1;\n+\t}\n+\td = &dir->dir_tab[i];\n+\treturn cdf_read_sector_chain(fd, h, sat, ssat, sst,\n+\t    d->d_stream_first_sector, d->d_size, scn);\n+}\n+\n+int\n+cdf_read_property_info(const cdf_stream_t *sst, uint32_t offs,\n+    cdf_property_info_t **info, size_t *count, size_t *maxcount)\n+{\n+\tconst cdf_section_header_t *shp;\n+\tcdf_section_header_t sh;\n+\tconst uint32_t *p, *q, *e;\n+\tint16_t s16;\n+\tint32_t s32;\n+\tuint32_t u32;\n+\tint64_t s64;\n+\tuint64_t u64;\n+\tcdf_timestamp_t tp;\n+\tsize_t i, o, nelements, j;\n+\tcdf_property_info_t *inp;\n+\n+\tshp = (const void *)((const char *)sst->sst_tab + offs);\n+\tsh.sh_len = CDF_TOLE4(shp->sh_len);\n+\tsh.sh_properties = CDF_TOLE4(shp->sh_properties);\n+\tDPRINTF((""section len: %d properties %d\\n"", sh.sh_len,\n+\t    sh.sh_properties));\n+\tif (*maxcount) {\n+\t\t*maxcount += sh.sh_properties;\n+\t\tinp = realloc(*info, *maxcount * sizeof(*inp));\n+\t} else {\n+\t\t*maxcount = sh.sh_properties;\n+\t\tinp = malloc(*maxcount * sizeof(*inp));\n+\t}\n+\tif (inp == NULL)\n+\t\tgoto out;\n+\t*info = inp;\n+\tinp += *count;\n+\t*count += sh.sh_properties;\n+\tp = (const void *)((const char *)sst->sst_tab + offs + sizeof(sh));\n+\te = (const void *)(((const char *)shp) + sh.sh_len);\n+\tfor (i = 0; i < sh.sh_properties; i++) {\n+\t\tq = (const uint32_t *)((const char *)p +\n+\t\t    CDF_TOLE4(p[(i << 1) + 1])) - 2;\n+\t\tif (q > e) {\n+\t\t\tDPRINTF((""Ran of the end %p > %p\\n"", q, e));\n+\t\t\tgoto out;\n+\t\t}\n+\t\tinp[i].pi_id = CDF_TOLE4(p[i << 1]);\n+\t\tinp[i].pi_type = CDF_TOLE4(q[0]);\n+\t\tDPRINTF((""%d) id=%x type=%x offs=%x\\n"", i, inp[i].pi_id,\n+\t\t    inp[i].pi_type, (const char *)q - (const char *)p));\n+\t\tif (inp[i].pi_type & CDF_VECTOR) {\n+\t\t\tnelements = CDF_TOLE4(q[1]);\n+\t\t\to = 2;\n+\t\t} else {\n+\t\t\tnelements = 1;\n+\t\t\to = 1;\n+\t\t}\n+\t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))\n+\t\t\tgoto unknown;\n+\t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {\n+\t\tcase CDF_EMPTY:\n+\t\t\tbreak;\n+\t\tcase CDF_SIGNED16:\n+\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n+\t\t\t\tgoto unknown;\n+\t\t\t(void)memcpy(&s16, &q[o], sizeof(s16));\n+\t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);\n+\t\t\tbreak;\n+\t\tcase CDF_SIGNED32:\n+\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n+\t\t\t\tgoto unknown;\n+\t\t\t(void)memcpy(&s32, &q[o], sizeof(s32));\n+\t\t\tinp[i].pi_s32 = CDF_TOLE4(s32);\n+\t\t\tbreak;\n+\t\tcase CDF_BOOL:\n+\t\tcase CDF_UNSIGNED32:\n+\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n+\t\t\t\tgoto unknown;\n+\t\t\t(void)memcpy(&u32, &q[o], sizeof(u32));\n+\t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);\n+\t\t\tbreak;\n+\t\tcase CDF_SIGNED64:\n+\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n+\t\t\t\tgoto unknown;\n+\t\t\t(void)memcpy(&s64, &q[o], sizeof(s64));\n+\t\t\tinp[i].pi_s64 = CDF_TOLE4(s64);\n+\t\t\tbreak;\n+\t\tcase CDF_UNSIGNED64:\n+\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n+\t\t\t\tgoto unknown;\n+\t\t\t(void)memcpy(&u64, &q[o], sizeof(u64));\n+\t\t\tinp[i].pi_u64 = CDF_TOLE4(u64);\n+\t\t\tbreak;\n+\t\tcase CDF_LENGTH32_STRING:\n+\t\t\tif (nelements > 1) {\n+\t\t\t\tsize_t nelem = inp - *info;\n+\t\t\t\t*maxcount += nelements;\n+\t\t\t\tinp = realloc(*info, *maxcount * sizeof(*inp));\n+\t\t\t\tif (inp == NULL)\n+\t\t\t\t\tgoto out;\n+\t\t\t\t*info = inp;\n+\t\t\t\tinp = *info + nelem;\n+\t\t\t}\n+\t\t\tDPRINTF((""nelements = %d\\n"", nelements));\n+\t\t\tfor (j = 0; j < nelements; j++, i++) {\n+\t\t\t\tuint32_t l = CDF_TOLE4(q[o]);\n+\t\t\t\tinp[i].pi_str.s_len = l;\n+\t\t\t\tinp[i].pi_str.s_buf = (const char *)(&q[o+1]);\n+\t\t\t\tDPRINTF((""l = %d, r = %d, s = %s\\n"", l,\n+\t\t\t\t    CDF_ROUND(l, sizeof(l)),\n+\t\t\t\t    inp[i].pi_str.s_buf));\n+\t\t\t\tl = 4 + CDF_ROUND(l, sizeof(l));\n+\t\t\t\to += l >> 2;\n+\t\t\t}\n+\t\t\ti--;\n+\t\t\tbreak;\n+\t\tcase CDF_FILETIME:\n+\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n+\t\t\t\tgoto unknown;\n+\t\t\t(void)memcpy(&tp, &q[o], sizeof(tp));\n+\t\t\tinp[i].pi_tp = CDF_TOLE8(tp);\n+\t\t\tbreak;\n+\t\tcase CDF_CLIPBOARD:\n+\t\t\tif (inp[i].pi_type & CDF_VECTOR)\n+\t\t\t\tgoto unknown;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\tunknown:\n+\t\t\tDPRINTF((""Don\'t know how to deal with %x\\n"",\n+\t\t\t    inp[i].pi_type));\n+\t\t\tgoto out;\n+\t\t}\n+\t}\n+\treturn 0;\n+out:\n+\tfree(*info);\n+\treturn -1;\n+}\n+\n+int\n+cdf_unpack_summary_info(const cdf_stream_t *sst, cdf_summary_info_header_t *ssi,\n+    cdf_property_info_t **info, size_t *count)\n+{\n+\tsize_t i, maxcount;\n+\tconst cdf_summary_info_header_t *si = sst->sst_tab;\n+\tconst cdf_section_declaration_t *sd = (const void *)\n+\t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET);\n+\n+\tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);\n+\tssi->si_os_version = CDF_TOLE2(si->si_os_version);\n+\tssi->si_os = CDF_TOLE2(si->si_os);\n+\tssi->si_class = si->si_class;\n+\tcdf_swap_class(&ssi->si_class);\n+\tssi->si_count = CDF_TOLE2(si->si_count);\n+\t*count = 0;\n+\tmaxcount = 0;\n+\t*info = NULL;\n+\tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {\n+\t\tif (i >= CDF_LOOP_LIMIT) {\n+\t\t\tDPRINTF((""Unpack summary info loop limit""));\n+\t\t\terrno = EFTYPE;\n+\t\t\treturn -1;\n+\t\t}\n+\t\tif (cdf_read_property_info(sst, CDF_TOLE4(sd->sd_offset),\n+\t\t    info, count, &maxcount) == -1)\n+\t\t\treturn -1;\n+\t}\n+\treturn 0;\n+}\n+\n+\n+\n+int\n+cdf_print_classid(char *buf, size_t buflen, const cdf_classid_t *id)\n+{\n+\treturn snprintf(buf, buflen, ""%.8x-%.4x-%.4x-%.2x%.2x-""\n+\t    ""%.2x%.2x%.2x%.2x%.2x%.2x"", id->cl_dword, id->cl_word[0],\n+\t    id->cl_word[1], id->cl_two[0], id->cl_two[1], id->cl_six[0],\n+\t    id->cl_six[1], id->cl_six[2], id->cl_six[3], id->cl_six[4],\n+\t    id->cl_six[5]);\n+}\n+\n+static const struct {\n+\tuint32_t v;\n+\tconst char *n;\n+} vn[] = {\n+\t{ CDF_PROPERTY_CODE_PAGE, ""Code page"" },\n+\t{ CDF_PROPERTY_TITLE, ""Title"" },\n+\t{ CDF_PROPERTY_SUBJECT, ""Subject"" },\n+\t{ CDF_PROPERTY_AUTHOR, ""Author"" },\n+\t{ CDF_PROPERTY_KEYWORDS, ""Keywords"" },\n+\t{ CDF_PROPERTY_COMMENTS, ""Comments"" },\n+\t{ CDF_PROPERTY_TEMPLATE, ""Template"" },\n+\t{ CDF_PROPERTY_LAST_SAVED_BY, ""Last Saved By"" },\n+\t{ CDF_PROPERTY_REVISION_NUMBER, ""Revision Number"" },\n+\t{ CDF_PROPERTY_TOTAL_EDITING_TIME, ""Total Editing Time"" },\n+\t{ CDF_PROPERTY_LAST_PRINTED, ""Last Printed"" },\n+\t{ CDF_PROPERTY_CREATE_TIME, ""Create Time/Date"" },\n+\t{ CDF_PROPERTY_LAST_SAVED_TIME, ""Last Saved Time/Date"" },\n+\t{ CDF_PROPERTY_NUMBER_OF_PAGES, ""Number of Pages"" },\n+\t{ CDF_PROPERTY_NUMBER_OF_WORDS, ""Number of Words"" },\n+\t{ CDF_PROPERTY_NUMBER_OF_CHARACTERS, ""Number of Characters"" },\n+\t{ CDF_PROPERTY_THUMBNAIL, ""Thumbnail"" },\n+\t{ CDF_PROPERTY_NAME_OF_APPLICATION, ""Name of Creating Application"" },\n+\t{ CDF_PROPERTY_SECURITY, ""Security"" },\n+\t{ CDF_PROPERTY_LOCALE_ID, ""Locale ID"" },\n+};\n+\n+int\n+cdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)\n+{\n+\tsize_t i;\n+\n+\tfor (i = 0; i < __arraycount(vn); i++)\n+\t\tif (vn[i].v == p)\n+\t\t\treturn snprintf(buf, bufsiz, ""%s"", vn[i].n);\n+\treturn snprintf(buf, bufsiz, ""0x%x"", p);\n+}\n+\n+int\n+cdf_print_elapsed_time(char *buf, size_t bufsiz, cdf_timestamp_t ts)\n+{\n+\tsize_t len = 0;\n+\tint days, hours, mins, secs;\n+\n+\tts /= CDF_TIME_PREC;\n+\tsecs = ts % 60;\n+\tts /= 60;\n+\tmins = ts % 60;\n+\tts /= 60;\n+\thours = ts % 24;\n+\tts /= 24;\n+\tdays = ts;\n+\n+\tif (days) {\n+\t\tlen += snprintf(buf + len, bufsiz - len, ""%dd+"", days);\n+\t\tif (len >= bufsiz)\n+\t\t\treturn len;\n+\t}\n+\n+\tif (days || hours) {\n+\t\tlen += snprintf(buf + len, bufsiz - len, ""%.2d:"", hours);\n+\t\tif (len >= bufsiz)\n+\t\t\treturn len;\n+\t}\n+\n+\tlen += snprintf(buf + len, bufsiz - len, ""%.2d:"", mins);\n+\tif (len >= bufsiz)\n+\t\treturn len;\n+\n+\tlen += snprintf(buf + len, bufsiz - len, ""%.2d"", secs);\n+\treturn len;\n+}\n+\n+\n+#ifdef CDF_DEBUG\n+void\n+cdf_dump_header(const cdf_header_t *h)\n+{\n+\tsize_t i;\n+\n+#define DUMP(a, b) printf(""%40.40s = "" a ""\\n"", # b, h->h_ ## b)\n+\tDUMP(""%d"", revision);\n+\tDUMP(""%d"", version);\n+\tDUMP(""0x%x"", byte_order);\n+\tDUMP(""%d"", sec_size_p2);\n+\tDUMP(""%d"", short_sec_size_p2);\n+\tDUMP(""%d"", num_sectors_in_sat);\n+\tDUMP(""%d"", secid_first_directory);\n+\tDUMP(""%d"", min_size_standard_stream);\n+\tDUMP(""%d"", secid_first_sector_in_short_sat);\n+\tDUMP(""%d"", num_sectors_in_short_sat);\n+\tDUMP(""%d"", secid_first_sector_in_master_sat);\n+\tDUMP(""%d"", num_sectors_in_master_sat);\n+\tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {\n+\t\tif (h->h_master_sat[i] == CDF_SECID_FREE)\n+\t\t\tbreak;\n+\t\tprintf(""%35.35s[%.3zu] = %d\\n"",\n+\t\t    ""master_sat"", i, h->h_master_sat[i]);\n+\t}\n+}\n+\n+void\n+cdf_dump_sat(const char *prefix, const cdf_header_t *h, const cdf_sat_t *sat)\n+{\n+\tsize_t i, j, s = CDF_SEC_SIZE(h) / sizeof(cdf_secid_t);\n+\n+\tfor (i = 0; i < sat->sat_len; i++) {\n+\t\tprintf(""%s[%zu]:\\n"", prefix, i);\n+\t\tfor (j = 0; j < s; j++) {\n+\t\t\tprintf(""%5d, "", CDF_TOLE4(sat->sat_tab[s * i + j]));\n+\t\t\tif ((j + 1) % 10 == 0)\n+\t\t\t\tprintf(""\\n"");\n+\t\t}\n+\t\tprintf(""\\n"");\n+\t}\n+}\n+\n+void\n+cdf_dump(void *v, size_t len)\n+{\n+\tsize_t i, j;\n+\tunsigned char *p = v;\n+\tchar abuf[16];\n+\tprintf(""%.4x: "", 0);\n+\tfor (i = 0, j = 0; i < len; i++, p++) {\n+\t\tprintf(""%.2x "", *p);\n+\t\tabuf[j++] = isprint(*p) ? *p : \'.\';\n+\t\tif (j == 16) {\n+\t\t\tj = 0;\n+\t\t\tabuf[15] = \'\\0\';\n+\t\t\tprintf(""%s\\n%.4x: "", abuf, i + 1);\n+\t\t}\n+\t}\n+\tprintf(""\\n"");\n+}\n+\n+void\n+cdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)\n+{\n+\tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?\n+\t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);\n+\tcdf_dump(sst->sst_tab, ss * sst->sst_len);\n+}\n+\n+void\n+cdf_dump_dir(int fd, const cdf_header_t *h, const cdf_sat_t *sat,\n+    const cdf_sat_t *ssat, const cdf_stream_t *sst,\n+    const cdf_dir_t *dir)\n+{\n+\tsize_t i, j;\n+\tcdf_directory_t *d;\n+\tchar name[__arraycount(d->d_name)];\n+\tcdf_stream_t scn;\n+\tstruct timeval ts;\n+\n+\tstatic const char *types[] = { ""empty"", ""user storage"",\n+\t    ""user stream"", ""lockbytes"", ""property"", ""root storage"" };\n+\n+\tfor (i = 0; i < dir->dir_len; i++) {\n+\t\td = &dir->dir_tab[i];\n+\t\tfor (j = 0; j < sizeof(name); j++)\n+\t\t\tname[j] = (char)CDF_TOLE2(d->d_name[j]);\n+\t\tprintf(""Directory %zu: %s\\n"", i, name);\n+\t\tif (d->d_type < __arraycount(types))\n+\t\t\tprintf(""Type: %s\\n"", types[d->d_type]);\n+\t\telse\n+\t\t\tprintf(""Type: %d\\n"", d->d_type);\n+\t\tprintf(""Color: %s\\n"", d->d_color ? ""black"" : ""red"");\n+\t\tprintf(""Left child: %d\\n"", d->d_left_child);\n+\t\tprintf(""Right child: %d\\n"", d->d_right_child);\n+\t\tprintf(""Flags: 0x%x\\n"", d->d_flags);\n+\t\tcdf_timestamp_to_timespec(&ts, d->d_created);\n+\t\tprintf(""Created %s"", ctime(&ts.tv_sec));\n+\t\tcdf_timestamp_to_timespec(&ts, d->d_modified);\n+\t\tprintf(""Modified %s"", ctime(&ts.tv_sec));\n+\t\tprintf(""Stream %d\\n"", d->d_stream_first_sector);\n+\t\tprintf(""Size %d\\n"", d->d_size);\n+\t\tswitch (d->d_type) {\n+\t\tcase CDF_DIR_TYPE_USER_STORAGE:\n+\t\t\tprintf(""Storage: %d\\n"", d->d_storage);\n+\t\t\tbreak;\n+\t\tcase CDF_DIR_TYPE_USER_STREAM:\n+\t\t\tif (sst == NULL)\n+\t\t\t\tbreak;\n+\t\t\tif (cdf_read_sector_chain(fd, h, sat, ssat, sst,\n+\t\t\t    d->d_stream_first_sector, d->d_size, &scn) == -1) {\n+\t\t\t\twarn(""Can\'t read stream for %s at %d len %d"",\n+\t\t\t\t    name, d->d_stream_first_sector, d->d_size);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tcdf_dump_stream(h, &scn);\n+\t\t\tfree(scn.sst_tab);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tbreak;\n+\t\t}\n+\t\t\t\n+\t}\n+}\n+\n+void\n+cdf_dump_property_info(const cdf_property_info_t *info, size_t count)\n+{\n+\tcdf_timestamp_t tp;\n+\tstruct timeval ts;\n+\tchar buf[64];\n+\tsize_t i;\n+\n+\tfor (i = 0; i < count; i++) {\n+\t\tcdf_print_property_name(buf, sizeof(buf), info[i].pi_id);\n+\t\tprintf(""%zu) %s: "", i, buf); \n+\t\tswitch (info[i].pi_type) {\n+\t\tcase CDF_SIGNED16:\n+\t\t\tprintf(""signed 16 [%hd]\\n"", info[i].pi_s16);\n+\t\t\tbreak;\n+\t\tcase CDF_SIGNED32:\n+\t\t\tprintf(""signed 32 [%d]\\n"", info[i].pi_s32);\n+\t\t\tbreak;\n+\t\tcase CDF_UNSIGNED32:\n+\t\t\tprintf(""unsigned 32 [%u]\\n"", info[i].pi_u32);\n+\t\t\tbreak;\n+\t\tcase CDF_LENGTH32_STRING:\n+\t\t\tprintf(""string %u [%.*s]\\n"", info[i].pi_str.s_len,\n+\t\t\t    info[i].pi_str.s_len, info[i].pi_str.s_buf);\n+\t\t\tbreak;\n+\t\tcase CDF_FILETIME:\n+\t\t\ttp = info[i].pi_tp;\n+\t\t\tif (tp < 1000000000000000LL) {\n+\t\t\t\tcdf_print_elapsed_time(buf, sizeof(buf), tp);\n+\t\t\t\tprintf(""timestamp %s\\n"", buf);\n+\t\t\t} else {\n+\t\t\t\tcdf_timestamp_to_timespec(&ts, tp);\n+\t\t\t\tprintf(""timestamp %s"", ctime(&ts.tv_sec));\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase CDF_CLIPBOARD:\n+\t\t\tprintf(""CLIPBOARD %u\\n"", info[i].pi_u32);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tDPRINTF((""Don\'t know how to deal with %x\\n"",\n+\t\t\t    info[i].pi_type));\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+}\n+\n+\n+void\n+cdf_dump_summary_info(const cdf_header_t *h, const cdf_stream_t *sst)\n+{\n+\tchar buf[128];\n+\tcdf_summary_info_header_t ssi;\n+\tcdf_property_info_t *info;\n+\tsize_t count;\n+\n+\t(void)&h;\n+\tif (cdf_unpack_summary_info(sst, &ssi, &info, &count) == -1)\n+\t\treturn;\n+\tprintf(""Endian: %x\\n"", ssi.si_byte_order);\n+\tprintf(""Os Version %d.%d\\n"", ssi.si_os_version & 0xff,\n+\t\tssi.si_os_version >> 8);\n+\tprintf(""Os %d\\n"", ssi.si_os);\n+\tcdf_print_classid(buf, sizeof(buf), &ssi.si_class);\n+\tprintf(""Class %s\\n"", buf);\n+\tprintf(""Count %d\\n"", ssi.si_count);\n+\tcdf_dump_property_info(info, count);\n+\tfree(info);\n+}\n+\n+#endif\n+\n+#ifdef TEST\n+int\n+main(int argc, char *argv[])\n+{\n+\tint fd, i;\n+\tcdf_header_t h;\n+\tcdf_sat_t sat, ssat;\n+\tcdf_stream_t sst, scn;\n+\tcdf_dir_t dir;\n+\n+\tif (argc < 2) {\n+\t\t(void)fprintf(stderr, ""Usage: %s <filename>\\n"", getprogname());\n+\t\treturn -1;\n+\t}\n+\n+\tfor (i = 1; i < argc; i++) {\n+\t\tif ((fd = open(argv[1], O_RDONLY)) == -1)\n+\t\t\terr(1, ""Cannot open `%s\'"", argv[1]);\n+\n+\t\tif (cdf_read_header(fd, &h) == -1)\n+\t\t\terr(1, ""Cannot read header"");\n+#ifdef CDF_DEBUG\n+\t\tcdf_dump_header(&h);\n+#endif\n+\n+\t\tif (cdf_read_sat(fd, &h, &sat) == -1)\n+\t\t\terr(1, ""Cannot read sat"");\n+#ifdef CDF_DEBUG\n+\t\tcdf_dump_sat(""SAT"", &h, &sat);\n+#endif\n+\n+\t\tif (cdf_read_ssat(fd, &h, &sat, &ssat) == -1)\n+\t\t\terr(1, ""Cannot read ssat"");\n+#ifdef CDF_DEBUG\n+\t\tcdf_dump_sat(""SSAT"", &h, &ssat);\n+#endif\n+\n+\t\tif (cdf_read_dir(fd, &h, &sat, &dir) == -1)\n+\t\t\terr(1, ""Cannot read dir"");\n+\n+\t\tif (cdf_read_short_stream(fd, &h, &sat, &dir, &sst) == -1)\n+\t\t\terr(1, ""Cannot read short stream"");\n+#ifdef CDF_DEBUG\n+\t\tcdf_dump_stream(&h, &sst);\n+#endif\n+\n+#ifdef CDF_DEBUG\n+\t\tcdf_dump_dir(fd, &h, &sat, &ssat, &sst, &dir);\n+#endif\n+\n+\n+\t\tif (cdf_read_summary_info(fd, &h, &sat, &ssat, &sst, &dir,\n+\t\t    &scn) == -1)\n+\t\t\terr(1, ""Cannot read summary info"");\n+#ifdef CDF_DEBUG\n+\t\tcdf_dump_summary_info(&h, &scn);\n+#endif\n+\n+\t\t(void)close(fd);\n+\t}\n+\n+\treturn 0;\n+}\n+#endif\n']",2009-03-15 23:04:19+00:00,MFH Update fileinfo to libmagic 5.00 and remove dependency on dirent.h on Windows,"[['+ ', '+ #include ""file.h""', '+ ', '+ #ifndef lint', '+ FILE_RCSID(""@(#)$File: cdf.c,v 1.17 2009/02/03 20:27:51 christos Exp $"")', '+ #endif', '+ ', '+ #include <assert.h>', '+ #ifdef CDF_DEBUG', '+ #include <err.h>', '+ #endif', '+ #include <stdlib.h>', '+ ', '+ #ifdef PHP_WIN32', '+ #include ""win32/unistd.h""', '+ #else', '+ #include <unistd.h>', '+ #endif', '+ ', '+ #include <string.h>', '+ #include <time.h>', '+ #include <ctype.h>', '+ ', '+ #ifndef EFTYPE', '+ #define EFTYPE EINVAL', '+ #endif', '+ ', '+ #include ""cdf.h""', '+ ', '+ #ifndef __arraycount', '+ #define __arraycount(a) (sizeof(a) / sizeof(a[0]))', '+ #endif', '+ ', '+ #ifdef CDF_DEBUG', '+ #define DPRINTF(a) printf a', '+ #else', '+ #define DPRINTF(a)', '+ #endif', '+ ', '+ static union {', '+ \tchar s[4];', '+ \tuint32_t u;', '+ } cdf_bo;', '+ ', '+ #define NEED_SWAP\t(cdf_bo.u == (uint32_t)0x01020304)', '+ ', '+ #define CDF_TOLE8(x)\t(NEED_SWAP ? cdf_tole8(x) : (uint64_t)(x))', '+ #define CDF_TOLE4(x)\t(NEED_SWAP ? cdf_tole4(x) : (uint32_t)(x))', '+ #define CDF_TOLE2(x)\t(NEED_SWAP ? cdf_tole2(x) : (uint16_t)(x))', '+ ', '+ uint16_t', '+ cdf_tole2(uint16_t sv)', '+ {', '+ \tuint16_t rv;', '+ \tuint8_t *s = (uint8_t *)(void *)&sv;', '+ \tuint8_t *d = (uint8_t *)(void *)&rv;', '+ \td[0] = s[1];', '+ \td[1] = s[0];', '+ \treturn rv;', '+ }', '+ ', '+ uint32_t', '+ cdf_tole4(uint32_t sv)', '+ {', '+ \tuint32_t rv;', '+ \tuint8_t *s = (uint8_t *)(void *)&sv;', '+ \tuint8_t *d = (uint8_t *)(void *)&rv;', '+ \td[0] = s[3];', '+ \td[1] = s[2];', '+ \td[2] = s[1];', '+ \td[3] = s[0];', '+ \treturn rv;', '+ }', '+ ', '+ uint64_t', '+ cdf_tole8(uint64_t sv)', '+ {', '+ \tuint64_t rv;', '+ \tuint8_t *s = (uint8_t *)(void *)&sv;', '+ \tuint8_t *d = (uint8_t *)(void *)&rv;', '+ \td[0] = s[7];', '+ \td[1] = s[6];', '+ \td[2] = s[5];', '+ \td[3] = s[4];', '+ \td[4] = s[3];', '+ \td[5] = s[2];', '+ \td[6] = s[1];', '+ \td[7] = s[0];', '+ \treturn rv;', '+ }', '+ ', '+ #define CDF_UNPACK(a)\t\\', '+     (void)memcpy(&(a), &buf[len], sizeof(a)), len += sizeof(a)', '+ #define CDF_UNPACKA(a)\t\\', '+     (void)memcpy((a), &buf[len], sizeof(a)), len += sizeof(a)', '+ ', '+ void', '+ cdf_swap_header(cdf_header_t *h)', '+ {', '+ \tsize_t i;', '+ ', '+ \th->h_magic = CDF_TOLE8(h->h_magic);', '+ \th->h_uuid[0] = CDF_TOLE8(h->h_uuid[0]);', '+ \th->h_uuid[1] = CDF_TOLE8(h->h_uuid[1]);', '+ \th->h_revision = CDF_TOLE2(h->h_revision);', '+ \th->h_version = CDF_TOLE2(h->h_version);', '+ \th->h_byte_order = CDF_TOLE2(h->h_byte_order);', '+ \th->h_sec_size_p2 = CDF_TOLE2(h->h_sec_size_p2);', '+ \th->h_short_sec_size_p2 = CDF_TOLE2(h->h_short_sec_size_p2);', '+ \th->h_num_sectors_in_sat = CDF_TOLE4(h->h_num_sectors_in_sat);', '+ \th->h_secid_first_directory = CDF_TOLE4(h->h_secid_first_directory);', '+ \th->h_min_size_standard_stream =', '+ \t    CDF_TOLE4(h->h_min_size_standard_stream);', '+ \th->h_secid_first_sector_in_short_sat =', '+ \t    CDF_TOLE4(h->h_secid_first_sector_in_short_sat);', '+ \th->h_num_sectors_in_short_sat =', '+ \t    CDF_TOLE4(h->h_num_sectors_in_short_sat);', '+ \th->h_secid_first_sector_in_master_sat =', '+ \t    CDF_TOLE4(h->h_secid_first_sector_in_master_sat);', '+ \th->h_num_sectors_in_master_sat =', '+ \t    CDF_TOLE4(h->h_num_sectors_in_master_sat);', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++)', '+ \t\th->h_master_sat[i] = CDF_TOLE4(h->h_master_sat[i]);', '+ }', '+ ', '+ void', '+ cdf_unpack_header(cdf_header_t *h, char *buf)', '+ {', '+ \tsize_t i;', '+ \tsize_t len = 0;', '+ ', '+ \tCDF_UNPACK(h->h_magic);', '+ \tCDF_UNPACKA(h->h_uuid);', '+ \tCDF_UNPACK(h->h_revision);', '+ \tCDF_UNPACK(h->h_version);', '+ \tCDF_UNPACK(h->h_byte_order);', '+ \tCDF_UNPACK(h->h_sec_size_p2);', '+ \tCDF_UNPACK(h->h_short_sec_size_p2);', '+ \tCDF_UNPACKA(h->h_unused0);', '+ \tCDF_UNPACK(h->h_num_sectors_in_sat);', '+ \tCDF_UNPACK(h->h_secid_first_directory);', '+ \tCDF_UNPACKA(h->h_unused1);', '+ \tCDF_UNPACK(h->h_min_size_standard_stream);', '+ \tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);', '+ \tCDF_UNPACK(h->h_num_sectors_in_short_sat);', '+ \tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);', '+ \tCDF_UNPACK(h->h_num_sectors_in_master_sat);', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++)', '+ \t\tCDF_UNPACK(h->h_master_sat[i]);', '+ }', '+ ', '+ void', '+ cdf_swap_dir(cdf_directory_t *d)', '+ {', '+ \td->d_namelen = CDF_TOLE2(d->d_namelen);', '+ \td->d_left_child = CDF_TOLE4(d->d_left_child);', '+ \td->d_right_child = CDF_TOLE4(d->d_right_child);', '+ \td->d_storage = CDF_TOLE4(d->d_storage);', '+ \td->d_storage_uuid[0] = CDF_TOLE8(d->d_storage_uuid[0]);', '+ \td->d_storage_uuid[1] = CDF_TOLE8(d->d_storage_uuid[1]);', '+ \td->d_flags = CDF_TOLE4(d->d_flags);', '+ \td->d_created = CDF_TOLE8(d->d_created);', '+ \td->d_modified = CDF_TOLE8(d->d_modified);', '+ \td->d_stream_first_sector = CDF_TOLE4(d->d_stream_first_sector);', '+ \td->d_size = CDF_TOLE4(d->d_size);', '+ }', '+ ', '+ void', '+ cdf_swap_class(cdf_classid_t *d)', '+ {', '+ \td->cl_dword = CDF_TOLE4(d->cl_dword);', '+ \td->cl_word[0] = CDF_TOLE2(d->cl_word[0]);', '+ \td->cl_word[1] = CDF_TOLE2(d->cl_word[1]);', '+ }', '+ ', '+ void', '+ cdf_unpack_dir(cdf_directory_t *d, char *buf)', '+ {', '+ \tsize_t len = 0;', '+ ', '+ \tCDF_UNPACKA(d->d_name);', '+ \tCDF_UNPACK(d->d_namelen);', '+ \tCDF_UNPACK(d->d_type);', '+ \tCDF_UNPACK(d->d_color);', '+ \tCDF_UNPACK(d->d_left_child);', '+ \tCDF_UNPACK(d->d_right_child);', '+ \tCDF_UNPACK(d->d_storage);', '+ \tCDF_UNPACKA(d->d_storage_uuid);', '+ \tCDF_UNPACK(d->d_flags);', '+ \tCDF_UNPACK(d->d_created);', '+ \tCDF_UNPACK(d->d_modified);', '+ \tCDF_UNPACK(d->d_stream_first_sector);', '+ \tCDF_UNPACK(d->d_size);', '+ \tCDF_UNPACK(d->d_unused0);', '+ }', '+ ', '+ int', '+ cdf_read_header(int fd, cdf_header_t *h)', '+ {', '+ \tchar buf[512];', '+ \t(void)memcpy(cdf_bo.s, ""\\01\\02\\03\\04"", 4);', '+ \tif (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1)', '+ \t\treturn -1;', '+ \tif (read(fd, buf, sizeof(buf)) != sizeof(buf))', '+ \t\treturn -1;', '+ \tcdf_unpack_header(h, buf);', '+ \tcdf_swap_header(h);', '+ \tif (h->h_magic != CDF_MAGIC) {', '+ \t\tDPRINTF((""Bad magic 0x%x != 0x$x\\n"", h->h_magic, CDF_MAGIC));', '+ \t\terrno = EFTYPE;', '+ \t\treturn -1;', '+ \t}', '+ \treturn 0;', '+ }', '+ ', '+ ', '+ ssize_t', '+ cdf_read_sector(int fd, void *buf, size_t offs, size_t len,', '+     const cdf_header_t *h, cdf_secid_t id)', '+ {', '+ \tassert((size_t)CDF_SEC_SIZE(h) == len);', '+ \tif (lseek(fd, (off_t)CDF_SEC_POS(h, id), SEEK_SET) == (off_t)-1)', '+ \t\treturn -1;', '+ \treturn read(fd, ((char *)buf) + offs, len);', '+ }', '+ ', '+ ssize_t', '+ cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,', '+     size_t len, const cdf_header_t *h, cdf_secid_t id)', '+ {', '+ \tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);', '+ \t(void)memcpy(((char *)buf) + offs,', '+ \t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);', '+ \treturn len;', '+ }', '+ ', '+ int', '+ cdf_read_sat(int fd, cdf_header_t *h, cdf_sat_t *sat)', '+ {', '+ \tsize_t i, j, k;', '+ \tsize_t ss = CDF_SEC_SIZE(h);', '+ \tcdf_secid_t *msa, mid;', '+ ', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++)', '+ \t\tif (h->h_master_sat[i] == CDF_SECID_FREE)', '+ \t\t\tbreak;', '+ ', '+ \tsat->sat_len = (h->h_num_sectors_in_master_sat + i);', '+ \tif ((sat->sat_tab = calloc(sat->sat_len, ss)) == NULL)', '+ \t\treturn -1;', '+ ', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {', '+ \t\tif (h->h_master_sat[i] < 0)', '+ \t\t\tbreak;', '+ \t\tif (cdf_read_sector(fd, sat->sat_tab, ss * i, ss, h,', '+ \t\t    h->h_master_sat[i]) != (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading sector %d"", h->h_master_sat[i]));', '+ \t\t\tgoto out1;', '+ \t\t}', '+ \t}', '+ ', '+ \tif ((msa = calloc(1, ss)) == NULL)', '+ \t\tgoto out1;', '+ ', '+ \tmid = h->h_secid_first_sector_in_master_sat;', '+ \tfor (j = 0; j < h->h_num_sectors_in_master_sat; j++) {', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Reading master sector loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out2;', '+ \t\t}', '+ \t\tif (cdf_read_sector(fd, msa, 0, ss, h, mid) != (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading master sector %d"", mid));', '+ \t\t\tgoto out2;', '+ \t\t}', '+ \t\tfor (k = 0; k < (ss / sizeof(mid)) - 1; k++, i++)', '+ \t\t\tif (cdf_read_sector(fd, sat->sat_tab, ss * i, ss, h,', '+ \t\t\t    CDF_TOLE4(msa[k])) != (ssize_t)ss) {', '+ \t\t\t\tDPRINTF((""Reading sector %d"",', '+ \t\t\t\t    CDF_TOLE4(msa[k])));', '+ \t\t\t\tgoto out2;', '+ \t\t\t}', '+ \t\tmid = CDF_TOLE4(msa[(ss / sizeof(mid)) - 1]);', '+ \t}', '+ \tfree(msa);', '+ \treturn 0;', '+ out2:', '+ \tfree(msa);', '+ out1:', '+ \tfree(sat->sat_tab);', '+ \treturn -1;', '+ }', '+ ', '+ size_t', '+ cdf_count_chain(const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_secid_t sid)', '+ {', '+ \tsize_t i, j, s = CDF_SEC_SIZE(h) / sizeof(cdf_secid_t);', '+ \tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * s);', '+ ', '+ \tDPRINTF((""Chain:""));', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tDPRINTF(("" %d"", sid));', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Counting chain loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\treturn (size_t)-1;', '+ \t\t}', '+ \t\tif (sid > maxsector) {', '+ \t\t\tDPRINTF((""Sector %d > %d\\n"", sid, maxsector));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\treturn (size_t)-1;', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(sat->sat_tab[sid]);', '+ \t}', '+ \tDPRINTF((""\\n""));', '+ \treturn i;', '+ }', '+ ', '+ int', '+ cdf_read_long_sector_chain(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_secid_t sid, size_t len, cdf_stream_t *scn)', '+ {', '+ \tsize_t ss = CDF_SEC_SIZE(h), i, j;', '+ \tssize_t nr;', '+ \tscn->sst_len = cdf_count_chain(h, sat, sid);', '+ \tscn->sst_dirlen = len;', '+ ', '+ \tif (scn->sst_len == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tscn->sst_tab = calloc(scn->sst_len, ss);', '+ \tif (scn->sst_tab == NULL)', '+ \t\treturn -1;', '+ ', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tif ((nr = cdf_read_sector(fd, scn->sst_tab, i * ss, ss, h,', '+ \t\t    sid)) != (ssize_t)ss) {', '+ \t\t\tif (i == scn->sst_len - 1 && nr > 0) {', '+ \t\t\t\treturn 0;', '+ \t\t\t}', '+ \t\t\tDPRINTF((""Reading long sector chain %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(sat->sat_tab[sid]);', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Read long sector chain loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(scn->sst_tab);', '+ \treturn (size_t)-1;', '+ }', '+ ', '+ int', '+ cdf_read_short_sector_chain(const cdf_header_t *h,', '+     const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     cdf_secid_t sid, size_t len, cdf_stream_t *scn)', '+ {', '+ \tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;', '+ \tscn->sst_len = cdf_count_chain(h, ssat, sid);', '+ \tscn->sst_dirlen = len;', '+ ', '+ \tif (scn->sst_len == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tscn->sst_tab = calloc(scn->sst_len, ss);', '+ \tif (scn->sst_tab == NULL)', '+ \t\treturn -1;', '+ ', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Read short sector chain loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,', '+ \t\t    sid) != (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading short sector chain %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(ssat->sat_tab[sid]);', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(scn->sst_tab);', '+ \treturn (size_t)-1;', '+ }', '+ ', '+ int', '+ cdf_read_sector_chain(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     cdf_secid_t sid, size_t len, cdf_stream_t *scn)', '+ {', '+ ', '+ \tif (len < h->h_min_size_standard_stream)', '+ \t\treturn cdf_read_short_sector_chain(h, ssat, sst, sid, len,', '+ \t\t    scn);', '+ \telse', '+ \t\treturn cdf_read_long_sector_chain(fd, h, sat, sid, len, scn);', '+ }', '+ ', '+ int', '+ cdf_read_dir(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_dir_t *dir)', '+ {', '+ \tsize_t i, j;', '+ \tsize_t ss = CDF_SEC_SIZE(h), ns, nd;', '+ \tchar *buf;', '+ \tcdf_secid_t sid = h->h_secid_first_directory;', '+ ', '+ \tns = cdf_count_chain(h, sat, sid);', '+ \tif (ns == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tnd = ss / CDF_DIRECTORY_SIZE;', '+ ', '+ \tdir->dir_len = ns * nd;', '+ \tdir->dir_tab = calloc(dir->dir_len, sizeof(dir->dir_tab[0]));', '+ \tif (dir->dir_tab == NULL)', '+ \t\treturn -1;', '+ ', '+ \tif ((buf = malloc(ss)) == NULL) {', '+ \t\tfree(dir->dir_tab);', '+ \t\treturn -1;', '+ \t}', '+ ', '+ \tfor (j = i = 0; i < ns; i++, j++) {', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Read dir loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tif (cdf_read_sector(fd, buf, 0, ss, h, sid) != (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading directory sector %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tfor (j = 0; j < nd; j++) {', '+ \t\t\tcdf_unpack_dir(&dir->dir_tab[i * nd + j],', '+ \t\t\t    &buf[j * CDF_DIRECTORY_SIZE]);', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(sat->sat_tab[sid]);', '+ \t}', '+ \tif (NEED_SWAP)', '+ \t\tfor (i = 0; i < dir->dir_len; i++)', '+ \t\t\tcdf_swap_dir(&dir->dir_tab[i]);', '+ \tfree(buf);', '+ \treturn 0;', '+ out:', '+ \tfree(dir->dir_tab);', '+ \tfree(buf);', '+ \treturn -1;', '+ }', '+ ', '+ ', '+ int', '+ cdf_read_ssat(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_sat_t *ssat)', '+ {', '+ \tsize_t i, j;', '+ \tsize_t ss = CDF_SEC_SIZE(h);', '+ \tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;', '+ ', '+ \tssat->sat_len = cdf_count_chain(h, sat, sid);', '+ \tif (ssat->sat_len == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tssat->sat_tab = calloc(ssat->sat_len, ss);', '+ \tif (ssat->sat_tab == NULL)', '+ \t\treturn -1;', '+ ', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Read short sat sector loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tif (cdf_read_sector(fd, ssat->sat_tab, i * ss, ss, h, sid) !=', '+ \t\t    (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading short sat sector %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(sat->sat_tab[sid]);', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(ssat->sat_tab);', '+ \treturn -1;', '+ }', '+ ', '+ int', '+ cdf_read_short_stream(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     const cdf_dir_t *dir, cdf_stream_t *scn)', '+ {', '+ \tsize_t i;', '+ \tconst cdf_directory_t *d;', '+ ', '+ \tfor (i = 0; i < dir->dir_len; i++)', '+ \t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)', '+ \t\t\tbreak;', '+ ', '+ \tif (i == dir->dir_len) {', '+ \t\tDPRINTF((""Cannot find root storage node\\n""));', '+ \t\terrno = EFTYPE;', '+ \t\treturn -1;', '+ \t}', '+ \td = &dir->dir_tab[i];', '+ ', '+ \tif (d->d_stream_first_sector < 0) {', '+ \t\tscn->sst_tab = NULL;', '+ \t\tscn->sst_len = 0;', '+ \t\treturn 0;', '+ \t}', '+ ', '+ \treturn  cdf_read_long_sector_chain(fd, h, sat,', '+ \t    d->d_stream_first_sector, d->d_size, scn);', '+ }', '+ ', '+ static int', '+ cdf_namecmp(const char *d, const uint16_t *s, size_t l)', '+ {', '+ \tfor (; l--; d++, s++)', '+ \t\tif (*d != CDF_TOLE2(*s))', '+ \t\t\treturn (unsigned char)*d - CDF_TOLE2(*s);', '+ \treturn 0;', '+ }', '+ ', '+ int', '+ cdf_read_summary_info(int fd, const cdf_header_t *h,', '+     const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     const cdf_dir_t *dir, cdf_stream_t *scn)', '+ {', '+ \tsize_t i;', '+ \tconst cdf_directory_t *d;', '+ \tstatic const char name[] = ""\\05SummaryInformation"";', '+ ', '+ \tfor (i = 0; i < dir->dir_len; i++)', '+ \t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_USER_STREAM &&', '+ \t\t    cdf_namecmp(name, dir->dir_tab[i].d_name, sizeof(name))', '+ \t\t    == 0)', '+ \t\t\tbreak;', '+ ', '+ \tif (i == dir->dir_len) {', '+ \t\tDPRINTF((""Cannot find summary information section\\n""));', '+ \t\terrno = EFTYPE;', '+ \t\treturn -1;', '+ \t}', '+ \td = &dir->dir_tab[i];', '+ \treturn cdf_read_sector_chain(fd, h, sat, ssat, sst,', '+ \t    d->d_stream_first_sector, d->d_size, scn);', '+ }', '+ ', '+ int', '+ cdf_read_property_info(const cdf_stream_t *sst, uint32_t offs,', '+     cdf_property_info_t **info, size_t *count, size_t *maxcount)', '+ {', '+ \tconst cdf_section_header_t *shp;', '+ \tcdf_section_header_t sh;', '+ \tconst uint32_t *p, *q, *e;', '+ \tint16_t s16;', '+ \tint32_t s32;', '+ \tuint32_t u32;', '+ \tint64_t s64;', '+ \tuint64_t u64;', '+ \tcdf_timestamp_t tp;', '+ \tsize_t i, o, nelements, j;', '+ \tcdf_property_info_t *inp;', '+ ', '+ \tshp = (const void *)((const char *)sst->sst_tab + offs);', '+ \tsh.sh_len = CDF_TOLE4(shp->sh_len);', '+ \tsh.sh_properties = CDF_TOLE4(shp->sh_properties);', '+ \tDPRINTF((""section len: %d properties %d\\n"", sh.sh_len,', '+ \t    sh.sh_properties));', '+ \tif (*maxcount) {', '+ \t\t*maxcount += sh.sh_properties;', '+ \t\tinp = realloc(*info, *maxcount * sizeof(*inp));', '+ \t} else {', '+ \t\t*maxcount = sh.sh_properties;', '+ \t\tinp = malloc(*maxcount * sizeof(*inp));', '+ \t}', '+ \tif (inp == NULL)', '+ \t\tgoto out;', '+ \t*info = inp;', '+ \tinp += *count;', '+ \t*count += sh.sh_properties;', '+ \tp = (const void *)((const char *)sst->sst_tab + offs + sizeof(sh));', '+ \te = (const void *)(((const char *)shp) + sh.sh_len);', '+ \tfor (i = 0; i < sh.sh_properties; i++) {', '+ \t\tq = (const uint32_t *)((const char *)p +', '+ \t\t    CDF_TOLE4(p[(i << 1) + 1])) - 2;', '+ \t\tif (q > e) {', '+ \t\t\tDPRINTF((""Ran of the end %p > %p\\n"", q, e));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tinp[i].pi_id = CDF_TOLE4(p[i << 1]);', '+ \t\tinp[i].pi_type = CDF_TOLE4(q[0]);', '+ \t\tDPRINTF((""%d) id=%x type=%x offs=%x\\n"", i, inp[i].pi_id,', '+ \t\t    inp[i].pi_type, (const char *)q - (const char *)p));', '+ \t\tif (inp[i].pi_type & CDF_VECTOR) {', '+ \t\t\tnelements = CDF_TOLE4(q[1]);', '+ \t\t\to = 2;', '+ \t\t} else {', '+ \t\t\tnelements = 1;', '+ \t\t\to = 1;', '+ \t\t}', '+ \t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))', '+ \t\t\tgoto unknown;', '+ \t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {', '+ \t\tcase CDF_EMPTY:', '+ \t\t\tbreak;', '+ \t\tcase CDF_SIGNED16:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&s16, &q[o], sizeof(s16));', '+ \t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);', '+ \t\t\tbreak;', '+ \t\tcase CDF_SIGNED32:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&s32, &q[o], sizeof(s32));', '+ \t\t\tinp[i].pi_s32 = CDF_TOLE4(s32);', '+ \t\t\tbreak;', '+ \t\tcase CDF_BOOL:', '+ \t\tcase CDF_UNSIGNED32:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&u32, &q[o], sizeof(u32));', '+ \t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);', '+ \t\t\tbreak;', '+ \t\tcase CDF_SIGNED64:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&s64, &q[o], sizeof(s64));', '+ \t\t\tinp[i].pi_s64 = CDF_TOLE4(s64);', '+ \t\t\tbreak;', '+ \t\tcase CDF_UNSIGNED64:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&u64, &q[o], sizeof(u64));', '+ \t\t\tinp[i].pi_u64 = CDF_TOLE4(u64);', '+ \t\t\tbreak;', '+ \t\tcase CDF_LENGTH32_STRING:', '+ \t\t\tif (nelements > 1) {', '+ \t\t\t\tsize_t nelem = inp - *info;', '+ \t\t\t\t*maxcount += nelements;', '+ \t\t\t\tinp = realloc(*info, *maxcount * sizeof(*inp));', '+ \t\t\t\tif (inp == NULL)', '+ \t\t\t\t\tgoto out;', '+ \t\t\t\t*info = inp;', '+ \t\t\t\tinp = *info + nelem;', '+ \t\t\t}', '+ \t\t\tDPRINTF((""nelements = %d\\n"", nelements));', '+ \t\t\tfor (j = 0; j < nelements; j++, i++) {', '+ \t\t\t\tuint32_t l = CDF_TOLE4(q[o]);', '+ \t\t\t\tinp[i].pi_str.s_len = l;', '+ \t\t\t\tinp[i].pi_str.s_buf = (const char *)(&q[o+1]);', '+ \t\t\t\tDPRINTF((""l = %d, r = %d, s = %s\\n"", l,', '+ \t\t\t\t    CDF_ROUND(l, sizeof(l)),', '+ \t\t\t\t    inp[i].pi_str.s_buf));', '+ \t\t\t\tl = 4 + CDF_ROUND(l, sizeof(l));', '+ \t\t\t\to += l >> 2;', '+ \t\t\t}', '+ \t\t\ti--;', '+ \t\t\tbreak;', '+ \t\tcase CDF_FILETIME:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&tp, &q[o], sizeof(tp));', '+ \t\t\tinp[i].pi_tp = CDF_TOLE8(tp);', '+ \t\t\tbreak;', '+ \t\tcase CDF_CLIPBOARD:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\tunknown:', '+ \t\t\tDPRINTF((""Don\'t know how to deal with %x\\n"",', '+ \t\t\t    inp[i].pi_type));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(*info);', '+ \treturn -1;', '+ }', '+ ', '+ int', '+ cdf_unpack_summary_info(const cdf_stream_t *sst, cdf_summary_info_header_t *ssi,', '+     cdf_property_info_t **info, size_t *count)', '+ {', '+ \tsize_t i, maxcount;', '+ \tconst cdf_summary_info_header_t *si = sst->sst_tab;', '+ \tconst cdf_section_declaration_t *sd = (const void *)', '+ \t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET);', '+ ', '+ \tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);', '+ \tssi->si_os_version = CDF_TOLE2(si->si_os_version);', '+ \tssi->si_os = CDF_TOLE2(si->si_os);', '+ \tssi->si_class = si->si_class;', '+ \tcdf_swap_class(&ssi->si_class);', '+ \tssi->si_count = CDF_TOLE2(si->si_count);', '+ \t*count = 0;', '+ \tmaxcount = 0;', '+ \t*info = NULL;', '+ \tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {', '+ \t\tif (i >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Unpack summary info loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\treturn -1;', '+ \t\t}', '+ \t\tif (cdf_read_property_info(sst, CDF_TOLE4(sd->sd_offset),', '+ \t\t    info, count, &maxcount) == -1)', '+ \t\t\treturn -1;', '+ \t}', '+ \treturn 0;', '+ }', '+ ', '+ ', '+ ', '+ int', '+ cdf_print_classid(char *buf, size_t buflen, const cdf_classid_t *id)', '+ {', '+ \treturn snprintf(buf, buflen, ""%.8x-%.4x-%.4x-%.2x%.2x-""', '+ \t    ""%.2x%.2x%.2x%.2x%.2x%.2x"", id->cl_dword, id->cl_word[0],', '+ \t    id->cl_word[1], id->cl_two[0], id->cl_two[1], id->cl_six[0],', '+ \t    id->cl_six[1], id->cl_six[2], id->cl_six[3], id->cl_six[4],', '+ \t    id->cl_six[5]);', '+ }', '+ ', '+ static const struct {', '+ \tuint32_t v;', '+ \tconst char *n;', '+ } vn[] = {', '+ \t{ CDF_PROPERTY_CODE_PAGE, ""Code page"" },', '+ \t{ CDF_PROPERTY_TITLE, ""Title"" },', '+ \t{ CDF_PROPERTY_SUBJECT, ""Subject"" },', '+ \t{ CDF_PROPERTY_AUTHOR, ""Author"" },', '+ \t{ CDF_PROPERTY_KEYWORDS, ""Keywords"" },', '+ \t{ CDF_PROPERTY_COMMENTS, ""Comments"" },', '+ \t{ CDF_PROPERTY_TEMPLATE, ""Template"" },', '+ \t{ CDF_PROPERTY_LAST_SAVED_BY, ""Last Saved By"" },', '+ \t{ CDF_PROPERTY_REVISION_NUMBER, ""Revision Number"" },', '+ \t{ CDF_PROPERTY_TOTAL_EDITING_TIME, ""Total Editing Time"" },', '+ \t{ CDF_PROPERTY_LAST_PRINTED, ""Last Printed"" },', '+ \t{ CDF_PROPERTY_CREATE_TIME, ""Create Time/Date"" },', '+ \t{ CDF_PROPERTY_LAST_SAVED_TIME, ""Last Saved Time/Date"" },', '+ \t{ CDF_PROPERTY_NUMBER_OF_PAGES, ""Number of Pages"" },', '+ \t{ CDF_PROPERTY_NUMBER_OF_WORDS, ""Number of Words"" },', '+ \t{ CDF_PROPERTY_NUMBER_OF_CHARACTERS, ""Number of Characters"" },', '+ \t{ CDF_PROPERTY_THUMBNAIL, ""Thumbnail"" },', '+ \t{ CDF_PROPERTY_NAME_OF_APPLICATION, ""Name of Creating Application"" },', '+ \t{ CDF_PROPERTY_SECURITY, ""Security"" },', '+ \t{ CDF_PROPERTY_LOCALE_ID, ""Locale ID"" },', '+ };', '+ ', '+ int', '+ cdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)', '+ {', '+ \tsize_t i;', '+ ', '+ \tfor (i = 0; i < __arraycount(vn); i++)', '+ \t\tif (vn[i].v == p)', '+ \t\t\treturn snprintf(buf, bufsiz, ""%s"", vn[i].n);', '+ \treturn snprintf(buf, bufsiz, ""0x%x"", p);', '+ }', '+ ', '+ int', '+ cdf_print_elapsed_time(char *buf, size_t bufsiz, cdf_timestamp_t ts)', '+ {', '+ \tsize_t len = 0;', '+ \tint days, hours, mins, secs;', '+ ', '+ \tts /= CDF_TIME_PREC;', '+ \tsecs = ts % 60;', '+ \tts /= 60;', '+ \tmins = ts % 60;', '+ \tts /= 60;', '+ \thours = ts % 24;', '+ \tts /= 24;', '+ \tdays = ts;', '+ ', '+ \tif (days) {', '+ \t\tlen += snprintf(buf + len, bufsiz - len, ""%dd+"", days);', '+ \t\tif (len >= bufsiz)', '+ \t\t\treturn len;', '+ \t}', '+ ', '+ \tif (days || hours) {', '+ \t\tlen += snprintf(buf + len, bufsiz - len, ""%.2d:"", hours);', '+ \t\tif (len >= bufsiz)', '+ \t\t\treturn len;', '+ \t}', '+ ', '+ \tlen += snprintf(buf + len, bufsiz - len, ""%.2d:"", mins);', '+ \tif (len >= bufsiz)', '+ \t\treturn len;', '+ ', '+ \tlen += snprintf(buf + len, bufsiz - len, ""%.2d"", secs);', '+ \treturn len;', '+ }', '+ ', '+ ', '+ #ifdef CDF_DEBUG', '+ void', '+ cdf_dump_header(const cdf_header_t *h)', '+ {', '+ \tsize_t i;', '+ ', '+ #define DUMP(a, b) printf(""%40.40s = "" a ""\\n"", # b, h->h_ ## b)', '+ \tDUMP(""%d"", revision);', '+ \tDUMP(""%d"", version);', '+ \tDUMP(""0x%x"", byte_order);', '+ \tDUMP(""%d"", sec_size_p2);', '+ \tDUMP(""%d"", short_sec_size_p2);', '+ \tDUMP(""%d"", num_sectors_in_sat);', '+ \tDUMP(""%d"", secid_first_directory);', '+ \tDUMP(""%d"", min_size_standard_stream);', '+ \tDUMP(""%d"", secid_first_sector_in_short_sat);', '+ \tDUMP(""%d"", num_sectors_in_short_sat);', '+ \tDUMP(""%d"", secid_first_sector_in_master_sat);', '+ \tDUMP(""%d"", num_sectors_in_master_sat);', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {', '+ \t\tif (h->h_master_sat[i] == CDF_SECID_FREE)', '+ \t\t\tbreak;', '+ \t\tprintf(""%35.35s[%.3zu] = %d\\n"",', '+ \t\t    ""master_sat"", i, h->h_master_sat[i]);', '+ \t}', '+ }', '+ ', '+ void', '+ cdf_dump_sat(const char *prefix, const cdf_header_t *h, const cdf_sat_t *sat)', '+ {', '+ \tsize_t i, j, s = CDF_SEC_SIZE(h) / sizeof(cdf_secid_t);', '+ ', '+ \tfor (i = 0; i < sat->sat_len; i++) {', '+ \t\tprintf(""%s[%zu]:\\n"", prefix, i);', '+ \t\tfor (j = 0; j < s; j++) {', '+ \t\t\tprintf(""%5d, "", CDF_TOLE4(sat->sat_tab[s * i + j]));', '+ \t\t\tif ((j + 1) % 10 == 0)', '+ \t\t\t\tprintf(""\\n"");', '+ \t\t}', '+ \t\tprintf(""\\n"");', '+ \t}', '+ }', '+ ', '+ void', '+ cdf_dump(void *v, size_t len)', '+ {', '+ \tsize_t i, j;', '+ \tunsigned char *p = v;', '+ \tchar abuf[16];', '+ \tprintf(""%.4x: "", 0);', '+ \tfor (i = 0, j = 0; i < len; i++, p++) {', '+ \t\tprintf(""%.2x "", *p);', ""+ \t\tabuf[j++] = isprint(*p) ? *p : '.';"", '+ \t\tif (j == 16) {', '+ \t\t\tj = 0;', ""+ \t\t\tabuf[15] = '\\0';"", '+ \t\t\tprintf(""%s\\n%.4x: "", abuf, i + 1);', '+ \t\t}', '+ \t}', '+ \tprintf(""\\n"");', '+ }', '+ ', '+ void', '+ cdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)', '+ {', '+ \tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?', '+ \t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);', '+ \tcdf_dump(sst->sst_tab, ss * sst->sst_len);', '+ }', '+ ', '+ void', '+ cdf_dump_dir(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     const cdf_dir_t *dir)', '+ {', '+ \tsize_t i, j;', '+ \tcdf_directory_t *d;', '+ \tchar name[__arraycount(d->d_name)];', '+ \tcdf_stream_t scn;', '+ \tstruct timeval ts;', '+ ', '+ \tstatic const char *types[] = { ""empty"", ""user storage"",', '+ \t    ""user stream"", ""lockbytes"", ""property"", ""root storage"" };', '+ ', '+ \tfor (i = 0; i < dir->dir_len; i++) {', '+ \t\td = &dir->dir_tab[i];', '+ \t\tfor (j = 0; j < sizeof(name); j++)', '+ \t\t\tname[j] = (char)CDF_TOLE2(d->d_name[j]);', '+ \t\tprintf(""Directory %zu: %s\\n"", i, name);', '+ \t\tif (d->d_type < __arraycount(types))', '+ \t\t\tprintf(""Type: %s\\n"", types[d->d_type]);', '+ \t\telse', '+ \t\t\tprintf(""Type: %d\\n"", d->d_type);', '+ \t\tprintf(""Color: %s\\n"", d->d_color ? ""black"" : ""red"");', '+ \t\tprintf(""Left child: %d\\n"", d->d_left_child);', '+ \t\tprintf(""Right child: %d\\n"", d->d_right_child);', '+ \t\tprintf(""Flags: 0x%x\\n"", d->d_flags);', '+ \t\tcdf_timestamp_to_timespec(&ts, d->d_created);', '+ \t\tprintf(""Created %s"", ctime(&ts.tv_sec));', '+ \t\tcdf_timestamp_to_timespec(&ts, d->d_modified);', '+ \t\tprintf(""Modified %s"", ctime(&ts.tv_sec));', '+ \t\tprintf(""Stream %d\\n"", d->d_stream_first_sector);', '+ \t\tprintf(""Size %d\\n"", d->d_size);', '+ \t\tswitch (d->d_type) {', '+ \t\tcase CDF_DIR_TYPE_USER_STORAGE:', '+ \t\t\tprintf(""Storage: %d\\n"", d->d_storage);', '+ \t\t\tbreak;', '+ \t\tcase CDF_DIR_TYPE_USER_STREAM:', '+ \t\t\tif (sst == NULL)', '+ \t\t\t\tbreak;', '+ \t\t\tif (cdf_read_sector_chain(fd, h, sat, ssat, sst,', '+ \t\t\t    d->d_stream_first_sector, d->d_size, &scn) == -1) {', '+ \t\t\t\twarn(""Can\'t read stream for %s at %d len %d"",', '+ \t\t\t\t    name, d->d_stream_first_sector, d->d_size);', '+ \t\t\t\tbreak;', '+ \t\t\t}', '+ \t\t\tcdf_dump_stream(h, &scn);', '+ \t\t\tfree(scn.sst_tab);', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\t\tbreak;', '+ \t\t}', '+ ', '+ \t}', '+ }', '+ ', '+ void', '+ cdf_dump_property_info(const cdf_property_info_t *info, size_t count)', '+ {', '+ \tcdf_timestamp_t tp;', '+ \tstruct timeval ts;', '+ \tchar buf[64];', '+ \tsize_t i;', '+ ', '+ \tfor (i = 0; i < count; i++) {', '+ \t\tcdf_print_property_name(buf, sizeof(buf), info[i].pi_id);', '+ \t\tprintf(""%zu) %s: "", i, buf);', '+ \t\tswitch (info[i].pi_type) {', '+ \t\tcase CDF_SIGNED16:', '+ \t\t\tprintf(""signed 16 [%hd]\\n"", info[i].pi_s16);', '+ \t\t\tbreak;', '+ \t\tcase CDF_SIGNED32:', '+ \t\t\tprintf(""signed 32 [%d]\\n"", info[i].pi_s32);', '+ \t\t\tbreak;', '+ \t\tcase CDF_UNSIGNED32:', '+ \t\t\tprintf(""unsigned 32 [%u]\\n"", info[i].pi_u32);', '+ \t\t\tbreak;', '+ \t\tcase CDF_LENGTH32_STRING:', '+ \t\t\tprintf(""string %u [%.*s]\\n"", info[i].pi_str.s_len,', '+ \t\t\t    info[i].pi_str.s_len, info[i].pi_str.s_buf);', '+ \t\t\tbreak;', '+ \t\tcase CDF_FILETIME:', '+ \t\t\ttp = info[i].pi_tp;', '+ \t\t\tif (tp < 1000000000000000LL) {', '+ \t\t\t\tcdf_print_elapsed_time(buf, sizeof(buf), tp);', '+ \t\t\t\tprintf(""timestamp %s\\n"", buf);', '+ \t\t\t} else {', '+ \t\t\t\tcdf_timestamp_to_timespec(&ts, tp);', '+ \t\t\t\tprintf(""timestamp %s"", ctime(&ts.tv_sec));', '+ \t\t\t}', '+ \t\t\tbreak;', '+ \t\tcase CDF_CLIPBOARD:', '+ \t\t\tprintf(""CLIPBOARD %u\\n"", info[i].pi_u32);', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\t\tDPRINTF((""Don\'t know how to deal with %x\\n"",', '+ \t\t\t    info[i].pi_type));', '+ \t\t\tbreak;', '+ \t\t}', '+ \t}', '+ }', '+ ', '+ ', '+ void', '+ cdf_dump_summary_info(const cdf_header_t *h, const cdf_stream_t *sst)', '+ {', '+ \tchar buf[128];', '+ \tcdf_summary_info_header_t ssi;', '+ \tcdf_property_info_t *info;', '+ \tsize_t count;', '+ ', '+ \t(void)&h;', '+ \tif (cdf_unpack_summary_info(sst, &ssi, &info, &count) == -1)', '+ \t\treturn;', '+ \tprintf(""Endian: %x\\n"", ssi.si_byte_order);', '+ \tprintf(""Os Version %d.%d\\n"", ssi.si_os_version & 0xff,', '+ \t\tssi.si_os_version >> 8);', '+ \tprintf(""Os %d\\n"", ssi.si_os);', '+ \tcdf_print_classid(buf, sizeof(buf), &ssi.si_class);', '+ \tprintf(""Class %s\\n"", buf);', '+ \tprintf(""Count %d\\n"", ssi.si_count);', '+ \tcdf_dump_property_info(info, count);', '+ \tfree(info);', '+ }', '+ ', '+ #endif', '+ ', '+ #ifdef TEST', '+ int', '+ main(int argc, char *argv[])', '+ {', '+ \tint fd, i;', '+ \tcdf_header_t h;', '+ \tcdf_sat_t sat, ssat;', '+ \tcdf_stream_t sst, scn;', '+ \tcdf_dir_t dir;', '+ ', '+ \tif (argc < 2) {', '+ \t\t(void)fprintf(stderr, ""Usage: %s <filename>\\n"", getprogname());', '+ \t\treturn -1;', '+ \t}', '+ ', '+ \tfor (i = 1; i < argc; i++) {', '+ \t\tif ((fd = open(argv[1], O_RDONLY)) == -1)', '+ \t\t\terr(1, ""Cannot open `%s\'"", argv[1]);', '+ ', '+ \t\tif (cdf_read_header(fd, &h) == -1)', '+ \t\t\terr(1, ""Cannot read header"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_header(&h);', '+ #endif', '+ ', '+ \t\tif (cdf_read_sat(fd, &h, &sat) == -1)', '+ \t\t\terr(1, ""Cannot read sat"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_sat(""SAT"", &h, &sat);', '+ #endif', '+ ', '+ \t\tif (cdf_read_ssat(fd, &h, &sat, &ssat) == -1)', '+ \t\t\terr(1, ""Cannot read ssat"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_sat(""SSAT"", &h, &ssat);', '+ #endif', '+ ', '+ \t\tif (cdf_read_dir(fd, &h, &sat, &dir) == -1)', '+ \t\t\terr(1, ""Cannot read dir"");', '+ ', '+ \t\tif (cdf_read_short_stream(fd, &h, &sat, &dir, &sst) == -1)', '+ \t\t\terr(1, ""Cannot read short stream"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_stream(&h, &sst);', '+ #endif', '+ ', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_dir(fd, &h, &sat, &ssat, &sst, &dir);', '+ #endif', '+ ', '+ ', '+ \t\tif (cdf_read_summary_info(fd, &h, &sat, &ssat, &sst, &dir,', '+ \t\t    &scn) == -1)', '+ \t\t\terr(1, ""Cannot read summary info"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_summary_info(&h, &scn);', '+ #endif', '+ ', '+ \t\t(void)close(fd);', '+ \t}', '+ ', '+ \treturn 0;', '+ }', '+ #endif']]","[['+ ', '+ #include ""file.h""', '+ ', '+ #ifndef lint', '+ file_rcsid(""@(#)$file: cdf.c,v 1.17 2009/02/03 20:27:51 christos exp $"")', '+ #endif', '+ ', '+ #include <assert.h>', '+ #ifdef cdf_debug', '+ #include <err.h>', '+ #endif', '+ #include <stdlib.h>', '+ ', '+ #ifdef php_win32', '+ #include ""win32/unistd.h""', '+ #else', '+ #include <unistd.h>', '+ #endif', '+ ', '+ #include <string.h>', '+ #include <time.h>', '+ #include <ctype.h>', '+ ', '+ #ifndef eftype', '+ #define eftype einval', '+ #endif', '+ ', '+ #include ""cdf.h""', '+ ', '+ #ifndef __arraycount', '+ #define __arraycount(a) (sizeof(a) / sizeof(a[0]))', '+ #endif', '+ ', '+ #ifdef cdf_debug', '+ #define dprintf(a) printf a', '+ #else', '+ #define dprintf(a)', '+ #endif', '+ ', '+ static union {', '+ \tchar s[4];', '+ \tuint32_t u;', '+ } cdf_bo;', '+ ', '+ #define need_swap\t(cdf_bo.u == (uint32_t)0x01020304)', '+ ', '+ #define cdf_tole8(x)\t(need_swap ? cdf_tole8(x) : (uint64_t)(x))', '+ #define cdf_tole4(x)\t(need_swap ? cdf_tole4(x) : (uint32_t)(x))', '+ #define cdf_tole2(x)\t(need_swap ? cdf_tole2(x) : (uint16_t)(x))', '+ ', '+ uint16_t', '+ cdf_tole2(uint16_t sv)', '+ {', '+ \tuint16_t rv;', '+ \tuint8_t *s = (uint8_t *)(void *)&sv;', '+ \tuint8_t *d = (uint8_t *)(void *)&rv;', '+ \td[0] = s[1];', '+ \td[1] = s[0];', '+ \treturn rv;', '+ }', '+ ', '+ uint32_t', '+ cdf_tole4(uint32_t sv)', '+ {', '+ \tuint32_t rv;', '+ \tuint8_t *s = (uint8_t *)(void *)&sv;', '+ \tuint8_t *d = (uint8_t *)(void *)&rv;', '+ \td[0] = s[3];', '+ \td[1] = s[2];', '+ \td[2] = s[1];', '+ \td[3] = s[0];', '+ \treturn rv;', '+ }', '+ ', '+ uint64_t', '+ cdf_tole8(uint64_t sv)', '+ {', '+ \tuint64_t rv;', '+ \tuint8_t *s = (uint8_t *)(void *)&sv;', '+ \tuint8_t *d = (uint8_t *)(void *)&rv;', '+ \td[0] = s[7];', '+ \td[1] = s[6];', '+ \td[2] = s[5];', '+ \td[3] = s[4];', '+ \td[4] = s[3];', '+ \td[5] = s[2];', '+ \td[6] = s[1];', '+ \td[7] = s[0];', '+ \treturn rv;', '+ }', '+ ', '+ #define cdf_unpack(a)\t\\', '+     (void)memcpy(&(a), &buf[len], sizeof(a)), len += sizeof(a)', '+ #define cdf_unpacka(a)\t\\', '+     (void)memcpy((a), &buf[len], sizeof(a)), len += sizeof(a)', '+ ', '+ void', '+ cdf_swap_header(cdf_header_t *h)', '+ {', '+ \tsize_t i;', '+ ', '+ \th->h_magic = cdf_tole8(h->h_magic);', '+ \th->h_uuid[0] = cdf_tole8(h->h_uuid[0]);', '+ \th->h_uuid[1] = cdf_tole8(h->h_uuid[1]);', '+ \th->h_revision = cdf_tole2(h->h_revision);', '+ \th->h_version = cdf_tole2(h->h_version);', '+ \th->h_byte_order = cdf_tole2(h->h_byte_order);', '+ \th->h_sec_size_p2 = cdf_tole2(h->h_sec_size_p2);', '+ \th->h_short_sec_size_p2 = cdf_tole2(h->h_short_sec_size_p2);', '+ \th->h_num_sectors_in_sat = cdf_tole4(h->h_num_sectors_in_sat);', '+ \th->h_secid_first_directory = cdf_tole4(h->h_secid_first_directory);', '+ \th->h_min_size_standard_stream =', '+ \t    cdf_tole4(h->h_min_size_standard_stream);', '+ \th->h_secid_first_sector_in_short_sat =', '+ \t    cdf_tole4(h->h_secid_first_sector_in_short_sat);', '+ \th->h_num_sectors_in_short_sat =', '+ \t    cdf_tole4(h->h_num_sectors_in_short_sat);', '+ \th->h_secid_first_sector_in_master_sat =', '+ \t    cdf_tole4(h->h_secid_first_sector_in_master_sat);', '+ \th->h_num_sectors_in_master_sat =', '+ \t    cdf_tole4(h->h_num_sectors_in_master_sat);', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++)', '+ \t\th->h_master_sat[i] = cdf_tole4(h->h_master_sat[i]);', '+ }', '+ ', '+ void', '+ cdf_unpack_header(cdf_header_t *h, char *buf)', '+ {', '+ \tsize_t i;', '+ \tsize_t len = 0;', '+ ', '+ \tcdf_unpack(h->h_magic);', '+ \tcdf_unpacka(h->h_uuid);', '+ \tcdf_unpack(h->h_revision);', '+ \tcdf_unpack(h->h_version);', '+ \tcdf_unpack(h->h_byte_order);', '+ \tcdf_unpack(h->h_sec_size_p2);', '+ \tcdf_unpack(h->h_short_sec_size_p2);', '+ \tcdf_unpacka(h->h_unused0);', '+ \tcdf_unpack(h->h_num_sectors_in_sat);', '+ \tcdf_unpack(h->h_secid_first_directory);', '+ \tcdf_unpacka(h->h_unused1);', '+ \tcdf_unpack(h->h_min_size_standard_stream);', '+ \tcdf_unpack(h->h_secid_first_sector_in_short_sat);', '+ \tcdf_unpack(h->h_num_sectors_in_short_sat);', '+ \tcdf_unpack(h->h_secid_first_sector_in_master_sat);', '+ \tcdf_unpack(h->h_num_sectors_in_master_sat);', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++)', '+ \t\tcdf_unpack(h->h_master_sat[i]);', '+ }', '+ ', '+ void', '+ cdf_swap_dir(cdf_directory_t *d)', '+ {', '+ \td->d_namelen = cdf_tole2(d->d_namelen);', '+ \td->d_left_child = cdf_tole4(d->d_left_child);', '+ \td->d_right_child = cdf_tole4(d->d_right_child);', '+ \td->d_storage = cdf_tole4(d->d_storage);', '+ \td->d_storage_uuid[0] = cdf_tole8(d->d_storage_uuid[0]);', '+ \td->d_storage_uuid[1] = cdf_tole8(d->d_storage_uuid[1]);', '+ \td->d_flags = cdf_tole4(d->d_flags);', '+ \td->d_created = cdf_tole8(d->d_created);', '+ \td->d_modified = cdf_tole8(d->d_modified);', '+ \td->d_stream_first_sector = cdf_tole4(d->d_stream_first_sector);', '+ \td->d_size = cdf_tole4(d->d_size);', '+ }', '+ ', '+ void', '+ cdf_swap_class(cdf_classid_t *d)', '+ {', '+ \td->cl_dword = cdf_tole4(d->cl_dword);', '+ \td->cl_word[0] = cdf_tole2(d->cl_word[0]);', '+ \td->cl_word[1] = cdf_tole2(d->cl_word[1]);', '+ }', '+ ', '+ void', '+ cdf_unpack_dir(cdf_directory_t *d, char *buf)', '+ {', '+ \tsize_t len = 0;', '+ ', '+ \tcdf_unpacka(d->d_name);', '+ \tcdf_unpack(d->d_namelen);', '+ \tcdf_unpack(d->d_type);', '+ \tcdf_unpack(d->d_color);', '+ \tcdf_unpack(d->d_left_child);', '+ \tcdf_unpack(d->d_right_child);', '+ \tcdf_unpack(d->d_storage);', '+ \tcdf_unpacka(d->d_storage_uuid);', '+ \tcdf_unpack(d->d_flags);', '+ \tcdf_unpack(d->d_created);', '+ \tcdf_unpack(d->d_modified);', '+ \tcdf_unpack(d->d_stream_first_sector);', '+ \tcdf_unpack(d->d_size);', '+ \tcdf_unpack(d->d_unused0);', '+ }', '+ ', '+ int', '+ cdf_read_header(int fd, cdf_header_t *h)', '+ {', '+ \tchar buf[512];', '+ \t(void)memcpy(cdf_bo.s, ""\\01\\02\\03\\04"", 4);', '+ \tif (lseek(fd, (off_t)0, seek_set) == (off_t)-1)', '+ \t\treturn -1;', '+ \tif (read(fd, buf, sizeof(buf)) != sizeof(buf))', '+ \t\treturn -1;', '+ \tcdf_unpack_header(h, buf);', '+ \tcdf_swap_header(h);', '+ \tif (h->h_magic != cdf_magic) {', '+ \t\tdprintf((""bad magic 0x%x != 0x$x\\n"", h->h_magic, cdf_magic));', '+ \t\terrno = eftype;', '+ \t\treturn -1;', '+ \t}', '+ \treturn 0;', '+ }', '+ ', '+ ', '+ ssize_t', '+ cdf_read_sector(int fd, void *buf, size_t offs, size_t len,', '+     const cdf_header_t *h, cdf_secid_t id)', '+ {', '+ \tassert((size_t)cdf_sec_size(h) == len);', '+ \tif (lseek(fd, (off_t)cdf_sec_pos(h, id), seek_set) == (off_t)-1)', '+ \t\treturn -1;', '+ \treturn read(fd, ((char *)buf) + offs, len);', '+ }', '+ ', '+ ssize_t', '+ cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,', '+     size_t len, const cdf_header_t *h, cdf_secid_t id)', '+ {', '+ \tassert((size_t)cdf_short_sec_size(h) == len);', '+ \t(void)memcpy(((char *)buf) + offs,', '+ \t    ((const char *)sst->sst_tab) + cdf_short_sec_pos(h, id), len);', '+ \treturn len;', '+ }', '+ ', '+ int', '+ cdf_read_sat(int fd, cdf_header_t *h, cdf_sat_t *sat)', '+ {', '+ \tsize_t i, j, k;', '+ \tsize_t ss = cdf_sec_size(h);', '+ \tcdf_secid_t *msa, mid;', '+ ', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++)', '+ \t\tif (h->h_master_sat[i] == cdf_secid_free)', '+ \t\t\tbreak;', '+ ', '+ \tsat->sat_len = (h->h_num_sectors_in_master_sat + i);', '+ \tif ((sat->sat_tab = calloc(sat->sat_len, ss)) == null)', '+ \t\treturn -1;', '+ ', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {', '+ \t\tif (h->h_master_sat[i] < 0)', '+ \t\t\tbreak;', '+ \t\tif (cdf_read_sector(fd, sat->sat_tab, ss * i, ss, h,', '+ \t\t    h->h_master_sat[i]) != (ssize_t)ss) {', '+ \t\t\tdprintf((""reading sector %d"", h->h_master_sat[i]));', '+ \t\t\tgoto out1;', '+ \t\t}', '+ \t}', '+ ', '+ \tif ((msa = calloc(1, ss)) == null)', '+ \t\tgoto out1;', '+ ', '+ \tmid = h->h_secid_first_sector_in_master_sat;', '+ \tfor (j = 0; j < h->h_num_sectors_in_master_sat; j++) {', '+ \t\tif (j >= cdf_loop_limit) {', '+ \t\t\tdprintf((""reading master sector loop limit""));', '+ \t\t\terrno = eftype;', '+ \t\t\tgoto out2;', '+ \t\t}', '+ \t\tif (cdf_read_sector(fd, msa, 0, ss, h, mid) != (ssize_t)ss) {', '+ \t\t\tdprintf((""reading master sector %d"", mid));', '+ \t\t\tgoto out2;', '+ \t\t}', '+ \t\tfor (k = 0; k < (ss / sizeof(mid)) - 1; k++, i++)', '+ \t\t\tif (cdf_read_sector(fd, sat->sat_tab, ss * i, ss, h,', '+ \t\t\t    cdf_tole4(msa[k])) != (ssize_t)ss) {', '+ \t\t\t\tdprintf((""reading sector %d"",', '+ \t\t\t\t    cdf_tole4(msa[k])));', '+ \t\t\t\tgoto out2;', '+ \t\t\t}', '+ \t\tmid = cdf_tole4(msa[(ss / sizeof(mid)) - 1]);', '+ \t}', '+ \tfree(msa);', '+ \treturn 0;', '+ out2:', '+ \tfree(msa);', '+ out1:', '+ \tfree(sat->sat_tab);', '+ \treturn -1;', '+ }', '+ ', '+ size_t', '+ cdf_count_chain(const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_secid_t sid)', '+ {', '+ \tsize_t i, j, s = cdf_sec_size(h) / sizeof(cdf_secid_t);', '+ \tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * s);', '+ ', '+ \tdprintf((""chain:""));', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tdprintf(("" %d"", sid));', '+ \t\tif (j >= cdf_loop_limit) {', '+ \t\t\tdprintf((""counting chain loop limit""));', '+ \t\t\terrno = eftype;', '+ \t\t\treturn (size_t)-1;', '+ \t\t}', '+ \t\tif (sid > maxsector) {', '+ \t\t\tdprintf((""sector %d > %d\\n"", sid, maxsector));', '+ \t\t\terrno = eftype;', '+ \t\t\treturn (size_t)-1;', '+ \t\t}', '+ \t\tsid = cdf_tole4(sat->sat_tab[sid]);', '+ \t}', '+ \tdprintf((""\\n""));', '+ \treturn i;', '+ }', '+ ', '+ int', '+ cdf_read_long_sector_chain(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_secid_t sid, size_t len, cdf_stream_t *scn)', '+ {', '+ \tsize_t ss = cdf_sec_size(h), i, j;', '+ \tssize_t nr;', '+ \tscn->sst_len = cdf_count_chain(h, sat, sid);', '+ \tscn->sst_dirlen = len;', '+ ', '+ \tif (scn->sst_len == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tscn->sst_tab = calloc(scn->sst_len, ss);', '+ \tif (scn->sst_tab == null)', '+ \t\treturn -1;', '+ ', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tif ((nr = cdf_read_sector(fd, scn->sst_tab, i * ss, ss, h,', '+ \t\t    sid)) != (ssize_t)ss) {', '+ \t\t\tif (i == scn->sst_len - 1 && nr > 0) {', '+ \t\t\t\treturn 0;', '+ \t\t\t}', '+ \t\t\tdprintf((""reading long sector chain %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tsid = cdf_tole4(sat->sat_tab[sid]);', '+ \t\tif (j >= cdf_loop_limit) {', '+ \t\t\tdprintf((""read long sector chain loop limit""));', '+ \t\t\terrno = eftype;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(scn->sst_tab);', '+ \treturn (size_t)-1;', '+ }', '+ ', '+ int', '+ cdf_read_short_sector_chain(const cdf_header_t *h,', '+     const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     cdf_secid_t sid, size_t len, cdf_stream_t *scn)', '+ {', '+ \tsize_t ss = cdf_short_sec_size(h), i, j;', '+ \tscn->sst_len = cdf_count_chain(h, ssat, sid);', '+ \tscn->sst_dirlen = len;', '+ ', '+ \tif (scn->sst_len == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tscn->sst_tab = calloc(scn->sst_len, ss);', '+ \tif (scn->sst_tab == null)', '+ \t\treturn -1;', '+ ', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tif (j >= cdf_loop_limit) {', '+ \t\t\tdprintf((""read short sector chain loop limit""));', '+ \t\t\terrno = eftype;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,', '+ \t\t    sid) != (ssize_t)ss) {', '+ \t\t\tdprintf((""reading short sector chain %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tsid = cdf_tole4(ssat->sat_tab[sid]);', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(scn->sst_tab);', '+ \treturn (size_t)-1;', '+ }', '+ ', '+ int', '+ cdf_read_sector_chain(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     cdf_secid_t sid, size_t len, cdf_stream_t *scn)', '+ {', '+ ', '+ \tif (len < h->h_min_size_standard_stream)', '+ \t\treturn cdf_read_short_sector_chain(h, ssat, sst, sid, len,', '+ \t\t    scn);', '+ \telse', '+ \t\treturn cdf_read_long_sector_chain(fd, h, sat, sid, len, scn);', '+ }', '+ ', '+ int', '+ cdf_read_dir(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_dir_t *dir)', '+ {', '+ \tsize_t i, j;', '+ \tsize_t ss = cdf_sec_size(h), ns, nd;', '+ \tchar *buf;', '+ \tcdf_secid_t sid = h->h_secid_first_directory;', '+ ', '+ \tns = cdf_count_chain(h, sat, sid);', '+ \tif (ns == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tnd = ss / cdf_directory_size;', '+ ', '+ \tdir->dir_len = ns * nd;', '+ \tdir->dir_tab = calloc(dir->dir_len, sizeof(dir->dir_tab[0]));', '+ \tif (dir->dir_tab == null)', '+ \t\treturn -1;', '+ ', '+ \tif ((buf = malloc(ss)) == null) {', '+ \t\tfree(dir->dir_tab);', '+ \t\treturn -1;', '+ \t}', '+ ', '+ \tfor (j = i = 0; i < ns; i++, j++) {', '+ \t\tif (j >= cdf_loop_limit) {', '+ \t\t\tdprintf((""read dir loop limit""));', '+ \t\t\terrno = eftype;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tif (cdf_read_sector(fd, buf, 0, ss, h, sid) != (ssize_t)ss) {', '+ \t\t\tdprintf((""reading directory sector %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tfor (j = 0; j < nd; j++) {', '+ \t\t\tcdf_unpack_dir(&dir->dir_tab[i * nd + j],', '+ \t\t\t    &buf[j * cdf_directory_size]);', '+ \t\t}', '+ \t\tsid = cdf_tole4(sat->sat_tab[sid]);', '+ \t}', '+ \tif (need_swap)', '+ \t\tfor (i = 0; i < dir->dir_len; i++)', '+ \t\t\tcdf_swap_dir(&dir->dir_tab[i]);', '+ \tfree(buf);', '+ \treturn 0;', '+ out:', '+ \tfree(dir->dir_tab);', '+ \tfree(buf);', '+ \treturn -1;', '+ }', '+ ', '+ ', '+ int', '+ cdf_read_ssat(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_sat_t *ssat)', '+ {', '+ \tsize_t i, j;', '+ \tsize_t ss = cdf_sec_size(h);', '+ \tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;', '+ ', '+ \tssat->sat_len = cdf_count_chain(h, sat, sid);', '+ \tif (ssat->sat_len == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tssat->sat_tab = calloc(ssat->sat_len, ss);', '+ \tif (ssat->sat_tab == null)', '+ \t\treturn -1;', '+ ', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tif (j >= cdf_loop_limit) {', '+ \t\t\tdprintf((""read short sat sector loop limit""));', '+ \t\t\terrno = eftype;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tif (cdf_read_sector(fd, ssat->sat_tab, i * ss, ss, h, sid) !=', '+ \t\t    (ssize_t)ss) {', '+ \t\t\tdprintf((""reading short sat sector %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tsid = cdf_tole4(sat->sat_tab[sid]);', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(ssat->sat_tab);', '+ \treturn -1;', '+ }', '+ ', '+ int', '+ cdf_read_short_stream(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     const cdf_dir_t *dir, cdf_stream_t *scn)', '+ {', '+ \tsize_t i;', '+ \tconst cdf_directory_t *d;', '+ ', '+ \tfor (i = 0; i < dir->dir_len; i++)', '+ \t\tif (dir->dir_tab[i].d_type == cdf_dir_type_root_storage)', '+ \t\t\tbreak;', '+ ', '+ \tif (i == dir->dir_len) {', '+ \t\tdprintf((""cannot find root storage node\\n""));', '+ \t\terrno = eftype;', '+ \t\treturn -1;', '+ \t}', '+ \td = &dir->dir_tab[i];', '+ ', '+ \tif (d->d_stream_first_sector < 0) {', '+ \t\tscn->sst_tab = null;', '+ \t\tscn->sst_len = 0;', '+ \t\treturn 0;', '+ \t}', '+ ', '+ \treturn  cdf_read_long_sector_chain(fd, h, sat,', '+ \t    d->d_stream_first_sector, d->d_size, scn);', '+ }', '+ ', '+ static int', '+ cdf_namecmp(const char *d, const uint16_t *s, size_t l)', '+ {', '+ \tfor (; l--; d++, s++)', '+ \t\tif (*d != cdf_tole2(*s))', '+ \t\t\treturn (unsigned char)*d - cdf_tole2(*s);', '+ \treturn 0;', '+ }', '+ ', '+ int', '+ cdf_read_summary_info(int fd, const cdf_header_t *h,', '+     const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     const cdf_dir_t *dir, cdf_stream_t *scn)', '+ {', '+ \tsize_t i;', '+ \tconst cdf_directory_t *d;', '+ \tstatic const char name[] = ""\\05summaryinformation"";', '+ ', '+ \tfor (i = 0; i < dir->dir_len; i++)', '+ \t\tif (dir->dir_tab[i].d_type == cdf_dir_type_user_stream &&', '+ \t\t    cdf_namecmp(name, dir->dir_tab[i].d_name, sizeof(name))', '+ \t\t    == 0)', '+ \t\t\tbreak;', '+ ', '+ \tif (i == dir->dir_len) {', '+ \t\tdprintf((""cannot find summary information section\\n""));', '+ \t\terrno = eftype;', '+ \t\treturn -1;', '+ \t}', '+ \td = &dir->dir_tab[i];', '+ \treturn cdf_read_sector_chain(fd, h, sat, ssat, sst,', '+ \t    d->d_stream_first_sector, d->d_size, scn);', '+ }', '+ ', '+ int', '+ cdf_read_property_info(const cdf_stream_t *sst, uint32_t offs,', '+     cdf_property_info_t **info, size_t *count, size_t *maxcount)', '+ {', '+ \tconst cdf_section_header_t *shp;', '+ \tcdf_section_header_t sh;', '+ \tconst uint32_t *p, *q, *e;', '+ \tint16_t s16;', '+ \tint32_t s32;', '+ \tuint32_t u32;', '+ \tint64_t s64;', '+ \tuint64_t u64;', '+ \tcdf_timestamp_t tp;', '+ \tsize_t i, o, nelements, j;', '+ \tcdf_property_info_t *inp;', '+ ', '+ \tshp = (const void *)((const char *)sst->sst_tab + offs);', '+ \tsh.sh_len = cdf_tole4(shp->sh_len);', '+ \tsh.sh_properties = cdf_tole4(shp->sh_properties);', '+ \tdprintf((""section len: %d properties %d\\n"", sh.sh_len,', '+ \t    sh.sh_properties));', '+ \tif (*maxcount) {', '+ \t\t*maxcount += sh.sh_properties;', '+ \t\tinp = realloc(*info, *maxcount * sizeof(*inp));', '+ \t} else {', '+ \t\t*maxcount = sh.sh_properties;', '+ \t\tinp = malloc(*maxcount * sizeof(*inp));', '+ \t}', '+ \tif (inp == null)', '+ \t\tgoto out;', '+ \t*info = inp;', '+ \tinp += *count;', '+ \t*count += sh.sh_properties;', '+ \tp = (const void *)((const char *)sst->sst_tab + offs + sizeof(sh));', '+ \te = (const void *)(((const char *)shp) + sh.sh_len);', '+ \tfor (i = 0; i < sh.sh_properties; i++) {', '+ \t\tq = (const uint32_t *)((const char *)p +', '+ \t\t    cdf_tole4(p[(i << 1) + 1])) - 2;', '+ \t\tif (q > e) {', '+ \t\t\tdprintf((""ran of the end %p > %p\\n"", q, e));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tinp[i].pi_id = cdf_tole4(p[i << 1]);', '+ \t\tinp[i].pi_type = cdf_tole4(q[0]);', '+ \t\tdprintf((""%d) id=%x type=%x offs=%x\\n"", i, inp[i].pi_id,', '+ \t\t    inp[i].pi_type, (const char *)q - (const char *)p));', '+ \t\tif (inp[i].pi_type & cdf_vector) {', '+ \t\t\tnelements = cdf_tole4(q[1]);', '+ \t\t\to = 2;', '+ \t\t} else {', '+ \t\t\tnelements = 1;', '+ \t\t\to = 1;', '+ \t\t}', '+ \t\tif (inp[i].pi_type & (cdf_array|cdf_byref|cdf_reserved))', '+ \t\t\tgoto unknown;', '+ \t\tswitch (inp[i].pi_type & cdf_typemask) {', '+ \t\tcase cdf_empty:', '+ \t\t\tbreak;', '+ \t\tcase cdf_signed16:', '+ \t\t\tif (inp[i].pi_type & cdf_vector)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&s16, &q[o], sizeof(s16));', '+ \t\t\tinp[i].pi_s16 = cdf_tole2(s16);', '+ \t\t\tbreak;', '+ \t\tcase cdf_signed32:', '+ \t\t\tif (inp[i].pi_type & cdf_vector)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&s32, &q[o], sizeof(s32));', '+ \t\t\tinp[i].pi_s32 = cdf_tole4(s32);', '+ \t\t\tbreak;', '+ \t\tcase cdf_bool:', '+ \t\tcase cdf_unsigned32:', '+ \t\t\tif (inp[i].pi_type & cdf_vector)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&u32, &q[o], sizeof(u32));', '+ \t\t\tinp[i].pi_u32 = cdf_tole4(u32);', '+ \t\t\tbreak;', '+ \t\tcase cdf_signed64:', '+ \t\t\tif (inp[i].pi_type & cdf_vector)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&s64, &q[o], sizeof(s64));', '+ \t\t\tinp[i].pi_s64 = cdf_tole4(s64);', '+ \t\t\tbreak;', '+ \t\tcase cdf_unsigned64:', '+ \t\t\tif (inp[i].pi_type & cdf_vector)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&u64, &q[o], sizeof(u64));', '+ \t\t\tinp[i].pi_u64 = cdf_tole4(u64);', '+ \t\t\tbreak;', '+ \t\tcase cdf_length32_string:', '+ \t\t\tif (nelements > 1) {', '+ \t\t\t\tsize_t nelem = inp - *info;', '+ \t\t\t\t*maxcount += nelements;', '+ \t\t\t\tinp = realloc(*info, *maxcount * sizeof(*inp));', '+ \t\t\t\tif (inp == null)', '+ \t\t\t\t\tgoto out;', '+ \t\t\t\t*info = inp;', '+ \t\t\t\tinp = *info + nelem;', '+ \t\t\t}', '+ \t\t\tdprintf((""nelements = %d\\n"", nelements));', '+ \t\t\tfor (j = 0; j < nelements; j++, i++) {', '+ \t\t\t\tuint32_t l = cdf_tole4(q[o]);', '+ \t\t\t\tinp[i].pi_str.s_len = l;', '+ \t\t\t\tinp[i].pi_str.s_buf = (const char *)(&q[o+1]);', '+ \t\t\t\tdprintf((""l = %d, r = %d, s = %s\\n"", l,', '+ \t\t\t\t    cdf_round(l, sizeof(l)),', '+ \t\t\t\t    inp[i].pi_str.s_buf));', '+ \t\t\t\tl = 4 + cdf_round(l, sizeof(l));', '+ \t\t\t\to += l >> 2;', '+ \t\t\t}', '+ \t\t\ti--;', '+ \t\t\tbreak;', '+ \t\tcase cdf_filetime:', '+ \t\t\tif (inp[i].pi_type & cdf_vector)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&tp, &q[o], sizeof(tp));', '+ \t\t\tinp[i].pi_tp = cdf_tole8(tp);', '+ \t\t\tbreak;', '+ \t\tcase cdf_clipboard:', '+ \t\t\tif (inp[i].pi_type & cdf_vector)', '+ \t\t\t\tgoto unknown;', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\tunknown:', '+ \t\t\tdprintf((""don\'t know how to deal with %x\\n"",', '+ \t\t\t    inp[i].pi_type));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(*info);', '+ \treturn -1;', '+ }', '+ ', '+ int', '+ cdf_unpack_summary_info(const cdf_stream_t *sst, cdf_summary_info_header_t *ssi,', '+     cdf_property_info_t **info, size_t *count)', '+ {', '+ \tsize_t i, maxcount;', '+ \tconst cdf_summary_info_header_t *si = sst->sst_tab;', '+ \tconst cdf_section_declaration_t *sd = (const void *)', '+ \t    ((const char *)sst->sst_tab + cdf_section_declaration_offset);', '+ ', '+ \tssi->si_byte_order = cdf_tole2(si->si_byte_order);', '+ \tssi->si_os_version = cdf_tole2(si->si_os_version);', '+ \tssi->si_os = cdf_tole2(si->si_os);', '+ \tssi->si_class = si->si_class;', '+ \tcdf_swap_class(&ssi->si_class);', '+ \tssi->si_count = cdf_tole2(si->si_count);', '+ \t*count = 0;', '+ \tmaxcount = 0;', '+ \t*info = null;', '+ \tfor (i = 0; i < cdf_tole4(si->si_count); i++) {', '+ \t\tif (i >= cdf_loop_limit) {', '+ \t\t\tdprintf((""unpack summary info loop limit""));', '+ \t\t\terrno = eftype;', '+ \t\t\treturn -1;', '+ \t\t}', '+ \t\tif (cdf_read_property_info(sst, cdf_tole4(sd->sd_offset),', '+ \t\t    info, count, &maxcount) == -1)', '+ \t\t\treturn -1;', '+ \t}', '+ \treturn 0;', '+ }', '+ ', '+ ', '+ ', '+ int', '+ cdf_print_classid(char *buf, size_t buflen, const cdf_classid_t *id)', '+ {', '+ \treturn snprintf(buf, buflen, ""%.8x-%.4x-%.4x-%.2x%.2x-""', '+ \t    ""%.2x%.2x%.2x%.2x%.2x%.2x"", id->cl_dword, id->cl_word[0],', '+ \t    id->cl_word[1], id->cl_two[0], id->cl_two[1], id->cl_six[0],', '+ \t    id->cl_six[1], id->cl_six[2], id->cl_six[3], id->cl_six[4],', '+ \t    id->cl_six[5]);', '+ }', '+ ', '+ static const struct {', '+ \tuint32_t v;', '+ \tconst char *n;', '+ } vn[] = {', '+ \t{ cdf_property_code_page, ""code page"" },', '+ \t{ cdf_property_title, ""title"" },', '+ \t{ cdf_property_subject, ""subject"" },', '+ \t{ cdf_property_author, ""author"" },', '+ \t{ cdf_property_keywords, ""keywords"" },', '+ \t{ cdf_property_comments, ""comments"" },', '+ \t{ cdf_property_template, ""template"" },', '+ \t{ cdf_property_last_saved_by, ""last saved by"" },', '+ \t{ cdf_property_revision_number, ""revision number"" },', '+ \t{ cdf_property_total_editing_time, ""total editing time"" },', '+ \t{ cdf_property_last_printed, ""last printed"" },', '+ \t{ cdf_property_create_time, ""create time/date"" },', '+ \t{ cdf_property_last_saved_time, ""last saved time/date"" },', '+ \t{ cdf_property_number_of_pages, ""number of pages"" },', '+ \t{ cdf_property_number_of_words, ""number of words"" },', '+ \t{ cdf_property_number_of_characters, ""number of characters"" },', '+ \t{ cdf_property_thumbnail, ""thumbnail"" },', '+ \t{ cdf_property_name_of_application, ""name of creating application"" },', '+ \t{ cdf_property_security, ""security"" },', '+ \t{ cdf_property_locale_id, ""locale id"" },', '+ };', '+ ', '+ int', '+ cdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)', '+ {', '+ \tsize_t i;', '+ ', '+ \tfor (i = 0; i < __arraycount(vn); i++)', '+ \t\tif (vn[i].v == p)', '+ \t\t\treturn snprintf(buf, bufsiz, ""%s"", vn[i].n);', '+ \treturn snprintf(buf, bufsiz, ""0x%x"", p);', '+ }', '+ ', '+ int', '+ cdf_print_elapsed_time(char *buf, size_t bufsiz, cdf_timestamp_t ts)', '+ {', '+ \tsize_t len = 0;', '+ \tint days, hours, mins, secs;', '+ ', '+ \tts /= cdf_time_prec;', '+ \tsecs = ts % 60;', '+ \tts /= 60;', '+ \tmins = ts % 60;', '+ \tts /= 60;', '+ \thours = ts % 24;', '+ \tts /= 24;', '+ \tdays = ts;', '+ ', '+ \tif (days) {', '+ \t\tlen += snprintf(buf + len, bufsiz - len, ""%dd+"", days);', '+ \t\tif (len >= bufsiz)', '+ \t\t\treturn len;', '+ \t}', '+ ', '+ \tif (days || hours) {', '+ \t\tlen += snprintf(buf + len, bufsiz - len, ""%.2d:"", hours);', '+ \t\tif (len >= bufsiz)', '+ \t\t\treturn len;', '+ \t}', '+ ', '+ \tlen += snprintf(buf + len, bufsiz - len, ""%.2d:"", mins);', '+ \tif (len >= bufsiz)', '+ \t\treturn len;', '+ ', '+ \tlen += snprintf(buf + len, bufsiz - len, ""%.2d"", secs);', '+ \treturn len;', '+ }', '+ ', '+ ', '+ #ifdef cdf_debug', '+ void', '+ cdf_dump_header(const cdf_header_t *h)', '+ {', '+ \tsize_t i;', '+ ', '+ #define dump(a, b) printf(""%40.40s = "" a ""\\n"", # b, h->h_ ## b)', '+ \tdump(""%d"", revision);', '+ \tdump(""%d"", version);', '+ \tdump(""0x%x"", byte_order);', '+ \tdump(""%d"", sec_size_p2);', '+ \tdump(""%d"", short_sec_size_p2);', '+ \tdump(""%d"", num_sectors_in_sat);', '+ \tdump(""%d"", secid_first_directory);', '+ \tdump(""%d"", min_size_standard_stream);', '+ \tdump(""%d"", secid_first_sector_in_short_sat);', '+ \tdump(""%d"", num_sectors_in_short_sat);', '+ \tdump(""%d"", secid_first_sector_in_master_sat);', '+ \tdump(""%d"", num_sectors_in_master_sat);', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {', '+ \t\tif (h->h_master_sat[i] == cdf_secid_free)', '+ \t\t\tbreak;', '+ \t\tprintf(""%35.35s[%.3zu] = %d\\n"",', '+ \t\t    ""master_sat"", i, h->h_master_sat[i]);', '+ \t}', '+ }', '+ ', '+ void', '+ cdf_dump_sat(const char *prefix, const cdf_header_t *h, const cdf_sat_t *sat)', '+ {', '+ \tsize_t i, j, s = cdf_sec_size(h) / sizeof(cdf_secid_t);', '+ ', '+ \tfor (i = 0; i < sat->sat_len; i++) {', '+ \t\tprintf(""%s[%zu]:\\n"", prefix, i);', '+ \t\tfor (j = 0; j < s; j++) {', '+ \t\t\tprintf(""%5d, "", cdf_tole4(sat->sat_tab[s * i + j]));', '+ \t\t\tif ((j + 1) % 10 == 0)', '+ \t\t\t\tprintf(""\\n"");', '+ \t\t}', '+ \t\tprintf(""\\n"");', '+ \t}', '+ }', '+ ', '+ void', '+ cdf_dump(void *v, size_t len)', '+ {', '+ \tsize_t i, j;', '+ \tunsigned char *p = v;', '+ \tchar abuf[16];', '+ \tprintf(""%.4x: "", 0);', '+ \tfor (i = 0, j = 0; i < len; i++, p++) {', '+ \t\tprintf(""%.2x "", *p);', ""+ \t\tabuf[j++] = isprint(*p) ? *p : '.';"", '+ \t\tif (j == 16) {', '+ \t\t\tj = 0;', ""+ \t\t\tabuf[15] = '\\0';"", '+ \t\t\tprintf(""%s\\n%.4x: "", abuf, i + 1);', '+ \t\t}', '+ \t}', '+ \tprintf(""\\n"");', '+ }', '+ ', '+ void', '+ cdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)', '+ {', '+ \tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?', '+ \t    cdf_short_sec_size(h) : cdf_sec_size(h);', '+ \tcdf_dump(sst->sst_tab, ss * sst->sst_len);', '+ }', '+ ', '+ void', '+ cdf_dump_dir(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     const cdf_dir_t *dir)', '+ {', '+ \tsize_t i, j;', '+ \tcdf_directory_t *d;', '+ \tchar name[__arraycount(d->d_name)];', '+ \tcdf_stream_t scn;', '+ \tstruct timeval ts;', '+ ', '+ \tstatic const char *types[] = { ""empty"", ""user storage"",', '+ \t    ""user stream"", ""lockbytes"", ""property"", ""root storage"" };', '+ ', '+ \tfor (i = 0; i < dir->dir_len; i++) {', '+ \t\td = &dir->dir_tab[i];', '+ \t\tfor (j = 0; j < sizeof(name); j++)', '+ \t\t\tname[j] = (char)cdf_tole2(d->d_name[j]);', '+ \t\tprintf(""directory %zu: %s\\n"", i, name);', '+ \t\tif (d->d_type < __arraycount(types))', '+ \t\t\tprintf(""type: %s\\n"", types[d->d_type]);', '+ \t\telse', '+ \t\t\tprintf(""type: %d\\n"", d->d_type);', '+ \t\tprintf(""color: %s\\n"", d->d_color ? ""black"" : ""red"");', '+ \t\tprintf(""left child: %d\\n"", d->d_left_child);', '+ \t\tprintf(""right child: %d\\n"", d->d_right_child);', '+ \t\tprintf(""flags: 0x%x\\n"", d->d_flags);', '+ \t\tcdf_timestamp_to_timespec(&ts, d->d_created);', '+ \t\tprintf(""created %s"", ctime(&ts.tv_sec));', '+ \t\tcdf_timestamp_to_timespec(&ts, d->d_modified);', '+ \t\tprintf(""modified %s"", ctime(&ts.tv_sec));', '+ \t\tprintf(""stream %d\\n"", d->d_stream_first_sector);', '+ \t\tprintf(""size %d\\n"", d->d_size);', '+ \t\tswitch (d->d_type) {', '+ \t\tcase cdf_dir_type_user_storage:', '+ \t\t\tprintf(""storage: %d\\n"", d->d_storage);', '+ \t\t\tbreak;', '+ \t\tcase cdf_dir_type_user_stream:', '+ \t\t\tif (sst == null)', '+ \t\t\t\tbreak;', '+ \t\t\tif (cdf_read_sector_chain(fd, h, sat, ssat, sst,', '+ \t\t\t    d->d_stream_first_sector, d->d_size, &scn) == -1) {', '+ \t\t\t\twarn(""can\'t read stream for %s at %d len %d"",', '+ \t\t\t\t    name, d->d_stream_first_sector, d->d_size);', '+ \t\t\t\tbreak;', '+ \t\t\t}', '+ \t\t\tcdf_dump_stream(h, &scn);', '+ \t\t\tfree(scn.sst_tab);', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\t\tbreak;', '+ \t\t}', '+ ', '+ \t}', '+ }', '+ ', '+ void', '+ cdf_dump_property_info(const cdf_property_info_t *info, size_t count)', '+ {', '+ \tcdf_timestamp_t tp;', '+ \tstruct timeval ts;', '+ \tchar buf[64];', '+ \tsize_t i;', '+ ', '+ \tfor (i = 0; i < count; i++) {', '+ \t\tcdf_print_property_name(buf, sizeof(buf), info[i].pi_id);', '+ \t\tprintf(""%zu) %s: "", i, buf);', '+ \t\tswitch (info[i].pi_type) {', '+ \t\tcase cdf_signed16:', '+ \t\t\tprintf(""signed 16 [%hd]\\n"", info[i].pi_s16);', '+ \t\t\tbreak;', '+ \t\tcase cdf_signed32:', '+ \t\t\tprintf(""signed 32 [%d]\\n"", info[i].pi_s32);', '+ \t\t\tbreak;', '+ \t\tcase cdf_unsigned32:', '+ \t\t\tprintf(""unsigned 32 [%u]\\n"", info[i].pi_u32);', '+ \t\t\tbreak;', '+ \t\tcase cdf_length32_string:', '+ \t\t\tprintf(""string %u [%.*s]\\n"", info[i].pi_str.s_len,', '+ \t\t\t    info[i].pi_str.s_len, info[i].pi_str.s_buf);', '+ \t\t\tbreak;', '+ \t\tcase cdf_filetime:', '+ \t\t\ttp = info[i].pi_tp;', '+ \t\t\tif (tp < 1000000000000000ll) {', '+ \t\t\t\tcdf_print_elapsed_time(buf, sizeof(buf), tp);', '+ \t\t\t\tprintf(""timestamp %s\\n"", buf);', '+ \t\t\t} else {', '+ \t\t\t\tcdf_timestamp_to_timespec(&ts, tp);', '+ \t\t\t\tprintf(""timestamp %s"", ctime(&ts.tv_sec));', '+ \t\t\t}', '+ \t\t\tbreak;', '+ \t\tcase cdf_clipboard:', '+ \t\t\tprintf(""clipboard %u\\n"", info[i].pi_u32);', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\t\tdprintf((""don\'t know how to deal with %x\\n"",', '+ \t\t\t    info[i].pi_type));', '+ \t\t\tbreak;', '+ \t\t}', '+ \t}', '+ }', '+ ', '+ ', '+ void', '+ cdf_dump_summary_info(const cdf_header_t *h, const cdf_stream_t *sst)', '+ {', '+ \tchar buf[128];', '+ \tcdf_summary_info_header_t ssi;', '+ \tcdf_property_info_t *info;', '+ \tsize_t count;', '+ ', '+ \t(void)&h;', '+ \tif (cdf_unpack_summary_info(sst, &ssi, &info, &count) == -1)', '+ \t\treturn;', '+ \tprintf(""endian: %x\\n"", ssi.si_byte_order);', '+ \tprintf(""os version %d.%d\\n"", ssi.si_os_version & 0xff,', '+ \t\tssi.si_os_version >> 8);', '+ \tprintf(""os %d\\n"", ssi.si_os);', '+ \tcdf_print_classid(buf, sizeof(buf), &ssi.si_class);', '+ \tprintf(""class %s\\n"", buf);', '+ \tprintf(""count %d\\n"", ssi.si_count);', '+ \tcdf_dump_property_info(info, count);', '+ \tfree(info);', '+ }', '+ ', '+ #endif', '+ ', '+ #ifdef test', '+ int', '+ main(int argc, char *argv[])', '+ {', '+ \tint fd, i;', '+ \tcdf_header_t h;', '+ \tcdf_sat_t sat, ssat;', '+ \tcdf_stream_t sst, scn;', '+ \tcdf_dir_t dir;', '+ ', '+ \tif (argc < 2) {', '+ \t\t(void)fprintf(stderr, ""usage: %s <filename>\\n"", getprogname());', '+ \t\treturn -1;', '+ \t}', '+ ', '+ \tfor (i = 1; i < argc; i++) {', '+ \t\tif ((fd = open(argv[1], o_rdonly)) == -1)', '+ \t\t\terr(1, ""cannot open `%s\'"", argv[1]);', '+ ', '+ \t\tif (cdf_read_header(fd, &h) == -1)', '+ \t\t\terr(1, ""cannot read header"");', '+ #ifdef cdf_debug', '+ \t\tcdf_dump_header(&h);', '+ #endif', '+ ', '+ \t\tif (cdf_read_sat(fd, &h, &sat) == -1)', '+ \t\t\terr(1, ""cannot read sat"");', '+ #ifdef cdf_debug', '+ \t\tcdf_dump_sat(""sat"", &h, &sat);', '+ #endif', '+ ', '+ \t\tif (cdf_read_ssat(fd, &h, &sat, &ssat) == -1)', '+ \t\t\terr(1, ""cannot read ssat"");', '+ #ifdef cdf_debug', '+ \t\tcdf_dump_sat(""ssat"", &h, &ssat);', '+ #endif', '+ ', '+ \t\tif (cdf_read_dir(fd, &h, &sat, &dir) == -1)', '+ \t\t\terr(1, ""cannot read dir"");', '+ ', '+ \t\tif (cdf_read_short_stream(fd, &h, &sat, &dir, &sst) == -1)', '+ \t\t\terr(1, ""cannot read short stream"");', '+ #ifdef cdf_debug', '+ \t\tcdf_dump_stream(&h, &sst);', '+ #endif', '+ ', '+ #ifdef cdf_debug', '+ \t\tcdf_dump_dir(fd, &h, &sat, &ssat, &sst, &dir);', '+ #endif', '+ ', '+ ', '+ \t\tif (cdf_read_summary_info(fd, &h, &sat, &ssat, &sst, &dir,', '+ \t\t    &scn) == -1)', '+ \t\t\terr(1, ""cannot read summary info"");', '+ #ifdef cdf_debug', '+ \t\tcdf_dump_summary_info(&h, &scn);', '+ #endif', '+ ', '+ \t\t(void)close(fd);', '+ \t}', '+ ', '+ \treturn 0;', '+ }', '+ #endif']]","[['+ ', '+ #include ""file.h""', '+ ', '+ #ifndef lint', '+ FILE_RCSID(""@(#)$File: cdf.c,v 1.17 2009/02/03 20:27:51 christos Exp $"")', '+ #endif', '+ ', '+ #include <assert.h>', '+ #ifdef CDF_DEBUG', '+ #include <err.h>', '+ #endif', '+ #include <stdlib.h>', '+ ', '+ #ifdef PHP_WIN32', '+ #include ""win32/unistd.h""', '+ #else', '+ #include <unistd.h>', '+ #endif', '+ ', '+ #include <string.h>', '+ #include <time.h>', '+ #include <ctype.h>', '+ ', '+ #ifndef EFTYPE', '+ #define EFTYPE EINVAL', '+ #endif', '+ ', '+ #include ""cdf.h""', '+ ', '+ #ifndef __arraycount', '+ #define __arraycount(a) (sizeof(a) / sizeof(a[0]))', '+ #endif', '+ ', '+ #ifdef CDF_DEBUG', '+ #define DPRINTF(a) printf a', '+ #else', '+ #define DPRINTF(a)', '+ #endif', '+ ', '+ static union {', '+ \tchar s[4];', '+ \tuint32_t u;', '+ } cdf_bo;', '+ ', '+ #define NEED_SWAP\t(cdf_bo.u == (uint32_t)0x01020304)', '+ ', '+ #define CDF_TOLE8(x)\t(NEED_SWAP ? cdf_tole8(x) : (uint64_t)(x))', '+ #define CDF_TOLE4(x)\t(NEED_SWAP ? cdf_tole4(x) : (uint32_t)(x))', '+ #define CDF_TOLE2(x)\t(NEED_SWAP ? cdf_tole2(x) : (uint16_t)(x))', '+ ', '+ uint16_t', '+ cdf_tole2(uint16_t sv)', '+ {', '+ \tuint16_t rv;', '+ \tuint8_t *s = (uint8_t *)(void *)&sv;', '+ \tuint8_t *d = (uint8_t *)(void *)&rv;', '+ \td[0] = s[1];', '+ \td[1] = s[0];', '+ \treturn rv;', '+ }', '+ ', '+ uint32_t', '+ cdf_tole4(uint32_t sv)', '+ {', '+ \tuint32_t rv;', '+ \tuint8_t *s = (uint8_t *)(void *)&sv;', '+ \tuint8_t *d = (uint8_t *)(void *)&rv;', '+ \td[0] = s[3];', '+ \td[1] = s[2];', '+ \td[2] = s[1];', '+ \td[3] = s[0];', '+ \treturn rv;', '+ }', '+ ', '+ uint64_t', '+ cdf_tole8(uint64_t sv)', '+ {', '+ \tuint64_t rv;', '+ \tuint8_t *s = (uint8_t *)(void *)&sv;', '+ \tuint8_t *d = (uint8_t *)(void *)&rv;', '+ \td[0] = s[7];', '+ \td[1] = s[6];', '+ \td[2] = s[5];', '+ \td[3] = s[4];', '+ \td[4] = s[3];', '+ \td[5] = s[2];', '+ \td[6] = s[1];', '+ \td[7] = s[0];', '+ \treturn rv;', '+ }', '+ ', '+ #define CDF_UNPACK(a)\t\\', '+     (void)memcpy(&(a), &buf[len], sizeof(a)), len += sizeof(a)', '+ #define CDF_UNPACKA(a)\t\\', '+     (void)memcpy((a), &buf[len], sizeof(a)), len += sizeof(a)', '+ ', '+ void', '+ cdf_swap_header(cdf_header_t *h)', '+ {', '+ \tsize_t i;', '+ ', '+ \th->h_magic = CDF_TOLE8(h->h_magic);', '+ \th->h_uuid[0] = CDF_TOLE8(h->h_uuid[0]);', '+ \th->h_uuid[1] = CDF_TOLE8(h->h_uuid[1]);', '+ \th->h_revision = CDF_TOLE2(h->h_revision);', '+ \th->h_version = CDF_TOLE2(h->h_version);', '+ \th->h_byte_order = CDF_TOLE2(h->h_byte_order);', '+ \th->h_sec_size_p2 = CDF_TOLE2(h->h_sec_size_p2);', '+ \th->h_short_sec_size_p2 = CDF_TOLE2(h->h_short_sec_size_p2);', '+ \th->h_num_sectors_in_sat = CDF_TOLE4(h->h_num_sectors_in_sat);', '+ \th->h_secid_first_directory = CDF_TOLE4(h->h_secid_first_directory);', '+ \th->h_min_size_standard_stream =', '+ \t    CDF_TOLE4(h->h_min_size_standard_stream);', '+ \th->h_secid_first_sector_in_short_sat =', '+ \t    CDF_TOLE4(h->h_secid_first_sector_in_short_sat);', '+ \th->h_num_sectors_in_short_sat =', '+ \t    CDF_TOLE4(h->h_num_sectors_in_short_sat);', '+ \th->h_secid_first_sector_in_master_sat =', '+ \t    CDF_TOLE4(h->h_secid_first_sector_in_master_sat);', '+ \th->h_num_sectors_in_master_sat =', '+ \t    CDF_TOLE4(h->h_num_sectors_in_master_sat);', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++)', '+ \t\th->h_master_sat[i] = CDF_TOLE4(h->h_master_sat[i]);', '+ }', '+ ', '+ void', '+ cdf_unpack_header(cdf_header_t *h, char *buf)', '+ {', '+ \tsize_t i;', '+ \tsize_t len = 0;', '+ ', '+ \tCDF_UNPACK(h->h_magic);', '+ \tCDF_UNPACKA(h->h_uuid);', '+ \tCDF_UNPACK(h->h_revision);', '+ \tCDF_UNPACK(h->h_version);', '+ \tCDF_UNPACK(h->h_byte_order);', '+ \tCDF_UNPACK(h->h_sec_size_p2);', '+ \tCDF_UNPACK(h->h_short_sec_size_p2);', '+ \tCDF_UNPACKA(h->h_unused0);', '+ \tCDF_UNPACK(h->h_num_sectors_in_sat);', '+ \tCDF_UNPACK(h->h_secid_first_directory);', '+ \tCDF_UNPACKA(h->h_unused1);', '+ \tCDF_UNPACK(h->h_min_size_standard_stream);', '+ \tCDF_UNPACK(h->h_secid_first_sector_in_short_sat);', '+ \tCDF_UNPACK(h->h_num_sectors_in_short_sat);', '+ \tCDF_UNPACK(h->h_secid_first_sector_in_master_sat);', '+ \tCDF_UNPACK(h->h_num_sectors_in_master_sat);', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++)', '+ \t\tCDF_UNPACK(h->h_master_sat[i]);', '+ }', '+ ', '+ void', '+ cdf_swap_dir(cdf_directory_t *d)', '+ {', '+ \td->d_namelen = CDF_TOLE2(d->d_namelen);', '+ \td->d_left_child = CDF_TOLE4(d->d_left_child);', '+ \td->d_right_child = CDF_TOLE4(d->d_right_child);', '+ \td->d_storage = CDF_TOLE4(d->d_storage);', '+ \td->d_storage_uuid[0] = CDF_TOLE8(d->d_storage_uuid[0]);', '+ \td->d_storage_uuid[1] = CDF_TOLE8(d->d_storage_uuid[1]);', '+ \td->d_flags = CDF_TOLE4(d->d_flags);', '+ \td->d_created = CDF_TOLE8(d->d_created);', '+ \td->d_modified = CDF_TOLE8(d->d_modified);', '+ \td->d_stream_first_sector = CDF_TOLE4(d->d_stream_first_sector);', '+ \td->d_size = CDF_TOLE4(d->d_size);', '+ }', '+ ', '+ void', '+ cdf_swap_class(cdf_classid_t *d)', '+ {', '+ \td->cl_dword = CDF_TOLE4(d->cl_dword);', '+ \td->cl_word[0] = CDF_TOLE2(d->cl_word[0]);', '+ \td->cl_word[1] = CDF_TOLE2(d->cl_word[1]);', '+ }', '+ ', '+ void', '+ cdf_unpack_dir(cdf_directory_t *d, char *buf)', '+ {', '+ \tsize_t len = 0;', '+ ', '+ \tCDF_UNPACKA(d->d_name);', '+ \tCDF_UNPACK(d->d_namelen);', '+ \tCDF_UNPACK(d->d_type);', '+ \tCDF_UNPACK(d->d_color);', '+ \tCDF_UNPACK(d->d_left_child);', '+ \tCDF_UNPACK(d->d_right_child);', '+ \tCDF_UNPACK(d->d_storage);', '+ \tCDF_UNPACKA(d->d_storage_uuid);', '+ \tCDF_UNPACK(d->d_flags);', '+ \tCDF_UNPACK(d->d_created);', '+ \tCDF_UNPACK(d->d_modified);', '+ \tCDF_UNPACK(d->d_stream_first_sector);', '+ \tCDF_UNPACK(d->d_size);', '+ \tCDF_UNPACK(d->d_unused0);', '+ }', '+ ', '+ int', '+ cdf_read_header(int fd, cdf_header_t *h)', '+ {', '+ \tchar buf[512];', '+ \t(void)memcpy(cdf_bo.s, ""\\01\\02\\03\\04"", 4);', '+ \tif (lseek(fd, (off_t)0, SEEK_SET) == (off_t)-1)', '+ \t\treturn -1;', '+ \tif (read(fd, buf, sizeof(buf)) != sizeof(buf))', '+ \t\treturn -1;', '+ \tcdf_unpack_header(h, buf);', '+ \tcdf_swap_header(h);', '+ \tif (h->h_magic != CDF_MAGIC) {', '+ \t\tDPRINTF((""Bad magic 0x%x != 0x$x\\n"", h->h_magic, CDF_MAGIC));', '+ \t\terrno = EFTYPE;', '+ \t\treturn -1;', '+ \t}', '+ \treturn 0;', '+ }', '+ ', '+ ', '+ ssize_t', '+ cdf_read_sector(int fd, void *buf, size_t offs, size_t len,', '+     const cdf_header_t *h, cdf_secid_t id)', '+ {', '+ \tassert((size_t)CDF_SEC_SIZE(h) == len);', '+ \tif (lseek(fd, (off_t)CDF_SEC_POS(h, id), SEEK_SET) == (off_t)-1)', '+ \t\treturn -1;', '+ \treturn read(fd, ((char *)buf) + offs, len);', '+ }', '+ ', '+ ssize_t', '+ cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,', '+     size_t len, const cdf_header_t *h, cdf_secid_t id)', '+ {', '+ \tassert((size_t)CDF_SHORT_SEC_SIZE(h) == len);', '+ \t(void)memcpy(((char *)buf) + offs,', '+ \t    ((const char *)sst->sst_tab) + CDF_SHORT_SEC_POS(h, id), len);', '+ \treturn len;', '+ }', '+ ', '+ int', '+ cdf_read_sat(int fd, cdf_header_t *h, cdf_sat_t *sat)', '+ {', '+ \tsize_t i, j, k;', '+ \tsize_t ss = CDF_SEC_SIZE(h);', '+ \tcdf_secid_t *msa, mid;', '+ ', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++)', '+ \t\tif (h->h_master_sat[i] == CDF_SECID_FREE)', '+ \t\t\tbreak;', '+ ', '+ \tsat->sat_len = (h->h_num_sectors_in_master_sat + i);', '+ \tif ((sat->sat_tab = calloc(sat->sat_len, ss)) == NULL)', '+ \t\treturn -1;', '+ ', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {', '+ \t\tif (h->h_master_sat[i] < 0)', '+ \t\t\tbreak;', '+ \t\tif (cdf_read_sector(fd, sat->sat_tab, ss * i, ss, h,', '+ \t\t    h->h_master_sat[i]) != (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading sector %d"", h->h_master_sat[i]));', '+ \t\t\tgoto out1;', '+ \t\t}', '+ \t}', '+ ', '+ \tif ((msa = calloc(1, ss)) == NULL)', '+ \t\tgoto out1;', '+ ', '+ \tmid = h->h_secid_first_sector_in_master_sat;', '+ \tfor (j = 0; j < h->h_num_sectors_in_master_sat; j++) {', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Reading master sector loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out2;', '+ \t\t}', '+ \t\tif (cdf_read_sector(fd, msa, 0, ss, h, mid) != (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading master sector %d"", mid));', '+ \t\t\tgoto out2;', '+ \t\t}', '+ \t\tfor (k = 0; k < (ss / sizeof(mid)) - 1; k++, i++)', '+ \t\t\tif (cdf_read_sector(fd, sat->sat_tab, ss * i, ss, h,', '+ \t\t\t    CDF_TOLE4(msa[k])) != (ssize_t)ss) {', '+ \t\t\t\tDPRINTF((""Reading sector %d"",', '+ \t\t\t\t    CDF_TOLE4(msa[k])));', '+ \t\t\t\tgoto out2;', '+ \t\t\t}', '+ \t\tmid = CDF_TOLE4(msa[(ss / sizeof(mid)) - 1]);', '+ \t}', '+ \tfree(msa);', '+ \treturn 0;', '+ out2:', '+ \tfree(msa);', '+ out1:', '+ \tfree(sat->sat_tab);', '+ \treturn -1;', '+ }', '+ ', '+ size_t', '+ cdf_count_chain(const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_secid_t sid)', '+ {', '+ \tsize_t i, j, s = CDF_SEC_SIZE(h) / sizeof(cdf_secid_t);', '+ \tcdf_secid_t maxsector = (cdf_secid_t)(sat->sat_len * s);', '+ ', '+ \tDPRINTF((""Chain:""));', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tDPRINTF(("" %d"", sid));', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Counting chain loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\treturn (size_t)-1;', '+ \t\t}', '+ \t\tif (sid > maxsector) {', '+ \t\t\tDPRINTF((""Sector %d > %d\\n"", sid, maxsector));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\treturn (size_t)-1;', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(sat->sat_tab[sid]);', '+ \t}', '+ \tDPRINTF((""\\n""));', '+ \treturn i;', '+ }', '+ ', '+ int', '+ cdf_read_long_sector_chain(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_secid_t sid, size_t len, cdf_stream_t *scn)', '+ {', '+ \tsize_t ss = CDF_SEC_SIZE(h), i, j;', '+ \tssize_t nr;', '+ \tscn->sst_len = cdf_count_chain(h, sat, sid);', '+ \tscn->sst_dirlen = len;', '+ ', '+ \tif (scn->sst_len == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tscn->sst_tab = calloc(scn->sst_len, ss);', '+ \tif (scn->sst_tab == NULL)', '+ \t\treturn -1;', '+ ', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tif ((nr = cdf_read_sector(fd, scn->sst_tab, i * ss, ss, h,', '+ \t\t    sid)) != (ssize_t)ss) {', '+ \t\t\tif (i == scn->sst_len - 1 && nr > 0) {', '+ \t\t\t\treturn 0;', '+ \t\t\t}', '+ \t\t\tDPRINTF((""Reading long sector chain %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(sat->sat_tab[sid]);', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Read long sector chain loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(scn->sst_tab);', '+ \treturn (size_t)-1;', '+ }', '+ ', '+ int', '+ cdf_read_short_sector_chain(const cdf_header_t *h,', '+     const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     cdf_secid_t sid, size_t len, cdf_stream_t *scn)', '+ {', '+ \tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;', '+ \tscn->sst_len = cdf_count_chain(h, ssat, sid);', '+ \tscn->sst_dirlen = len;', '+ ', '+ \tif (scn->sst_len == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tscn->sst_tab = calloc(scn->sst_len, ss);', '+ \tif (scn->sst_tab == NULL)', '+ \t\treturn -1;', '+ ', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Read short sector chain loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tif (cdf_read_short_sector(sst, scn->sst_tab, i * ss, ss, h,', '+ \t\t    sid) != (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading short sector chain %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(ssat->sat_tab[sid]);', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(scn->sst_tab);', '+ \treturn (size_t)-1;', '+ }', '+ ', '+ int', '+ cdf_read_sector_chain(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     cdf_secid_t sid, size_t len, cdf_stream_t *scn)', '+ {', '+ ', '+ \tif (len < h->h_min_size_standard_stream)', '+ \t\treturn cdf_read_short_sector_chain(h, ssat, sst, sid, len,', '+ \t\t    scn);', '+ \telse', '+ \t\treturn cdf_read_long_sector_chain(fd, h, sat, sid, len, scn);', '+ }', '+ ', '+ int', '+ cdf_read_dir(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_dir_t *dir)', '+ {', '+ \tsize_t i, j;', '+ \tsize_t ss = CDF_SEC_SIZE(h), ns, nd;', '+ \tchar *buf;', '+ \tcdf_secid_t sid = h->h_secid_first_directory;', '+ ', '+ \tns = cdf_count_chain(h, sat, sid);', '+ \tif (ns == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tnd = ss / CDF_DIRECTORY_SIZE;', '+ ', '+ \tdir->dir_len = ns * nd;', '+ \tdir->dir_tab = calloc(dir->dir_len, sizeof(dir->dir_tab[0]));', '+ \tif (dir->dir_tab == NULL)', '+ \t\treturn -1;', '+ ', '+ \tif ((buf = malloc(ss)) == NULL) {', '+ \t\tfree(dir->dir_tab);', '+ \t\treturn -1;', '+ \t}', '+ ', '+ \tfor (j = i = 0; i < ns; i++, j++) {', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Read dir loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tif (cdf_read_sector(fd, buf, 0, ss, h, sid) != (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading directory sector %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tfor (j = 0; j < nd; j++) {', '+ \t\t\tcdf_unpack_dir(&dir->dir_tab[i * nd + j],', '+ \t\t\t    &buf[j * CDF_DIRECTORY_SIZE]);', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(sat->sat_tab[sid]);', '+ \t}', '+ \tif (NEED_SWAP)', '+ \t\tfor (i = 0; i < dir->dir_len; i++)', '+ \t\t\tcdf_swap_dir(&dir->dir_tab[i]);', '+ \tfree(buf);', '+ \treturn 0;', '+ out:', '+ \tfree(dir->dir_tab);', '+ \tfree(buf);', '+ \treturn -1;', '+ }', '+ ', '+ ', '+ int', '+ cdf_read_ssat(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     cdf_sat_t *ssat)', '+ {', '+ \tsize_t i, j;', '+ \tsize_t ss = CDF_SEC_SIZE(h);', '+ \tcdf_secid_t sid = h->h_secid_first_sector_in_short_sat;', '+ ', '+ \tssat->sat_len = cdf_count_chain(h, sat, sid);', '+ \tif (ssat->sat_len == (size_t)-1)', '+ \t\treturn -1;', '+ ', '+ \tssat->sat_tab = calloc(ssat->sat_len, ss);', '+ \tif (ssat->sat_tab == NULL)', '+ \t\treturn -1;', '+ ', '+ \tfor (j = i = 0; sid >= 0; i++, j++) {', '+ \t\tif (j >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Read short sat sector loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tif (cdf_read_sector(fd, ssat->sat_tab, i * ss, ss, h, sid) !=', '+ \t\t    (ssize_t)ss) {', '+ \t\t\tDPRINTF((""Reading short sat sector %d"", sid));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tsid = CDF_TOLE4(sat->sat_tab[sid]);', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(ssat->sat_tab);', '+ \treturn -1;', '+ }', '+ ', '+ int', '+ cdf_read_short_stream(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     const cdf_dir_t *dir, cdf_stream_t *scn)', '+ {', '+ \tsize_t i;', '+ \tconst cdf_directory_t *d;', '+ ', '+ \tfor (i = 0; i < dir->dir_len; i++)', '+ \t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_ROOT_STORAGE)', '+ \t\t\tbreak;', '+ ', '+ \tif (i == dir->dir_len) {', '+ \t\tDPRINTF((""Cannot find root storage node\\n""));', '+ \t\terrno = EFTYPE;', '+ \t\treturn -1;', '+ \t}', '+ \td = &dir->dir_tab[i];', '+ ', '+ \tif (d->d_stream_first_sector < 0) {', '+ \t\tscn->sst_tab = NULL;', '+ \t\tscn->sst_len = 0;', '+ \t\treturn 0;', '+ \t}', '+ ', '+ \treturn  cdf_read_long_sector_chain(fd, h, sat,', '+ \t    d->d_stream_first_sector, d->d_size, scn);', '+ }', '+ ', '+ static int', '+ cdf_namecmp(const char *d, const uint16_t *s, size_t l)', '+ {', '+ \tfor (; l--; d++, s++)', '+ \t\tif (*d != CDF_TOLE2(*s))', '+ \t\t\treturn (unsigned char)*d - CDF_TOLE2(*s);', '+ \treturn 0;', '+ }', '+ ', '+ int', '+ cdf_read_summary_info(int fd, const cdf_header_t *h,', '+     const cdf_sat_t *sat, const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     const cdf_dir_t *dir, cdf_stream_t *scn)', '+ {', '+ \tsize_t i;', '+ \tconst cdf_directory_t *d;', '+ \tstatic const char name[] = ""\\05SummaryInformation"";', '+ ', '+ \tfor (i = 0; i < dir->dir_len; i++)', '+ \t\tif (dir->dir_tab[i].d_type == CDF_DIR_TYPE_USER_STREAM &&', '+ \t\t    cdf_namecmp(name, dir->dir_tab[i].d_name, sizeof(name))', '+ \t\t    == 0)', '+ \t\t\tbreak;', '+ ', '+ \tif (i == dir->dir_len) {', '+ \t\tDPRINTF((""Cannot find summary information section\\n""));', '+ \t\terrno = EFTYPE;', '+ \t\treturn -1;', '+ \t}', '+ \td = &dir->dir_tab[i];', '+ \treturn cdf_read_sector_chain(fd, h, sat, ssat, sst,', '+ \t    d->d_stream_first_sector, d->d_size, scn);', '+ }', '+ ', '+ int', '+ cdf_read_property_info(const cdf_stream_t *sst, uint32_t offs,', '+     cdf_property_info_t **info, size_t *count, size_t *maxcount)', '+ {', '+ \tconst cdf_section_header_t *shp;', '+ \tcdf_section_header_t sh;', '+ \tconst uint32_t *p, *q, *e;', '+ \tint16_t s16;', '+ \tint32_t s32;', '+ \tuint32_t u32;', '+ \tint64_t s64;', '+ \tuint64_t u64;', '+ \tcdf_timestamp_t tp;', '+ \tsize_t i, o, nelements, j;', '+ \tcdf_property_info_t *inp;', '+ ', '+ \tshp = (const void *)((const char *)sst->sst_tab + offs);', '+ \tsh.sh_len = CDF_TOLE4(shp->sh_len);', '+ \tsh.sh_properties = CDF_TOLE4(shp->sh_properties);', '+ \tDPRINTF((""section len: %d properties %d\\n"", sh.sh_len,', '+ \t    sh.sh_properties));', '+ \tif (*maxcount) {', '+ \t\t*maxcount += sh.sh_properties;', '+ \t\tinp = realloc(*info, *maxcount * sizeof(*inp));', '+ \t} else {', '+ \t\t*maxcount = sh.sh_properties;', '+ \t\tinp = malloc(*maxcount * sizeof(*inp));', '+ \t}', '+ \tif (inp == NULL)', '+ \t\tgoto out;', '+ \t*info = inp;', '+ \tinp += *count;', '+ \t*count += sh.sh_properties;', '+ \tp = (const void *)((const char *)sst->sst_tab + offs + sizeof(sh));', '+ \te = (const void *)(((const char *)shp) + sh.sh_len);', '+ \tfor (i = 0; i < sh.sh_properties; i++) {', '+ \t\tq = (const uint32_t *)((const char *)p +', '+ \t\t    CDF_TOLE4(p[(i << 1) + 1])) - 2;', '+ \t\tif (q > e) {', '+ \t\t\tDPRINTF((""Ran of the end %p > %p\\n"", q, e));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t\tinp[i].pi_id = CDF_TOLE4(p[i << 1]);', '+ \t\tinp[i].pi_type = CDF_TOLE4(q[0]);', '+ \t\tDPRINTF((""%d) id=%x type=%x offs=%x\\n"", i, inp[i].pi_id,', '+ \t\t    inp[i].pi_type, (const char *)q - (const char *)p));', '+ \t\tif (inp[i].pi_type & CDF_VECTOR) {', '+ \t\t\tnelements = CDF_TOLE4(q[1]);', '+ \t\t\to = 2;', '+ \t\t} else {', '+ \t\t\tnelements = 1;', '+ \t\t\to = 1;', '+ \t\t}', '+ \t\tif (inp[i].pi_type & (CDF_ARRAY|CDF_BYREF|CDF_RESERVED))', '+ \t\t\tgoto unknown;', '+ \t\tswitch (inp[i].pi_type & CDF_TYPEMASK) {', '+ \t\tcase CDF_EMPTY:', '+ \t\t\tbreak;', '+ \t\tcase CDF_SIGNED16:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&s16, &q[o], sizeof(s16));', '+ \t\t\tinp[i].pi_s16 = CDF_TOLE2(s16);', '+ \t\t\tbreak;', '+ \t\tcase CDF_SIGNED32:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&s32, &q[o], sizeof(s32));', '+ \t\t\tinp[i].pi_s32 = CDF_TOLE4(s32);', '+ \t\t\tbreak;', '+ \t\tcase CDF_BOOL:', '+ \t\tcase CDF_UNSIGNED32:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&u32, &q[o], sizeof(u32));', '+ \t\t\tinp[i].pi_u32 = CDF_TOLE4(u32);', '+ \t\t\tbreak;', '+ \t\tcase CDF_SIGNED64:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&s64, &q[o], sizeof(s64));', '+ \t\t\tinp[i].pi_s64 = CDF_TOLE4(s64);', '+ \t\t\tbreak;', '+ \t\tcase CDF_UNSIGNED64:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&u64, &q[o], sizeof(u64));', '+ \t\t\tinp[i].pi_u64 = CDF_TOLE4(u64);', '+ \t\t\tbreak;', '+ \t\tcase CDF_LENGTH32_STRING:', '+ \t\t\tif (nelements > 1) {', '+ \t\t\t\tsize_t nelem = inp - *info;', '+ \t\t\t\t*maxcount += nelements;', '+ \t\t\t\tinp = realloc(*info, *maxcount * sizeof(*inp));', '+ \t\t\t\tif (inp == NULL)', '+ \t\t\t\t\tgoto out;', '+ \t\t\t\t*info = inp;', '+ \t\t\t\tinp = *info + nelem;', '+ \t\t\t}', '+ \t\t\tDPRINTF((""nelements = %d\\n"", nelements));', '+ \t\t\tfor (j = 0; j < nelements; j++, i++) {', '+ \t\t\t\tuint32_t l = CDF_TOLE4(q[o]);', '+ \t\t\t\tinp[i].pi_str.s_len = l;', '+ \t\t\t\tinp[i].pi_str.s_buf = (const char *)(&q[o+1]);', '+ \t\t\t\tDPRINTF((""l = %d, r = %d, s = %s\\n"", l,', '+ \t\t\t\t    CDF_ROUND(l, sizeof(l)),', '+ \t\t\t\t    inp[i].pi_str.s_buf));', '+ \t\t\t\tl = 4 + CDF_ROUND(l, sizeof(l));', '+ \t\t\t\to += l >> 2;', '+ \t\t\t}', '+ \t\t\ti--;', '+ \t\t\tbreak;', '+ \t\tcase CDF_FILETIME:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\t(void)memcpy(&tp, &q[o], sizeof(tp));', '+ \t\t\tinp[i].pi_tp = CDF_TOLE8(tp);', '+ \t\t\tbreak;', '+ \t\tcase CDF_CLIPBOARD:', '+ \t\t\tif (inp[i].pi_type & CDF_VECTOR)', '+ \t\t\t\tgoto unknown;', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\tunknown:', '+ \t\t\tDPRINTF((""Don\'t know how to deal with %x\\n"",', '+ \t\t\t    inp[i].pi_type));', '+ \t\t\tgoto out;', '+ \t\t}', '+ \t}', '+ \treturn 0;', '+ out:', '+ \tfree(*info);', '+ \treturn -1;', '+ }', '+ ', '+ int', '+ cdf_unpack_summary_info(const cdf_stream_t *sst, cdf_summary_info_header_t *ssi,', '+     cdf_property_info_t **info, size_t *count)', '+ {', '+ \tsize_t i, maxcount;', '+ \tconst cdf_summary_info_header_t *si = sst->sst_tab;', '+ \tconst cdf_section_declaration_t *sd = (const void *)', '+ \t    ((const char *)sst->sst_tab + CDF_SECTION_DECLARATION_OFFSET);', '+ ', '+ \tssi->si_byte_order = CDF_TOLE2(si->si_byte_order);', '+ \tssi->si_os_version = CDF_TOLE2(si->si_os_version);', '+ \tssi->si_os = CDF_TOLE2(si->si_os);', '+ \tssi->si_class = si->si_class;', '+ \tcdf_swap_class(&ssi->si_class);', '+ \tssi->si_count = CDF_TOLE2(si->si_count);', '+ \t*count = 0;', '+ \tmaxcount = 0;', '+ \t*info = NULL;', '+ \tfor (i = 0; i < CDF_TOLE4(si->si_count); i++) {', '+ \t\tif (i >= CDF_LOOP_LIMIT) {', '+ \t\t\tDPRINTF((""Unpack summary info loop limit""));', '+ \t\t\terrno = EFTYPE;', '+ \t\t\treturn -1;', '+ \t\t}', '+ \t\tif (cdf_read_property_info(sst, CDF_TOLE4(sd->sd_offset),', '+ \t\t    info, count, &maxcount) == -1)', '+ \t\t\treturn -1;', '+ \t}', '+ \treturn 0;', '+ }', '+ ', '+ ', '+ ', '+ int', '+ cdf_print_classid(char *buf, size_t buflen, const cdf_classid_t *id)', '+ {', '+ \treturn snprintf(buf, buflen, ""%.8x-%.4x-%.4x-%.2x%.2x-""', '+ \t    ""%.2x%.2x%.2x%.2x%.2x%.2x"", id->cl_dword, id->cl_word[0],', '+ \t    id->cl_word[1], id->cl_two[0], id->cl_two[1], id->cl_six[0],', '+ \t    id->cl_six[1], id->cl_six[2], id->cl_six[3], id->cl_six[4],', '+ \t    id->cl_six[5]);', '+ }', '+ ', '+ static const struct {', '+ \tuint32_t v;', '+ \tconst char *n;', '+ } vn[] = {', '+ \t{ CDF_PROPERTY_CODE_PAGE, ""Code page"" },', '+ \t{ CDF_PROPERTY_TITLE, ""Title"" },', '+ \t{ CDF_PROPERTY_SUBJECT, ""Subject"" },', '+ \t{ CDF_PROPERTY_AUTHOR, ""Author"" },', '+ \t{ CDF_PROPERTY_KEYWORDS, ""Keywords"" },', '+ \t{ CDF_PROPERTY_COMMENTS, ""Comments"" },', '+ \t{ CDF_PROPERTY_TEMPLATE, ""Template"" },', '+ \t{ CDF_PROPERTY_LAST_SAVED_BY, ""Last Saved By"" },', '+ \t{ CDF_PROPERTY_REVISION_NUMBER, ""Revision Number"" },', '+ \t{ CDF_PROPERTY_TOTAL_EDITING_TIME, ""Total Editing Time"" },', '+ \t{ CDF_PROPERTY_LAST_PRINTED, ""Last Printed"" },', '+ \t{ CDF_PROPERTY_CREATE_TIME, ""Create Time/Date"" },', '+ \t{ CDF_PROPERTY_LAST_SAVED_TIME, ""Last Saved Time/Date"" },', '+ \t{ CDF_PROPERTY_NUMBER_OF_PAGES, ""Number of Pages"" },', '+ \t{ CDF_PROPERTY_NUMBER_OF_WORDS, ""Number of Words"" },', '+ \t{ CDF_PROPERTY_NUMBER_OF_CHARACTERS, ""Number of Characters"" },', '+ \t{ CDF_PROPERTY_THUMBNAIL, ""Thumbnail"" },', '+ \t{ CDF_PROPERTY_NAME_OF_APPLICATION, ""Name of Creating Application"" },', '+ \t{ CDF_PROPERTY_SECURITY, ""Security"" },', '+ \t{ CDF_PROPERTY_LOCALE_ID, ""Locale ID"" },', '+ };', '+ ', '+ int', '+ cdf_print_property_name(char *buf, size_t bufsiz, uint32_t p)', '+ {', '+ \tsize_t i;', '+ ', '+ \tfor (i = 0; i < __arraycount(vn); i++)', '+ \t\tif (vn[i].v == p)', '+ \t\t\treturn snprintf(buf, bufsiz, ""%s"", vn[i].n);', '+ \treturn snprintf(buf, bufsiz, ""0x%x"", p);', '+ }', '+ ', '+ int', '+ cdf_print_elapsed_time(char *buf, size_t bufsiz, cdf_timestamp_t ts)', '+ {', '+ \tsize_t len = 0;', '+ \tint days, hours, mins, secs;', '+ ', '+ \tts /= CDF_TIME_PREC;', '+ \tsecs = ts % 60;', '+ \tts /= 60;', '+ \tmins = ts % 60;', '+ \tts /= 60;', '+ \thours = ts % 24;', '+ \tts /= 24;', '+ \tdays = ts;', '+ ', '+ \tif (days) {', '+ \t\tlen += snprintf(buf + len, bufsiz - len, ""%dd+"", days);', '+ \t\tif (len >= bufsiz)', '+ \t\t\treturn len;', '+ \t}', '+ ', '+ \tif (days || hours) {', '+ \t\tlen += snprintf(buf + len, bufsiz - len, ""%.2d:"", hours);', '+ \t\tif (len >= bufsiz)', '+ \t\t\treturn len;', '+ \t}', '+ ', '+ \tlen += snprintf(buf + len, bufsiz - len, ""%.2d:"", mins);', '+ \tif (len >= bufsiz)', '+ \t\treturn len;', '+ ', '+ \tlen += snprintf(buf + len, bufsiz - len, ""%.2d"", secs);', '+ \treturn len;', '+ }', '+ ', '+ ', '+ #ifdef CDF_DEBUG', '+ void', '+ cdf_dump_header(const cdf_header_t *h)', '+ {', '+ \tsize_t i;', '+ ', '+ #define DUMP(a, b) printf(""%40.40s = "" a ""\\n"", # b, h->h_ ## b)', '+ \tDUMP(""%d"", revision);', '+ \tDUMP(""%d"", version);', '+ \tDUMP(""0x%x"", byte_order);', '+ \tDUMP(""%d"", sec_size_p2);', '+ \tDUMP(""%d"", short_sec_size_p2);', '+ \tDUMP(""%d"", num_sectors_in_sat);', '+ \tDUMP(""%d"", secid_first_directory);', '+ \tDUMP(""%d"", min_size_standard_stream);', '+ \tDUMP(""%d"", secid_first_sector_in_short_sat);', '+ \tDUMP(""%d"", num_sectors_in_short_sat);', '+ \tDUMP(""%d"", secid_first_sector_in_master_sat);', '+ \tDUMP(""%d"", num_sectors_in_master_sat);', '+ \tfor (i = 0; i < __arraycount(h->h_master_sat); i++) {', '+ \t\tif (h->h_master_sat[i] == CDF_SECID_FREE)', '+ \t\t\tbreak;', '+ \t\tprintf(""%35.35s[%.3zu] = %d\\n"",', '+ \t\t    ""master_sat"", i, h->h_master_sat[i]);', '+ \t}', '+ }', '+ ', '+ void', '+ cdf_dump_sat(const char *prefix, const cdf_header_t *h, const cdf_sat_t *sat)', '+ {', '+ \tsize_t i, j, s = CDF_SEC_SIZE(h) / sizeof(cdf_secid_t);', '+ ', '+ \tfor (i = 0; i < sat->sat_len; i++) {', '+ \t\tprintf(""%s[%zu]:\\n"", prefix, i);', '+ \t\tfor (j = 0; j < s; j++) {', '+ \t\t\tprintf(""%5d, "", CDF_TOLE4(sat->sat_tab[s * i + j]));', '+ \t\t\tif ((j + 1) % 10 == 0)', '+ \t\t\t\tprintf(""\\n"");', '+ \t\t}', '+ \t\tprintf(""\\n"");', '+ \t}', '+ }', '+ ', '+ void', '+ cdf_dump(void *v, size_t len)', '+ {', '+ \tsize_t i, j;', '+ \tunsigned char *p = v;', '+ \tchar abuf[16];', '+ \tprintf(""%.4x: "", 0);', '+ \tfor (i = 0, j = 0; i < len; i++, p++) {', '+ \t\tprintf(""%.2x "", *p);', ""+ \t\tabuf[j++] = isprint(*p) ? *p : '.';"", '+ \t\tif (j == 16) {', '+ \t\t\tj = 0;', ""+ \t\t\tabuf[15] = '\\0';"", '+ \t\t\tprintf(""%s\\n%.4x: "", abuf, i + 1);', '+ \t\t}', '+ \t}', '+ \tprintf(""\\n"");', '+ }', '+ ', '+ void', '+ cdf_dump_stream(const cdf_header_t *h, const cdf_stream_t *sst)', '+ {', '+ \tsize_t ss = sst->sst_dirlen < h->h_min_size_standard_stream ?', '+ \t    CDF_SHORT_SEC_SIZE(h) : CDF_SEC_SIZE(h);', '+ \tcdf_dump(sst->sst_tab, ss * sst->sst_len);', '+ }', '+ ', '+ void', '+ cdf_dump_dir(int fd, const cdf_header_t *h, const cdf_sat_t *sat,', '+     const cdf_sat_t *ssat, const cdf_stream_t *sst,', '+     const cdf_dir_t *dir)', '+ {', '+ \tsize_t i, j;', '+ \tcdf_directory_t *d;', '+ \tchar name[__arraycount(d->d_name)];', '+ \tcdf_stream_t scn;', '+ \tstruct timeval ts;', '+ ', '+ \tstatic const char *types[] = { ""empty"", ""user storage"",', '+ \t    ""user stream"", ""lockbytes"", ""property"", ""root storage"" };', '+ ', '+ \tfor (i = 0; i < dir->dir_len; i++) {', '+ \t\td = &dir->dir_tab[i];', '+ \t\tfor (j = 0; j < sizeof(name); j++)', '+ \t\t\tname[j] = (char)CDF_TOLE2(d->d_name[j]);', '+ \t\tprintf(""Directory %zu: %s\\n"", i, name);', '+ \t\tif (d->d_type < __arraycount(types))', '+ \t\t\tprintf(""Type: %s\\n"", types[d->d_type]);', '+ \t\telse', '+ \t\t\tprintf(""Type: %d\\n"", d->d_type);', '+ \t\tprintf(""Color: %s\\n"", d->d_color ? ""black"" : ""red"");', '+ \t\tprintf(""Left child: %d\\n"", d->d_left_child);', '+ \t\tprintf(""Right child: %d\\n"", d->d_right_child);', '+ \t\tprintf(""Flags: 0x%x\\n"", d->d_flags);', '+ \t\tcdf_timestamp_to_timespec(&ts, d->d_created);', '+ \t\tprintf(""Created %s"", ctime(&ts.tv_sec));', '+ \t\tcdf_timestamp_to_timespec(&ts, d->d_modified);', '+ \t\tprintf(""Modified %s"", ctime(&ts.tv_sec));', '+ \t\tprintf(""Stream %d\\n"", d->d_stream_first_sector);', '+ \t\tprintf(""Size %d\\n"", d->d_size);', '+ \t\tswitch (d->d_type) {', '+ \t\tcase CDF_DIR_TYPE_USER_STORAGE:', '+ \t\t\tprintf(""Storage: %d\\n"", d->d_storage);', '+ \t\t\tbreak;', '+ \t\tcase CDF_DIR_TYPE_USER_STREAM:', '+ \t\t\tif (sst == NULL)', '+ \t\t\t\tbreak;', '+ \t\t\tif (cdf_read_sector_chain(fd, h, sat, ssat, sst,', '+ \t\t\t    d->d_stream_first_sector, d->d_size, &scn) == -1) {', '+ \t\t\t\twarn(""Can\'t read stream for %s at %d len %d"",', '+ \t\t\t\t    name, d->d_stream_first_sector, d->d_size);', '+ \t\t\t\tbreak;', '+ \t\t\t}', '+ \t\t\tcdf_dump_stream(h, &scn);', '+ \t\t\tfree(scn.sst_tab);', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\t\tbreak;', '+ \t\t}', '+ ', '+ \t}', '+ }', '+ ', '+ void', '+ cdf_dump_property_info(const cdf_property_info_t *info, size_t count)', '+ {', '+ \tcdf_timestamp_t tp;', '+ \tstruct timeval ts;', '+ \tchar buf[64];', '+ \tsize_t i;', '+ ', '+ \tfor (i = 0; i < count; i++) {', '+ \t\tcdf_print_property_name(buf, sizeof(buf), info[i].pi_id);', '+ \t\tprintf(""%zu) %s: "", i, buf);', '+ \t\tswitch (info[i].pi_type) {', '+ \t\tcase CDF_SIGNED16:', '+ \t\t\tprintf(""signed 16 [%hd]\\n"", info[i].pi_s16);', '+ \t\t\tbreak;', '+ \t\tcase CDF_SIGNED32:', '+ \t\t\tprintf(""signed 32 [%d]\\n"", info[i].pi_s32);', '+ \t\t\tbreak;', '+ \t\tcase CDF_UNSIGNED32:', '+ \t\t\tprintf(""unsigned 32 [%u]\\n"", info[i].pi_u32);', '+ \t\t\tbreak;', '+ \t\tcase CDF_LENGTH32_STRING:', '+ \t\t\tprintf(""string %u [%.*s]\\n"", info[i].pi_str.s_len,', '+ \t\t\t    info[i].pi_str.s_len, info[i].pi_str.s_buf);', '+ \t\t\tbreak;', '+ \t\tcase CDF_FILETIME:', '+ \t\t\ttp = info[i].pi_tp;', '+ \t\t\tif (tp < 1000000000000000LL) {', '+ \t\t\t\tcdf_print_elapsed_time(buf, sizeof(buf), tp);', '+ \t\t\t\tprintf(""timestamp %s\\n"", buf);', '+ \t\t\t} else {', '+ \t\t\t\tcdf_timestamp_to_timespec(&ts, tp);', '+ \t\t\t\tprintf(""timestamp %s"", ctime(&ts.tv_sec));', '+ \t\t\t}', '+ \t\t\tbreak;', '+ \t\tcase CDF_CLIPBOARD:', '+ \t\t\tprintf(""CLIPBOARD %u\\n"", info[i].pi_u32);', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\t\tDPRINTF((""Don\'t know how to deal with %x\\n"",', '+ \t\t\t    info[i].pi_type));', '+ \t\t\tbreak;', '+ \t\t}', '+ \t}', '+ }', '+ ', '+ ', '+ void', '+ cdf_dump_summary_info(const cdf_header_t *h, const cdf_stream_t *sst)', '+ {', '+ \tchar buf[128];', '+ \tcdf_summary_info_header_t ssi;', '+ \tcdf_property_info_t *info;', '+ \tsize_t count;', '+ ', '+ \t(void)&h;', '+ \tif (cdf_unpack_summary_info(sst, &ssi, &info, &count) == -1)', '+ \t\treturn;', '+ \tprintf(""Endian: %x\\n"", ssi.si_byte_order);', '+ \tprintf(""Os Version %d.%d\\n"", ssi.si_os_version & 0xff,', '+ \t\tssi.si_os_version >> 8);', '+ \tprintf(""Os %d\\n"", ssi.si_os);', '+ \tcdf_print_classid(buf, sizeof(buf), &ssi.si_class);', '+ \tprintf(""Class %s\\n"", buf);', '+ \tprintf(""Count %d\\n"", ssi.si_count);', '+ \tcdf_dump_property_info(info, count);', '+ \tfree(info);', '+ }', '+ ', '+ #endif', '+ ', '+ #ifdef TEST', '+ int', '+ main(int argc, char *argv[])', '+ {', '+ \tint fd, i;', '+ \tcdf_header_t h;', '+ \tcdf_sat_t sat, ssat;', '+ \tcdf_stream_t sst, scn;', '+ \tcdf_dir_t dir;', '+ ', '+ \tif (argc < 2) {', '+ \t\t(void)fprintf(stderr, ""Usage: %s <filename>\\n"", getprogname());', '+ \t\treturn -1;', '+ \t}', '+ ', '+ \tfor (i = 1; i < argc; i++) {', '+ \t\tif ((fd = open(argv[1], O_RDONLY)) == -1)', '+ \t\t\terr(1, ""Cannot open `%s\'"", argv[1]);', '+ ', '+ \t\tif (cdf_read_header(fd, &h) == -1)', '+ \t\t\terr(1, ""Cannot read header"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_header(&h);', '+ #endif', '+ ', '+ \t\tif (cdf_read_sat(fd, &h, &sat) == -1)', '+ \t\t\terr(1, ""Cannot read sat"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_sat(""SAT"", &h, &sat);', '+ #endif', '+ ', '+ \t\tif (cdf_read_ssat(fd, &h, &sat, &ssat) == -1)', '+ \t\t\terr(1, ""Cannot read ssat"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_sat(""SSAT"", &h, &ssat);', '+ #endif', '+ ', '+ \t\tif (cdf_read_dir(fd, &h, &sat, &dir) == -1)', '+ \t\t\terr(1, ""Cannot read dir"");', '+ ', '+ \t\tif (cdf_read_short_stream(fd, &h, &sat, &dir, &sst) == -1)', '+ \t\t\terr(1, ""Cannot read short stream"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_stream(&h, &sst);', '+ #endif', '+ ', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_dir(fd, &h, &sat, &ssat, &sst, &dir);', '+ #endif', '+ ', '+ ', '+ \t\tif (cdf_read_summary_info(fd, &h, &sat, &ssat, &sst, &dir,', '+ \t\t    &scn) == -1)', '+ \t\t\terr(1, ""Cannot read summary info"");', '+ #ifdef CDF_DEBUG', '+ \t\tcdf_dump_summary_info(&h, &scn);', '+ #endif', '+ ', '+ \t\t(void)close(fd);', '+ \t}', '+ ', '+ \treturn 0;', '+ }', '+ #endif']]",[[]],1067,0.0,1067.0,7a29c8f38677d1c7474c979836562488f6bbadecphp/php-src,['7ba1409a1aee5925180de546057ddd84ff267947']
980fc7b83458fe6bbd58910813ba7ad3faf6cf76,FFmpeg/FFmpeg,imgresample.c,train,C,0,"['@@ -130,7 +130,7 @@ static void v_resample(UINT8 *dst, int dst_width, UINT8 *src, int wrap,\n     }\n }\n \n-#ifdef CONFIG_MMX\n+#ifdef HAVE_MMX\n \n #include ""i386/mmx.h""\n \n@@ -317,7 +317,7 @@ static void h_resample(UINT8 *dst, int dst_width, UINT8 *src, int src_width,\n     } else {\n         n = dst_width;\n     }\n-#ifdef CONFIG_MMX\n+#ifdef HAVE_MMX\n     if ((mm_flags & MM_MMX) && NB_TAPS == 4)\n         h_resample_fast4_mmx(dst, n, \n                              src, src_width, src_start, src_incr, filters);\n@@ -374,7 +374,7 @@ static void component_resample(ImgReSampleContext *s,\n         }\n         /* apply vertical filter */\n         phase_y = get_phase(src_y);\n-#ifdef CONFIG_MMX\n+#ifdef HAVE_MMX\n         /* desactivated MMX because loss of precision */\n         if ((mm_flags & MM_MMX) && NB_TAPS == 4 && 0)\n             v_resample4_mmx(output, owidth, \n@@ -516,7 +516,7 @@ static void dump_filter(INT16 *filter)\n     }\n }\n \n-#ifdef CONFIG_MMX\n+#ifdef HAVE_MMX\n int mm_flags;\n #endif\n \n@@ -588,7 +588,7 @@ int main(int argc, char **argv)\n     }\n \n     /* mmx test */\n-#ifdef CONFIG_MMX\n+#ifdef HAVE_MMX\n     printf(""MMX test\\n"");\n     fact = 0.72;\n     xsize = (int)(XSIZE * fact);\n']",,,"['+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX', '- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX']","['+ #ifdef have_mmx', '+ #ifdef have_mmx', '+ #ifdef have_mmx', '+ #ifdef have_mmx', '+ #ifdef have_mmx', '- #ifdef config_mmx', '- #ifdef config_mmx', '- #ifdef config_mmx', '- #ifdef config_mmx', '- #ifdef config_mmx']","['+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX']","['- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX']",5,5.0,10.0,980fc7b83458fe6bbd58910813ba7ad3faf6cf76FFmpeg/FFmpeg,[]
54c5dd89e3125c1f363fe8f95d2837a796967c6e,FFmpeg/FFmpeg,libavfilter/vf_fps.c,train,C,1,"['@@ -0,0 +1,271 @@\n+/*\n+ * This file is part of Libav.\n+ *\n+ * Libav is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2.1 of the License, or (at your option) any later version.\n+ *\n+ * Libav is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with Libav; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n+ */\n+\n+/**\n+ * @file\n+ * a filter enforcing given constant framerate\n+ */\n+\n+#include ""libavutil/fifo.h""\n+#include ""libavutil/mathematics.h""\n+#include ""libavutil/opt.h""\n+#include ""libavutil/parseutils.h""\n+\n+#include ""avfilter.h""\n+\n+typedef struct FPSContext {\n+    const AVClass *class;\n+\n+    AVFifoBuffer *fifo;     ///< store frames until we get two successive timestamps\n+\n+    /* timestamps in input timebase */\n+    int64_t first_pts;      ///< pts of the first frame that arrived on this filter\n+    int64_t pts;            ///< pts of the first frame currently in the fifo\n+\n+    AVRational framerate;   ///< target framerate\n+    char *fps;              ///< a string describing target framerate\n+\n+    /* statistics */\n+    int frames_in;             ///< number of frames on input\n+    int frames_out;            ///< number of frames on output\n+    int dup;                   ///< number of frames duplicated\n+    int drop;                  ///< number of framed dropped\n+} FPSContext;\n+\n+#define OFFSET(x) offsetof(FPSContext, x)\n+#define V AV_OPT_FLAG_VIDEO_PARAM\n+static const AVOption options[] = {\n+    { ""fps"", ""A string describing desired output framerate"", OFFSET(fps), AV_OPT_TYPE_STRING, { .str = ""25"" }, .flags = V },\n+    { NULL },\n+};\n+\n+static const AVClass class = {\n+    .class_name = ""FPS filter"",\n+    .item_name  = av_default_item_name,\n+    .option     = options,\n+    .version    = LIBAVUTIL_VERSION_INT,\n+};\n+\n+static av_cold int init(AVFilterContext *ctx, const char *args, void *opaque)\n+{\n+    FPSContext *s = ctx->priv;\n+    int ret;\n+\n+    s->class = &class;\n+    av_opt_set_defaults(s);\n+\n+    if ((ret = av_set_options_string(s, args, ""="", "":"")) < 0) {\n+        av_log(ctx, AV_LOG_ERROR, ""Error parsing the options string %s.\\n"",\n+               args);\n+        return ret;\n+    }\n+\n+    if ((ret = av_parse_video_rate(&s->framerate, s->fps)) < 0) {\n+        av_log(ctx, AV_LOG_ERROR, ""Error parsing framerate %s.\\n"", s->fps);\n+        return ret;\n+    }\n+    av_opt_free(s);\n+\n+    if (!(s->fifo = av_fifo_alloc(2*sizeof(AVFilterBufferRef*))))\n+        return AVERROR(ENOMEM);\n+\n+    av_log(ctx, AV_LOG_VERBOSE, ""fps=%d/%d\\n"", s->framerate.num, s->framerate.den);\n+    return 0;\n+}\n+\n+static void flush_fifo(AVFifoBuffer *fifo)\n+{\n+    while (av_fifo_size(fifo)) {\n+        AVFilterBufferRef *tmp;\n+        av_fifo_generic_read(fifo, &tmp, sizeof(tmp), NULL);\n+        avfilter_unref_buffer(tmp);\n+    }\n+}\n+\n+static av_cold void uninit(AVFilterContext *ctx)\n+{\n+    FPSContext *s = ctx->priv;\n+    if (s->fifo) {\n+        flush_fifo(s->fifo);\n+        av_fifo_free(s->fifo);\n+    }\n+\n+    av_log(ctx, AV_LOG_VERBOSE, ""%d frames in, %d frames out; %d frames dropped, ""\n+           ""%d frames duplicated.\\n"", s->frames_in, s->frames_out, s->drop, s->dup);\n+}\n+\n+static int config_props(AVFilterLink* link)\n+{\n+    FPSContext   *s = link->src->priv;\n+\n+    link->time_base = (AVRational){ s->framerate.den, s->framerate.num };\n+    link->w         = link->src->inputs[0]->w;\n+    link->h         = link->src->inputs[0]->h;\n+    s->pts          = AV_NOPTS_VALUE;\n+\n+    return 0;\n+}\n+\n+static int request_frame(AVFilterLink *outlink)\n+{\n+    AVFilterContext *ctx = outlink->src;\n+    FPSContext        *s = ctx->priv;\n+    int frames_out = s->frames_out;\n+    int ret = 0;\n+\n+    while (ret >= 0 && s->frames_out == frames_out)\n+        ret = avfilter_request_frame(ctx->inputs[0]);\n+\n+    /* flush the fifo */\n+    if (ret == AVERROR_EOF && av_fifo_size(s->fifo)) {\n+        int i;\n+        for (i = 0; av_fifo_size(s->fifo); i++) {\n+            AVFilterBufferRef *buf;\n+\n+            av_fifo_generic_read(s->fifo, &buf, sizeof(buf), NULL);\n+            buf->pts = av_rescale_q(s->first_pts, ctx->inputs[0]->time_base,\n+                                    outlink->time_base) + s->frames_out;\n+\n+            avfilter_start_frame(outlink, buf);\n+            avfilter_draw_slice(outlink, 0, outlink->h, 1);\n+            avfilter_end_frame(outlink);\n+            s->frames_out++;\n+        }\n+        return 0;\n+    }\n+\n+    return ret;\n+}\n+\n+static int write_to_fifo(AVFifoBuffer *fifo, AVFilterBufferRef *buf)\n+{\n+    int ret;\n+\n+    if (!av_fifo_space(fifo) &&\n+        (ret = av_fifo_realloc2(fifo, 2*av_fifo_size(fifo))))\n+        return ret;\n+\n+    av_fifo_generic_write(fifo, &buf, sizeof(buf), NULL);\n+    return 0;\n+}\n+\n+static void end_frame(AVFilterLink *inlink)\n+{\n+    AVFilterContext    *ctx = inlink->dst;\n+    FPSContext           *s = ctx->priv;\n+    AVFilterLink   *outlink = ctx->outputs[0];\n+    AVFilterBufferRef  *buf = inlink->cur_buf;\n+    int64_t delta;\n+    int i;\n+\n+    s->frames_in++;\n+    /* discard frames until we get the first timestamp */\n+    if (s->pts == AV_NOPTS_VALUE) {\n+        if (buf->pts != AV_NOPTS_VALUE) {\n+            write_to_fifo(s->fifo, buf);\n+            s->first_pts = s->pts = buf->pts;\n+        } else {\n+            av_log(ctx, AV_LOG_WARNING, ""Discarding initial frame(s) with no ""\n+                   ""timestamp.\\n"");\n+            avfilter_unref_buffer(buf);\n+            s->drop++;\n+        }\n+        return;\n+    }\n+\n+    /* now wait for the next timestamp */\n+    if (buf->pts == AV_NOPTS_VALUE) {\n+        write_to_fifo(s->fifo, buf);\n+        return;\n+    }\n+\n+    /* number of output frames */\n+    delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,\n+                         outlink->time_base);\n+\n+    if (delta < 1) {\n+        /* drop the frame and everything buffered except the first */\n+        AVFilterBufferRef *tmp;\n+        int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);\n+\n+        av_log(ctx, AV_LOG_DEBUG, ""Dropping %d frame(s).\\n"", drop);\n+        s->drop += drop;\n+\n+        av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);\n+        flush_fifo(s->fifo);\n+        write_to_fifo(s->fifo, tmp);\n+\n+        avfilter_unref_buffer(buf);\n+        return;\n+    }\n+\n+    /* can output >= 1 frames */\n+    for (i = 0; i < delta; i++) {\n+        AVFilterBufferRef *buf_out;\n+        av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);\n+\n+        /* duplicate the frame if needed */\n+        if (!av_fifo_size(s->fifo) && i < delta - 1) {\n+            av_log(ctx, AV_LOG_DEBUG, ""Duplicating frame.\\n"");\n+            write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));\n+            s->dup++;\n+        }\n+\n+        buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,\n+                                    outlink->time_base) + s->frames_out;\n+\n+        avfilter_start_frame(outlink, buf_out);\n+        avfilter_draw_slice(outlink, 0, outlink->h, 1);\n+        avfilter_end_frame(outlink);\n+        s->frames_out++;\n+    }\n+    flush_fifo(s->fifo);\n+\n+    write_to_fifo(s->fifo, buf);\n+    s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);\n+}\n+\n+static void null_start_frame(AVFilterLink *link, AVFilterBufferRef *buf)\n+{\n+}\n+\n+static void null_draw_slice(AVFilterLink *link, int y, int h, int slice_dir)\n+{\n+}\n+\n+AVFilter avfilter_vf_fps = {\n+    .name        = ""fps"",\n+    .description = NULL_IF_CONFIG_SMALL(""Force constant framerate""),\n+\n+    .init      = init,\n+    .uninit    = uninit,\n+\n+    .priv_size = sizeof(FPSContext),\n+\n+    .inputs    = (AVFilterPad[]) {{ .name            = ""default"",\n+                                    .type            = AVMEDIA_TYPE_VIDEO,\n+                                    .start_frame     = null_start_frame,\n+                                    .draw_slice      = null_draw_slice,\n+                                    .end_frame       = end_frame, },\n+                                  { .name = NULL}},\n+    .outputs   = (AVFilterPad[]) {{ .name            = ""default"",\n+                                    .type            = AVMEDIA_TYPE_VIDEO,\n+                                    .request_frame   = request_frame,\n+                                    .config_props    = config_props},\n+                                  { .name = NULL}},\n+};\n']",2012-05-18 19:33:54+02:00,"lavfi: Add fps filter.

Partially based on a patch by Robert Nagy <ronag89@gmail.com>","[['+ ', '+ ', '+ #include ""libavutil/fifo.h""', '+ #include ""libavutil/mathematics.h""', '+ #include ""libavutil/opt.h""', '+ #include ""libavutil/parseutils.h""', '+ ', '+ #include ""avfilter.h""', '+ ', '+ typedef struct FPSContext {', '+     const AVClass *class;', '+ ', '+ ', '+ ', '+ ', '+ } FPSContext;', '+ ', '+ #define OFFSET(x) offsetof(FPSContext, x)', '+ #define V AV_OPT_FLAG_VIDEO_PARAM', '+ static const AVOption options[] = {', '+     { ""fps"", ""A string describing desired output framerate"", OFFSET(fps), AV_OPT_TYPE_STRING, { .str = ""25"" }, .flags = V },', '+     { NULL },', '+ };', '+ ', '+ static const AVClass class = {', '+     .class_name = ""FPS filter"",', '+     .item_name  = av_default_item_name,', '+     .option     = options,', '+     .version    = LIBAVUTIL_VERSION_INT,', '+ };', '+ ', '+ static av_cold int init(AVFilterContext *ctx, const char *args, void *opaque)', '+ {', '+     FPSContext *s = ctx->priv;', '+     int ret;', '+ ', '+     s->class = &class;', '+     av_opt_set_defaults(s);', '+ ', '+     if ((ret = av_set_options_string(s, args, ""="", "":"")) < 0) {', '+         av_log(ctx, AV_LOG_ERROR, ""Error parsing the options string %s.\\n"",', '+                args);', '+         return ret;', '+     }', '+ ', '+     if ((ret = av_parse_video_rate(&s->framerate, s->fps)) < 0) {', '+         av_log(ctx, AV_LOG_ERROR, ""Error parsing framerate %s.\\n"", s->fps);', '+         return ret;', '+     }', '+     av_opt_free(s);', '+ ', '+     if (!(s->fifo = av_fifo_alloc(2*sizeof(AVFilterBufferRef*))))', '+         return AVERROR(ENOMEM);', '+ ', '+     av_log(ctx, AV_LOG_VERBOSE, ""fps=%d/%d\\n"", s->framerate.num, s->framerate.den);', '+     return 0;', '+ }', '+ ', '+ static void flush_fifo(AVFifoBuffer *fifo)', '+ {', '+     while (av_fifo_size(fifo)) {', '+         AVFilterBufferRef *tmp;', '+         av_fifo_generic_read(fifo, &tmp, sizeof(tmp), NULL);', '+         avfilter_unref_buffer(tmp);', '+     }', '+ }', '+ ', '+ static av_cold void uninit(AVFilterContext *ctx)', '+ {', '+     FPSContext *s = ctx->priv;', '+     if (s->fifo) {', '+         flush_fifo(s->fifo);', '+         av_fifo_free(s->fifo);', '+     }', '+ ', '+     av_log(ctx, AV_LOG_VERBOSE, ""%d frames in, %d frames out; %d frames dropped, ""', '+            ""%d frames duplicated.\\n"", s->frames_in, s->frames_out, s->drop, s->dup);', '+ }', '+ ', '+ static int config_props(AVFilterLink* link)', '+ {', '+     FPSContext   *s = link->src->priv;', '+ ', '+     link->time_base = (AVRational){ s->framerate.den, s->framerate.num };', '+     link->w         = link->src->inputs[0]->w;', '+     link->h         = link->src->inputs[0]->h;', '+     s->pts          = AV_NOPTS_VALUE;', '+ ', '+     return 0;', '+ }', '+ ', '+ static int request_frame(AVFilterLink *outlink)', '+ {', '+     AVFilterContext *ctx = outlink->src;', '+     FPSContext        *s = ctx->priv;', '+     int frames_out = s->frames_out;', '+     int ret = 0;', '+ ', '+     while (ret >= 0 && s->frames_out == frames_out)', '+         ret = avfilter_request_frame(ctx->inputs[0]);', '+ ', '+     if (ret == AVERROR_EOF && av_fifo_size(s->fifo)) {', '+         int i;', '+         for (i = 0; av_fifo_size(s->fifo); i++) {', '+             AVFilterBufferRef *buf;', '+ ', '+             av_fifo_generic_read(s->fifo, &buf, sizeof(buf), NULL);', '+             buf->pts = av_rescale_q(s->first_pts, ctx->inputs[0]->time_base,', '+                                     outlink->time_base) + s->frames_out;', '+ ', '+             avfilter_start_frame(outlink, buf);', '+             avfilter_draw_slice(outlink, 0, outlink->h, 1);', '+             avfilter_end_frame(outlink);', '+             s->frames_out++;', '+         }', '+         return 0;', '+     }', '+ ', '+     return ret;', '+ }', '+ ', '+ static int write_to_fifo(AVFifoBuffer *fifo, AVFilterBufferRef *buf)', '+ {', '+     int ret;', '+ ', '+     if (!av_fifo_space(fifo) &&', '+         (ret = av_fifo_realloc2(fifo, 2*av_fifo_size(fifo))))', '+         return ret;', '+ ', '+     av_fifo_generic_write(fifo, &buf, sizeof(buf), NULL);', '+     return 0;', '+ }', '+ ', '+ static void end_frame(AVFilterLink *inlink)', '+ {', '+     AVFilterContext    *ctx = inlink->dst;', '+     FPSContext           *s = ctx->priv;', '+     AVFilterLink   *outlink = ctx->outputs[0];', '+     AVFilterBufferRef  *buf = inlink->cur_buf;', '+     int64_t delta;', '+     int i;', '+ ', '+     s->frames_in++;', '+     if (s->pts == AV_NOPTS_VALUE) {', '+         if (buf->pts != AV_NOPTS_VALUE) {', '+             write_to_fifo(s->fifo, buf);', '+             s->first_pts = s->pts = buf->pts;', '+         } else {', '+             av_log(ctx, AV_LOG_WARNING, ""Discarding initial frame(s) with no ""', '+                    ""timestamp.\\n"");', '+             avfilter_unref_buffer(buf);', '+             s->drop++;', '+         }', '+         return;', '+     }', '+ ', '+     if (buf->pts == AV_NOPTS_VALUE) {', '+         write_to_fifo(s->fifo, buf);', '+         return;', '+     }', '+ ', '+     delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,', '+                          outlink->time_base);', '+ ', '+     if (delta < 1) {', '+         AVFilterBufferRef *tmp;', '+         int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);', '+ ', '+         av_log(ctx, AV_LOG_DEBUG, ""Dropping %d frame(s).\\n"", drop);', '+         s->drop += drop;', '+ ', '+         av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);', '+         flush_fifo(s->fifo);', '+         write_to_fifo(s->fifo, tmp);', '+ ', '+         avfilter_unref_buffer(buf);', '+         return;', '+     }', '+ ', '+     for (i = 0; i < delta; i++) {', '+         AVFilterBufferRef *buf_out;', '+         av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);', '+ ', '+         if (!av_fifo_size(s->fifo) && i < delta - 1) {', '+             av_log(ctx, AV_LOG_DEBUG, ""Duplicating frame.\\n"");', '+             write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));', '+             s->dup++;', '+         }', '+ ', '+         buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,', '+                                     outlink->time_base) + s->frames_out;', '+ ', '+         avfilter_start_frame(outlink, buf_out);', '+         avfilter_draw_slice(outlink, 0, outlink->h, 1);', '+         avfilter_end_frame(outlink);', '+         s->frames_out++;', '+     }', '+     flush_fifo(s->fifo);', '+ ', '+     write_to_fifo(s->fifo, buf);', '+     s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);', '+ }', '+ ', '+ static void null_start_frame(AVFilterLink *link, AVFilterBufferRef *buf)', '+ {', '+ }', '+ ', '+ static void null_draw_slice(AVFilterLink *link, int y, int h, int slice_dir)', '+ {', '+ }', '+ ', '+ AVFilter avfilter_vf_fps = {', '+     .name        = ""fps"",', '+     .description = NULL_IF_CONFIG_SMALL(""Force constant framerate""),', '+ ', '+     .init      = init,', '+     .uninit    = uninit,', '+ ', '+     .priv_size = sizeof(FPSContext),', '+ ', '+     .inputs    = (AVFilterPad[]) {{ .name            = ""default"",', '+                                     .type            = AVMEDIA_TYPE_VIDEO,', '+                                     .start_frame     = null_start_frame,', '+                                     .draw_slice      = null_draw_slice,', '+                                     .end_frame       = end_frame, },', '+                                   { .name = NULL}},', '+     .outputs   = (AVFilterPad[]) {{ .name            = ""default"",', '+                                     .type            = AVMEDIA_TYPE_VIDEO,', '+                                     .request_frame   = request_frame,', '+                                     .config_props    = config_props},', '+                                   { .name = NULL}},', '+ };']]","[['+ ', '+ ', '+ #include ""libavutil/fifo.h""', '+ #include ""libavutil/mathematics.h""', '+ #include ""libavutil/opt.h""', '+ #include ""libavutil/parseutils.h""', '+ ', '+ #include ""avfilter.h""', '+ ', '+ typedef struct fpscontext {', '+     const avclass *class;', '+ ', '+ ', '+ ', '+ ', '+ } fpscontext;', '+ ', '+ #define offset(x) offsetof(fpscontext, x)', '+ #define v av_opt_flag_video_param', '+ static const avoption options[] = {', '+     { ""fps"", ""a string describing desired output framerate"", offset(fps), av_opt_type_string, { .str = ""25"" }, .flags = v },', '+     { null },', '+ };', '+ ', '+ static const avclass class = {', '+     .class_name = ""fps filter"",', '+     .item_name  = av_default_item_name,', '+     .option     = options,', '+     .version    = libavutil_version_int,', '+ };', '+ ', '+ static av_cold int init(avfiltercontext *ctx, const char *args, void *opaque)', '+ {', '+     fpscontext *s = ctx->priv;', '+     int ret;', '+ ', '+     s->class = &class;', '+     av_opt_set_defaults(s);', '+ ', '+     if ((ret = av_set_options_string(s, args, ""="", "":"")) < 0) {', '+         av_log(ctx, av_log_error, ""error parsing the options string %s.\\n"",', '+                args);', '+         return ret;', '+     }', '+ ', '+     if ((ret = av_parse_video_rate(&s->framerate, s->fps)) < 0) {', '+         av_log(ctx, av_log_error, ""error parsing framerate %s.\\n"", s->fps);', '+         return ret;', '+     }', '+     av_opt_free(s);', '+ ', '+     if (!(s->fifo = av_fifo_alloc(2*sizeof(avfilterbufferref*))))', '+         return averror(enomem);', '+ ', '+     av_log(ctx, av_log_verbose, ""fps=%d/%d\\n"", s->framerate.num, s->framerate.den);', '+     return 0;', '+ }', '+ ', '+ static void flush_fifo(avfifobuffer *fifo)', '+ {', '+     while (av_fifo_size(fifo)) {', '+         avfilterbufferref *tmp;', '+         av_fifo_generic_read(fifo, &tmp, sizeof(tmp), null);', '+         avfilter_unref_buffer(tmp);', '+     }', '+ }', '+ ', '+ static av_cold void uninit(avfiltercontext *ctx)', '+ {', '+     fpscontext *s = ctx->priv;', '+     if (s->fifo) {', '+         flush_fifo(s->fifo);', '+         av_fifo_free(s->fifo);', '+     }', '+ ', '+     av_log(ctx, av_log_verbose, ""%d frames in, %d frames out; %d frames dropped, ""', '+            ""%d frames duplicated.\\n"", s->frames_in, s->frames_out, s->drop, s->dup);', '+ }', '+ ', '+ static int config_props(avfilterlink* link)', '+ {', '+     fpscontext   *s = link->src->priv;', '+ ', '+     link->time_base = (avrational){ s->framerate.den, s->framerate.num };', '+     link->w         = link->src->inputs[0]->w;', '+     link->h         = link->src->inputs[0]->h;', '+     s->pts          = av_nopts_value;', '+ ', '+     return 0;', '+ }', '+ ', '+ static int request_frame(avfilterlink *outlink)', '+ {', '+     avfiltercontext *ctx = outlink->src;', '+     fpscontext        *s = ctx->priv;', '+     int frames_out = s->frames_out;', '+     int ret = 0;', '+ ', '+     while (ret >= 0 && s->frames_out == frames_out)', '+         ret = avfilter_request_frame(ctx->inputs[0]);', '+ ', '+     if (ret == averror_eof && av_fifo_size(s->fifo)) {', '+         int i;', '+         for (i = 0; av_fifo_size(s->fifo); i++) {', '+             avfilterbufferref *buf;', '+ ', '+             av_fifo_generic_read(s->fifo, &buf, sizeof(buf), null);', '+             buf->pts = av_rescale_q(s->first_pts, ctx->inputs[0]->time_base,', '+                                     outlink->time_base) + s->frames_out;', '+ ', '+             avfilter_start_frame(outlink, buf);', '+             avfilter_draw_slice(outlink, 0, outlink->h, 1);', '+             avfilter_end_frame(outlink);', '+             s->frames_out++;', '+         }', '+         return 0;', '+     }', '+ ', '+     return ret;', '+ }', '+ ', '+ static int write_to_fifo(avfifobuffer *fifo, avfilterbufferref *buf)', '+ {', '+     int ret;', '+ ', '+     if (!av_fifo_space(fifo) &&', '+         (ret = av_fifo_realloc2(fifo, 2*av_fifo_size(fifo))))', '+         return ret;', '+ ', '+     av_fifo_generic_write(fifo, &buf, sizeof(buf), null);', '+     return 0;', '+ }', '+ ', '+ static void end_frame(avfilterlink *inlink)', '+ {', '+     avfiltercontext    *ctx = inlink->dst;', '+     fpscontext           *s = ctx->priv;', '+     avfilterlink   *outlink = ctx->outputs[0];', '+     avfilterbufferref  *buf = inlink->cur_buf;', '+     int64_t delta;', '+     int i;', '+ ', '+     s->frames_in++;', '+     if (s->pts == av_nopts_value) {', '+         if (buf->pts != av_nopts_value) {', '+             write_to_fifo(s->fifo, buf);', '+             s->first_pts = s->pts = buf->pts;', '+         } else {', '+             av_log(ctx, av_log_warning, ""discarding initial frame(s) with no ""', '+                    ""timestamp.\\n"");', '+             avfilter_unref_buffer(buf);', '+             s->drop++;', '+         }', '+         return;', '+     }', '+ ', '+     if (buf->pts == av_nopts_value) {', '+         write_to_fifo(s->fifo, buf);', '+         return;', '+     }', '+ ', '+     delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,', '+                          outlink->time_base);', '+ ', '+     if (delta < 1) {', '+         avfilterbufferref *tmp;', '+         int drop = av_fifo_size(s->fifo)/sizeof(avfilterbufferref*);', '+ ', '+         av_log(ctx, av_log_debug, ""dropping %d frame(s).\\n"", drop);', '+         s->drop += drop;', '+ ', '+         av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), null);', '+         flush_fifo(s->fifo);', '+         write_to_fifo(s->fifo, tmp);', '+ ', '+         avfilter_unref_buffer(buf);', '+         return;', '+     }', '+ ', '+     for (i = 0; i < delta; i++) {', '+         avfilterbufferref *buf_out;', '+         av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), null);', '+ ', '+         if (!av_fifo_size(s->fifo) && i < delta - 1) {', '+             av_log(ctx, av_log_debug, ""duplicating frame.\\n"");', '+             write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, av_perm_read));', '+             s->dup++;', '+         }', '+ ', '+         buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,', '+                                     outlink->time_base) + s->frames_out;', '+ ', '+         avfilter_start_frame(outlink, buf_out);', '+         avfilter_draw_slice(outlink, 0, outlink->h, 1);', '+         avfilter_end_frame(outlink);', '+         s->frames_out++;', '+     }', '+     flush_fifo(s->fifo);', '+ ', '+     write_to_fifo(s->fifo, buf);', '+     s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);', '+ }', '+ ', '+ static void null_start_frame(avfilterlink *link, avfilterbufferref *buf)', '+ {', '+ }', '+ ', '+ static void null_draw_slice(avfilterlink *link, int y, int h, int slice_dir)', '+ {', '+ }', '+ ', '+ avfilter avfilter_vf_fps = {', '+     .name        = ""fps"",', '+     .description = null_if_config_small(""force constant framerate""),', '+ ', '+     .init      = init,', '+     .uninit    = uninit,', '+ ', '+     .priv_size = sizeof(fpscontext),', '+ ', '+     .inputs    = (avfilterpad[]) {{ .name            = ""default"",', '+                                     .type            = avmedia_type_video,', '+                                     .start_frame     = null_start_frame,', '+                                     .draw_slice      = null_draw_slice,', '+                                     .end_frame       = end_frame, },', '+                                   { .name = null}},', '+     .outputs   = (avfilterpad[]) {{ .name            = ""default"",', '+                                     .type            = avmedia_type_video,', '+                                     .request_frame   = request_frame,', '+                                     .config_props    = config_props},', '+                                   { .name = null}},', '+ };']]","[['+ ', '+ ', '+ #include ""libavutil/fifo.h""', '+ #include ""libavutil/mathematics.h""', '+ #include ""libavutil/opt.h""', '+ #include ""libavutil/parseutils.h""', '+ ', '+ #include ""avfilter.h""', '+ ', '+ typedef struct FPSContext {', '+     const AVClass *class;', '+ ', '+ ', '+ ', '+ ', '+ } FPSContext;', '+ ', '+ #define OFFSET(x) offsetof(FPSContext, x)', '+ #define V AV_OPT_FLAG_VIDEO_PARAM', '+ static const AVOption options[] = {', '+     { ""fps"", ""A string describing desired output framerate"", OFFSET(fps), AV_OPT_TYPE_STRING, { .str = ""25"" }, .flags = V },', '+     { NULL },', '+ };', '+ ', '+ static const AVClass class = {', '+     .class_name = ""FPS filter"",', '+     .item_name  = av_default_item_name,', '+     .option     = options,', '+     .version    = LIBAVUTIL_VERSION_INT,', '+ };', '+ ', '+ static av_cold int init(AVFilterContext *ctx, const char *args, void *opaque)', '+ {', '+     FPSContext *s = ctx->priv;', '+     int ret;', '+ ', '+     s->class = &class;', '+     av_opt_set_defaults(s);', '+ ', '+     if ((ret = av_set_options_string(s, args, ""="", "":"")) < 0) {', '+         av_log(ctx, AV_LOG_ERROR, ""Error parsing the options string %s.\\n"",', '+                args);', '+         return ret;', '+     }', '+ ', '+     if ((ret = av_parse_video_rate(&s->framerate, s->fps)) < 0) {', '+         av_log(ctx, AV_LOG_ERROR, ""Error parsing framerate %s.\\n"", s->fps);', '+         return ret;', '+     }', '+     av_opt_free(s);', '+ ', '+     if (!(s->fifo = av_fifo_alloc(2*sizeof(AVFilterBufferRef*))))', '+         return AVERROR(ENOMEM);', '+ ', '+     av_log(ctx, AV_LOG_VERBOSE, ""fps=%d/%d\\n"", s->framerate.num, s->framerate.den);', '+     return 0;', '+ }', '+ ', '+ static void flush_fifo(AVFifoBuffer *fifo)', '+ {', '+     while (av_fifo_size(fifo)) {', '+         AVFilterBufferRef *tmp;', '+         av_fifo_generic_read(fifo, &tmp, sizeof(tmp), NULL);', '+         avfilter_unref_buffer(tmp);', '+     }', '+ }', '+ ', '+ static av_cold void uninit(AVFilterContext *ctx)', '+ {', '+     FPSContext *s = ctx->priv;', '+     if (s->fifo) {', '+         flush_fifo(s->fifo);', '+         av_fifo_free(s->fifo);', '+     }', '+ ', '+     av_log(ctx, AV_LOG_VERBOSE, ""%d frames in, %d frames out; %d frames dropped, ""', '+            ""%d frames duplicated.\\n"", s->frames_in, s->frames_out, s->drop, s->dup);', '+ }', '+ ', '+ static int config_props(AVFilterLink* link)', '+ {', '+     FPSContext   *s = link->src->priv;', '+ ', '+     link->time_base = (AVRational){ s->framerate.den, s->framerate.num };', '+     link->w         = link->src->inputs[0]->w;', '+     link->h         = link->src->inputs[0]->h;', '+     s->pts          = AV_NOPTS_VALUE;', '+ ', '+     return 0;', '+ }', '+ ', '+ static int request_frame(AVFilterLink *outlink)', '+ {', '+     AVFilterContext *ctx = outlink->src;', '+     FPSContext        *s = ctx->priv;', '+     int frames_out = s->frames_out;', '+     int ret = 0;', '+ ', '+     while (ret >= 0 && s->frames_out == frames_out)', '+         ret = avfilter_request_frame(ctx->inputs[0]);', '+ ', '+     if (ret == AVERROR_EOF && av_fifo_size(s->fifo)) {', '+         int i;', '+         for (i = 0; av_fifo_size(s->fifo); i++) {', '+             AVFilterBufferRef *buf;', '+ ', '+             av_fifo_generic_read(s->fifo, &buf, sizeof(buf), NULL);', '+             buf->pts = av_rescale_q(s->first_pts, ctx->inputs[0]->time_base,', '+                                     outlink->time_base) + s->frames_out;', '+ ', '+             avfilter_start_frame(outlink, buf);', '+             avfilter_draw_slice(outlink, 0, outlink->h, 1);', '+             avfilter_end_frame(outlink);', '+             s->frames_out++;', '+         }', '+         return 0;', '+     }', '+ ', '+     return ret;', '+ }', '+ ', '+ static int write_to_fifo(AVFifoBuffer *fifo, AVFilterBufferRef *buf)', '+ {', '+     int ret;', '+ ', '+     if (!av_fifo_space(fifo) &&', '+         (ret = av_fifo_realloc2(fifo, 2*av_fifo_size(fifo))))', '+         return ret;', '+ ', '+     av_fifo_generic_write(fifo, &buf, sizeof(buf), NULL);', '+     return 0;', '+ }', '+ ', '+ static void end_frame(AVFilterLink *inlink)', '+ {', '+     AVFilterContext    *ctx = inlink->dst;', '+     FPSContext           *s = ctx->priv;', '+     AVFilterLink   *outlink = ctx->outputs[0];', '+     AVFilterBufferRef  *buf = inlink->cur_buf;', '+     int64_t delta;', '+     int i;', '+ ', '+     s->frames_in++;', '+     if (s->pts == AV_NOPTS_VALUE) {', '+         if (buf->pts != AV_NOPTS_VALUE) {', '+             write_to_fifo(s->fifo, buf);', '+             s->first_pts = s->pts = buf->pts;', '+         } else {', '+             av_log(ctx, AV_LOG_WARNING, ""Discarding initial frame(s) with no ""', '+                    ""timestamp.\\n"");', '+             avfilter_unref_buffer(buf);', '+             s->drop++;', '+         }', '+         return;', '+     }', '+ ', '+     if (buf->pts == AV_NOPTS_VALUE) {', '+         write_to_fifo(s->fifo, buf);', '+         return;', '+     }', '+ ', '+     delta = av_rescale_q(buf->pts - s->pts, inlink->time_base,', '+                          outlink->time_base);', '+ ', '+     if (delta < 1) {', '+         AVFilterBufferRef *tmp;', '+         int drop = av_fifo_size(s->fifo)/sizeof(AVFilterBufferRef*);', '+ ', '+         av_log(ctx, AV_LOG_DEBUG, ""Dropping %d frame(s).\\n"", drop);', '+         s->drop += drop;', '+ ', '+         av_fifo_generic_read(s->fifo, &tmp, sizeof(tmp), NULL);', '+         flush_fifo(s->fifo);', '+         write_to_fifo(s->fifo, tmp);', '+ ', '+         avfilter_unref_buffer(buf);', '+         return;', '+     }', '+ ', '+     for (i = 0; i < delta; i++) {', '+         AVFilterBufferRef *buf_out;', '+         av_fifo_generic_read(s->fifo, &buf_out, sizeof(buf_out), NULL);', '+ ', '+         if (!av_fifo_size(s->fifo) && i < delta - 1) {', '+             av_log(ctx, AV_LOG_DEBUG, ""Duplicating frame.\\n"");', '+             write_to_fifo(s->fifo, avfilter_ref_buffer(buf_out, AV_PERM_READ));', '+             s->dup++;', '+         }', '+ ', '+         buf_out->pts = av_rescale_q(s->first_pts, inlink->time_base,', '+                                     outlink->time_base) + s->frames_out;', '+ ', '+         avfilter_start_frame(outlink, buf_out);', '+         avfilter_draw_slice(outlink, 0, outlink->h, 1);', '+         avfilter_end_frame(outlink);', '+         s->frames_out++;', '+     }', '+     flush_fifo(s->fifo);', '+ ', '+     write_to_fifo(s->fifo, buf);', '+     s->pts = s->first_pts + av_rescale_q(s->frames_out, outlink->time_base, inlink->time_base);', '+ }', '+ ', '+ static void null_start_frame(AVFilterLink *link, AVFilterBufferRef *buf)', '+ {', '+ }', '+ ', '+ static void null_draw_slice(AVFilterLink *link, int y, int h, int slice_dir)', '+ {', '+ }', '+ ', '+ AVFilter avfilter_vf_fps = {', '+     .name        = ""fps"",', '+     .description = NULL_IF_CONFIG_SMALL(""Force constant framerate""),', '+ ', '+     .init      = init,', '+     .uninit    = uninit,', '+ ', '+     .priv_size = sizeof(FPSContext),', '+ ', '+     .inputs    = (AVFilterPad[]) {{ .name            = ""default"",', '+                                     .type            = AVMEDIA_TYPE_VIDEO,', '+                                     .start_frame     = null_start_frame,', '+                                     .draw_slice      = null_draw_slice,', '+                                     .end_frame       = end_frame, },', '+                                   { .name = NULL}},', '+     .outputs   = (AVFilterPad[]) {{ .name            = ""default"",', '+                                     .type            = AVMEDIA_TYPE_VIDEO,', '+                                     .request_frame   = request_frame,', '+                                     .config_props    = config_props},', '+                                   { .name = NULL}},', '+ };']]",[[]],232,0.0,232.0,54c5dd89e3125c1f363fe8f95d2837a796967c6eFFmpeg/FFmpeg,['cdd5df8189ff1537f7abe8defe971f80602cc2d2']
226d5a99c5794b23282ba08746c7fc20d688e570,vadz/libtiff,tif_fax3.c,train,C,0,"['@@ -78,9 +78,9 @@ typedef struct {\n \tint\tbit;\t\t\t/* current i/o bit in byte */\n \tint\tEOLcnt;\t\t\t/* count of EOL codes recognized */\n \tTIFFFaxFillFunc fill;\t\t/* fill routine */\n-\tuint16*\truns;\t\t\t/* b&w runs for current/previous row */\n-\tuint16*\trefruns;\t\t/* runs for reference line */\n-\tuint16*\tcurruns;\t\t/* runs for current line */\n+\tuint32*\truns;\t\t\t/* b&w runs for current/previous row */\n+\tuint32*\trefruns;\t\t/* runs for reference line */\n+\tuint32*\tcurruns;\t\t/* runs for current line */\n } Fax3DecodeState;\n #define\tDecoderState(tif)\t((Fax3DecodeState*) Fax3State(tif))\n \n@@ -117,15 +117,15 @@ typedef struct {\n     int RunLength;\t\t\t/* length of current run */\t\\\n     u_char* cp;\t\t\t\t/* next byte of input data */\t\\\n     u_char* ep;\t\t\t\t/* end of input data */\t\t\\\n-    uint16* pa;\t\t\t\t/* place to stuff next run */\t\\\n-    uint16* thisrun;\t\t\t/* current row\'s run array */\t\\\n+    uint32* pa;\t\t\t\t/* place to stuff next run */\t\\\n+    uint32* thisrun;\t\t\t/* current row\'s run array */\t\\\n     int EOLcnt;\t\t\t\t/* # EOL codes recognized */\t\\\n     const u_char* bitmap = sp->bitmap;\t/* input data bit reverser */\t\\\n     const TIFFFaxTabEnt* TabEnt\n #define\tDECLARE_STATE_2D(tif, sp, mod)\t\t\t\t\t\\\n     DECLARE_STATE(tif, sp, mod);\t\t\t\t\t\\\n     int b1;\t\t\t\t/* next change on prev line */\t\\\n-    uint16* pb\t\t\t\t/* next run in reference line */\\\n+    uint32* pb\t\t\t\t/* next run in reference line */\\\n /*\n  * Load any state that may be changed during decoding.\n  */\n@@ -295,7 +295,7 @@ Fax3Decode2D(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)\n \t\t\tEXPAND2D(EOF2Da);\n \t\t(*sp->fill)(buf, thisrun, pa, lastx);\n \t\tSETVAL(0);\t\t/* imaginary change for reference */\n-\t\tSWAP(uint16*, sp->curruns, sp->refruns);\n+\t\tSWAP(uint32*, sp->curruns, sp->refruns);\n \t\tbuf += sp->b.rowbytes;\n \t\tocc -= sp->b.rowbytes;\n \t\tif (occ != 0)\n@@ -358,7 +358,7 @@ Fax3Decode2D(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)\n  * runs generated during G3/G4 decoding.\n  */\n void\n-_TIFFFax3fillruns(u_char* buf, uint16* runs, uint16* erun, uint32 lastx)\n+_TIFFFax3fillruns(u_char* buf, uint32* runs, uint32* erun, uint32 lastx)\n {\n \tstatic const unsigned char _fillmasks[] =\n \t    { 0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };\n@@ -499,7 +499,7 @@ Fax3SetupState(TIFF* tif)\n \t\tuint32 nruns = needsRefLine ?\n \t\t     2*TIFFroundup(rowpixels,32) : rowpixels;\n \n-\t\tdsp->runs = (uint16*) _TIFFmalloc(nruns*sizeof (uint16));\n+\t\tdsp->runs = (uint32*) _TIFFmalloc(nruns*sizeof (uint16));\n \t\tif (dsp->runs == NULL) {\n \t\t\tTIFFError(""Fax3SetupState"",\n \t\t\t    ""%s: No space for Group 3/4 run arrays"",\n@@ -1375,7 +1375,7 @@ Fax4Decode(TIFF* tif, tidata_t buf, tsize_t occ, tsample_t s)\n \t\tEXPAND2D(EOFG4);\n \t\t(*sp->fill)(buf, thisrun, pa, lastx);\n \t\tSETVAL(0);\t\t/* imaginary change for reference */\n-\t\tSWAP(uint16*, sp->curruns, sp->refruns);\n+\t\tSWAP(uint32*, sp->curruns, sp->refruns);\n \t\tbuf += sp->b.rowbytes;\n \t\tocc -= sp->b.rowbytes;\n \t\tif (occ != 0)\n']",,,"['+ \t\tSWAP(uint32*, sp->curruns, sp->refruns);', '+ _TIFFFax3fillruns(u_char* buf, uint32* runs, uint32* erun, uint32 lastx)', '+ \t\tSWAP(uint32*, sp->curruns, sp->refruns);', '- \t\tSWAP(uint16*, sp->curruns, sp->refruns);', '- _TIFFFax3fillruns(u_char* buf, uint16* runs, uint16* erun, uint32 lastx)', '- \t\tSWAP(uint16*, sp->curruns, sp->refruns);']","['+ \t\tswap(uint32*, sp->curruns, sp->refruns);', '+ _tifffax3fillruns(u_char* buf, uint32* runs, uint32* erun, uint32 lastx)', '+ \t\tswap(uint32*, sp->curruns, sp->refruns);', '- \t\tswap(uint16*, sp->curruns, sp->refruns);', '- _tifffax3fillruns(u_char* buf, uint16* runs, uint16* erun, uint32 lastx)', '- \t\tswap(uint16*, sp->curruns, sp->refruns);']","['+ \t\tSWAP(uint32*, sp->curruns, sp->refruns);', '+ _TIFFFax3fillruns(u_char* buf, uint32* runs, uint32* erun, uint32 lastx)', '+ \t\tSWAP(uint32*, sp->curruns, sp->refruns);']","['- \t\tSWAP(uint16*, sp->curruns, sp->refruns);', '- _TIFFFax3fillruns(u_char* buf, uint16* runs, uint16* erun, uint32 lastx)', '- \t\tSWAP(uint16*, sp->curruns, sp->refruns);']",3,3.0,6.0,226d5a99c5794b23282ba08746c7fc20d688e570vadz/libtiff,[]
3faee6df629ac64e5965e896544e90f066b4f74d,vadz/libtiff,tif_dir.c,train,C,0,"['@@ -967,7 +967,7 @@ TIFFAdvanceDirectory(TIFF* tif, uint32* nextdir, toff_t* off)\n \tif (isMapped(tif))\n \t  {\n \t    tsize_t poff=*nextdir;\n-\t    if (poff+sizeof (uint16) > tif->tif_size)\n+\t    if (((tsize_t) (poff+sizeof(uint16))) > tif->tif_size)\n \t      {\n \t\tTIFFError(module, ""%s: Error fetching directory count"",\n \t\t\t  tif->tif_name);\n@@ -979,7 +979,7 @@ TIFFAdvanceDirectory(TIFF* tif, uint32* nextdir, toff_t* off)\n \t    poff+=sizeof (uint16)+dircount*sizeof (TIFFDirEntry);\n \t    if (off != NULL)\n \t      *off = poff;\n-\t    if (poff+sizeof (uint32) > tif->tif_size)\n+\t    if (((tsize_t) (poff+sizeof (uint32))) > tif->tif_size)\n \t      {\n \t\tTIFFError(module, ""%s: Error fetching directory link"",\n \t\t\t  tif->tif_name);\n']",,,"['+ \t    if (((tsize_t) (poff+sizeof(uint16))) > tif->tif_size)', '+ \t    if (((tsize_t) (poff+sizeof (uint32))) > tif->tif_size)', '- \t    if (poff+sizeof (uint16) > tif->tif_size)', '- \t    if (poff+sizeof (uint32) > tif->tif_size)']","['+ \t    if (((tsize_t) (poff+sizeof(uint16))) > tif->tif_size)', '+ \t    if (((tsize_t) (poff+sizeof (uint32))) > tif->tif_size)', '- \t    if (poff+sizeof (uint16) > tif->tif_size)', '- \t    if (poff+sizeof (uint32) > tif->tif_size)']","['+ \t    if (((tsize_t) (poff+sizeof(uint16))) > tif->tif_size)', '+ \t    if (((tsize_t) (poff+sizeof (uint32))) > tif->tif_size)']","['- \t    if (poff+sizeof (uint16) > tif->tif_size)', '- \t    if (poff+sizeof (uint32) > tif->tif_size)']",2,2.0,4.0,3faee6df629ac64e5965e896544e90f066b4f74dvadz/libtiff,[]
21c6761c35613fe454dc3599063dfbde479b3e9f,memcached/memcached,memcached.c,train,C,0,"['@@ -614,7 +614,7 @@ void process_command(conn *c, char *command) {\n     }\n \n     if (strcmp(command, ""version"") == 0) {\n-        out_string(c, ""VERSION 2.0"");\n+        out_string(c, ""VERSION "" VERSION);\n         return;\n     }\n \n@@ -697,7 +697,7 @@ int try_read_network(conn *c) {\n \n int update_event(conn *c, int new_flags) {\n     if (c->ev_flags == new_flags)\n-        return 0;\n+        return 1;\n     if (event_del(&c->event) == -1) return 0;\n     event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n     c->ev_flags = new_flags;\n']",,,"['+         out_string(c, ""VERSION "" VERSION);', '+         return 1;', '-         out_string(c, ""VERSION 2.0"");', '-         return 0;']","['+         out_string(c, ""version "" version);', '+         return 1;', '-         out_string(c, ""version 2.0"");', '-         return 0;']","['+         out_string(c, ""VERSION "" VERSION);', '+         return 1;']","['-         out_string(c, ""VERSION 2.0"");', '-         return 0;']",2,2.0,4.0,21c6761c35613fe454dc3599063dfbde479b3e9fmemcached/memcached,[]
501f9a21ebe15178f996e86d2c8fcf23e7b63aea,yoe/nbd,nbd-server.c,test,C,1,"['@@ -88,6 +88,15 @@\n #define MY_NAME ""nbd_server""\n #include ""cliserv.h""\n \n+/** Default position of the config file */\n+#ifndef SYSCONFDIR\n+#define SYSCONFDIR ""/etc""\n+#endif\n+#define CFILE SYSCONFDIR ""/nbd-server/config""\n+\n+/** Where our config file actually is */\n+gchar* config_file_pos;\n+\n /** how much space for child PIDs we have by default. Dynamically\n    allocated, and will be realloc()ed if out of space, so this should\n    probably be fair for most situations. */\n@@ -151,7 +160,7 @@ char default_authname[] = ""/etc/nbd_server.allow""; /**< default name of allow fi\n  * Variables associated with a server.\n  **/\n typedef struct {\n-\tchar* exportname;    /**< (unprocessed) filename of the file we\'re exporting */\n+\tgchar* exportname;    /**< (unprocessed) filename of the file we\'re exporting */\n \toff_t hunksize;      /**< size of a hunk of an exported file */\n \toff_t expected_size; /**< size of the exported file as it was told to\n \t\t\t       us through configuration */\n@@ -183,11 +192,36 @@ typedef struct {\n \tu32 *difmap;\t     /**< see comment on the global difmap for this one */\n } CLIENT;\n \n+/**\n+ * Type of configuration file values\n+ **/\n+typedef enum {\n+\tPARAM_INT,\t\t/**< This parameter is an integer */\n+\tPARAM_STRING,\t\t/**< This parameter is a string */\n+\tPARAM_BOOL,\t\t/**< This parameter is a boolean */\n+} PARAM_TYPE;\n+/**\n+ * Configuration file values\n+ **/\n+typedef struct {\n+\tgchar *paramname;\t/**< Name of the parameter, as it appears in\n+\t\t\t\t  the config file */\n+\tgboolean required;\t/**< Whether this is a required (as opposed to\n+\t\t\t\t  optional) parameter */\n+\tPARAM_TYPE ptype;\t/**< Type of the parameter. */\n+\tgpointer target;\t/**< Pointer to where the data of this\n+\t\t\t\t  parameter should be written. If ptype is\n+\t\t\t\t  PARAM_BOOL, the data is or\'ed rather than\n+\t\t\t\t  overwritten. */\n+\tgint flagval;\t\t/**< Flag mask for this parameter in case ptype\n+\t\t\t\t  is PARAM_BOOL. */\n+} PARAM;\n+\n /**\n  * Check whether a client is allowed to connect. Works with an authorization\n  * file which contains one line per machine, no wildcards.\n  *\n- * @param name IP address of client trying to connect (in human-readable form)\n+ * @param opts The client who\'s trying to connect.\n  * @return 0 - authorization refused, 1 - OK\n  **/\n int authorized_client(CLIENT *opts) {\n@@ -262,20 +296,18 @@ void usage() {\n \t       ""\\tif port is set to 0, stdin is used (for running from inetd)\\n""\n \t       ""\\tif file_to_export contains \'%%s\', it is substituted with the IP\\n""\n \t       ""\\t\\taddress of the machine trying to connect\\n"" );\n+\tprintf(""Using configuration file %s\\n"", CFILE);\n }\n \n /**\n  * Parse the command line.\n  *\n- * @todo getopt() is a great thing, and easy to use. Also, we want to\n- * create a configuration file which nbd-server will read. Maybe do (as in,\n- * parse) that here.\n- *\n  * @param argc the argc argument to main()\n  * @param argv the argv argument to main()\n  **/\n SERVER* cmdline(int argc, char *argv[]) {\n \tint i=0;\n+\tint nonspecial=0;\n \tint c;\n \tstruct option long_options[] = {\n \t\t{""read-only"", no_argument, NULL, \'r\'},\n@@ -283,71 +315,209 @@ SERVER* cmdline(int argc, char *argv[]) {\n \t\t{""copy-on-write"", no_argument, NULL, \'c\'},\n \t\t{""authorize-file"", required_argument, NULL, \'l\'},\n \t\t{""idle-time"", required_argument, NULL, \'a\'},\n+\t\t{""config-file"", required_argument, NULL, \'C\'},\n \t\t{0,0,0,0}\n \t};\n \tSERVER *serve;\n+\toff_t es;\n+\tsize_t last;\n+\tchar suffix;\n \n-\tserve=g_malloc(sizeof(SERVER));\n+\tif(argc==1) {\n+\t\treturn NULL;\n+\t}\n+\tserve=g_new0(SERVER, 1);\n \tserve->hunksize=OFFT_MAX;\n-\twhile((c=getopt_long(argc, argv, ""a:cl:mr"", long_options, &i))>=0) {\n+\tserve->authname = g_strdup(default_authname);\n+\twhile((c=getopt_long(argc, argv, ""-a:C:cl:mr"", long_options, &i))>=0) {\n \t\tswitch (c) {\n+\t\tcase 1:\n+\t\t\t/* non-option argument */\n+\t\t\tswitch(nonspecial++) {\n+\t\t\tcase 0:\n+\t\t\t\tserve->port=strtol(optarg, NULL, 0);\n+\t\t\t\tbreak;\n+\t\t\tcase 1:\n+\t\t\t\tserve->exportname = g_strdup(optarg);\n+\t\t\t\tif(serve->exportname[0] != \'/\') {\n+\t\t\t\t\tfprintf(stderr, ""E: The to be exported file needs to be an absolute filename!\\n"");\n+\t\t\t\t\texit(EXIT_FAILURE);\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase 2:\n+\t\t\t\tlast=strlen(optarg)-1;\n+\t\t\t\tsuffix=optarg[last];\n+\t\t\t\tif (suffix == \'k\' || suffix == \'K\' ||\n+\t\t\t\t    suffix == \'m\' || suffix == \'M\')\n+\t\t\t\t\toptarg[last] = \'\\0\';\n+\t\t\t\tes = (off_t)atol(optarg);\n+\t\t\t\tswitch (suffix) {\n+\t\t\t\t\tcase \'m\':\n+\t\t\t\t\tcase \'M\':  es <<= 10;\n+\t\t\t\t\tcase \'k\':\n+\t\t\t\t\tcase \'K\':  es <<= 10;\n+\t\t\t\t\tdefault :  break;\n+\t\t\t\t}\n+\t\t\t\tserve->expected_size = es;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tbreak;\n \t\tcase \'r\':\n \t\t\tserve->flags |= F_READONLY;\n \t\t\tbreak;\n \t\tcase \'m\':\n \t\t\tserve->flags |= F_MULTIFILE;\n \t\t\tserve->hunksize = 1*GIGA;\n-\t\t\tserve->authname = default_authname;\n \t\t\tbreak;\n \t\tcase \'c\': \n \t\t\tserve->flags |=F_COPYONWRITE;\n \t\t        break;\n+\t\tcase \'C\':\n+\t\t\tg_free(config_file_pos);\n+\t\t\tconfig_file_pos=g_strdup(optarg);\n+\t\t\tbreak;\n \t\tcase \'l\':\n-\t\t\tserve->authname=optarg;\n+\t\t\tg_free(serve->authname);\n+\t\t\tserve->authname=g_strdup(optarg);\n \t\t\tbreak;\n \t\tcase \'a\': \n \t\t\tserve->timeout=strtol(optarg, NULL, 0);\n \t\t\tbreak;\n \t\tdefault:\n \t\t\tusage();\n-\t\t\texit(0);\n+\t\t\texit(EXIT_FAILURE);\n \t\t\tbreak;\n \t\t}\n \t}\n \t/* What\'s left: the port to export, the name of the to be exported\n \t * file, and, optionally, the size of the file, in that order. */\n-\tif(++i>=argc) {\n-\t\tusage();\n-\t\texit(0);\n-\t} \n-\tserve->port=strtol(argv[i], NULL, 0);\n-\tif(++i>=argc) {\n+\tif(nonspecial<2) {\n \t\tusage();\n-\t\texit(0);\n-\t}\n-\tserve->exportname = argv[i];\n-\tif(serve->exportname[0] != \'/\') {\n-\t\tfprintf(stderr, ""E: The to be exported file needs to be an absolute filename!\\n"");\n \t\texit(EXIT_FAILURE);\n \t}\n-\tif(++i<argc) {\n-\t\toff_t es;\n-\t\tsize_t last = strlen(argv[i])-1;\n-\t\tchar suffix = argv[i][last];\n-\t\tif (suffix == \'k\' || suffix == \'K\' ||\n-\t\t    suffix == \'m\' || suffix == \'M\')\n-\t\t\targv[i][last] = \'\\0\';\n-\t\tes = (off_t)atol(argv[i]);\n-\t\tswitch (suffix) {\n-\t\t\tcase \'m\':\n-\t\t\tcase \'M\':  es <<= 10;\n-\t\t\tcase \'k\':\n-\t\t\tcase \'K\':  es <<= 10;\n-\t\t\tdefault :  break;\n+\treturn serve;\n+}\n+\n+/**\n+ * Error codes for config file parsing\n+ **/\n+typedef enum {\n+\tCFILE_NOTFOUND,\t\t/**< The configuration file is not found */\n+\tCFILE_MISSING_GENERIC,\t/**< The (required) group ""generic"" is missing */\n+\tCFILE_KEY_MISSING,\t/**< A (required) key is missing */\n+\tCFILE_VALUE_INVALID,\t/**< A value is syntactically invalid */\n+\tCFILE_PROGERR\t\t/**< Programmer error */\n+} CFILE_ERRORS;\n+\n+/**\n+ * Remove a SERVER from memory. Used from the hash table\n+ **/\n+void remove_server(gpointer s) {\n+\tSERVER *server;\n+\n+\tserver=(SERVER*)s;\n+\tg_free(server->exportname);\n+\tif(server->authname)\n+\t\tg_free(server->authname);\n+\tg_free(server);\n+}\n+\n+/**\n+ * Parse the config file.\n+ *\n+ * @param f the name of the config file\n+ * @param e a GError. @see CFILE_ERRORS for what error values this function can\n+ * \treturn.\n+ * @return a GHashTable of SERVER* pointers, with the port number as the hash\n+ *\tkey. If the config file is empty or does not exist, returns an empty\n+ *\tGHashTable; if the config file contains an error, returns NULL, and\n+ *\te is set appropriately\n+ **/\n+GHashTable* parse_cfile(gchar* f, GError** e) {\n+\tSERVER *s;\n+\tPARAM p[] = {\n+\t\t{ ""exportname"", TRUE,\tPARAM_STRING, \tNULL, 0 },\n+\t\t{ ""port"", \tTRUE,\tPARAM_INT, \tNULL, 0 },\n+\t\t{ ""authfile"",\tFALSE,\tPARAM_STRING,\tNULL, 0 },\n+\t\t{ ""timeout"",\tFALSE,\tPARAM_INT,\tNULL, 0 },\n+\t\t{ ""filesize"",\tFALSE,\tPARAM_INT,\tNULL, 0 },\n+\t\t{ ""readonly"",\tFALSE,\tPARAM_BOOL,\tNULL, F_READONLY },\n+\t\t{ ""multifile"",\tFALSE,\tPARAM_BOOL,\tNULL, F_MULTIFILE },\n+\t\t{ ""copyonwrite"", FALSE,\tPARAM_BOOL,\tNULL, F_COPYONWRITE },\n+\t};\n+\tGKeyFile *cfile;\n+\tGError *err = NULL;\n+\tGQuark errdomain;\n+\tGHashTable *retval;\n+\tgchar **groups;\n+\tgboolean value;\n+\tgint i,j;\n+\n+\terrdomain = g_quark_from_string(""parse_cfile"");\n+\tcfile = g_key_file_new();\n+\tretval = g_hash_table_new_full(g_int_hash, g_int_equal, NULL, remove_server);\n+\tif(!g_key_file_load_from_file(cfile, f, G_KEY_FILE_KEEP_COMMENTS |\n+\t\t\tG_KEY_FILE_KEEP_TRANSLATIONS, &err)) {\n+\t\tg_set_error(e, errdomain, CFILE_NOTFOUND, ""Could not open config file."");\n+\t\tg_key_file_free(cfile);\n+\t\treturn retval;\n+\t}\n+\tif(strcmp(g_key_file_get_start_group(cfile), ""generic"")) {\n+\t\tg_set_error(e, errdomain, CFILE_MISSING_GENERIC, ""Config file does not contain the [generic] group!"");\n+\t\tg_key_file_free(cfile);\n+\t\treturn NULL;\n+\t}\n+\tgroups = g_key_file_get_groups(cfile, NULL);\n+\tfor(i=0;groups[i];i++) {\n+\t\ts=g_new0(SERVER, 1);\n+\t\tp[0].target=&(s->exportname);\n+\t\tp[1].target=&(s->port);\n+\t\tp[2].target=&(s->authname);\n+\t\tp[3].target=&(s->timeout);\n+\t\tp[4].target=&(s->expected_size);\n+\t\tp[5].target=p[6].target=p[7].target=p[8].target=&(s->flags);\n+\t\tfor(j=0;j<9;j++) {\n+\t\t\tg_assert(p[j].target != NULL);\n+\t\t\tg_assert(p[j].ptype==PARAM_INT||p[j].ptype==PARAM_STRING||p[j].ptype==PARAM_BOOL);\n+\t\t\tswitch(p[j].ptype) {\n+\t\t\t\tcase PARAM_INT:\n+\t\t\t\t\t*((gint*)p[j].target) = g_key_file_get_integer(cfile, groups[i], p[j].paramname, &err);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase PARAM_STRING:\n+\t\t\t\t\t*((gchar**)p[j].target) = g_key_file_get_string(cfile, groups[i], p[j].paramname, &err);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase PARAM_BOOL:\n+\t\t\t\t\tvalue = g_key_file_get_boolean(cfile, groups[i], p[j].paramname, &err);\n+\t\t\t\t\tif(!err) {\n+\t\t\t\t\t\t*((gint*)p[j].target) |= value;\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif(err) {\n+\t\t\t\tif(err->code == G_KEY_FILE_ERROR_KEY_NOT_FOUND) {\n+\t\t\t\t\tif(p[j].required) {\n+\t\t\t\t\t\tg_set_error(e, errdomain, CFILE_KEY_MISSING, ""Could not find required value %s in group %s: %s"", p[j].paramname, groups[i], err->message);\n+\t\t\t\t\t\tg_hash_table_destroy(retval);\n+\t\t\t\t\t\tg_error_free(err);\n+\t\t\t\t\t\tg_key_file_free(cfile);\n+\t\t\t\t\t\tg_free(s);\n+\t\t\t\t\t\treturn NULL;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tg_error_free(err);\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\tg_set_error(e, errdomain, CFILE_VALUE_INVALID, ""Could not parse %s in group %s: %s"", p[j].paramname, groups[i], err->message);\n+\t\t\t\t\tg_hash_table_destroy(retval);\n+\t\t\t\t\tg_error_free(err);\n+\t\t\t\t\tg_key_file_free(cfile);\n+\t\t\t\t\tg_free(s);\n+\t\t\t\t\treturn NULL;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\tserve->expected_size = es;\n+\t\tg_hash_table_insert(retval, &(s->port), s);\n \t}\n-\treturn serve;\n+\treturn retval;\n }\n \n /**\n@@ -475,6 +645,7 @@ void myseek(int handle,off_t a) {\n  * @param a The offset where the write should start\n  * @param buf The buffer to write from\n  * @param len The length of buf\n+ * @param client The client we\'re serving for\n  * @return The number of bytes actually written, or -1 in case of an error\n  **/\n int rawexpwrite(off_t a, char *buf, size_t len, CLIENT *client) {\n@@ -493,6 +664,7 @@ int rawexpwrite(off_t a, char *buf, size_t len, CLIENT *client) {\n  * @param a The offset where the read should start\n  * @param buf A buffer to read into\n  * @param len The size of buf\n+ * @param client The client we\'re serving for\n  * @return The number of bytes actually read, or -1 in case of an\n  * error.\n  **/\n@@ -512,6 +684,7 @@ int rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {\n  * @param a The offset where the read should start\n  * @param buf A buffer to read into\n  * @param len The size of buf\n+ * @param client The client we\'re going to read for\n  * @return The number of bytes actually read, or -1 in case of an error\n  **/\n int expread(off_t a, char *buf, size_t len, CLIENT *client) {\n@@ -552,6 +725,7 @@ int expread(off_t a, char *buf, size_t len, CLIENT *client) {\n  * @param a The offset where the write should start\n  * @param buf The buffer to write from\n  * @param len The length of buf\n+ * @param client The client we\'re going to write for.\n  * @return The number of bytes actually written, or -1 in case of an error\n  **/\n int expwrite(off_t a, char *buf, size_t len, CLIENT *client) {\n@@ -605,7 +779,7 @@ int expwrite(off_t a, char *buf, size_t len, CLIENT *client) {\n /**\n  * Do the initial negotiation.\n  *\n- * @param net A socket to do the negotiation over\n+ * @param client The client we\'re negotiating with.\n  **/\n void negotiate(CLIENT *client) {\n \tchar zeros[300];\n@@ -634,7 +808,7 @@ void negotiate(CLIENT *client) {\n  * @todo This beast needs to be split up in many tiny little manageable\n  * pieces. Preferably with a chainsaw.\n  *\n- * @param net A network socket, connected to an nbd client\n+ * @param client The client we\'re going to serve to.\n  * @return never\n  **/\n int mainloop(CLIENT *client) {\n@@ -677,7 +851,7 @@ int mainloop(CLIENT *client) {\n \n \t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n \t\t\terr(""Not enough magic."");\n-\t\tif (len > BUFSIZE)\n+\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))\n \t\t\terr(""Request too big!"");\n #ifdef DODBG\n \t\tprintf(""%s from %Lu (%Lu) len %d, "", request.type ? ""WRITE"" :\n@@ -786,7 +960,7 @@ int copyonwrite_prepare(CLIENT* client)\n  * @todo allow for multithreading, perhaps use libevent. Not just yet, though;\n  * follow the road map.\n  *\n- * @param net A network socket connected to an nbd client\n+ * @param client a connected client\n  **/\n void serveconnection(CLIENT *client) {\n \tsplitexport(client);\n@@ -851,25 +1025,29 @@ void destroy_pid_t(gpointer data) {\n /**\n  * Go daemon (unless we specified at compile time that we didn\'t want this)\n  * @param serve the first server of our configuration. If its port is zero,\n- * \tthen do not daemonize, because we\'re doing inetd then.\n+ * \tthen do not daemonize, because we\'re doing inetd then. This parameter\n+ * \tis only used to create a PID file of the form\n+ * \t/var/run/nbd-server.&lt;port&gt;.pid; it\'s not modified in any way.\n  **/\n #if !defined(NODAEMON) && !defined(NOFORK)\n void daemonize(SERVER* serve) {\n \tFILE*pidf;\n \n-\tif((serve->port)) {\n-\t\tif(daemon(0,0)<0) {\n-\t\t\terr(""daemon"");\n-\t\t}\n+\tif(daemon(0,0)<0) {\n+\t\terr(""daemon"");\n+\t}\n+\tif(serve) {\n \t\tsnprintf(pidfname, sizeof(char)*255, ""/var/run/nbd-server.%d.pid"", serve->port);\n-\t\tpidf=fopen(pidfname, ""w"");\n-\t\tif(pidf) {\n-\t\t\tfprintf(pidf,""%d"", (int)getpid());\n-\t\t\tfclose(pidf);\n-\t\t} else {\n-\t\t\tperror(""fopen"");\n-\t\t\tfprintf(stderr, ""Not fatal; continuing"");\n-\t\t}\n+\t} else {\n+\t\tstrncpy(pidfname, ""/var/run/nbd-server.pid"", sizeof(char)*255);\n+\t}\n+\tpidf=fopen(pidfname, ""w"");\n+\tif(pidf) {\n+\t\tfprintf(pidf,""%d\\n"", (int)getpid());\n+\t\tfclose(pidf);\n+\t} else {\n+\t\tperror(""fopen"");\n+\t\tfprintf(stderr, ""Not fatal; continuing"");\n \t}\n }\n #else\n@@ -879,13 +1057,14 @@ void daemonize(SERVER* serve) {\n /**\n  * Connect a server\'s socket.\n  *\n- * @todo modularize this giant beast. Preferably with a chainsaw. Also,\n- * it has no business starting mainloop(), through serveconnection(); it\n- * should connect, and be done with it.\n+ * @todo modularize this giant beast.\n  *\n+ * @param port the port we\'re connecting to (we don\'t need it, but\n+ * g_hash_table_foreach requires it)\n  * @param serve the server we want to connect.\n+ * @param data (unused) user data.\n  **/\n-void setup_serve(SERVER* serve) {\n+void setup_serve(gpointer port, gpointer s, gpointer data) {\n \tstruct sockaddr_in addrin;\n \tstruct sigaction sa;\n \tint addrinlen = sizeof(addrin);\n@@ -894,7 +1073,9 @@ void setup_serve(SERVER* serve) {\n #else\n \tchar yes=\'1\';\n #endif /* sun */\n+\tSERVER *serve=(SERVER*)s;\n \n+\tg_assert(data==NULL);\n \tif ((serve->socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)\n \t\terr(""socket: %m"");\n \n@@ -928,6 +1109,13 @@ void setup_serve(SERVER* serve) {\n \tchildren=g_hash_table_new_full(g_int_hash, g_int_equal, NULL, destroy_pid_t);\n }\n \n+/**\n+ * Connect our servers.\n+ **/\n+void setup_servers(GHashTable* servers) {\n+\tg_hash_table_foreach(servers, setup_serve, NULL);\n+}\n+\n /**\n  * Loop through the available servers, and serve them.\n  *\n@@ -982,8 +1170,9 @@ int serveloop(SERVER* serve) {\n  * Main entry point...\n  **/\n int main(int argc, char *argv[]) {\n-\tSERVER* serve;\n-\tGArray* servers;\n+\tSERVER *serve;\n+\tGHashTable *servers;\n+\tGError *err=NULL;\n \n \tif (sizeof( struct nbd_request )!=28) {\n \t\tfprintf(stderr,""Bad size of structure. Alignment problems?\\n"");\n@@ -991,9 +1180,18 @@ int main(int argc, char *argv[]) {\n \t}\n \n \tlogging();\n+\tconfig_file_pos = g_strdup(CFILE);\n \tserve=cmdline(argc, argv);\n-\tservers=g_array_new(TRUE, FALSE, sizeof(SERVER*));\n+\tservers = parse_cfile(config_file_pos, &err);\n+\tif(!servers) {\n+\t\tg_critical(""Could not parse command file: %s"", err->message);\n+\t}\n+\tif(serve) {\n+\t\tg_hash_table_insert(servers, &serve->port, serve);\n+\t}\n \n+/* We don\'t support this at this time */\n+#if 0\n \tif (!(serve->port)) {\n \t  \tCLIENT *client;\n #ifndef ISSERVER\n@@ -1014,8 +1212,13 @@ int main(int argc, char *argv[]) {\n           \tserveconnection(client);\n           \treturn 0;\n         }\n+#endif\n+\tif((!serve) && (!servers)) {\n+\t\tg_message(""Nothing to do! Bye!"");\n+\t\texit(EXIT_FAILURE);\n+\t}\n \tdaemonize(serve);\n-\tsetup_serve(serve);\n-\tserveloop(serve);\n+\tsetup_servers(servers);\n+\tserveloop(servers);\n \treturn 0 ;\n }\n']",2006-01-06 17:03:10+00:00,r141: Commit this before I accidentally remove it again..,"[['+ #ifndef SYSCONFDIR', '+ #define SYSCONFDIR ""/etc""', '+ #endif', '+ #define CFILE SYSCONFDIR ""/nbd-server/config""', '+ ', '+ gchar* config_file_pos;', '+ ', '+ typedef enum {', '+ } PARAM_TYPE;', '+ typedef struct {', '+ \t\t\t\t  the config file */', '+ \t\t\t\t  optional) parameter */', '+ \t\t\t\t  parameter should be written. If ptype is', ""+ \t\t\t\t  PARAM_BOOL, the data is or'ed rather than"", '+ \t\t\t\t  overwritten. */', '+ \t\t\t\t  is PARAM_BOOL. */', '+ } PARAM;', '+ ', '+ \tprintf(""Using configuration file %s\\n"", CFILE);', '+ \tint nonspecial=0;', '+ \t\t{""config-file"", required_argument, NULL, \'C\'},', '+ \toff_t es;', '+ \tsize_t last;', '+ \tchar suffix;', '+ \tif(argc==1) {', '+ \t\treturn NULL;', '+ \t}', '+ \tserve=g_new0(SERVER, 1);', '+ \tserve->authname = g_strdup(default_authname);', '+ \twhile((c=getopt_long(argc, argv, ""-a:C:cl:mr"", long_options, &i))>=0) {', '+ \t\tcase 1:', '+ \t\t\tswitch(nonspecial++) {', '+ \t\t\tcase 0:', '+ \t\t\t\tserve->port=strtol(optarg, NULL, 0);', '+ \t\t\t\tbreak;', '+ \t\t\tcase 1:', '+ \t\t\t\tserve->exportname = g_strdup(optarg);', ""+ \t\t\t\tif(serve->exportname[0] != '/') {"", '+ \t\t\t\t\tfprintf(stderr, ""E: The to be exported file needs to be an absolute filename!\\n"");', '+ \t\t\t\t\texit(EXIT_FAILURE);', '+ \t\t\t\t}', '+ \t\t\t\tbreak;', '+ \t\t\tcase 2:', '+ \t\t\t\tlast=strlen(optarg)-1;', '+ \t\t\t\tsuffix=optarg[last];', ""+ \t\t\t\tif (suffix == 'k' || suffix == 'K' ||"", ""+ \t\t\t\t    suffix == 'm' || suffix == 'M')"", ""+ \t\t\t\t\toptarg[last] = '\\0';"", '+ \t\t\t\tes = (off_t)atol(optarg);', '+ \t\t\t\tswitch (suffix) {', ""+ \t\t\t\t\tcase 'm':"", ""+ \t\t\t\t\tcase 'M':  es <<= 10;"", ""+ \t\t\t\t\tcase 'k':"", ""+ \t\t\t\t\tcase 'K':  es <<= 10;"", '+ \t\t\t\t\tdefault :  break;', '+ \t\t\t\t}', '+ \t\t\t\tserve->expected_size = es;', '+ \t\t\t\tbreak;', '+ \t\t\t}', '+ \t\t\tbreak;', ""+ \t\tcase 'C':"", '+ \t\t\tg_free(config_file_pos);', '+ \t\t\tconfig_file_pos=g_strdup(optarg);', '+ \t\t\tbreak;', '+ \t\t\tg_free(serve->authname);', '+ \t\t\tserve->authname=g_strdup(optarg);', '+ \t\t\texit(EXIT_FAILURE);', '+ \tif(nonspecial<2) {', '+ \treturn serve;', '+ }', '+ ', '+ typedef enum {', '+ } CFILE_ERRORS;', '+ ', '+ void remove_server(gpointer s) {', '+ \tSERVER *server;', '+ ', '+ \tserver=(SERVER*)s;', '+ \tg_free(server->exportname);', '+ \tif(server->authname)', '+ \t\tg_free(server->authname);', '+ \tg_free(server);', '+ }', '+ ', '+ GHashTable* parse_cfile(gchar* f, GError** e) {', '+ \tSERVER *s;', '+ \tPARAM p[] = {', '+ \t\t{ ""exportname"", TRUE,\tPARAM_STRING, \tNULL, 0 },', '+ \t\t{ ""port"", \tTRUE,\tPARAM_INT, \tNULL, 0 },', '+ \t\t{ ""authfile"",\tFALSE,\tPARAM_STRING,\tNULL, 0 },', '+ \t\t{ ""timeout"",\tFALSE,\tPARAM_INT,\tNULL, 0 },', '+ \t\t{ ""filesize"",\tFALSE,\tPARAM_INT,\tNULL, 0 },', '+ \t\t{ ""readonly"",\tFALSE,\tPARAM_BOOL,\tNULL, F_READONLY },', '+ \t\t{ ""multifile"",\tFALSE,\tPARAM_BOOL,\tNULL, F_MULTIFILE },', '+ \t\t{ ""copyonwrite"", FALSE,\tPARAM_BOOL,\tNULL, F_COPYONWRITE },', '+ \t};', '+ \tGKeyFile *cfile;', '+ \tGError *err = NULL;', '+ \tGQuark errdomain;', '+ \tGHashTable *retval;', '+ \tgchar **groups;', '+ \tgboolean value;', '+ \tgint i,j;', '+ ', '+ \terrdomain = g_quark_from_string(""parse_cfile"");', '+ \tcfile = g_key_file_new();', '+ \tretval = g_hash_table_new_full(g_int_hash, g_int_equal, NULL, remove_server);', '+ \tif(!g_key_file_load_from_file(cfile, f, G_KEY_FILE_KEEP_COMMENTS |', '+ \t\t\tG_KEY_FILE_KEEP_TRANSLATIONS, &err)) {', '+ \t\tg_set_error(e, errdomain, CFILE_NOTFOUND, ""Could not open config file."");', '+ \t\tg_key_file_free(cfile);', '+ \t\treturn retval;', '+ \t}', '+ \tif(strcmp(g_key_file_get_start_group(cfile), ""generic"")) {', '+ \t\tg_set_error(e, errdomain, CFILE_MISSING_GENERIC, ""Config file does not contain the [generic] group!"");', '+ \t\tg_key_file_free(cfile);', '+ \t\treturn NULL;', '+ \t}', '+ \tgroups = g_key_file_get_groups(cfile, NULL);', '+ \tfor(i=0;groups[i];i++) {', '+ \t\ts=g_new0(SERVER, 1);', '+ \t\tp[0].target=&(s->exportname);', '+ \t\tp[1].target=&(s->port);', '+ \t\tp[2].target=&(s->authname);', '+ \t\tp[3].target=&(s->timeout);', '+ \t\tp[4].target=&(s->expected_size);', '+ \t\tp[5].target=p[6].target=p[7].target=p[8].target=&(s->flags);', '+ \t\tfor(j=0;j<9;j++) {', '+ \t\t\tg_assert(p[j].target != NULL);', '+ \t\t\tg_assert(p[j].ptype==PARAM_INT||p[j].ptype==PARAM_STRING||p[j].ptype==PARAM_BOOL);', '+ \t\t\tswitch(p[j].ptype) {', '+ \t\t\t\tcase PARAM_INT:', '+ \t\t\t\t\t*((gint*)p[j].target) = g_key_file_get_integer(cfile, groups[i], p[j].paramname, &err);', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase PARAM_STRING:', '+ \t\t\t\t\t*((gchar**)p[j].target) = g_key_file_get_string(cfile, groups[i], p[j].paramname, &err);', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase PARAM_BOOL:', '+ \t\t\t\t\tvalue = g_key_file_get_boolean(cfile, groups[i], p[j].paramname, &err);', '+ \t\t\t\t\tif(!err) {', '+ \t\t\t\t\t\t*((gint*)p[j].target) |= value;', '+ \t\t\t\t\t}', '+ \t\t\t\t\tbreak;', '+ \t\t\t}', '+ \t\t\tif(err) {', '+ \t\t\t\tif(err->code == G_KEY_FILE_ERROR_KEY_NOT_FOUND) {', '+ \t\t\t\t\tif(p[j].required) {', '+ \t\t\t\t\t\tg_set_error(e, errdomain, CFILE_KEY_MISSING, ""Could not find required value %s in group %s: %s"", p[j].paramname, groups[i], err->message);', '+ \t\t\t\t\t\tg_hash_table_destroy(retval);', '+ \t\t\t\t\t\tg_error_free(err);', '+ \t\t\t\t\t\tg_key_file_free(cfile);', '+ \t\t\t\t\t\tg_free(s);', '+ \t\t\t\t\t\treturn NULL;', '+ \t\t\t\t\t} else {', '+ \t\t\t\t\t\tg_error_free(err);', '+ \t\t\t\t\t\tcontinue;', '+ \t\t\t\t\t}', '+ \t\t\t\t\tg_set_error(e, errdomain, CFILE_VALUE_INVALID, ""Could not parse %s in group %s: %s"", p[j].paramname, groups[i], err->message);', '+ \t\t\t\t\tg_hash_table_destroy(retval);', '+ \t\t\t\t\tg_error_free(err);', '+ \t\t\t\t\tg_key_file_free(cfile);', '+ \t\t\t\t\tg_free(s);', '+ \t\t\t\t\treturn NULL;', '+ \t\t\t\t}', '+ \t\t\t}', '+ \t\tg_hash_table_insert(retval, &(s->port), s);', '+ \treturn retval;', '+ \t\tif (len > BUFSIZE + sizeof(struct nbd_reply))', '+ \tif(daemon(0,0)<0) {', '+ \t\terr(""daemon"");', '+ \t}', '+ \tif(serve) {', '+ \t} else {', '+ \t\tstrncpy(pidfname, ""/var/run/nbd-server.pid"", sizeof(char)*255);', '+ \t}', '+ \tpidf=fopen(pidfname, ""w"");', '+ \tif(pidf) {', '+ \t\tfprintf(pidf,""%d\\n"", (int)getpid());', '+ \t\tfclose(pidf);', '+ \t} else {', '+ \t\tperror(""fopen"");', '+ \t\tfprintf(stderr, ""Not fatal; continuing"");', '+ void setup_serve(gpointer port, gpointer s, gpointer data) {', '+ \tSERVER *serve=(SERVER*)s;', '+ \tg_assert(data==NULL);', '+ void setup_servers(GHashTable* servers) {', '+ \tg_hash_table_foreach(servers, setup_serve, NULL);', '+ }', '+ ', '+ \tSERVER *serve;', '+ \tGHashTable *servers;', '+ \tGError *err=NULL;', '+ \tconfig_file_pos = g_strdup(CFILE);', '+ \tservers = parse_cfile(config_file_pos, &err);', '+ \tif(!servers) {', '+ \t\tg_critical(""Could not parse command file: %s"", err->message);', '+ \t}', '+ \tif(serve) {', '+ \t\tg_hash_table_insert(servers, &serve->port, serve);', '+ \t}', '+ #if 0', '+ #endif', '+ \tif((!serve) && (!servers)) {', '+ \t\tg_message(""Nothing to do! Bye!"");', '+ \t\texit(EXIT_FAILURE);', '+ \t}', '+ \tsetup_servers(servers);', '+ \tserveloop(servers);', '- \tserve=g_malloc(sizeof(SERVER));', '- \twhile((c=getopt_long(argc, argv, ""a:cl:mr"", long_options, &i))>=0) {', '- \t\t\tserve->authname = default_authname;', '- \t\t\tserve->authname=optarg;', '- \t\t\texit(0);', '- \tif(++i>=argc) {', '- \t\tusage();', '- \t\texit(0);', '- \t}', '- \tserve->port=strtol(argv[i], NULL, 0);', '- \tif(++i>=argc) {', '- \t\texit(0);', '- \t}', '- \tserve->exportname = argv[i];', ""- \tif(serve->exportname[0] != '/') {"", '- \t\tfprintf(stderr, ""E: The to be exported file needs to be an absolute filename!\\n"");', '- \tif(++i<argc) {', '- \t\toff_t es;', '- \t\tsize_t last = strlen(argv[i])-1;', '- \t\tchar suffix = argv[i][last];', ""- \t\tif (suffix == 'k' || suffix == 'K' ||"", ""- \t\t    suffix == 'm' || suffix == 'M')"", ""- \t\t\targv[i][last] = '\\0';"", '- \t\tes = (off_t)atol(argv[i]);', '- \t\tswitch (suffix) {', ""- \t\t\tcase 'm':"", ""- \t\t\tcase 'M':  es <<= 10;"", ""- \t\t\tcase 'k':"", ""- \t\t\tcase 'K':  es <<= 10;"", '- \t\t\tdefault :  break;', '- \t\tserve->expected_size = es;', '- \treturn serve;', '- \t\tif (len > BUFSIZE)', '- \tif((serve->port)) {', '- \t\tif(daemon(0,0)<0) {', '- \t\t\terr(""daemon"");', '- \t\t}', '- \t\tpidf=fopen(pidfname, ""w"");', '- \t\tif(pidf) {', '- \t\t\tfprintf(pidf,""%d"", (int)getpid());', '- \t\t\tfclose(pidf);', '- \t\t} else {', '- \t\t\tperror(""fopen"");', '- \t\t\tfprintf(stderr, ""Not fatal; continuing"");', '- \t\t}', '- void setup_serve(SERVER* serve) {', '- \tSERVER* serve;', '- \tGArray* servers;', '- \tservers=g_array_new(TRUE, FALSE, sizeof(SERVER*));', '- \tsetup_serve(serve);', '- \tserveloop(serve);']]","[['+ #ifndef sysconfdir', '+ #define sysconfdir ""/etc""', '+ #endif', '+ #define cfile sysconfdir ""/nbd-server/config""', '+ ', '+ gchar* config_file_pos;', '+ ', '+ typedef enum {', '+ } param_type;', '+ typedef struct {', '+ \t\t\t\t  the config file */', '+ \t\t\t\t  optional) parameter */', '+ \t\t\t\t  parameter should be written. if ptype is', ""+ \t\t\t\t  param_bool, the data is or'ed rather than"", '+ \t\t\t\t  overwritten. */', '+ \t\t\t\t  is param_bool. */', '+ } param;', '+ ', '+ \tprintf(""using configuration file %s\\n"", cfile);', '+ \tint nonspecial=0;', '+ \t\t{""config-file"", required_argument, null, \'c\'},', '+ \toff_t es;', '+ \tsize_t last;', '+ \tchar suffix;', '+ \tif(argc==1) {', '+ \t\treturn null;', '+ \t}', '+ \tserve=g_new0(server, 1);', '+ \tserve->authname = g_strdup(default_authname);', '+ \twhile((c=getopt_long(argc, argv, ""-a:c:cl:mr"", long_options, &i))>=0) {', '+ \t\tcase 1:', '+ \t\t\tswitch(nonspecial++) {', '+ \t\t\tcase 0:', '+ \t\t\t\tserve->port=strtol(optarg, null, 0);', '+ \t\t\t\tbreak;', '+ \t\t\tcase 1:', '+ \t\t\t\tserve->exportname = g_strdup(optarg);', ""+ \t\t\t\tif(serve->exportname[0] != '/') {"", '+ \t\t\t\t\tfprintf(stderr, ""e: the to be exported file needs to be an absolute filename!\\n"");', '+ \t\t\t\t\texit(exit_failure);', '+ \t\t\t\t}', '+ \t\t\t\tbreak;', '+ \t\t\tcase 2:', '+ \t\t\t\tlast=strlen(optarg)-1;', '+ \t\t\t\tsuffix=optarg[last];', ""+ \t\t\t\tif (suffix == 'k' || suffix == 'k' ||"", ""+ \t\t\t\t    suffix == 'm' || suffix == 'm')"", ""+ \t\t\t\t\toptarg[last] = '\\0';"", '+ \t\t\t\tes = (off_t)atol(optarg);', '+ \t\t\t\tswitch (suffix) {', ""+ \t\t\t\t\tcase 'm':"", ""+ \t\t\t\t\tcase 'm':  es <<= 10;"", ""+ \t\t\t\t\tcase 'k':"", ""+ \t\t\t\t\tcase 'k':  es <<= 10;"", '+ \t\t\t\t\tdefault :  break;', '+ \t\t\t\t}', '+ \t\t\t\tserve->expected_size = es;', '+ \t\t\t\tbreak;', '+ \t\t\t}', '+ \t\t\tbreak;', ""+ \t\tcase 'c':"", '+ \t\t\tg_free(config_file_pos);', '+ \t\t\tconfig_file_pos=g_strdup(optarg);', '+ \t\t\tbreak;', '+ \t\t\tg_free(serve->authname);', '+ \t\t\tserve->authname=g_strdup(optarg);', '+ \t\t\texit(exit_failure);', '+ \tif(nonspecial<2) {', '+ \treturn serve;', '+ }', '+ ', '+ typedef enum {', '+ } cfile_errors;', '+ ', '+ void remove_server(gpointer s) {', '+ \tserver *server;', '+ ', '+ \tserver=(server*)s;', '+ \tg_free(server->exportname);', '+ \tif(server->authname)', '+ \t\tg_free(server->authname);', '+ \tg_free(server);', '+ }', '+ ', '+ ghashtable* parse_cfile(gchar* f, gerror** e) {', '+ \tserver *s;', '+ \tparam p[] = {', '+ \t\t{ ""exportname"", true,\tparam_string, \tnull, 0 },', '+ \t\t{ ""port"", \ttrue,\tparam_int, \tnull, 0 },', '+ \t\t{ ""authfile"",\tfalse,\tparam_string,\tnull, 0 },', '+ \t\t{ ""timeout"",\tfalse,\tparam_int,\tnull, 0 },', '+ \t\t{ ""filesize"",\tfalse,\tparam_int,\tnull, 0 },', '+ \t\t{ ""readonly"",\tfalse,\tparam_bool,\tnull, f_readonly },', '+ \t\t{ ""multifile"",\tfalse,\tparam_bool,\tnull, f_multifile },', '+ \t\t{ ""copyonwrite"", false,\tparam_bool,\tnull, f_copyonwrite },', '+ \t};', '+ \tgkeyfile *cfile;', '+ \tgerror *err = null;', '+ \tgquark errdomain;', '+ \tghashtable *retval;', '+ \tgchar **groups;', '+ \tgboolean value;', '+ \tgint i,j;', '+ ', '+ \terrdomain = g_quark_from_string(""parse_cfile"");', '+ \tcfile = g_key_file_new();', '+ \tretval = g_hash_table_new_full(g_int_hash, g_int_equal, null, remove_server);', '+ \tif(!g_key_file_load_from_file(cfile, f, g_key_file_keep_comments |', '+ \t\t\tg_key_file_keep_translations, &err)) {', '+ \t\tg_set_error(e, errdomain, cfile_notfound, ""could not open config file."");', '+ \t\tg_key_file_free(cfile);', '+ \t\treturn retval;', '+ \t}', '+ \tif(strcmp(g_key_file_get_start_group(cfile), ""generic"")) {', '+ \t\tg_set_error(e, errdomain, cfile_missing_generic, ""config file does not contain the [generic] group!"");', '+ \t\tg_key_file_free(cfile);', '+ \t\treturn null;', '+ \t}', '+ \tgroups = g_key_file_get_groups(cfile, null);', '+ \tfor(i=0;groups[i];i++) {', '+ \t\ts=g_new0(server, 1);', '+ \t\tp[0].target=&(s->exportname);', '+ \t\tp[1].target=&(s->port);', '+ \t\tp[2].target=&(s->authname);', '+ \t\tp[3].target=&(s->timeout);', '+ \t\tp[4].target=&(s->expected_size);', '+ \t\tp[5].target=p[6].target=p[7].target=p[8].target=&(s->flags);', '+ \t\tfor(j=0;j<9;j++) {', '+ \t\t\tg_assert(p[j].target != null);', '+ \t\t\tg_assert(p[j].ptype==param_int||p[j].ptype==param_string||p[j].ptype==param_bool);', '+ \t\t\tswitch(p[j].ptype) {', '+ \t\t\t\tcase param_int:', '+ \t\t\t\t\t*((gint*)p[j].target) = g_key_file_get_integer(cfile, groups[i], p[j].paramname, &err);', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase param_string:', '+ \t\t\t\t\t*((gchar**)p[j].target) = g_key_file_get_string(cfile, groups[i], p[j].paramname, &err);', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase param_bool:', '+ \t\t\t\t\tvalue = g_key_file_get_boolean(cfile, groups[i], p[j].paramname, &err);', '+ \t\t\t\t\tif(!err) {', '+ \t\t\t\t\t\t*((gint*)p[j].target) |= value;', '+ \t\t\t\t\t}', '+ \t\t\t\t\tbreak;', '+ \t\t\t}', '+ \t\t\tif(err) {', '+ \t\t\t\tif(err->code == g_key_file_error_key_not_found) {', '+ \t\t\t\t\tif(p[j].required) {', '+ \t\t\t\t\t\tg_set_error(e, errdomain, cfile_key_missing, ""could not find required value %s in group %s: %s"", p[j].paramname, groups[i], err->message);', '+ \t\t\t\t\t\tg_hash_table_destroy(retval);', '+ \t\t\t\t\t\tg_error_free(err);', '+ \t\t\t\t\t\tg_key_file_free(cfile);', '+ \t\t\t\t\t\tg_free(s);', '+ \t\t\t\t\t\treturn null;', '+ \t\t\t\t\t} else {', '+ \t\t\t\t\t\tg_error_free(err);', '+ \t\t\t\t\t\tcontinue;', '+ \t\t\t\t\t}', '+ \t\t\t\t\tg_set_error(e, errdomain, cfile_value_invalid, ""could not parse %s in group %s: %s"", p[j].paramname, groups[i], err->message);', '+ \t\t\t\t\tg_hash_table_destroy(retval);', '+ \t\t\t\t\tg_error_free(err);', '+ \t\t\t\t\tg_key_file_free(cfile);', '+ \t\t\t\t\tg_free(s);', '+ \t\t\t\t\treturn null;', '+ \t\t\t\t}', '+ \t\t\t}', '+ \t\tg_hash_table_insert(retval, &(s->port), s);', '+ \treturn retval;', '+ \t\tif (len > bufsize + sizeof(struct nbd_reply))', '+ \tif(daemon(0,0)<0) {', '+ \t\terr(""daemon"");', '+ \t}', '+ \tif(serve) {', '+ \t} else {', '+ \t\tstrncpy(pidfname, ""/var/run/nbd-server.pid"", sizeof(char)*255);', '+ \t}', '+ \tpidf=fopen(pidfname, ""w"");', '+ \tif(pidf) {', '+ \t\tfprintf(pidf,""%d\\n"", (int)getpid());', '+ \t\tfclose(pidf);', '+ \t} else {', '+ \t\tperror(""fopen"");', '+ \t\tfprintf(stderr, ""not fatal; continuing"");', '+ void setup_serve(gpointer port, gpointer s, gpointer data) {', '+ \tserver *serve=(server*)s;', '+ \tg_assert(data==null);', '+ void setup_servers(ghashtable* servers) {', '+ \tg_hash_table_foreach(servers, setup_serve, null);', '+ }', '+ ', '+ \tserver *serve;', '+ \tghashtable *servers;', '+ \tgerror *err=null;', '+ \tconfig_file_pos = g_strdup(cfile);', '+ \tservers = parse_cfile(config_file_pos, &err);', '+ \tif(!servers) {', '+ \t\tg_critical(""could not parse command file: %s"", err->message);', '+ \t}', '+ \tif(serve) {', '+ \t\tg_hash_table_insert(servers, &serve->port, serve);', '+ \t}', '+ #if 0', '+ #endif', '+ \tif((!serve) && (!servers)) {', '+ \t\tg_message(""nothing to do! bye!"");', '+ \t\texit(exit_failure);', '+ \t}', '+ \tsetup_servers(servers);', '+ \tserveloop(servers);', '- \tserve=g_malloc(sizeof(server));', '- \twhile((c=getopt_long(argc, argv, ""a:cl:mr"", long_options, &i))>=0) {', '- \t\t\tserve->authname = default_authname;', '- \t\t\tserve->authname=optarg;', '- \t\t\texit(0);', '- \tif(++i>=argc) {', '- \t\tusage();', '- \t\texit(0);', '- \t}', '- \tserve->port=strtol(argv[i], null, 0);', '- \tif(++i>=argc) {', '- \t\texit(0);', '- \t}', '- \tserve->exportname = argv[i];', ""- \tif(serve->exportname[0] != '/') {"", '- \t\tfprintf(stderr, ""e: the to be exported file needs to be an absolute filename!\\n"");', '- \tif(++i<argc) {', '- \t\toff_t es;', '- \t\tsize_t last = strlen(argv[i])-1;', '- \t\tchar suffix = argv[i][last];', ""- \t\tif (suffix == 'k' || suffix == 'k' ||"", ""- \t\t    suffix == 'm' || suffix == 'm')"", ""- \t\t\targv[i][last] = '\\0';"", '- \t\tes = (off_t)atol(argv[i]);', '- \t\tswitch (suffix) {', ""- \t\t\tcase 'm':"", ""- \t\t\tcase 'm':  es <<= 10;"", ""- \t\t\tcase 'k':"", ""- \t\t\tcase 'k':  es <<= 10;"", '- \t\t\tdefault :  break;', '- \t\tserve->expected_size = es;', '- \treturn serve;', '- \t\tif (len > bufsize)', '- \tif((serve->port)) {', '- \t\tif(daemon(0,0)<0) {', '- \t\t\terr(""daemon"");', '- \t\t}', '- \t\tpidf=fopen(pidfname, ""w"");', '- \t\tif(pidf) {', '- \t\t\tfprintf(pidf,""%d"", (int)getpid());', '- \t\t\tfclose(pidf);', '- \t\t} else {', '- \t\t\tperror(""fopen"");', '- \t\t\tfprintf(stderr, ""not fatal; continuing"");', '- \t\t}', '- void setup_serve(server* serve) {', '- \tserver* serve;', '- \tgarray* servers;', '- \tservers=g_array_new(true, false, sizeof(server*));', '- \tsetup_serve(serve);', '- \tserveloop(serve);']]","[['+ #ifndef SYSCONFDIR', '+ #define SYSCONFDIR ""/etc""', '+ #endif', '+ #define CFILE SYSCONFDIR ""/nbd-server/config""', '+ ', '+ gchar* config_file_pos;', '+ ', '+ typedef enum {', '+ } PARAM_TYPE;', '+ typedef struct {', '+ \t\t\t\t  the config file */', '+ \t\t\t\t  optional) parameter */', '+ \t\t\t\t  parameter should be written. If ptype is', ""+ \t\t\t\t  PARAM_BOOL, the data is or'ed rather than"", '+ \t\t\t\t  overwritten. */', '+ \t\t\t\t  is PARAM_BOOL. */', '+ } PARAM;', '+ ', '+ \tprintf(""Using configuration file %s\\n"", CFILE);', '+ \tint nonspecial=0;', '+ \t\t{""config-file"", required_argument, NULL, \'C\'},', '+ \toff_t es;', '+ \tsize_t last;', '+ \tchar suffix;', '+ \tif(argc==1) {', '+ \t\treturn NULL;', '+ \t}', '+ \tserve=g_new0(SERVER, 1);', '+ \tserve->authname = g_strdup(default_authname);', '+ \twhile((c=getopt_long(argc, argv, ""-a:C:cl:mr"", long_options, &i))>=0) {', '+ \t\tcase 1:', '+ \t\t\tswitch(nonspecial++) {', '+ \t\t\tcase 0:', '+ \t\t\t\tserve->port=strtol(optarg, NULL, 0);', '+ \t\t\t\tbreak;', '+ \t\t\tcase 1:', '+ \t\t\t\tserve->exportname = g_strdup(optarg);', ""+ \t\t\t\tif(serve->exportname[0] != '/') {"", '+ \t\t\t\t\tfprintf(stderr, ""E: The to be exported file needs to be an absolute filename!\\n"");', '+ \t\t\t\t\texit(EXIT_FAILURE);', '+ \t\t\t\t}', '+ \t\t\t\tbreak;', '+ \t\t\tcase 2:', '+ \t\t\t\tlast=strlen(optarg)-1;', '+ \t\t\t\tsuffix=optarg[last];', ""+ \t\t\t\tif (suffix == 'k' || suffix == 'K' ||"", ""+ \t\t\t\t    suffix == 'm' || suffix == 'M')"", ""+ \t\t\t\t\toptarg[last] = '\\0';"", '+ \t\t\t\tes = (off_t)atol(optarg);', '+ \t\t\t\tswitch (suffix) {', ""+ \t\t\t\t\tcase 'm':"", ""+ \t\t\t\t\tcase 'M':  es <<= 10;"", ""+ \t\t\t\t\tcase 'k':"", ""+ \t\t\t\t\tcase 'K':  es <<= 10;"", '+ \t\t\t\t\tdefault :  break;', '+ \t\t\t\t}', '+ \t\t\t\tserve->expected_size = es;', '+ \t\t\t\tbreak;', '+ \t\t\t}', '+ \t\t\tbreak;', ""+ \t\tcase 'C':"", '+ \t\t\tg_free(config_file_pos);', '+ \t\t\tconfig_file_pos=g_strdup(optarg);', '+ \t\t\tbreak;', '+ \t\t\tg_free(serve->authname);', '+ \t\t\tserve->authname=g_strdup(optarg);', '+ \t\t\texit(EXIT_FAILURE);', '+ \tif(nonspecial<2) {', '+ \treturn serve;', '+ }', '+ ', '+ typedef enum {', '+ } CFILE_ERRORS;', '+ ', '+ void remove_server(gpointer s) {', '+ \tSERVER *server;', '+ ', '+ \tserver=(SERVER*)s;', '+ \tg_free(server->exportname);', '+ \tif(server->authname)', '+ \t\tg_free(server->authname);', '+ \tg_free(server);', '+ }', '+ ', '+ GHashTable* parse_cfile(gchar* f, GError** e) {', '+ \tSERVER *s;', '+ \tPARAM p[] = {', '+ \t\t{ ""exportname"", TRUE,\tPARAM_STRING, \tNULL, 0 },', '+ \t\t{ ""port"", \tTRUE,\tPARAM_INT, \tNULL, 0 },', '+ \t\t{ ""authfile"",\tFALSE,\tPARAM_STRING,\tNULL, 0 },', '+ \t\t{ ""timeout"",\tFALSE,\tPARAM_INT,\tNULL, 0 },', '+ \t\t{ ""filesize"",\tFALSE,\tPARAM_INT,\tNULL, 0 },', '+ \t\t{ ""readonly"",\tFALSE,\tPARAM_BOOL,\tNULL, F_READONLY },', '+ \t\t{ ""multifile"",\tFALSE,\tPARAM_BOOL,\tNULL, F_MULTIFILE },', '+ \t\t{ ""copyonwrite"", FALSE,\tPARAM_BOOL,\tNULL, F_COPYONWRITE },', '+ \t};', '+ \tGKeyFile *cfile;', '+ \tGError *err = NULL;', '+ \tGQuark errdomain;', '+ \tGHashTable *retval;', '+ \tgchar **groups;', '+ \tgboolean value;', '+ \tgint i,j;', '+ ', '+ \terrdomain = g_quark_from_string(""parse_cfile"");', '+ \tcfile = g_key_file_new();', '+ \tretval = g_hash_table_new_full(g_int_hash, g_int_equal, NULL, remove_server);', '+ \tif(!g_key_file_load_from_file(cfile, f, G_KEY_FILE_KEEP_COMMENTS |', '+ \t\t\tG_KEY_FILE_KEEP_TRANSLATIONS, &err)) {', '+ \t\tg_set_error(e, errdomain, CFILE_NOTFOUND, ""Could not open config file."");', '+ \t\tg_key_file_free(cfile);', '+ \t\treturn retval;', '+ \t}', '+ \tif(strcmp(g_key_file_get_start_group(cfile), ""generic"")) {', '+ \t\tg_set_error(e, errdomain, CFILE_MISSING_GENERIC, ""Config file does not contain the [generic] group!"");', '+ \t\tg_key_file_free(cfile);', '+ \t\treturn NULL;', '+ \t}', '+ \tgroups = g_key_file_get_groups(cfile, NULL);', '+ \tfor(i=0;groups[i];i++) {', '+ \t\ts=g_new0(SERVER, 1);', '+ \t\tp[0].target=&(s->exportname);', '+ \t\tp[1].target=&(s->port);', '+ \t\tp[2].target=&(s->authname);', '+ \t\tp[3].target=&(s->timeout);', '+ \t\tp[4].target=&(s->expected_size);', '+ \t\tp[5].target=p[6].target=p[7].target=p[8].target=&(s->flags);', '+ \t\tfor(j=0;j<9;j++) {', '+ \t\t\tg_assert(p[j].target != NULL);', '+ \t\t\tg_assert(p[j].ptype==PARAM_INT||p[j].ptype==PARAM_STRING||p[j].ptype==PARAM_BOOL);', '+ \t\t\tswitch(p[j].ptype) {', '+ \t\t\t\tcase PARAM_INT:', '+ \t\t\t\t\t*((gint*)p[j].target) = g_key_file_get_integer(cfile, groups[i], p[j].paramname, &err);', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase PARAM_STRING:', '+ \t\t\t\t\t*((gchar**)p[j].target) = g_key_file_get_string(cfile, groups[i], p[j].paramname, &err);', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase PARAM_BOOL:', '+ \t\t\t\t\tvalue = g_key_file_get_boolean(cfile, groups[i], p[j].paramname, &err);', '+ \t\t\t\t\tif(!err) {', '+ \t\t\t\t\t\t*((gint*)p[j].target) |= value;', '+ \t\t\t\t\t}', '+ \t\t\t\t\tbreak;', '+ \t\t\t}', '+ \t\t\tif(err) {', '+ \t\t\t\tif(err->code == G_KEY_FILE_ERROR_KEY_NOT_FOUND) {', '+ \t\t\t\t\tif(p[j].required) {', '+ \t\t\t\t\t\tg_set_error(e, errdomain, CFILE_KEY_MISSING, ""Could not find required value %s in group %s: %s"", p[j].paramname, groups[i], err->message);', '+ \t\t\t\t\t\tg_hash_table_destroy(retval);', '+ \t\t\t\t\t\tg_error_free(err);', '+ \t\t\t\t\t\tg_key_file_free(cfile);', '+ \t\t\t\t\t\tg_free(s);', '+ \t\t\t\t\t\treturn NULL;', '+ \t\t\t\t\t} else {', '+ \t\t\t\t\t\tg_error_free(err);', '+ \t\t\t\t\t\tcontinue;', '+ \t\t\t\t\t}', '+ \t\t\t\t\tg_set_error(e, errdomain, CFILE_VALUE_INVALID, ""Could not parse %s in group %s: %s"", p[j].paramname, groups[i], err->message);', '+ \t\t\t\t\tg_hash_table_destroy(retval);', '+ \t\t\t\t\tg_error_free(err);', '+ \t\t\t\t\tg_key_file_free(cfile);', '+ \t\t\t\t\tg_free(s);', '+ \t\t\t\t\treturn NULL;', '+ \t\t\t\t}', '+ \t\t\t}', '+ \t\tg_hash_table_insert(retval, &(s->port), s);', '+ \treturn retval;', '+ \t\tif (len > BUFSIZE + sizeof(struct nbd_reply))', '+ \tif(daemon(0,0)<0) {', '+ \t\terr(""daemon"");', '+ \t}', '+ \tif(serve) {', '+ \t} else {', '+ \t\tstrncpy(pidfname, ""/var/run/nbd-server.pid"", sizeof(char)*255);', '+ \t}', '+ \tpidf=fopen(pidfname, ""w"");', '+ \tif(pidf) {', '+ \t\tfprintf(pidf,""%d\\n"", (int)getpid());', '+ \t\tfclose(pidf);', '+ \t} else {', '+ \t\tperror(""fopen"");', '+ \t\tfprintf(stderr, ""Not fatal; continuing"");', '+ void setup_serve(gpointer port, gpointer s, gpointer data) {', '+ \tSERVER *serve=(SERVER*)s;', '+ \tg_assert(data==NULL);', '+ void setup_servers(GHashTable* servers) {', '+ \tg_hash_table_foreach(servers, setup_serve, NULL);', '+ }', '+ ', '+ \tSERVER *serve;', '+ \tGHashTable *servers;', '+ \tGError *err=NULL;', '+ \tconfig_file_pos = g_strdup(CFILE);', '+ \tservers = parse_cfile(config_file_pos, &err);', '+ \tif(!servers) {', '+ \t\tg_critical(""Could not parse command file: %s"", err->message);', '+ \t}', '+ \tif(serve) {', '+ \t\tg_hash_table_insert(servers, &serve->port, serve);', '+ \t}', '+ #if 0', '+ #endif', '+ \tif((!serve) && (!servers)) {', '+ \t\tg_message(""Nothing to do! Bye!"");', '+ \t\texit(EXIT_FAILURE);', '+ \t}', '+ \tsetup_servers(servers);', '+ \tserveloop(servers);']]","[['- \tserve=g_malloc(sizeof(SERVER));', '- \twhile((c=getopt_long(argc, argv, ""a:cl:mr"", long_options, &i))>=0) {', '- \t\t\tserve->authname = default_authname;', '- \t\t\tserve->authname=optarg;', '- \t\t\texit(0);', '- \tif(++i>=argc) {', '- \t\tusage();', '- \t\texit(0);', '- \t}', '- \tserve->port=strtol(argv[i], NULL, 0);', '- \tif(++i>=argc) {', '- \t\texit(0);', '- \t}', '- \tserve->exportname = argv[i];', ""- \tif(serve->exportname[0] != '/') {"", '- \t\tfprintf(stderr, ""E: The to be exported file needs to be an absolute filename!\\n"");', '- \tif(++i<argc) {', '- \t\toff_t es;', '- \t\tsize_t last = strlen(argv[i])-1;', '- \t\tchar suffix = argv[i][last];', ""- \t\tif (suffix == 'k' || suffix == 'K' ||"", ""- \t\t    suffix == 'm' || suffix == 'M')"", ""- \t\t\targv[i][last] = '\\0';"", '- \t\tes = (off_t)atol(argv[i]);', '- \t\tswitch (suffix) {', ""- \t\t\tcase 'm':"", ""- \t\t\tcase 'M':  es <<= 10;"", ""- \t\t\tcase 'k':"", ""- \t\t\tcase 'K':  es <<= 10;"", '- \t\t\tdefault :  break;', '- \t\tserve->expected_size = es;', '- \treturn serve;', '- \t\tif (len > BUFSIZE)', '- \tif((serve->port)) {', '- \t\tif(daemon(0,0)<0) {', '- \t\t\terr(""daemon"");', '- \t\t}', '- \t\tpidf=fopen(pidfname, ""w"");', '- \t\tif(pidf) {', '- \t\t\tfprintf(pidf,""%d"", (int)getpid());', '- \t\t\tfclose(pidf);', '- \t\t} else {', '- \t\t\tperror(""fopen"");', '- \t\t\tfprintf(stderr, ""Not fatal; continuing"");', '- \t\t}', '- void setup_serve(SERVER* serve) {', '- \tSERVER* serve;', '- \tGArray* servers;', '- \tservers=g_array_new(TRUE, FALSE, sizeof(SERVER*));', '- \tsetup_serve(serve);', '- \tserveloop(serve);']]",208,51.0,259.0,501f9a21ebe15178f996e86d2c8fcf23e7b63aeayoe/nbd,['3ef52043861ab16352d49af89e048ba6339d6df8']
abe1977070e2c71d82f473c6d3aa807b489c7fb0,yoe/nbd,nbd-server.c,train,C,1,"['@@ -2204,8 +2204,10 @@ int serveloop(GArray* servers) {\n \n \t\t\tDEBUG(""accept, "");\n \t\t\tif(modernsock >= 0 && FD_ISSET(modernsock, &rset)) {\n-\t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0)\n-\t\t\t\t\terr(""accept: %m"");\n+\t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {\n+\t\t\t\t\terr_nonfatal(""accept: %m"");\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n \t\t\t\tclient = negotiate(net, NULL, servers, NEG_INIT | NEG_MODERN);\n \t\t\t\tif(!client) {\n \t\t\t\t\terr_nonfatal(""negotiation failed"");\n@@ -2217,8 +2219,10 @@ int serveloop(GArray* servers) {\n \t\t\tfor(i=0; i < servers->len && net < 0; i++) {\n \t\t\t\tserve=&(g_array_index(servers, SERVER, i));\n \t\t\t\tif(FD_ISSET(serve->socket, &rset)) {\n-\t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0)\n-\t\t\t\t\t\terr(""accept: %m"");\n+\t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0) {\n+\t\t\t\t\t\terr_nonfatal(""accept: %m"");\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tif(net >= 0) {\n']",2012-06-24 01:38:34+02:00,"nbd-server: treat accept errors as non-fatal

In most cases, an error returned by accept system call is a network
error, which should not terminate the whole nbd-server.

Signed-off-by: Dmitry V. Levin <ldv@altlinux.org>","[['+ \t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {', '+ \t\t\t\t\terr_nonfatal(""accept: %m"");', '+ \t\t\t\t\tcontinue;', '+ \t\t\t\t}', '+ \t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0) {', '+ \t\t\t\t\t\terr_nonfatal(""accept: %m"");', '+ \t\t\t\t\t\tcontinue;', '+ \t\t\t\t\t}', '- \t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0)', '- \t\t\t\t\terr(""accept: %m"");', '- \t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0)', '- \t\t\t\t\t\terr(""accept: %m"");']]","[['+ \t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {', '+ \t\t\t\t\terr_nonfatal(""accept: %m"");', '+ \t\t\t\t\tcontinue;', '+ \t\t\t\t}', '+ \t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0) {', '+ \t\t\t\t\t\terr_nonfatal(""accept: %m"");', '+ \t\t\t\t\t\tcontinue;', '+ \t\t\t\t\t}', '- \t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0)', '- \t\t\t\t\terr(""accept: %m"");', '- \t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0)', '- \t\t\t\t\t\terr(""accept: %m"");']]","[['+ \t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0) {', '+ \t\t\t\t\terr_nonfatal(""accept: %m"");', '+ \t\t\t\t\tcontinue;', '+ \t\t\t\t}', '+ \t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0) {', '+ \t\t\t\t\t\terr_nonfatal(""accept: %m"");', '+ \t\t\t\t\t\tcontinue;', '+ \t\t\t\t\t}']]","[['- \t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0)', '- \t\t\t\t\terr(""accept: %m"");', '- \t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0)', '- \t\t\t\t\t\terr(""accept: %m"");']]",8,4.0,12.0,abe1977070e2c71d82f473c6d3aa807b489c7fb0yoe/nbd,['741495cb08503fd32a9d22648e63b64390c601f4']
3bb13e37def9fdcd0b4524265b5a952f38933e43,libarchive/libarchive,filter_fork.c,train,C,0,"['@@ -25,6 +25,9 @@\n \n #include ""archive_platform.h""\n \n+/* This capability is only available on POSIX systems. */\n+#if defined(HAVE_PIPE) && defined(HAVE_VFORK) && defined(HAVE_FCNTL)\n+\n __FBSDID(""$FreeBSD: src/lib/libarchive/filter_fork.c,v 1.2 2007/12/30 04:58:22 kientzle Exp $"");\n \n #if defined(HAVE_POLL)\n@@ -137,3 +140,5 @@ __archive_check_child(int in, int out)\n \tsleep(1);\n #endif\n }\n+\n+#endif /* defined(HAVE_PIPE) && defined(HAVE_VFORK) && defined(HAVE_FCNTL) */\n']",,,['+ #if defined(HAVE_PIPE) && defined(HAVE_VFORK) && defined(HAVE_FCNTL)'],['+ #if defined(have_pipe) && defined(have_vfork) && defined(have_fcntl)'],['+ #if defined(HAVE_PIPE) && defined(HAVE_VFORK) && defined(HAVE_FCNTL)'],[],1,0.0,1.0,3bb13e37def9fdcd0b4524265b5a952f38933e43libarchive/libarchive,[]
1f9accc3dd70612f510f6613520261626490fa8e,Dieterbe/uzbl,uzbl.c,train,C,1,"['@@ -62,18 +62,18 @@ static Uzbl uzbl;\n \n \n /* commandline arguments (set initial values for the state variables) */\n-static const \n+static const\n GOptionEntry entries[] =\n {\n     { ""uri"",     \'u\', 0, G_OPTION_ARG_STRING, &uzbl.state.uri,\n         ""Uri to load at startup (equivalent to \'set uri = URI\')"", ""URI"" },\n     { ""verbose"", \'v\', 0, G_OPTION_ARG_NONE,   &uzbl.state.verbose,\n         ""Whether to print all messages or just errors."", NULL },\n-    { ""name"",    \'n\', 0, G_OPTION_ARG_STRING, &uzbl.state.instance_name, \n+    { ""name"",    \'n\', 0, G_OPTION_ARG_STRING, &uzbl.state.instance_name,\n         ""Name of the current instance (defaults to Xorg window id)"", ""NAME"" },\n-    { ""config"",  \'c\', 0, G_OPTION_ARG_STRING, &uzbl.state.config_file,   \n+    { ""config"",  \'c\', 0, G_OPTION_ARG_STRING, &uzbl.state.config_file,\n         ""Config file (this is pretty much equivalent to uzbl < FILE )"", ""FILE"" },\n-    { ""socket"",  \'s\', 0, G_OPTION_ARG_INT, &uzbl.state.socket_id,   \n+    { ""socket"",  \'s\', 0, G_OPTION_ARG_INT, &uzbl.state.socket_id,\n         ""Socket ID"", ""SOCKET"" },\n     { NULL,      0, 0, 0, NULL, NULL, NULL }\n };\n@@ -208,7 +208,7 @@ get_exp_type(gchar *s) {\n return EXP_ERR;\n }\n \n-/* \n+/*\n  * recurse == 1: don\'t expand \'@(command)@\'\n  * recurse == 2: don\'t expand \'@<java script>@\'\n  */\n@@ -264,7 +264,7 @@ expand(char *s, guint recurse) {\n                             ret[vend-s] = \'\\0\';\n                         }\n                         break;\n-                    case EXP_JS: \n+                    case EXP_JS:\n                         s++;\n                         strcpy(str_end, "">@"");\n                         str_end[2] = \'\\0\';\n@@ -276,7 +276,7 @@ expand(char *s, guint recurse) {\n                         break;\n                 }\n \n-                if(etype == EXP_SIMPLE_VAR || \n+                if(etype == EXP_SIMPLE_VAR ||\n                    etype == EXP_BRACED_VAR) {\n                     if( (c = g_hash_table_lookup(uzbl.comm.proto_var, ret)) ) {\n                         if(c->type == TYPE_STR)\n@@ -292,7 +292,7 @@ expand(char *s, guint recurse) {\n                     else\n                         s = vend+1;\n                 }\n-                else if(recurse != 1 && \n+                else if(recurse != 1 &&\n                         etype == EXP_EXPR) {\n                     mycmd = expand(ret, 1);\n                     g_spawn_command_line_sync(mycmd, &cmd_stdout, NULL, NULL, &err);\n@@ -308,7 +308,7 @@ expand(char *s, guint recurse) {\n                     }\n                     s = vend+2;\n                 }\n-                else if(recurse != 2 && \n+                else if(recurse != 2 &&\n                         etype == EXP_JS) {\n                     mycmd = expand(ret, 2);\n                     eval_js(uzbl.gui.web_view, mycmd, js_ret);\n@@ -366,9 +366,9 @@ read_file_by_line (gchar *path) {\n     gsize len;\n     GArray *lines = g_array_new(TRUE, FALSE, sizeof(gchar*));\n     int i = 0;\n-    \n+\n     chan = g_io_channel_new_file(path, ""r"", NULL);\n-    \n+\n     if (chan) {\n         while (g_io_channel_read_line(chan, &readbuf, &len, NULL, NULL) == G_IO_STATUS_NORMAL) {\n             const gchar* val = g_strdup (readbuf);\n@@ -376,12 +376,12 @@ read_file_by_line (gchar *path) {\n             g_free (readbuf);\n             i ++;\n         }\n-        \n+\n         g_io_channel_unref (chan);\n     } else {\n         fprintf(stderr, ""File \'%s\' not be read.\\n"", path);\n     }\n-    \n+\n     return lines;\n }\n \n@@ -390,7 +390,7 @@ gchar* parseenv (char* string) {\n     extern char** environ;\n     gchar* tmpstr = NULL;\n     int i = 0;\n-    \n+\n \n     while (environ[i] != NULL) {\n         gchar** env = g_strsplit (environ[i], ""="", 2);\n@@ -438,7 +438,7 @@ clean_up(void) {\n     g_hash_table_destroy(uzbl.behave.commands);\n }\n \n-/* used for html_mode_timeout \n+/* used for html_mode_timeout\n  * be sure to extend this function to use\n  * more timers if needed in other places\n */\n@@ -882,7 +882,7 @@ js_run_command (JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject,\n     (void) function;\n     (void) thisObject;\n     (void) exception;\n-    \n+\n     JSStringRef js_result_string;\n     GString *result = g_string_new("""");\n \n@@ -920,7 +920,7 @@ js_init() {\n }\n \n \n-static void \n+static void\n eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     WebKitWebFrame *frame;\n     JSGlobalContextRef context;\n@@ -931,20 +931,20 @@ eval_js(WebKitWebView * web_view, gchar *script, GString *result) {\n     JSValueRef js_result;\n     JSStringRef js_result_string;\n     size_t js_result_size;\n-    \n+\n     js_init();\n \n     frame = webkit_web_view_get_main_frame(WEBKIT_WEB_VIEW(web_view));\n     context = webkit_web_frame_get_global_context(frame);\n     globalobject = JSContextGetGlobalObject(context);\n-    \n+\n     /* uzbl javascript namespace */\n     var_name = JSStringCreateWithUTF8CString(""Uzbl"");\n     JSObjectSetProperty(context, globalobject, var_name,\n-                        JSObjectMake(context, uzbl.js.classref, NULL),  \n+                        JSObjectMake(context, uzbl.js.classref, NULL),\n                         kJSClassAttributeNone, NULL);\n-    \n-    /* evaluate the script and get return value*/ \n+\n+    /* evaluate the script and get return value*/\n     js_script = JSStringCreateWithUTF8CString(script);\n     js_result = JSEvaluateScript(context, js_script, globalobject, NULL, 0, NULL);\n     if (js_result && !JSValueIsUndefined(context, js_result)) {\n@@ -993,7 +993,7 @@ run_external_js (WebKitWebView * web_view, GArray *argv, GString *result) {\n             i ++;\n             g_free (line);\n         }\n-        \n+\n         if (uzbl.state.verbose)\n             printf (""External JavaScript file %s loaded\\n"", argv_idx(argv, 0));\n \n@@ -1017,7 +1017,7 @@ search_text (WebKitWebView *page, GArray *argv, const gboolean forward) {\n             uzbl.state.searchtx = g_strdup(argv_idx(argv, 0));\n         }\n     }\n-    \n+\n     if (uzbl.state.searchtx) {\n         if (uzbl.state.verbose)\n             printf (""Searching: %s\\n"", uzbl.state.searchtx);\n@@ -1069,7 +1069,7 @@ chain (WebKitWebView *page, GArray *argv, GString *result) {\n     (void) page; (void) result;\n     gchar *a = NULL;\n     gchar **parts = NULL;\n-    guint i = 0;    \n+    guint i = 0;\n     while ((a = argv_idx(argv, i++))) {\n         parts = g_strsplit (a, "" "", 2);\n         parse_command(parts[0], parts[1], result);\n@@ -1352,7 +1352,7 @@ run_command (const gchar *command, const guint npre, const gchar **args,\n              const gboolean sync, char **output_stdout) {\n    //command <uzbl conf> <uzbl pid> <uzbl win id> <uzbl fifo file> <uzbl socket file> [args]\n     GError *err = NULL;\n-    \n+\n     GArray *a = g_array_new (TRUE, FALSE, sizeof(gchar*));\n     gchar *pid = itos(getpid());\n     gchar *xwin = itos(uzbl.xwin);\n@@ -1370,11 +1370,11 @@ run_command (const gchar *command, const guint npre, const gchar **args,\n \n     for (i = npre; i < g_strv_length((gchar**)args); i++)\n         sharg_append(a, args[i]);\n-    \n+\n     gboolean result;\n     if (sync) {\n         if (*output_stdout) *output_stdout = strfree(*output_stdout);\n-        \n+\n         result = g_spawn_sync(NULL, (gchar **)a->data, NULL, G_SPAWN_SEARCH_PATH,\n                               NULL, NULL, output_stdout, NULL, NULL, &err);\n     } else result = g_spawn_async(NULL, (gchar **)a->data, NULL, G_SPAWN_SEARCH_PATH,\n@@ -1409,7 +1409,7 @@ split_quoted(const gchar* src, const gboolean unquote) {\n     /* split on unquoted space, return array of strings;\n        remove a layer of quotes and backslashes if unquote */\n     if (!src) return NULL;\n-    \n+\n     gboolean dq = FALSE;\n     gboolean sq = FALSE;\n     GArray *a = g_array_new (TRUE, FALSE, sizeof(gchar*));\n@@ -1452,7 +1452,7 @@ spawn(WebKitWebView *web_view, GArray *argv, GString *result) {\n static void\n spawn_sync(WebKitWebView *web_view, GArray *argv, GString *result) {\n     (void)web_view; (void)result;\n-    \n+\n     if (argv_idx(argv, 0))\n         run_command(argv_idx(argv, 0), 0, ((const gchar **) (argv->data + sizeof(gchar*))),\n                     TRUE, &uzbl.comm.sync_stdout);\n@@ -1465,7 +1465,7 @@ spawn_sh(WebKitWebView *web_view, GArray *argv, GString *result) {\n         g_printerr (""spawn_sh: shell_cmd is not set!\\n"");\n         return;\n     }\n-    \n+\n     guint i;\n     gchar *spacer = g_strdup("""");\n     g_array_insert_val(argv, 1, spacer);\n@@ -1486,7 +1486,7 @@ spawn_sh_sync(WebKitWebView *web_view, GArray *argv, GString *result) {\n         g_printerr (""spawn_sh_sync: shell_cmd is not set!\\n"");\n         return;\n     }\n-    \n+\n     guint i;\n     gchar *spacer = g_strdup("""");\n     g_array_insert_val(argv, 1, spacer);\n@@ -1494,7 +1494,7 @@ spawn_sh_sync(WebKitWebView *web_view, GArray *argv, GString *result) {\n \n     for (i = 1; i < g_strv_length(cmd); i++)\n         g_array_prepend_val(argv, cmd[i]);\n-         \n+\n     if (cmd) run_command(cmd[0], g_strv_length(cmd) + 1, (const gchar **) argv->data,\n                          TRUE, &uzbl.comm.sync_stdout);\n     g_free (spacer);\n@@ -1573,7 +1573,7 @@ cmd_load_uri() {\n     g_array_free (a, TRUE);\n }\n \n-static void \n+static void\n cmd_always_insert_mode() {\n     uzbl.behave.insert_mode =\n         uzbl.behave.always_insert_mode ?  TRUE : FALSE;\n@@ -1615,7 +1615,7 @@ cmd_font_size() {\n     if (uzbl.behave.font_size > 0) {\n         g_object_set (G_OBJECT(ws), ""default-font-size"", uzbl.behave.font_size, NULL);\n     }\n-    \n+\n     if (uzbl.behave.monospace_size > 0) {\n         g_object_set (G_OBJECT(ws), ""default-monospace-font-size"",\n                       uzbl.behave.monospace_size, NULL);\n@@ -1632,7 +1632,7 @@ cmd_zoom_level() {\n \n static void\n cmd_disable_plugins() {\n-    g_object_set (G_OBJECT(view_settings()), ""enable-plugins"", \n+    g_object_set (G_OBJECT(view_settings()), ""enable-plugins"",\n             !uzbl.behave.disable_plugins, NULL);\n }\n \n@@ -1679,31 +1679,31 @@ cmd_print_bg() {\n             uzbl.behave.print_bg, NULL);\n }\n \n-static void \n+static void\n cmd_style_uri() {\n     g_object_set (G_OBJECT(view_settings()), ""user-stylesheet-uri"",\n             uzbl.behave.style_uri, NULL);\n }\n \n-static void \n+static void\n cmd_resizable_txt() {\n     g_object_set (G_OBJECT(view_settings()), ""resizable-text-areas"",\n             uzbl.behave.resizable_txt, NULL);\n }\n \n-static void \n+static void\n cmd_default_encoding() {\n     g_object_set (G_OBJECT(view_settings()), ""default-encoding"",\n             uzbl.behave.default_encoding, NULL);\n }\n \n-static void \n+static void\n cmd_enforce_96dpi() {\n     g_object_set (G_OBJECT(view_settings()), ""enforce-96-dpi"",\n             uzbl.behave.enforce_96dpi, NULL);\n }\n \n-static void \n+static void\n cmd_caret_browsing() {\n     g_object_set (G_OBJECT(view_settings()), ""enable-caret-browsing"",\n             uzbl.behave.caret_browsing, NULL);\n@@ -1748,7 +1748,7 @@ cmd_modkey() {\n     buf = g_utf8_strup(uzbl.behave.modkey, -1);\n     uzbl.behave.modmask = 0;\n \n-    if(uzbl.behave.modkey) \n+    if(uzbl.behave.modkey)\n         g_free(uzbl.behave.modkey);\n     uzbl.behave.modkey = buf;\n \n@@ -2006,7 +2006,7 @@ control_socket(GIOChannel *chan) {\n \n     clientsock = accept (g_io_channel_unix_get_fd(chan),\n                          (struct sockaddr *) &remote, &t);\n-    \n+\n     if ((clientchan = g_io_channel_unix_new(clientsock))) {\n         g_io_add_watch(clientchan, G_IO_IN|G_IO_HUP,\n                        (GIOFunc) control_client_socket, clientchan);\n@@ -2225,7 +2225,7 @@ run_keycmd(const gboolean key_ret) {\n             else exec_paramcmd(act, i); /* otherwise execute the incremental */\n             break;\n         }\n-        \n+\n         g_string_truncate(short_keys, short_keys->len - 1);\n     }\n     g_string_free (short_keys, TRUE);\n@@ -2378,7 +2378,7 @@ run_handler (const gchar *act, const gchar *args) {\n     if (g_strcmp0(parts[0], ""chain"") == 0) {\n         GString *newargs = g_string_new("""");\n         gchar **chainparts = split_quoted(parts[1], FALSE);\n-        \n+\n         /* for every argument in the chain, inject the handler args\n            and make sure the new parts are wrapped in quotes */\n         gchar **cp = chainparts;\n@@ -2386,7 +2386,7 @@ run_handler (const gchar *act, const gchar *args) {\n         gchar *quotless = NULL;\n         gchar **spliced_quotless = NULL; // sigh -_-;\n         gchar **inpart = NULL;\n-        \n+\n         while (*cp) {\n             if ((**cp == \'\\\'\') || (**cp == \'\\""\')) { /* strip old quotes */\n                 quot = **cp;\n@@ -2396,7 +2396,7 @@ run_handler (const gchar *act, const gchar *args) {\n             spliced_quotless = g_strsplit(quotless, "" "", 2);\n             inpart = inject_handler_args(spliced_quotless[0], spliced_quotless[1], args);\n             g_strfreev(spliced_quotless);\n-            \n+\n             g_string_append_printf(newargs, "" %c%s %s%c"", quot, inpart[0], inpart[1], quot);\n             g_free(quotless);\n             g_strfreev(inpart);\n@@ -2406,7 +2406,7 @@ run_handler (const gchar *act, const gchar *args) {\n         parse_command(parts[0], &(newargs->str[1]), NULL);\n         g_string_free(newargs, TRUE);\n         g_strfreev(chainparts);\n-        \n+\n     } else {\n         gchar **inparts = inject_handler_args(parts[0], parts[1], args);\n         parse_command(inparts[0], inparts[1], NULL);\n@@ -2478,7 +2478,7 @@ find_xdg_file (int xdg_type, char* filename) {\n             temporary_file = g_strconcat (temporary_string, filename, NULL);\n         }\n     }\n-    \n+\n     //g_free (temporary_string); - segfaults.\n \n     if (file_exists (temporary_file)) {\n@@ -2543,7 +2543,7 @@ static void handle_cookies (SoupSession *session, SoupMessage *msg, gpointer use\n     }\n     if (uzbl.comm.sync_stdout)\n         uzbl.comm.sync_stdout = strfree(uzbl.comm.sync_stdout);\n-        \n+\n     g_string_free(s, TRUE);\n }\n \n@@ -2700,7 +2700,7 @@ main (int argc, char* argv[]) {\n     g_option_context_add_group (context, gtk_get_option_group (TRUE));\n     g_option_context_parse (context, &argc, &argv, NULL);\n     g_option_context_free(context);\n-    \n+\n     gchar *uri_override = (uzbl.state.uri ? g_strdup(uzbl.state.uri) : NULL);\n     gboolean verbose_override = uzbl.state.verbose;\n \n@@ -2789,7 +2789,7 @@ main (int argc, char* argv[]) {\n \n     if (verbose_override > uzbl.state.verbose)\n         uzbl.state.verbose = verbose_override;\n-    \n+\n     if (uri_override) {\n         set_var_value(""uri"", uri_override);\n         g_free(uri_override);\n']",2009-07-11 11:28:21+01:00,Remove extraneous whitespace.,"[['+ static const', '+     { ""name"",    \'n\', 0, G_OPTION_ARG_STRING, &uzbl.state.instance_name,', '+     { ""config"",  \'c\', 0, G_OPTION_ARG_STRING, &uzbl.state.config_file,', '+     { ""socket"",  \'s\', 0, G_OPTION_ARG_INT, &uzbl.state.socket_id,', '+                     case EXP_JS:', '+                 if(etype == EXP_SIMPLE_VAR ||', '+                 else if(recurse != 1 &&', '+                 else if(recurse != 2 &&', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ static void', '+ ', '+ ', '+                         JSObjectMake(context, uzbl.js.classref, NULL),', '+ ', '+ ', '+ ', '+     guint i = 0;', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ static void', '+ ', '+     g_object_set (G_OBJECT(view_settings()), ""enable-plugins"",', '+ static void', '+ static void', '+ static void', '+ static void', '+ static void', '+     if(uzbl.behave.modkey)', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '- static const', '-     { ""name"",    \'n\', 0, G_OPTION_ARG_STRING, &uzbl.state.instance_name,', '-     { ""config"",  \'c\', 0, G_OPTION_ARG_STRING, &uzbl.state.config_file,', '-     { ""socket"",  \'s\', 0, G_OPTION_ARG_INT, &uzbl.state.socket_id,', '-                     case EXP_JS:', '-                 if(etype == EXP_SIMPLE_VAR ||', '-                 else if(recurse != 1 &&', '-                 else if(recurse != 2 &&', '- ', '- ', '- ', '- ', '- ', '- ', '- static void', '- ', '- ', '-                         JSObjectMake(context, uzbl.js.classref, NULL),', '- ', '- ', '- ', '-     guint i = 0;', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- static void', '- ', '-     g_object_set (G_OBJECT(view_settings()), ""enable-plugins"",', '- static void', '- static void', '- static void', '- static void', '- static void', '-     if(uzbl.behave.modkey)', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ']]","[['+ static const', '+     { ""name"",    \'n\', 0, g_option_arg_string, &uzbl.state.instance_name,', '+     { ""config"",  \'c\', 0, g_option_arg_string, &uzbl.state.config_file,', '+     { ""socket"",  \'s\', 0, g_option_arg_int, &uzbl.state.socket_id,', '+                     case exp_js:', '+                 if(etype == exp_simple_var ||', '+                 else if(recurse != 1 &&', '+                 else if(recurse != 2 &&', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ static void', '+ ', '+ ', '+                         jsobjectmake(context, uzbl.js.classref, null),', '+ ', '+ ', '+ ', '+     guint i = 0;', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ static void', '+ ', '+     g_object_set (g_object(view_settings()), ""enable-plugins"",', '+ static void', '+ static void', '+ static void', '+ static void', '+ static void', '+     if(uzbl.behave.modkey)', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '- static const', '-     { ""name"",    \'n\', 0, g_option_arg_string, &uzbl.state.instance_name,', '-     { ""config"",  \'c\', 0, g_option_arg_string, &uzbl.state.config_file,', '-     { ""socket"",  \'s\', 0, g_option_arg_int, &uzbl.state.socket_id,', '-                     case exp_js:', '-                 if(etype == exp_simple_var ||', '-                 else if(recurse != 1 &&', '-                 else if(recurse != 2 &&', '- ', '- ', '- ', '- ', '- ', '- ', '- static void', '- ', '- ', '-                         jsobjectmake(context, uzbl.js.classref, null),', '- ', '- ', '- ', '-     guint i = 0;', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- static void', '- ', '-     g_object_set (g_object(view_settings()), ""enable-plugins"",', '- static void', '- static void', '- static void', '- static void', '- static void', '-     if(uzbl.behave.modkey)', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ']]","[['+ static const', '+     { ""name"",    \'n\', 0, G_OPTION_ARG_STRING, &uzbl.state.instance_name,', '+     { ""config"",  \'c\', 0, G_OPTION_ARG_STRING, &uzbl.state.config_file,', '+     { ""socket"",  \'s\', 0, G_OPTION_ARG_INT, &uzbl.state.socket_id,', '+                     case EXP_JS:', '+                 if(etype == EXP_SIMPLE_VAR ||', '+                 else if(recurse != 1 &&', '+                 else if(recurse != 2 &&', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ static void', '+ ', '+ ', '+                         JSObjectMake(context, uzbl.js.classref, NULL),', '+ ', '+ ', '+ ', '+     guint i = 0;', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ static void', '+ ', '+     g_object_set (G_OBJECT(view_settings()), ""enable-plugins"",', '+ static void', '+ static void', '+ static void', '+ static void', '+ static void', '+     if(uzbl.behave.modkey)', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ', '+ ']]","[['- static const', '-     { ""name"",    \'n\', 0, G_OPTION_ARG_STRING, &uzbl.state.instance_name,', '-     { ""config"",  \'c\', 0, G_OPTION_ARG_STRING, &uzbl.state.config_file,', '-     { ""socket"",  \'s\', 0, G_OPTION_ARG_INT, &uzbl.state.socket_id,', '-                     case EXP_JS:', '-                 if(etype == EXP_SIMPLE_VAR ||', '-                 else if(recurse != 1 &&', '-                 else if(recurse != 2 &&', '- ', '- ', '- ', '- ', '- ', '- ', '- static void', '- ', '- ', '-                         JSObjectMake(context, uzbl.js.classref, NULL),', '- ', '- ', '- ', '-     guint i = 0;', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- static void', '- ', '-     g_object_set (G_OBJECT(view_settings()), ""enable-plugins"",', '- static void', '- static void', '- static void', '- static void', '- static void', '-     if(uzbl.behave.modkey)', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ', '- ']]",49,49.0,98.0,1f9accc3dd70612f510f6613520261626490fa8eDieterbe/uzbl,['1958b52d41cba96956dc1995660de49525ed1047']
60bff10b24b41905a9dea3539e4903738703aad9,memcached/memcached,memcached.c,test,C,0,"['@@ -300,6 +300,7 @@ void process_stat(conn *c, char *command) {\n     if (strcmp(command, ""stats reset"") == 0) {\n         stats_reset();\n         out_string(c, ""RESET"");\n+        return;\n     }\n \n     if (strcmp(command, ""stats malloc"") == 0) {\n@@ -310,6 +311,7 @@ void process_stat(conn *c, char *command) {\n         sprintf(temp, ""STAT arena_size %d\\r\\nSTAT free_chunks %d\\r\\nSTAT fastbin_blocks %d\\r\\nSTAT mmaped_regions %d\\r\\nSTAT mmapped_space %d\\r\\nSTAT max_total_alloc %d\\r\\nSTAT fastbin_space %d\\r\\nSTAT total_alloc %d\\r\\nSTAT total_free %d\\r\\nSTAT releasable_space %d\\r\\nEND"", \n                 info.arena, info.ordblks, info.smblks, info.hblks, info.hblkhd, info.usmblks, info.fsmblks, info.uordblks, info.fordblks, info.keepcost);\n         out_string(c, temp);\n+        return;\n     }\n \n     if (strcmp(command, ""stats maps"") == 0) {\n']",,,"['+         return;', '+         return;']","['+         return;', '+         return;']","['+         return;', '+         return;']",[],2,0.0,2.0,60bff10b24b41905a9dea3539e4903738703aad9memcached/memcached,[]
4fd1d5b81bcbf7d549704278a7dd32a8e4f8ddf7,php/php-src,php_ini.c,val,C,0,"['@@ -132,6 +132,7 @@ void php_unregister_ini_entries(int module_number)\n int php_alter_ini_entry(char *name, uint name_length, char *new_value, uint new_value_length, int modify_type)\n {\n \tphp_ini_entry *ini_entry;\n+\tchar *duplicate;\n \n \tif (_php3_hash_find(&known_directives, name, name_length, (void **) &ini_entry)==FAILURE) {\n \t\treturn FAILURE;\n@@ -141,17 +142,21 @@ int php_alter_ini_entry(char *name, uint name_length, char *new_value, uint new_\n \t\treturn FAILURE;\n \t}\n \n+\tduplicate = estrndup(new_value, new_value_length);\n+\t\n \tif (!ini_entry->on_modify\n-\t\t|| ini_entry->on_modify(ini_entry, new_value, new_value_length, ini_entry->mh_arg)==SUCCESS) {\n+\t\t|| ini_entry->on_modify(ini_entry, duplicate, new_value_length, ini_entry->mh_arg)==SUCCESS) {\n \t\tif (!ini_entry->orig_value) {\n \t\t\tini_entry->orig_value = ini_entry->value;\n \t\t\tini_entry->orig_value_length = ini_entry->value_length;\n \t\t} else { /* we already changed the value, free the changed value */\n \t\t\tefree(ini_entry->value);\n \t\t}\n-\t\tini_entry->value = estrndup(new_value, new_value_length);\n+\t\tini_entry->value = duplicate;\n \t\tini_entry->value_length = new_value_length;\n \t\tini_entry->modified = 1;\n+\t} else {\n+\t\tefree(duplicate);\n \t}\n \n \treturn SUCCESS;\n']",,,"['+ \tchar *duplicate;', '+ \tduplicate = estrndup(new_value, new_value_length);', '+ \t\t|| ini_entry->on_modify(ini_entry, duplicate, new_value_length, ini_entry->mh_arg)==SUCCESS) {', '+ \t\tini_entry->value = duplicate;', '+ \t} else {', '+ \t\tefree(duplicate);', '- \t\t|| ini_entry->on_modify(ini_entry, new_value, new_value_length, ini_entry->mh_arg)==SUCCESS) {', '- \t\tini_entry->value = estrndup(new_value, new_value_length);']","['+ \tchar *duplicate;', '+ \tduplicate = estrndup(new_value, new_value_length);', '+ \t\t|| ini_entry->on_modify(ini_entry, duplicate, new_value_length, ini_entry->mh_arg)==success) {', '+ \t\tini_entry->value = duplicate;', '+ \t} else {', '+ \t\tefree(duplicate);', '- \t\t|| ini_entry->on_modify(ini_entry, new_value, new_value_length, ini_entry->mh_arg)==success) {', '- \t\tini_entry->value = estrndup(new_value, new_value_length);']","['+ \tchar *duplicate;', '+ \tduplicate = estrndup(new_value, new_value_length);', '+ \t\t|| ini_entry->on_modify(ini_entry, duplicate, new_value_length, ini_entry->mh_arg)==SUCCESS) {', '+ \t\tini_entry->value = duplicate;', '+ \t} else {', '+ \t\tefree(duplicate);']","['- \t\t|| ini_entry->on_modify(ini_entry, new_value, new_value_length, ini_entry->mh_arg)==SUCCESS) {', '- \t\tini_entry->value = estrndup(new_value, new_value_length);']",6,2.0,8.0,4fd1d5b81bcbf7d549704278a7dd32a8e4f8ddf7php/php-src,[]
81d9614a3318141ad854b55b6a704edaa233f927,yoe/nbd,nbd-client.c,train,C,0,"['@@ -5,10 +5,10 @@\n  *  <pavel@atrey.karlin.mff.cuni.cz>\n  *\n  * Version 1.0 - 64bit issues should be fixed, now\n+ * Version 1.1 - added bs (blocksize) option (Alexey Guzeev, aga@permonline.ru)\n+ * Version 1.2 - I added new option \'-d\' to send the disconnect request\n  */\n \n-/* I added new option \'-d\' to send the disconnect request */\n-\n #include <asm/page.h>\n #include <sys/ioctl.h>\n #include <sys/socket.h>\n@@ -60,19 +60,27 @@ int main(int argc, char *argv[])\n \tu64 magic, size64;\n \tunsigned long size;\n \tchar buf[256] = ""\\0\\0\\0\\0\\0\\0\\0\\0\\0"";\n-\tint swap = (argc > 4);\n+\tint blocksize=1024;\n+\tchar *hostname;\n+\tint swap=0;\n \n \tlogging();\n \n-\tif (argc < 2) {\n+\tif (argc < 3) {\n \terrmsg:\n-\t\tfprintf(stderr, ""Usage: host port nbd_device -swap\\n"");\n-\t\tfprintf(stderr, ""or     -d nbd_device \\n"");\n+\t\tfprintf(stderr, ""Usage: nbd-client [bs=blocksize] host port nbd_device [-swap]\\n"");\n+\t\tfprintf(stderr, ""Or   : nbd-client -d nbd_device\\n"");\n+\t\tfprintf(stderr, ""Default value for blocksize is 1024 (recommended for ethernet)\\n"");\n+\t\tfprintf(stderr, ""Allowed values for blocksize are 512,1024,2048,4096\\n""); /* will be checked in kernel :) */\n+\t\tfprintf(stderr, ""Note, that kernel 2.4.2 and older ones do not work correctly with\\n"");\n+\t\tfprintf(stderr, ""blocksizes other than 1024 without patches\\n"");\n \t\treturn 1;\n \t}\n \n-\tif (strcmp(argv[1],""-d"")==0) {\n-\t  nbd = open(argv[2], O_RDWR);\n+\t++argv; --argc; /* skip programname */\n+\t\n+\tif (strcmp(argv[0], ""-d"")==0) {\n+\t  nbd = open(argv[1], O_RDWR);\n \t  if (nbd < 0)\n \t\terr(""Can not open NBD: %m"");\n \t  printf(""Disconnecting: que, "");\n@@ -84,20 +92,38 @@ int main(int argc, char *argv[])\n \t\terr(""Ioctl failed: %m\\n"");\n \t  printf(""sock, "");\n #else\n-\t  die(""Can\'t disconnect: I was not compiled with disconnect support!\\n"" );\n+\t  fprintf(stderr, ""Can\'t disconnect: I was not compiled with disconnect support!\\n"" );\n+\t  exit(1);\n #endif\n \t  if (ioctl(nbd, NBD_CLEAR_SOCK)<0)\n \t\terr(""Ioctl failed: %m\\n"");\n \t  printf(""done\\n"");\n \t  return 0;\n \t}\n-\t\n-\tif (argc<4) goto errmsg;\n-\tport = atoi(argv[2]);\n-\tsock = opennet(argv[1], port);\n-\tnbd = open(argv[3], O_RDWR);\n+\n+\tif (strncmp(argv[0], ""bs="", 3)==0) {\n+\t  blocksize=atoi(argv[0]+3);\n+\t  ++argv; --argc; /* skip blocksize */\n+\t}\n+\n+\tif (argc==0) goto errmsg;\n+\thostname=argv[0];\n+\t++argv; --argc; /* skip hostname */\n+\n+\tif (argc==0) goto errmsg;\n+\tport = atoi(argv[0]);\n+\t++argv; --argc; /* skip port */\n+\n+\tif (argc==0) goto errmsg;\n+\tsock = opennet(hostname, port);\n+\tnbd = open(argv[0], O_RDWR);\n \tif (nbd < 0)\n \t  err(""Can not open NBD: %m"");\n+\t++argv; --argc; /* skip device */\n+\n+\tif (argc>1) goto errmsg;\n+\tif (argc!=0) swap=1;\n+\targv=NULL; argc=0; /* don\'t use it later suddenly */\n \n \tprintf(""Negotiation: "");\n \tif (read(sock, buf, 8) < 0)\n@@ -115,50 +141,47 @@ int main(int argc, char *argv[])\n \tif (read(sock, &size64, sizeof(size64)) < 0)\n \t\terr(""Failed/3: %m\\n"");\n \tsize64 = ntohll(size64);\n-\tif (size64 > (~0UL >> 1)) {\n+\n #ifdef NBD_SET_SIZE_BLOCKS\n-\t\tif ((size64 >> 10) > (~0UL >> 1)) {\n-\t\t\tprintf(""size = %luMB"", (unsigned long)(size64>>20));\n-\t\t\terr(""Exported device is too big for me. Get 64-bit machine :-(\\n"");\n-\t\t} else\n-\t\t\tprintf(""size = %luKB"", (unsigned long)(size64>>10));\n+\tif ((size64>>10) > (~0UL >> 1)) {\n+\t\tprintf(""size = %luMB"", (unsigned long)(size64>>20));\n+\t\terr(""Exported device is too big for me. Get 64-bit machine :-(\\n"");\n+\t} else\n+\t\tprintf(""size = %luKB"", (unsigned long)(size64>>10));\n #else\n+\tif (size64 > (~0UL >> 1)) {\n \t\tprintf(""size = %luKB"", (unsigned long)(size64>>10));\n \t\terr(""Exported device is too big. Get 64-bit machine or newer kernel :-(\\n"");\n-#endif\n \t} else\n \t\tprintf(""size = %lu"", (unsigned long)(size64));\n+#endif\n \n \tif (read(sock, &buf, 128) < 0)\n \t\terr(""Failed/4: %m\\n"");\n \tprintf(""\\n"");\n \n-\tif (size64 > (~0UL >> 1)) {\n #ifdef NBD_SET_SIZE_BLOCKS\n-\t\tif ((size64 >> 10) > (~0UL >> 1))\n-\t\t/*\n-\t\t * If you really need NBDs larger than 2TB on 32-bit\n-\t\t * machines you can use blocksizes larger than 1kB\n-\t\t * - FIXME\n-\t\t */\n-\t\t\terr(""Device too large.\\n"");\n-\t\telse {\n-\t\t\tint er;\n-\n-\t\t\tif (ioctl(nbd, NBD_SET_BLKSIZE, 1UL << 10) < 0)\n-\t\t\t\terr(""Ioctl/1.1a failed: %m\\n"");\n-\t\t\tsize = (unsigned long)(size64 >> 10);\n-\t\t\tif ((er = ioctl(nbd, NBD_SET_SIZE_BLOCKS, size)) < 0)\n-\t\t\t\terr(""Ioctl/1.1b failed: %m\\n"");\n-\t\t}\n+\tif (size64/blocksize > (~0UL >> 1))\n+\t\terr(""Device too large.\\n"");\n+\telse {\n+\t\tint er;\n+\t\tif (ioctl(nbd, NBD_SET_BLKSIZE, (unsigned long)blocksize) < 0)\n+\t\t\terr(""Ioctl/1.1a failed: %m\\n"");\n+\t\tsize = (unsigned long)(size64/blocksize);\n+\t\tif ((er = ioctl(nbd, NBD_SET_SIZE_BLOCKS, size)) < 0)\n+\t\t\terr(""Ioctl/1.1b failed: %m\\n"");\n+fprintf(stderr, ""bs=%d, sz=%lu\\n"", blocksize, size);\n+\t}\n #else\n+\tif (size64 > (~0UL >> 1)) {\n \t\terr(""Device too large.\\n"");\n-#endif\n \t} else {\n \t\tsize = (unsigned long)size64;\n \t\tif (ioctl(nbd, NBD_SET_SIZE, size) < 0)\n \t\t\terr(""Ioctl/1 failed: %m\\n"");\n \t}\n+#endif\n+\n \tioctl(nbd, NBD_CLEAR_SOCK);\n \tif (ioctl(nbd, NBD_SET_SOCK, sock) < 0)\n \t\terr(""Ioctl/2 failed: %m\\n"");\n']",,,"['+ \tint blocksize=1024;', '+ \tchar *hostname;', '+ \tint swap=0;', '+ \tif (argc < 3) {', '+ \t\tfprintf(stderr, ""Usage: nbd-client [bs=blocksize] host port nbd_device [-swap]\\n"");', '+ \t\tfprintf(stderr, ""Or   : nbd-client -d nbd_device\\n"");', '+ \t\tfprintf(stderr, ""Default value for blocksize is 1024 (recommended for ethernet)\\n"");', '+ \t\tfprintf(stderr, ""Note, that kernel 2.4.2 and older ones do not work correctly with\\n"");', '+ \t\tfprintf(stderr, ""blocksizes other than 1024 without patches\\n"");', '+ \tif (strcmp(argv[0], ""-d"")==0) {', '+ \t  nbd = open(argv[1], O_RDWR);', '+ \t  fprintf(stderr, ""Can\'t disconnect: I was not compiled with disconnect support!\\n"" );', '+ \t  exit(1);', '+ \tif (strncmp(argv[0], ""bs="", 3)==0) {', '+ \t  blocksize=atoi(argv[0]+3);', '+ \t}', '+ \tif (argc==0) goto errmsg;', '+ \thostname=argv[0];', '+ \tif (argc==0) goto errmsg;', '+ \tport = atoi(argv[0]);', '+ \tif (argc==0) goto errmsg;', '+ \tsock = opennet(hostname, port);', '+ \tnbd = open(argv[0], O_RDWR);', '+ \tif (argc>1) goto errmsg;', '+ \tif (argc!=0) swap=1;', '+ \tif ((size64>>10) > (~0UL >> 1)) {', '+ \t\tprintf(""size = %luMB"", (unsigned long)(size64>>20));', '+ \t\terr(""Exported device is too big for me. Get 64-bit machine :-(\\n"");', '+ \t} else', '+ \t\tprintf(""size = %luKB"", (unsigned long)(size64>>10));', '+ \tif (size64 > (~0UL >> 1)) {', '+ #endif', '+ \tif (size64/blocksize > (~0UL >> 1))', '+ \t\terr(""Device too large.\\n"");', '+ \telse {', '+ \t\tint er;', '+ \t\tif (ioctl(nbd, NBD_SET_BLKSIZE, (unsigned long)blocksize) < 0)', '+ \t\t\terr(""Ioctl/1.1a failed: %m\\n"");', '+ \t\tsize = (unsigned long)(size64/blocksize);', '+ \t\tif ((er = ioctl(nbd, NBD_SET_SIZE_BLOCKS, size)) < 0)', '+ \t\t\terr(""Ioctl/1.1b failed: %m\\n"");', '+ fprintf(stderr, ""bs=%d, sz=%lu\\n"", blocksize, size);', '+ \t}', '+ \tif (size64 > (~0UL >> 1)) {', '+ #endif', '- \tint swap = (argc > 4);', '- \tif (argc < 2) {', '- \t\tfprintf(stderr, ""Usage: host port nbd_device -swap\\n"");', '- \t\tfprintf(stderr, ""or     -d nbd_device \\n"");', '- \tif (strcmp(argv[1],""-d"")==0) {', '- \t  nbd = open(argv[2], O_RDWR);', '- \t  die(""Can\'t disconnect: I was not compiled with disconnect support!\\n"" );', '- \tif (argc<4) goto errmsg;', '- \tport = atoi(argv[2]);', '- \tsock = opennet(argv[1], port);', '- \tnbd = open(argv[3], O_RDWR);', '- \tif (size64 > (~0UL >> 1)) {', '- \t\tif ((size64 >> 10) > (~0UL >> 1)) {', '- \t\t\tprintf(""size = %luMB"", (unsigned long)(size64>>20));', '- \t\t\terr(""Exported device is too big for me. Get 64-bit machine :-(\\n"");', '- \t\t} else', '- \t\t\tprintf(""size = %luKB"", (unsigned long)(size64>>10));', '- #endif', '- \tif (size64 > (~0UL >> 1)) {', '- \t\tif ((size64 >> 10) > (~0UL >> 1))', '- \t\t\terr(""Device too large.\\n"");', '- \t\telse {', '- \t\t\tint er;', '- \t\t\tif (ioctl(nbd, NBD_SET_BLKSIZE, 1UL << 10) < 0)', '- \t\t\t\terr(""Ioctl/1.1a failed: %m\\n"");', '- \t\t\tsize = (unsigned long)(size64 >> 10);', '- \t\t\tif ((er = ioctl(nbd, NBD_SET_SIZE_BLOCKS, size)) < 0)', '- \t\t\t\terr(""Ioctl/1.1b failed: %m\\n"");', '- \t\t}', '- #endif']","['+ \tint blocksize=1024;', '+ \tchar *hostname;', '+ \tint swap=0;', '+ \tif (argc < 3) {', '+ \t\tfprintf(stderr, ""usage: nbd-client [bs=blocksize] host port nbd_device [-swap]\\n"");', '+ \t\tfprintf(stderr, ""or   : nbd-client -d nbd_device\\n"");', '+ \t\tfprintf(stderr, ""default value for blocksize is 1024 (recommended for ethernet)\\n"");', '+ \t\tfprintf(stderr, ""note, that kernel 2.4.2 and older ones do not work correctly with\\n"");', '+ \t\tfprintf(stderr, ""blocksizes other than 1024 without patches\\n"");', '+ \tif (strcmp(argv[0], ""-d"")==0) {', '+ \t  nbd = open(argv[1], o_rdwr);', '+ \t  fprintf(stderr, ""can\'t disconnect: i was not compiled with disconnect support!\\n"" );', '+ \t  exit(1);', '+ \tif (strncmp(argv[0], ""bs="", 3)==0) {', '+ \t  blocksize=atoi(argv[0]+3);', '+ \t}', '+ \tif (argc==0) goto errmsg;', '+ \thostname=argv[0];', '+ \tif (argc==0) goto errmsg;', '+ \tport = atoi(argv[0]);', '+ \tif (argc==0) goto errmsg;', '+ \tsock = opennet(hostname, port);', '+ \tnbd = open(argv[0], o_rdwr);', '+ \tif (argc>1) goto errmsg;', '+ \tif (argc!=0) swap=1;', '+ \tif ((size64>>10) > (~0ul >> 1)) {', '+ \t\tprintf(""size = %lumb"", (unsigned long)(size64>>20));', '+ \t\terr(""exported device is too big for me. get 64-bit machine :-(\\n"");', '+ \t} else', '+ \t\tprintf(""size = %lukb"", (unsigned long)(size64>>10));', '+ \tif (size64 > (~0ul >> 1)) {', '+ #endif', '+ \tif (size64/blocksize > (~0ul >> 1))', '+ \t\terr(""device too large.\\n"");', '+ \telse {', '+ \t\tint er;', '+ \t\tif (ioctl(nbd, nbd_set_blksize, (unsigned long)blocksize) < 0)', '+ \t\t\terr(""ioctl/1.1a failed: %m\\n"");', '+ \t\tsize = (unsigned long)(size64/blocksize);', '+ \t\tif ((er = ioctl(nbd, nbd_set_size_blocks, size)) < 0)', '+ \t\t\terr(""ioctl/1.1b failed: %m\\n"");', '+ fprintf(stderr, ""bs=%d, sz=%lu\\n"", blocksize, size);', '+ \t}', '+ \tif (size64 > (~0ul >> 1)) {', '+ #endif', '- \tint swap = (argc > 4);', '- \tif (argc < 2) {', '- \t\tfprintf(stderr, ""usage: host port nbd_device -swap\\n"");', '- \t\tfprintf(stderr, ""or     -d nbd_device \\n"");', '- \tif (strcmp(argv[1],""-d"")==0) {', '- \t  nbd = open(argv[2], o_rdwr);', '- \t  die(""can\'t disconnect: i was not compiled with disconnect support!\\n"" );', '- \tif (argc<4) goto errmsg;', '- \tport = atoi(argv[2]);', '- \tsock = opennet(argv[1], port);', '- \tnbd = open(argv[3], o_rdwr);', '- \tif (size64 > (~0ul >> 1)) {', '- \t\tif ((size64 >> 10) > (~0ul >> 1)) {', '- \t\t\tprintf(""size = %lumb"", (unsigned long)(size64>>20));', '- \t\t\terr(""exported device is too big for me. get 64-bit machine :-(\\n"");', '- \t\t} else', '- \t\t\tprintf(""size = %lukb"", (unsigned long)(size64>>10));', '- #endif', '- \tif (size64 > (~0ul >> 1)) {', '- \t\tif ((size64 >> 10) > (~0ul >> 1))', '- \t\t\terr(""device too large.\\n"");', '- \t\telse {', '- \t\t\tint er;', '- \t\t\tif (ioctl(nbd, nbd_set_blksize, 1ul << 10) < 0)', '- \t\t\t\terr(""ioctl/1.1a failed: %m\\n"");', '- \t\t\tsize = (unsigned long)(size64 >> 10);', '- \t\t\tif ((er = ioctl(nbd, nbd_set_size_blocks, size)) < 0)', '- \t\t\t\terr(""ioctl/1.1b failed: %m\\n"");', '- \t\t}', '- #endif']","['+ \tint blocksize=1024;', '+ \tchar *hostname;', '+ \tint swap=0;', '+ \tif (argc < 3) {', '+ \t\tfprintf(stderr, ""Usage: nbd-client [bs=blocksize] host port nbd_device [-swap]\\n"");', '+ \t\tfprintf(stderr, ""Or   : nbd-client -d nbd_device\\n"");', '+ \t\tfprintf(stderr, ""Default value for blocksize is 1024 (recommended for ethernet)\\n"");', '+ \t\tfprintf(stderr, ""Note, that kernel 2.4.2 and older ones do not work correctly with\\n"");', '+ \t\tfprintf(stderr, ""blocksizes other than 1024 without patches\\n"");', '+ \tif (strcmp(argv[0], ""-d"")==0) {', '+ \t  nbd = open(argv[1], O_RDWR);', '+ \t  fprintf(stderr, ""Can\'t disconnect: I was not compiled with disconnect support!\\n"" );', '+ \t  exit(1);', '+ \tif (strncmp(argv[0], ""bs="", 3)==0) {', '+ \t  blocksize=atoi(argv[0]+3);', '+ \t}', '+ \tif (argc==0) goto errmsg;', '+ \thostname=argv[0];', '+ \tif (argc==0) goto errmsg;', '+ \tport = atoi(argv[0]);', '+ \tif (argc==0) goto errmsg;', '+ \tsock = opennet(hostname, port);', '+ \tnbd = open(argv[0], O_RDWR);', '+ \tif (argc>1) goto errmsg;', '+ \tif (argc!=0) swap=1;', '+ \tif ((size64>>10) > (~0UL >> 1)) {', '+ \t\tprintf(""size = %luMB"", (unsigned long)(size64>>20));', '+ \t\terr(""Exported device is too big for me. Get 64-bit machine :-(\\n"");', '+ \t} else', '+ \t\tprintf(""size = %luKB"", (unsigned long)(size64>>10));', '+ \tif (size64 > (~0UL >> 1)) {', '+ #endif', '+ \tif (size64/blocksize > (~0UL >> 1))', '+ \t\terr(""Device too large.\\n"");', '+ \telse {', '+ \t\tint er;', '+ \t\tif (ioctl(nbd, NBD_SET_BLKSIZE, (unsigned long)blocksize) < 0)', '+ \t\t\terr(""Ioctl/1.1a failed: %m\\n"");', '+ \t\tsize = (unsigned long)(size64/blocksize);', '+ \t\tif ((er = ioctl(nbd, NBD_SET_SIZE_BLOCKS, size)) < 0)', '+ \t\t\terr(""Ioctl/1.1b failed: %m\\n"");', '+ fprintf(stderr, ""bs=%d, sz=%lu\\n"", blocksize, size);', '+ \t}', '+ \tif (size64 > (~0UL >> 1)) {', '+ #endif']","['- \tint swap = (argc > 4);', '- \tif (argc < 2) {', '- \t\tfprintf(stderr, ""Usage: host port nbd_device -swap\\n"");', '- \t\tfprintf(stderr, ""or     -d nbd_device \\n"");', '- \tif (strcmp(argv[1],""-d"")==0) {', '- \t  nbd = open(argv[2], O_RDWR);', '- \t  die(""Can\'t disconnect: I was not compiled with disconnect support!\\n"" );', '- \tif (argc<4) goto errmsg;', '- \tport = atoi(argv[2]);', '- \tsock = opennet(argv[1], port);', '- \tnbd = open(argv[3], O_RDWR);', '- \tif (size64 > (~0UL >> 1)) {', '- \t\tif ((size64 >> 10) > (~0UL >> 1)) {', '- \t\t\tprintf(""size = %luMB"", (unsigned long)(size64>>20));', '- \t\t\terr(""Exported device is too big for me. Get 64-bit machine :-(\\n"");', '- \t\t} else', '- \t\t\tprintf(""size = %luKB"", (unsigned long)(size64>>10));', '- #endif', '- \tif (size64 > (~0UL >> 1)) {', '- \t\tif ((size64 >> 10) > (~0UL >> 1))', '- \t\t\terr(""Device too large.\\n"");', '- \t\telse {', '- \t\t\tint er;', '- \t\t\tif (ioctl(nbd, NBD_SET_BLKSIZE, 1UL << 10) < 0)', '- \t\t\t\terr(""Ioctl/1.1a failed: %m\\n"");', '- \t\t\tsize = (unsigned long)(size64 >> 10);', '- \t\t\tif ((er = ioctl(nbd, NBD_SET_SIZE_BLOCKS, size)) < 0)', '- \t\t\t\terr(""Ioctl/1.1b failed: %m\\n"");', '- \t\t}', '- #endif']",45,30.0,75.0,81d9614a3318141ad854b55b6a704edaa233f927yoe/nbd,[]
0369e8e2976617c001bb40f28d0b15ae603bf3f9,mumble-voip/mumble,src/mumble/Database.cpp,train,C++,1,"['@@ -88,7 +88,7 @@ Database::Database() {\n \tQFileInfo fi(db.databaseName());\n \n \tif (! fi.isWritable()) {\n-\t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""The database \'%1\' is read-only. Mumble can not store server settings (ie. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n+\t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""The database \'%1\' is read-only. Mumble cannot store server settings (i.e. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n \t\tqWarning(""Database: Database is read-only"");\n \t}\n \n']",2010-10-04 12:11:43+02:00,Fix English source strings,"[['+ \t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""The database \'%1\' is read-only. Mumble cannot store server settings (i.e. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);', '- \t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""The database \'%1\' is read-only. Mumble can not store server settings (ie. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);']]","[['+ \t\tqmessagebox::critical(null, qlatin1string(""mumble""), tr(""the database \'%1\' is read-only. mumble cannot store server settings (i.e. ssl certificates) until you fix this problem."").arg(fi.filepath()), qmessagebox::ok | qmessagebox::default, qmessagebox::nobutton);', '- \t\tqmessagebox::critical(null, qlatin1string(""mumble""), tr(""the database \'%1\' is read-only. mumble can not store server settings (ie. ssl certificates) until you fix this problem."").arg(fi.filepath()), qmessagebox::ok | qmessagebox::default, qmessagebox::nobutton);']]","[['+ \t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""The database \'%1\' is read-only. Mumble cannot store server settings (i.e. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);']]","[['- \t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""The database \'%1\' is read-only. Mumble can not store server settings (ie. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);']]",1,1.0,2.0,0369e8e2976617c001bb40f28d0b15ae603bf3f9mumble-voip/mumble,['5632c35d6759f5e13a7dfe78e4ee6403ff6a8e3e']
f8974ca74f2342f574a877dd66fff91104a09997,LawnGnome/php-radius,radius.c,train,C,0,"['@@ -12,7 +12,7 @@\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n-  | Author: Michael Bretterklieber <mbretter@jawa.at>                    |\n+  | Author: Michael Bretterklieber <mbretter@bretterklieber.com>         |\n   +----------------------------------------------------------------------+\n \n   $Id$\n@@ -50,30 +50,30 @@ static int le_radius;\n  * Every user visible function must have an entry in radius_functions[].\n  */\n function_entry radius_functions[] = {\n-\tPHP_FE(radius_auth_open,\tNULL)\n-\tPHP_FE(radius_acct_open,\tNULL)\n-\tPHP_FE(radius_close,\tNULL)\n-\tPHP_FE(radius_strerror,\tNULL)\n-\tPHP_FE(radius_config,\tNULL)\n-\tPHP_FE(radius_add_server,\tNULL)\n-\tPHP_FE(radius_create_request,\tNULL)\n-\tPHP_FE(radius_put_string,\tNULL)\n-\tPHP_FE(radius_put_int,\tNULL)\n-\tPHP_FE(radius_put_attr,\tNULL)\n-\tPHP_FE(radius_put_addr,\tNULL)\n-\tPHP_FE(radius_put_vendor_string,\tNULL)\n-\tPHP_FE(radius_put_vendor_int,\tNULL)\n-\tPHP_FE(radius_put_vendor_attr,\tNULL)\n-\tPHP_FE(radius_put_vendor_addr,\tNULL)\n-\tPHP_FE(radius_send_request,\tNULL)\n-\tPHP_FE(radius_get_attr,\tNULL)\n-\tPHP_FE(radius_get_vendor_attr,\tNULL)\n-\tPHP_FE(radius_cvt_addr,\tNULL)\n-\tPHP_FE(radius_cvt_int,\tNULL)\n-\tPHP_FE(radius_cvt_string,\tNULL)\n-\tPHP_FE(radius_request_authenticator,\tNULL)\n-\tPHP_FE(radius_server_secret,\tNULL)\n- \t{NULL, NULL, NULL}\t/* Must be the last line in radius_functions[] */\n+    PHP_FE(radius_auth_open,    NULL)\n+    PHP_FE(radius_acct_open,    NULL)\n+    PHP_FE(radius_close,        NULL)\n+    PHP_FE(radius_strerror,     NULL)\n+    PHP_FE(radius_config,       NULL)\n+    PHP_FE(radius_add_server,\tNULL)\n+    PHP_FE(radius_create_request,\tNULL)\n+    PHP_FE(radius_put_string,\tNULL)\n+    PHP_FE(radius_put_int,\tNULL)\n+    PHP_FE(radius_put_attr,\tNULL)\n+    PHP_FE(radius_put_addr,\tNULL)\n+    PHP_FE(radius_put_vendor_string,\tNULL)\n+    PHP_FE(radius_put_vendor_int,\tNULL)\n+    PHP_FE(radius_put_vendor_attr,\tNULL)\n+    PHP_FE(radius_put_vendor_addr,\tNULL)\n+    PHP_FE(radius_send_request,\tNULL)\n+    PHP_FE(radius_get_attr,\tNULL)\n+    PHP_FE(radius_get_vendor_attr,\tNULL)\n+    PHP_FE(radius_cvt_addr,\tNULL)\n+    PHP_FE(radius_cvt_int,\tNULL)\n+    PHP_FE(radius_cvt_string,\tNULL)\n+    PHP_FE(radius_request_authenticator,\tNULL)\n+    PHP_FE(radius_server_secret,\tNULL)\n+    {NULL, NULL, NULL}\t/* Must be the last line in radius_functions[] */\n };\n /* }}} */\n \n@@ -81,19 +81,19 @@ function_entry radius_functions[] = {\n  */\n zend_module_entry radius_module_entry = {\n #if ZEND_MODULE_API_NO >= 20010901\n-\tSTANDARD_MODULE_HEADER,\n+    STANDARD_MODULE_HEADER,\n #endif\n-\t""radius"",\n-\tradius_functions,\n-\tPHP_MINIT(radius),\n-\tPHP_MSHUTDOWN(radius),\n-\tPHP_RINIT(radius),\t\t/* Replace with NULL if there\'s nothing to do at request start */\n-\tPHP_RSHUTDOWN(radius),\t/* Replace with NULL if there\'s nothing to do at request end */\n-\tPHP_MINFO(radius),\n+    ""radius"",\n+    radius_functions,\n+    PHP_MINIT(radius),\n+    PHP_MSHUTDOWN(radius),\n+    PHP_RINIT(radius),      /* Replace with NULL if there\'s nothing to do at request start */\n+    PHP_RSHUTDOWN(radius),  /* Replace with NULL if there\'s nothing to do at request end */\n+    PHP_MINFO(radius),\n #if ZEND_MODULE_API_NO >= 20010901\n-\t""1.0"", /* Replace with version number for your extension */\n+    ""1.1"", /* Replace with version number for your extension */\n #endif\n-\tSTANDARD_MODULE_PROPERTIES\n+    STANDARD_MODULE_PROPERTIES\n };\n /* }}} */\n \n@@ -126,13 +126,13 @@ static void php_radius_init_globals(zend_radius_globals *radius_globals)\n  */\n PHP_MINIT_FUNCTION(radius)\n {\n-\t/* If you have INI entries, uncomment these lines\n-\tZEND_INIT_MODULE_GLOBALS(radius, php_radius_init_globals, NULL);\n-\tREGISTER_INI_ENTRIES();\n-\t*/\n- \tle_radius = zend_register_list_destructors_ex(_radius_close, NULL, ""rad_handle"", module_number);\n+    /* If you have INI entries, uncomment these lines\n+    ZEND_INIT_MODULE_GLOBALS(radius, php_radius_init_globals, NULL);\n+    REGISTER_INI_ENTRIES();\n+    */\n+    le_radius = zend_register_list_destructors_ex(_radius_close, NULL, ""rad_handle"", module_number);\n \t#include ""radius_init_const.h""\n-\treturn SUCCESS;\n+    return SUCCESS;\n }\n /* }}} */\n \n@@ -140,10 +140,10 @@ PHP_MINIT_FUNCTION(radius)\n  */\n PHP_MSHUTDOWN_FUNCTION(radius)\n {\n-\t/* uncomment this line if you have INI entries\n-\tUNREGISTER_INI_ENTRIES();\n-\t*/\n-\treturn SUCCESS;\n+    /* uncomment this line if you have INI entries\n+    UNREGISTER_INI_ENTRIES();\n+    */\n+    return SUCCESS;\n }\n /* }}} */\n \n@@ -152,7 +152,7 @@ PHP_MSHUTDOWN_FUNCTION(radius)\n  */\n PHP_RINIT_FUNCTION(radius)\n {\n-\treturn SUCCESS;\n+    return SUCCESS;\n }\n /* }}} */\n \n@@ -161,7 +161,7 @@ PHP_RINIT_FUNCTION(radius)\n  */\n PHP_RSHUTDOWN_FUNCTION(radius)\n {\n-\treturn SUCCESS;\n+    return SUCCESS;\n }\n /* }}} */\n \n@@ -169,106 +169,106 @@ PHP_RSHUTDOWN_FUNCTION(radius)\n  */\n PHP_MINFO_FUNCTION(radius)\n {\n-\tphp_info_print_table_start();\n-\tphp_info_print_table_header(2, ""radius support"", ""enabled"");\n-\tphp_info_print_table_end();\n+    php_info_print_table_start();\n+    php_info_print_table_header(2, ""radius support"", ""enabled"");\n+    php_info_print_table_end();\n \n-\t/* Remove comments if you have entries in php.ini\n-\tDISPLAY_INI_ENTRIES();\n-\t*/\n+    /* Remove comments if you have entries in php.ini\n+    DISPLAY_INI_ENTRIES();\n+    */\n }\n /* }}} */\n \n /* {{{ proto ressource radius_auth_open(string arg) */\n PHP_FUNCTION(radius_auth_open)\n {\n-\tradius_descriptor *raddesc;\n-\n-\traddesc = emalloc(sizeof(radius_descriptor));\n-\traddesc->radh = rad_auth_open();\n-\traddesc->request_created = 0;\n-\n-\tif (raddesc->radh != NULL) {\n-\t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);\n-\t\traddesc->id = Z_LVAL_P(return_value);\n-\t} else {\n-\t\tRETURN_FALSE;\n-\t}\n+    radius_descriptor *raddesc;\n+\n+    raddesc = emalloc(sizeof(radius_descriptor));\n+    raddesc->radh = rad_auth_open();\n+    raddesc->request_created = 0;\n+\n+    if (raddesc->radh != NULL) {\n+        ZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);\n+        raddesc->id = Z_LVAL_P(return_value);\n+    } else {\n+        RETURN_FALSE;\n+    }\n }\n /* }}} */\n \n /* {{{ proto ressource radius_acct_open(string arg) */\n PHP_FUNCTION(radius_acct_open)\n {\n-\tradius_descriptor *raddesc;\n-\n-\traddesc = emalloc(sizeof(radius_descriptor));\n-\traddesc->radh = rad_acct_open();\n-\traddesc->request_created = 0;\n-\n-\tif (raddesc->radh != NULL) {\n-\t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);\n-\t\traddesc->id = Z_LVAL_P(return_value);\n-\t} else {\n-\t\tRETURN_FALSE;\n-\t}\n+    radius_descriptor *raddesc;\n+\n+    raddesc = emalloc(sizeof(radius_descriptor));\n+    raddesc->radh = rad_acct_open();\n+    raddesc->request_created = 0;\n+\n+    if (raddesc->radh != NULL) {\n+        ZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);\n+        raddesc->id = Z_LVAL_P(return_value);\n+    } else {\n+        RETURN_FALSE;\n+    }\n }\n /* }}} */\n \n /* {{{ proto bool radius_close(radh) */\n PHP_FUNCTION(radius_close)\n {\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n-  \t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tzend_list_delete(raddesc->id);\n-\tRETURN_TRUE;\n+    zend_list_delete(raddesc->id);\n+    RETURN_TRUE;\n }\n /* }}} */\n \n /* {{{ proto string radius_strerror(radh) */\n PHP_FUNCTION(radius_strerror)\n {\n-\tchar *msg;\n-\tradius_descriptor *raddesc;\n- \tzval *z_radh;\n+    char *msg;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n-  \t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tmsg = (char *)rad_strerror(raddesc->radh);\n-\tRETURN_STRINGL(msg, strlen(msg), 1);\n+    msg = (char *)rad_strerror(raddesc->radh);\n+    RETURN_STRINGL(msg, strlen(msg), 1);\n }\n /* }}} */\n \n /* {{{ proto bool radius_config(desc, configfile) */\n PHP_FUNCTION(radius_config)\n {\n-\tchar *filename;\n-\tint filename_len;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n+    char *filename;\n+    int filename_len;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &z_radh, &filename, &filename_len) == FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &z_radh, &filename, &filename_len) == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tif (rad_config(raddesc->radh, filename) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_TRUE;\n-\t}\n+    if (rad_config(raddesc->radh, filename) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -276,26 +276,26 @@ PHP_FUNCTION(radius_config)\n /* {{{ proto bool radius_add_server(desc, hostname, port, secret, timeout, maxtries) */\n PHP_FUNCTION(radius_add_server)\n {\n-\tchar *hostname, *secret;\n-\tint hostname_len, secret_len, port, timeout, maxtries;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n-\n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rslsll"", &z_radh,\n-\t\t&hostname, &hostname_len,\n-\t\t&port,\n-\t\t&secret, &secret_len,\n-\t\t&timeout, &maxtries) == FAILURE) {\n-\t\treturn;\n-\t}\n-\n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n-\n-\tif (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_TRUE;\n-\t}\n+    char *hostname, *secret;\n+    int hostname_len, secret_len, port, timeout, maxtries;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n+\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rslsll"", &z_radh,\n+                              &hostname, &hostname_len,\n+                              &port,\n+                              &secret, &secret_len,\n+                              &timeout, &maxtries) == FAILURE) {\n+        return;\n+    }\n+\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+\n+    if (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -303,22 +303,22 @@ PHP_FUNCTION(radius_add_server)\n /* {{{ proto bool radius_create_request(desc, code) */\n PHP_FUNCTION(radius_create_request)\n {\n-\tint code;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n+    int code;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &z_radh, &code) == FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &z_radh, &code) == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tif (rad_create_request(raddesc->radh, code) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\traddesc->request_created = 1;\n-\t\tRETURN_TRUE;\n-\t}\n+    if (rad_create_request(raddesc->radh, code) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        raddesc->request_created = 1;\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -326,23 +326,23 @@ PHP_FUNCTION(radius_create_request)\n /* {{{ proto bool radius_put_string(desc, type, str) */\n PHP_FUNCTION(radius_put_string)\n {\n-\tchar *str;\n-\tint str_len, type;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n+    char *str;\n+    int str_len, type;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &str, &str_len)\n-\t\t== FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &str, &str_len)\n+            == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tif (rad_put_string(raddesc->radh, type, str) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_TRUE;\n-\t}\n+    if (rad_put_string(raddesc->radh, type, str) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -350,23 +350,23 @@ PHP_FUNCTION(radius_put_string)\n /* {{{ proto bool radius_put_int(desc, type, int) */\n PHP_FUNCTION(radius_put_int)\n {\n-\tint type;\n-\tunsigned int val;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n+    int type;\n+    unsigned int val;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rll"", &z_radh, &type, &val)\n-\t\t== FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rll"", &z_radh, &type, &val)\n+            == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tif (rad_put_int(raddesc->radh, type, val) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_TRUE;\n-\t}\n+    if (rad_put_int(raddesc->radh, type, val) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -374,23 +374,23 @@ PHP_FUNCTION(radius_put_int)\n /* {{{ proto bool radius_put_attr(desc, type, data) */\n PHP_FUNCTION(radius_put_attr)\n {\n-\tint type, len;\n-\tchar *data;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n+    int type, len;\n+    char *data;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &data, &len)\n-\t\t== FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &data, &len)\n+            == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tif (rad_put_attr(raddesc->radh, type, data, len) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_TRUE;\n-\t}\n+    if (rad_put_attr(raddesc->radh, type, data, len) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -398,29 +398,29 @@ PHP_FUNCTION(radius_put_attr)\n /* {{{ proto bool radius_put_addr(desc, type, addr) */\n PHP_FUNCTION(radius_put_addr)\n {\n-\tint type, addrlen;\n-\tchar\t*addr;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n-\tstruct in_addr intern_addr;\n-\n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &addr, &addrlen)\n-\t\t== FAILURE) {\n-\t\treturn;\n-\t}\n-\n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n-  \n-\tif (inet_aton(addr, &intern_addr) == 0) {\n-\t\tstrcpy(raddesc->errmsg, ""Error converting Address"");\n-\t\tRETURN_FALSE;\n-\t}\n-\n-\tif (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_TRUE;\n-\t}\n+    int type, addrlen;\n+    char\t*addr;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n+    struct in_addr intern_addr;\n+\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &addr, &addrlen)\n+            == FAILURE) {\n+        return;\n+    }\n+\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+\n+    if (inet_aton(addr, &intern_addr) == 0) {\n+        strcpy(raddesc->errmsg, ""Error converting Address"");\n+        RETURN_FALSE;\n+    }\n+\n+    if (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -428,23 +428,23 @@ PHP_FUNCTION(radius_put_addr)\n /* {{{ proto bool radius_put_vendor_string(desc, vendor, type, str) */\n PHP_FUNCTION(radius_put_vendor_string)\n {\n-\tchar *str;\n-\tint str_len, type, vendor;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n+    char *str;\n+    int str_len, type, vendor;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type, &str, &str_len)\n-\t\t== FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type, &str, &str_len)\n+            == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tif (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_TRUE;\n-\t}\n+    if (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -452,23 +452,23 @@ PHP_FUNCTION(radius_put_vendor_string)\n /* {{{ proto bool radius_put_vendor_int(desc, vendor, type, int) */\n PHP_FUNCTION(radius_put_vendor_int)\n {\n-\tint type, vendor;\n-\tunsigned int val;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n+    int type, vendor;\n+    unsigned int val;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlll"", &z_radh, &vendor, &type, &val)\n-\t\t== FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlll"", &z_radh, &vendor, &type, &val)\n+            == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tif (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_TRUE;\n-\t}\n+    if (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -476,23 +476,23 @@ PHP_FUNCTION(radius_put_vendor_int)\n /* {{{ proto bool radius_put_vendor_attr(desc, vendor, type, data) */\n PHP_FUNCTION(radius_put_vendor_attr)\n {\n-\tint type, len, vendor;\n-\tchar *data;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n+    int type, len, vendor;\n+    char *data;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type,\n-  \t\t&data, &len) == FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type,\n+                              &data, &len) == FAILURE) {\n+        return;\n+    }\n \n-  ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-  if (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {\n-\t\tRETURN_FALSE;\n-  } else {\n-\t\tRETURN_TRUE;\n-  }\n+    if (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -500,29 +500,29 @@ PHP_FUNCTION(radius_put_vendor_attr)\n /* {{{ proto bool radius_put_vendor_addr(desc, vendor, type, addr) */\n PHP_FUNCTION(radius_put_vendor_addr)\n {\n-\tint type, addrlen, vendor;\n-\tchar\t*addr;\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n-\tstruct in_addr intern_addr;\n-\n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, \n-  \t\t&type, &addr, &addrlen) == FAILURE) {\n-\t\treturn;\n-\t}\n-\n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n-\n-\tif (inet_aton(addr, &intern_addr) == 0) {\n-\t\tstrcpy(raddesc->errmsg, ""Error converting Address"");\n-\t\tRETURN_FALSE;\n-\t}\n-\n-\tif (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_TRUE;\n-\t}\n+    int type, addrlen, vendor;\n+    char\t*addr;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n+    struct in_addr intern_addr;\n+\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor,\n+                              &type, &addr, &addrlen) == FAILURE) {\n+        return;\n+    }\n+\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+\n+    if (inet_aton(addr, &intern_addr) == 0) {\n+        strcpy(raddesc->errmsg, ""Error converting Address"");\n+        RETURN_FALSE;\n+    }\n+\n+    if (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_TRUE;\n+    }\n \n }\n /* }}} */\n@@ -530,23 +530,23 @@ PHP_FUNCTION(radius_put_vendor_addr)\n /* {{{ proto bool radius_send_request(desc) */\n PHP_FUNCTION(radius_send_request)\n {\n-\tradius_descriptor *raddesc;\n-\tzval *z_radh;\n-\tint res;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n+    int res;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh)\n-\t\t== FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh)\n+            == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tres = rad_send_request(raddesc->radh);\n-\tif (res == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_LONG(res);\n-\t}\n+    res = rad_send_request(raddesc->radh);\n+    if (res == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_LONG(res);\n+    }\n \n }\n /* }}} */\n@@ -554,36 +554,36 @@ PHP_FUNCTION(radius_send_request)\n /* {{{ proto string radius_get_attr(desc) */\n PHP_FUNCTION(radius_get_attr)\n {\n-\tradius_descriptor *raddesc;\n-\tint res;\n-\tconst void *data;\n-\tsize_t len;\n-\tzval *z_radh;\n+    radius_descriptor *raddesc;\n+    int res;\n+    const void *data;\n+    size_t len;\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tres = rad_get_attr(raddesc->radh, &data, &len);\n-\tif (res == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n+    res = rad_get_attr(raddesc->radh, &data, &len);\n+    if (res == -1) {\n+        RETURN_FALSE;\n+    } else {\n \n-\t\tif (res > 0) {\n+        if (res > 0) {\n \n-\t\t\tif(array_init(return_value) != SUCCESS) {\n-\t\t\t\tzend_error(E_WARNING, ""Could not initialize array"");\n-\t\t\t\tRETURN_FALSE;\n-\t\t\t}\n-\t\t\tadd_assoc_long(return_value, ""attr"", res);\n-\t\t\tadd_assoc_stringl(return_value, ""data"", (char *) data, len, 1);\n-\t\t\treturn;\n-\t\t}\n+            if(array_init(return_value) != SUCCESS) {\n+                zend_error(E_WARNING, ""Could not initialize array"");\n+                RETURN_FALSE;\n+            }\n+            add_assoc_long(return_value, ""attr"", res);\n+            add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);\n+            return;\n+        }\n \n-\t\tRETURN_LONG(res);\n-\t}\n+        RETURN_LONG(res);\n+    }\n \n }\n /* }}} */\n@@ -591,28 +591,28 @@ PHP_FUNCTION(radius_get_attr)\n /* {{{ proto string radius_get_vendor_attr(data) */\n PHP_FUNCTION(radius_get_vendor_attr)\n {\n-\tint res, vendor;\n-\tconst void *data;\n-\tsize_t len;\n-\n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {\n-\t\treturn;\n-\t}\n-\n-\tres = rad_get_vendor_attr(&vendor, &data, &len);\n-\tif (res == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\n-\t\tif(array_init(return_value) != SUCCESS) {\n-\t\t\tzend_error(E_WARNING, ""Could not initialize array"");\n-\t\t\tRETURN_FALSE;\n-\t\t}\n-\t\tadd_assoc_long(return_value, ""attr"", res);\n-\t\tadd_assoc_long(return_value, ""vendor"", vendor);\n-\t\tadd_assoc_stringl(return_value, ""data"", (char *) data, len, 1);\n-\t\treturn;\n-\t}\n+    int res, vendor;\n+    const void *data;\n+    size_t len;\n+\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {\n+        return;\n+    }\n+\n+    res = rad_get_vendor_attr(&vendor, &data, &len);\n+    if (res == -1) {\n+        RETURN_FALSE;\n+    } else {\n+\n+        if(array_init(return_value) != SUCCESS) {\n+            zend_error(E_WARNING, ""Could not initialize array"");\n+            RETURN_FALSE;\n+        }\n+        add_assoc_long(return_value, ""attr"", res);\n+        add_assoc_long(return_value, ""vendor"", vendor);\n+        add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);\n+        return;\n+    }\n \n }\n /* }}} */\n@@ -620,79 +620,79 @@ PHP_FUNCTION(radius_get_vendor_attr)\n /* {{{ proto string radius_cvt_addr(data) */\n PHP_FUNCTION(radius_cvt_addr)\n {\n-  const void *data;\n-  char *addr_dot;\n-  int len;\n-  struct in_addr addr;\n-\n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {\n-\t\treturn;\n-\t}\n-\n-\taddr = rad_cvt_addr(data);\n-\taddr_dot = inet_ntoa(addr);\n-\tRETURN_STRINGL(addr_dot, strlen(addr_dot), 1);\n+    const void *data;\n+    char *addr_dot;\n+    int len;\n+    struct in_addr addr;\n+\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {\n+        return;\n+    }\n+\n+    addr = rad_cvt_addr(data);\n+    addr_dot = inet_ntoa(addr);\n+    RETURN_STRINGL(addr_dot, strlen(addr_dot), 1);\n }\n /* }}} */\n \n /* {{{ proto int radius_cvt_int(data) */\n PHP_FUNCTION(radius_cvt_int)\n {\n-\tconst void *data;\n-\tint len, val;\n+    const void *data;\n+    int len, val;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)\n-\t\t== FAILURE) {\n-  \t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)\n+            == FAILURE) {\n+        return;\n+    }\n \n-\tval = rad_cvt_int(data);\n-\tRETURN_LONG(val);\n+    val = rad_cvt_int(data);\n+    RETURN_LONG(val);\n }\n /* }}} */\n \n /* {{{ proto string radius_cvt_string(data) */\n PHP_FUNCTION(radius_cvt_string)\n {\n-\tconst void *data;\n-\tchar *val;\n-\tint len;\n+    const void *data;\n+    char *val;\n+    int len;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)\n-\t\t== FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)\n+            == FAILURE) {\n+        return;\n+    }\n \n-\tval = rad_cvt_string(data, len);\n+    val = rad_cvt_string(data, len);\n \n-\tif (val == NULL) RETURN_FALSE;\n-\tRETVAL_STRINGL(val, strlen(val), 1);\n-\tfree(val);\n-\treturn;\n+    if (val == NULL) RETURN_FALSE;\n+    RETVAL_STRINGL(val, strlen(val), 1);\n+    free(val);\n+    return;\n }\n /* }}} */\n \n /* {{{ proto string radius_request_authenticator(radh) */\n PHP_FUNCTION(radius_request_authenticator)\n {\n-\tradius_descriptor *raddesc;\n-\tssize_t res;\n-\tchar buf[LEN_AUTH];\n-\tzval *z_radh;\n+    radius_descriptor *raddesc;\n+    ssize_t res;\n+    char buf[LEN_AUTH];\n+    zval *z_radh;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n-\t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tres = rad_request_authenticator(raddesc->radh, buf, sizeof buf);\n+    res = rad_request_authenticator(raddesc->radh, buf, sizeof buf);\n \n-\tif (res == -1) {\n-\t\tRETURN_FALSE;\n-\t} else {\n-\t\tRETURN_STRINGL(buf, res, 1);\n-\t}\n+    if (res == -1) {\n+        RETURN_FALSE;\n+    } else {\n+        RETURN_STRINGL(buf, res, 1);\n+    }\n \n }\n /* }}} */\n@@ -700,27 +700,27 @@ PHP_FUNCTION(radius_request_authenticator)\n /* {{{ proto string radius_server_secret(radh) */\n PHP_FUNCTION(radius_server_secret)\n {\n-\tchar *secret;\n-\tradius_descriptor *raddesc;\n- \tzval *z_radh;\n+    char *secret;\n+    radius_descriptor *raddesc;\n+    zval *z_radh;\n \n- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n-  \t\treturn;\n-\t}\n+    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {\n+        return;\n+    }\n \n-\tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n+    ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);\n \n-\tsecret = (char *)rad_server_secret(raddesc->radh);\n-\tRETURN_STRINGL(secret, strlen(secret), 1);\n+    secret = (char *)rad_server_secret(raddesc->radh);\n+    RETURN_STRINGL(secret, strlen(secret), 1);\n }\n /* }}} */\n \n /* {{{ _radius_close() */\n void _radius_close(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n {\n-\tradius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;\n-\trad_close(raddesc->radh);\n-\tefree(raddesc);\n+    radius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;\n+    rad_close(raddesc->radh);\n+    efree(raddesc);\n }\n /* }}} */\n \n@@ -731,4 +731,4 @@ void _radius_close(zend_rsrc_list_entry *rsrc TSRMLS_DC)\n  * End:\n  * vim600: noet sw=4 ts=4 fdm=marker\n  * vim<600: noet sw=4 ts=4\n- */\n\\ No newline at end of file\n+ */\n']",,,"['+     PHP_FE(radius_auth_open,    NULL)', '+     PHP_FE(radius_acct_open,    NULL)', '+     PHP_FE(radius_close,        NULL)', '+     PHP_FE(radius_strerror,     NULL)', '+     PHP_FE(radius_config,       NULL)', '+     PHP_FE(radius_add_server,\tNULL)', '+     PHP_FE(radius_create_request,\tNULL)', '+     PHP_FE(radius_put_string,\tNULL)', '+     PHP_FE(radius_put_int,\tNULL)', '+     PHP_FE(radius_put_attr,\tNULL)', '+     PHP_FE(radius_put_addr,\tNULL)', '+     PHP_FE(radius_put_vendor_string,\tNULL)', '+     PHP_FE(radius_put_vendor_int,\tNULL)', '+     PHP_FE(radius_put_vendor_attr,\tNULL)', '+     PHP_FE(radius_put_vendor_addr,\tNULL)', '+     PHP_FE(radius_send_request,\tNULL)', '+     PHP_FE(radius_get_attr,\tNULL)', '+     PHP_FE(radius_get_vendor_attr,\tNULL)', '+     PHP_FE(radius_cvt_addr,\tNULL)', '+     PHP_FE(radius_cvt_int,\tNULL)', '+     PHP_FE(radius_cvt_string,\tNULL)', '+     PHP_FE(radius_request_authenticator,\tNULL)', '+     PHP_FE(radius_server_secret,\tNULL)', '+     STANDARD_MODULE_HEADER,', '+     ""radius"",', '+     radius_functions,', '+     PHP_MINIT(radius),', '+     PHP_MSHUTDOWN(radius),', '+     PHP_MINFO(radius),', '+     STANDARD_MODULE_PROPERTIES', '+     le_radius = zend_register_list_destructors_ex(_radius_close, NULL, ""rad_handle"", module_number);', '+     return SUCCESS;', '+     return SUCCESS;', '+     return SUCCESS;', '+     return SUCCESS;', '+     php_info_print_table_start();', '+     php_info_print_table_header(2, ""radius support"", ""enabled"");', '+     php_info_print_table_end();', '+     radius_descriptor *raddesc;', '+     raddesc = emalloc(sizeof(radius_descriptor));', '+     raddesc->radh = rad_auth_open();', '+     raddesc->request_created = 0;', '+     if (raddesc->radh != NULL) {', '+         ZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);', '+         raddesc->id = Z_LVAL_P(return_value);', '+     } else {', '+         RETURN_FALSE;', '+     }', '+     radius_descriptor *raddesc;', '+     raddesc = emalloc(sizeof(radius_descriptor));', '+     raddesc->radh = rad_acct_open();', '+     raddesc->request_created = 0;', '+     if (raddesc->radh != NULL) {', '+         ZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);', '+         raddesc->id = Z_LVAL_P(return_value);', '+     } else {', '+         RETURN_FALSE;', '+     }', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     zend_list_delete(raddesc->id);', '+     RETURN_TRUE;', '+     char *msg;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     msg = (char *)rad_strerror(raddesc->radh);', '+     RETURN_STRINGL(msg, strlen(msg), 1);', '+     char *filename;', '+     int filename_len;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &z_radh, &filename, &filename_len) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_config(raddesc->radh, filename) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     char *hostname, *secret;', '+     int hostname_len, secret_len, port, timeout, maxtries;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rslsll"", &z_radh,', '+                               &hostname, &hostname_len,', '+                               &port,', '+                               &secret, &secret_len,', '+                               &timeout, &maxtries) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int code;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &z_radh, &code) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_create_request(raddesc->radh, code) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         raddesc->request_created = 1;', '+         RETURN_TRUE;', '+     }', '+     char *str;', '+     int str_len, type;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &str, &str_len)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_string(raddesc->radh, type, str) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type;', '+     unsigned int val;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rll"", &z_radh, &type, &val)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_int(raddesc->radh, type, val) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, len;', '+     char *data;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &data, &len)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_attr(raddesc->radh, type, data, len) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, addrlen;', '+     char\t*addr;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     struct in_addr intern_addr;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &addr, &addrlen)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (inet_aton(addr, &intern_addr) == 0) {', '+         strcpy(raddesc->errmsg, ""Error converting Address"");', '+         RETURN_FALSE;', '+     }', '+     if (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     char *str;', '+     int str_len, type, vendor;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type, &str, &str_len)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, vendor;', '+     unsigned int val;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlll"", &z_radh, &vendor, &type, &val)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, len, vendor;', '+     char *data;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type,', '+                               &data, &len) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, addrlen, vendor;', '+     char\t*addr;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     struct in_addr intern_addr;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor,', '+                               &type, &addr, &addrlen) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (inet_aton(addr, &intern_addr) == 0) {', '+         strcpy(raddesc->errmsg, ""Error converting Address"");', '+         RETURN_FALSE;', '+     }', '+     if (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     int res;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     res = rad_send_request(raddesc->radh);', '+     if (res == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_LONG(res);', '+     }', '+     radius_descriptor *raddesc;', '+     int res;', '+     const void *data;', '+     size_t len;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     res = rad_get_attr(raddesc->radh, &data, &len);', '+     if (res == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         if (res > 0) {', '+             if(array_init(return_value) != SUCCESS) {', '+                 zend_error(E_WARNING, ""Could not initialize array"");', '+                 RETURN_FALSE;', '+             }', '+             add_assoc_long(return_value, ""attr"", res);', '+             add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '+             return;', '+         }', '+         RETURN_LONG(res);', '+     }', '+     int res, vendor;', '+     const void *data;', '+     size_t len;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {', '+         return;', '+     }', '+     res = rad_get_vendor_attr(&vendor, &data, &len);', '+     if (res == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         if(array_init(return_value) != SUCCESS) {', '+             zend_error(E_WARNING, ""Could not initialize array"");', '+             RETURN_FALSE;', '+         }', '+         add_assoc_long(return_value, ""attr"", res);', '+         add_assoc_long(return_value, ""vendor"", vendor);', '+         add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '+         return;', '+     }', '+     const void *data;', '+     char *addr_dot;', '+     int len;', '+     struct in_addr addr;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {', '+         return;', '+     }', '+     addr = rad_cvt_addr(data);', '+     addr_dot = inet_ntoa(addr);', '+     RETURN_STRINGL(addr_dot, strlen(addr_dot), 1);', '+     const void *data;', '+     int len, val;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)', '+             == FAILURE) {', '+         return;', '+     }', '+     val = rad_cvt_int(data);', '+     RETURN_LONG(val);', '+     const void *data;', '+     char *val;', '+     int len;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)', '+             == FAILURE) {', '+         return;', '+     }', '+     val = rad_cvt_string(data, len);', '+     if (val == NULL) RETURN_FALSE;', '+     RETVAL_STRINGL(val, strlen(val), 1);', '+     free(val);', '+     return;', '+     radius_descriptor *raddesc;', '+     ssize_t res;', '+     char buf[LEN_AUTH];', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     res = rad_request_authenticator(raddesc->radh, buf, sizeof buf);', '+     if (res == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_STRINGL(buf, res, 1);', '+     }', '+     char *secret;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     secret = (char *)rad_server_secret(raddesc->radh);', '+     RETURN_STRINGL(secret, strlen(secret), 1);', '+     radius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;', '+     rad_close(raddesc->radh);', '+     efree(raddesc);', '- \tPHP_FE(radius_auth_open,\tNULL)', '- \tPHP_FE(radius_acct_open,\tNULL)', '- \tPHP_FE(radius_close,\tNULL)', '- \tPHP_FE(radius_strerror,\tNULL)', '- \tPHP_FE(radius_config,\tNULL)', '- \tPHP_FE(radius_add_server,\tNULL)', '- \tPHP_FE(radius_create_request,\tNULL)', '- \tPHP_FE(radius_put_string,\tNULL)', '- \tPHP_FE(radius_put_int,\tNULL)', '- \tPHP_FE(radius_put_attr,\tNULL)', '- \tPHP_FE(radius_put_addr,\tNULL)', '- \tPHP_FE(radius_put_vendor_string,\tNULL)', '- \tPHP_FE(radius_put_vendor_int,\tNULL)', '- \tPHP_FE(radius_put_vendor_attr,\tNULL)', '- \tPHP_FE(radius_put_vendor_addr,\tNULL)', '- \tPHP_FE(radius_send_request,\tNULL)', '- \tPHP_FE(radius_get_attr,\tNULL)', '- \tPHP_FE(radius_get_vendor_attr,\tNULL)', '- \tPHP_FE(radius_cvt_addr,\tNULL)', '- \tPHP_FE(radius_cvt_int,\tNULL)', '- \tPHP_FE(radius_cvt_string,\tNULL)', '- \tPHP_FE(radius_request_authenticator,\tNULL)', '- \tPHP_FE(radius_server_secret,\tNULL)', '- \tSTANDARD_MODULE_HEADER,', '- \t""radius"",', '- \tradius_functions,', '- \tPHP_MINIT(radius),', '- \tPHP_MSHUTDOWN(radius),', '- \tPHP_MINFO(radius),', '- \tSTANDARD_MODULE_PROPERTIES', '-  \tle_radius = zend_register_list_destructors_ex(_radius_close, NULL, ""rad_handle"", module_number);', '- \treturn SUCCESS;', '- \treturn SUCCESS;', '- \treturn SUCCESS;', '- \treturn SUCCESS;', '- \tphp_info_print_table_start();', '- \tphp_info_print_table_header(2, ""radius support"", ""enabled"");', '- \tphp_info_print_table_end();', '- \tradius_descriptor *raddesc;', '- \traddesc = emalloc(sizeof(radius_descriptor));', '- \traddesc->radh = rad_auth_open();', '- \traddesc->request_created = 0;', '- \tif (raddesc->radh != NULL) {', '- \t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);', '- \t\traddesc->id = Z_LVAL_P(return_value);', '- \t} else {', '- \t\tRETURN_FALSE;', '- \t}', '- \tradius_descriptor *raddesc;', '- \traddesc = emalloc(sizeof(radius_descriptor));', '- \traddesc->radh = rad_acct_open();', '- \traddesc->request_created = 0;', '- \tif (raddesc->radh != NULL) {', '- \t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);', '- \t\traddesc->id = Z_LVAL_P(return_value);', '- \t} else {', '- \t\tRETURN_FALSE;', '- \t}', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '-  \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '-   \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tzend_list_delete(raddesc->id);', '- \tRETURN_TRUE;', '- \tchar *msg;', '- \tradius_descriptor *raddesc;', '-  \tzval *z_radh;', '-  \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '-   \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tmsg = (char *)rad_strerror(raddesc->radh);', '- \tRETURN_STRINGL(msg, strlen(msg), 1);', '- \tchar *filename;', '- \tint filename_len;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &z_radh, &filename, &filename_len) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_config(raddesc->radh, filename) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tchar *hostname, *secret;', '- \tint hostname_len, secret_len, port, timeout, maxtries;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rslsll"", &z_radh,', '- \t\t&hostname, &hostname_len,', '- \t\t&port,', '- \t\t&secret, &secret_len,', '- \t\t&timeout, &maxtries) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint code;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &z_radh, &code) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_create_request(raddesc->radh, code) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\traddesc->request_created = 1;', '- \t\tRETURN_TRUE;', '- \t}', '- \tchar *str;', '- \tint str_len, type;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &str, &str_len)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_string(raddesc->radh, type, str) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type;', '- \tunsigned int val;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rll"", &z_radh, &type, &val)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_int(raddesc->radh, type, val) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type, len;', '- \tchar *data;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &data, &len)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_attr(raddesc->radh, type, data, len) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type, addrlen;', '- \tchar\t*addr;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tstruct in_addr intern_addr;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &addr, &addrlen)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (inet_aton(addr, &intern_addr) == 0) {', '- \t\tstrcpy(raddesc->errmsg, ""Error converting Address"");', '- \t\tRETURN_FALSE;', '- \t}', '- \tif (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tchar *str;', '- \tint str_len, type, vendor;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type, &str, &str_len)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type, vendor;', '- \tunsigned int val;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlll"", &z_radh, &vendor, &type, &val)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type, len, vendor;', '- \tchar *data;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type,', '-   \t\t&data, &len) == FAILURE) {', '- \t\treturn;', '- \t}', '-   ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '-   if (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {', '- \t\tRETURN_FALSE;', '-   } else {', '- \t\tRETURN_TRUE;', '-   }', '- \tint type, addrlen, vendor;', '- \tchar\t*addr;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tstruct in_addr intern_addr;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor,', '-   \t\t&type, &addr, &addrlen) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (inet_aton(addr, &intern_addr) == 0) {', '- \t\tstrcpy(raddesc->errmsg, ""Error converting Address"");', '- \t\tRETURN_FALSE;', '- \t}', '- \tif (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tint res;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tres = rad_send_request(raddesc->radh);', '- \tif (res == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_LONG(res);', '- \t}', '- \tradius_descriptor *raddesc;', '- \tint res;', '- \tconst void *data;', '- \tsize_t len;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tres = rad_get_attr(raddesc->radh, &data, &len);', '- \tif (res == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tif (res > 0) {', '- \t\t\tif(array_init(return_value) != SUCCESS) {', '- \t\t\t\tzend_error(E_WARNING, ""Could not initialize array"");', '- \t\t\t\tRETURN_FALSE;', '- \t\t\t}', '- \t\t\tadd_assoc_long(return_value, ""attr"", res);', '- \t\t\tadd_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '- \t\t\treturn;', '- \t\t}', '- \t\tRETURN_LONG(res);', '- \t}', '- \tint res, vendor;', '- \tconst void *data;', '- \tsize_t len;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tres = rad_get_vendor_attr(&vendor, &data, &len);', '- \tif (res == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tif(array_init(return_value) != SUCCESS) {', '- \t\t\tzend_error(E_WARNING, ""Could not initialize array"");', '- \t\t\tRETURN_FALSE;', '- \t\t}', '- \t\tadd_assoc_long(return_value, ""attr"", res);', '- \t\tadd_assoc_long(return_value, ""vendor"", vendor);', '- \t\tadd_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '- \t\treturn;', '- \t}', '-   const void *data;', '-   char *addr_dot;', '-   int len;', '-   struct in_addr addr;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {', '- \t\treturn;', '- \t}', '- \taddr = rad_cvt_addr(data);', '- \taddr_dot = inet_ntoa(addr);', '- \tRETURN_STRINGL(addr_dot, strlen(addr_dot), 1);', '- \tconst void *data;', '- \tint len, val;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)', '- \t\t== FAILURE) {', '-   \t\treturn;', '- \t}', '- \tval = rad_cvt_int(data);', '- \tRETURN_LONG(val);', '- \tconst void *data;', '- \tchar *val;', '- \tint len;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tval = rad_cvt_string(data, len);', '- \tif (val == NULL) RETURN_FALSE;', '- \tRETVAL_STRINGL(val, strlen(val), 1);', '- \tfree(val);', '- \treturn;', '- \tradius_descriptor *raddesc;', '- \tssize_t res;', '- \tchar buf[LEN_AUTH];', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tres = rad_request_authenticator(raddesc->radh, buf, sizeof buf);', '- \tif (res == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_STRINGL(buf, res, 1);', '- \t}', '- \tchar *secret;', '- \tradius_descriptor *raddesc;', '-  \tzval *z_radh;', '-  \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '-   \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tsecret = (char *)rad_server_secret(raddesc->radh);', '- \tRETURN_STRINGL(secret, strlen(secret), 1);', '- \tradius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;', '- \trad_close(raddesc->radh);', '- \tefree(raddesc);']","['+     php_fe(radius_auth_open,    null)', '+     php_fe(radius_acct_open,    null)', '+     php_fe(radius_close,        null)', '+     php_fe(radius_strerror,     null)', '+     php_fe(radius_config,       null)', '+     php_fe(radius_add_server,\tnull)', '+     php_fe(radius_create_request,\tnull)', '+     php_fe(radius_put_string,\tnull)', '+     php_fe(radius_put_int,\tnull)', '+     php_fe(radius_put_attr,\tnull)', '+     php_fe(radius_put_addr,\tnull)', '+     php_fe(radius_put_vendor_string,\tnull)', '+     php_fe(radius_put_vendor_int,\tnull)', '+     php_fe(radius_put_vendor_attr,\tnull)', '+     php_fe(radius_put_vendor_addr,\tnull)', '+     php_fe(radius_send_request,\tnull)', '+     php_fe(radius_get_attr,\tnull)', '+     php_fe(radius_get_vendor_attr,\tnull)', '+     php_fe(radius_cvt_addr,\tnull)', '+     php_fe(radius_cvt_int,\tnull)', '+     php_fe(radius_cvt_string,\tnull)', '+     php_fe(radius_request_authenticator,\tnull)', '+     php_fe(radius_server_secret,\tnull)', '+     standard_module_header,', '+     ""radius"",', '+     radius_functions,', '+     php_minit(radius),', '+     php_mshutdown(radius),', '+     php_minfo(radius),', '+     standard_module_properties', '+     le_radius = zend_register_list_destructors_ex(_radius_close, null, ""rad_handle"", module_number);', '+     return success;', '+     return success;', '+     return success;', '+     return success;', '+     php_info_print_table_start();', '+     php_info_print_table_header(2, ""radius support"", ""enabled"");', '+     php_info_print_table_end();', '+     radius_descriptor *raddesc;', '+     raddesc = emalloc(sizeof(radius_descriptor));', '+     raddesc->radh = rad_auth_open();', '+     raddesc->request_created = 0;', '+     if (raddesc->radh != null) {', '+         zend_register_resource(return_value, raddesc, le_radius);', '+         raddesc->id = z_lval_p(return_value);', '+     } else {', '+         return_false;', '+     }', '+     radius_descriptor *raddesc;', '+     raddesc = emalloc(sizeof(radius_descriptor));', '+     raddesc->radh = rad_acct_open();', '+     raddesc->request_created = 0;', '+     if (raddesc->radh != null) {', '+         zend_register_resource(return_value, raddesc, le_radius);', '+         raddesc->id = z_lval_p(return_value);', '+     } else {', '+         return_false;', '+     }', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     zend_list_delete(raddesc->id);', '+     return_true;', '+     char *msg;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     msg = (char *)rad_strerror(raddesc->radh);', '+     return_stringl(msg, strlen(msg), 1);', '+     char *filename;', '+     int filename_len;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rs"", &z_radh, &filename, &filename_len) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_config(raddesc->radh, filename) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     char *hostname, *secret;', '+     int hostname_len, secret_len, port, timeout, maxtries;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rslsll"", &z_radh,', '+                               &hostname, &hostname_len,', '+                               &port,', '+                               &secret, &secret_len,', '+                               &timeout, &maxtries) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     int code;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rl"", &z_radh, &code) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_create_request(raddesc->radh, code) == -1) {', '+         return_false;', '+     } else {', '+         raddesc->request_created = 1;', '+         return_true;', '+     }', '+     char *str;', '+     int str_len, type;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rls"", &z_radh, &type, &str, &str_len)', '+             == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_string(raddesc->radh, type, str) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     int type;', '+     unsigned int val;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rll"", &z_radh, &type, &val)', '+             == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_int(raddesc->radh, type, val) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     int type, len;', '+     char *data;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rls"", &z_radh, &type, &data, &len)', '+             == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_attr(raddesc->radh, type, data, len) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     int type, addrlen;', '+     char\t*addr;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     struct in_addr intern_addr;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rls"", &z_radh, &type, &addr, &addrlen)', '+             == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (inet_aton(addr, &intern_addr) == 0) {', '+         strcpy(raddesc->errmsg, ""error converting address"");', '+         return_false;', '+     }', '+     if (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     char *str;', '+     int str_len, type, vendor;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rlls"", &z_radh, &vendor, &type, &str, &str_len)', '+             == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     int type, vendor;', '+     unsigned int val;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rlll"", &z_radh, &vendor, &type, &val)', '+             == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     int type, len, vendor;', '+     char *data;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rlls"", &z_radh, &vendor, &type,', '+                               &data, &len) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     int type, addrlen, vendor;', '+     char\t*addr;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     struct in_addr intern_addr;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rlls"", &z_radh, &vendor,', '+                               &type, &addr, &addrlen) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (inet_aton(addr, &intern_addr) == 0) {', '+         strcpy(raddesc->errmsg, ""error converting address"");', '+         return_false;', '+     }', '+     if (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {', '+         return_false;', '+     } else {', '+         return_true;', '+     }', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     int res;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh)', '+             == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     res = rad_send_request(raddesc->radh);', '+     if (res == -1) {', '+         return_false;', '+     } else {', '+         return_long(res);', '+     }', '+     radius_descriptor *raddesc;', '+     int res;', '+     const void *data;', '+     size_t len;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     res = rad_get_attr(raddesc->radh, &data, &len);', '+     if (res == -1) {', '+         return_false;', '+     } else {', '+         if (res > 0) {', '+             if(array_init(return_value) != success) {', '+                 zend_error(e_warning, ""could not initialize array"");', '+                 return_false;', '+             }', '+             add_assoc_long(return_value, ""attr"", res);', '+             add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '+             return;', '+         }', '+         return_long(res);', '+     }', '+     int res, vendor;', '+     const void *data;', '+     size_t len;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""s"", &data, &len) == failure) {', '+         return;', '+     }', '+     res = rad_get_vendor_attr(&vendor, &data, &len);', '+     if (res == -1) {', '+         return_false;', '+     } else {', '+         if(array_init(return_value) != success) {', '+             zend_error(e_warning, ""could not initialize array"");', '+             return_false;', '+         }', '+         add_assoc_long(return_value, ""attr"", res);', '+         add_assoc_long(return_value, ""vendor"", vendor);', '+         add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '+         return;', '+     }', '+     const void *data;', '+     char *addr_dot;', '+     int len;', '+     struct in_addr addr;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""s"", &data, &len) == failure) {', '+         return;', '+     }', '+     addr = rad_cvt_addr(data);', '+     addr_dot = inet_ntoa(addr);', '+     return_stringl(addr_dot, strlen(addr_dot), 1);', '+     const void *data;', '+     int len, val;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""s"", &data, &len)', '+             == failure) {', '+         return;', '+     }', '+     val = rad_cvt_int(data);', '+     return_long(val);', '+     const void *data;', '+     char *val;', '+     int len;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""s"", &data, &len)', '+             == failure) {', '+         return;', '+     }', '+     val = rad_cvt_string(data, len);', '+     if (val == null) return_false;', '+     retval_stringl(val, strlen(val), 1);', '+     free(val);', '+     return;', '+     radius_descriptor *raddesc;', '+     ssize_t res;', '+     char buf[len_auth];', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     res = rad_request_authenticator(raddesc->radh, buf, sizeof buf);', '+     if (res == -1) {', '+         return_false;', '+     } else {', '+         return_stringl(buf, res, 1);', '+     }', '+     char *secret;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '+         return;', '+     }', '+     zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     secret = (char *)rad_server_secret(raddesc->radh);', '+     return_stringl(secret, strlen(secret), 1);', '+     radius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;', '+     rad_close(raddesc->radh);', '+     efree(raddesc);', '- \tphp_fe(radius_auth_open,\tnull)', '- \tphp_fe(radius_acct_open,\tnull)', '- \tphp_fe(radius_close,\tnull)', '- \tphp_fe(radius_strerror,\tnull)', '- \tphp_fe(radius_config,\tnull)', '- \tphp_fe(radius_add_server,\tnull)', '- \tphp_fe(radius_create_request,\tnull)', '- \tphp_fe(radius_put_string,\tnull)', '- \tphp_fe(radius_put_int,\tnull)', '- \tphp_fe(radius_put_attr,\tnull)', '- \tphp_fe(radius_put_addr,\tnull)', '- \tphp_fe(radius_put_vendor_string,\tnull)', '- \tphp_fe(radius_put_vendor_int,\tnull)', '- \tphp_fe(radius_put_vendor_attr,\tnull)', '- \tphp_fe(radius_put_vendor_addr,\tnull)', '- \tphp_fe(radius_send_request,\tnull)', '- \tphp_fe(radius_get_attr,\tnull)', '- \tphp_fe(radius_get_vendor_attr,\tnull)', '- \tphp_fe(radius_cvt_addr,\tnull)', '- \tphp_fe(radius_cvt_int,\tnull)', '- \tphp_fe(radius_cvt_string,\tnull)', '- \tphp_fe(radius_request_authenticator,\tnull)', '- \tphp_fe(radius_server_secret,\tnull)', '- \tstandard_module_header,', '- \t""radius"",', '- \tradius_functions,', '- \tphp_minit(radius),', '- \tphp_mshutdown(radius),', '- \tphp_minfo(radius),', '- \tstandard_module_properties', '-  \tle_radius = zend_register_list_destructors_ex(_radius_close, null, ""rad_handle"", module_number);', '- \treturn success;', '- \treturn success;', '- \treturn success;', '- \treturn success;', '- \tphp_info_print_table_start();', '- \tphp_info_print_table_header(2, ""radius support"", ""enabled"");', '- \tphp_info_print_table_end();', '- \tradius_descriptor *raddesc;', '- \traddesc = emalloc(sizeof(radius_descriptor));', '- \traddesc->radh = rad_auth_open();', '- \traddesc->request_created = 0;', '- \tif (raddesc->radh != null) {', '- \t\tzend_register_resource(return_value, raddesc, le_radius);', '- \t\traddesc->id = z_lval_p(return_value);', '- \t} else {', '- \t\treturn_false;', '- \t}', '- \tradius_descriptor *raddesc;', '- \traddesc = emalloc(sizeof(radius_descriptor));', '- \traddesc->radh = rad_acct_open();', '- \traddesc->request_created = 0;', '- \tif (raddesc->radh != null) {', '- \t\tzend_register_resource(return_value, raddesc, le_radius);', '- \t\traddesc->id = z_lval_p(return_value);', '- \t} else {', '- \t\treturn_false;', '- \t}', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '-  \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '-   \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tzend_list_delete(raddesc->id);', '- \treturn_true;', '- \tchar *msg;', '- \tradius_descriptor *raddesc;', '-  \tzval *z_radh;', '-  \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '-   \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tmsg = (char *)rad_strerror(raddesc->radh);', '- \treturn_stringl(msg, strlen(msg), 1);', '- \tchar *filename;', '- \tint filename_len;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rs"", &z_radh, &filename, &filename_len) == failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_config(raddesc->radh, filename) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_true;', '- \t}', '- \tchar *hostname, *secret;', '- \tint hostname_len, secret_len, port, timeout, maxtries;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rslsll"", &z_radh,', '- \t\t&hostname, &hostname_len,', '- \t\t&port,', '- \t\t&secret, &secret_len,', '- \t\t&timeout, &maxtries) == failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_true;', '- \t}', '- \tint code;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rl"", &z_radh, &code) == failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_create_request(raddesc->radh, code) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\traddesc->request_created = 1;', '- \t\treturn_true;', '- \t}', '- \tchar *str;', '- \tint str_len, type;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rls"", &z_radh, &type, &str, &str_len)', '- \t\t== failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_string(raddesc->radh, type, str) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_true;', '- \t}', '- \tint type;', '- \tunsigned int val;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rll"", &z_radh, &type, &val)', '- \t\t== failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_int(raddesc->radh, type, val) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_true;', '- \t}', '- \tint type, len;', '- \tchar *data;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rls"", &z_radh, &type, &data, &len)', '- \t\t== failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_attr(raddesc->radh, type, data, len) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_true;', '- \t}', '- \tint type, addrlen;', '- \tchar\t*addr;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tstruct in_addr intern_addr;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rls"", &z_radh, &type, &addr, &addrlen)', '- \t\t== failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (inet_aton(addr, &intern_addr) == 0) {', '- \t\tstrcpy(raddesc->errmsg, ""error converting address"");', '- \t\treturn_false;', '- \t}', '- \tif (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_true;', '- \t}', '- \tchar *str;', '- \tint str_len, type, vendor;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rlls"", &z_radh, &vendor, &type, &str, &str_len)', '- \t\t== failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_true;', '- \t}', '- \tint type, vendor;', '- \tunsigned int val;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rlll"", &z_radh, &vendor, &type, &val)', '- \t\t== failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_true;', '- \t}', '- \tint type, len, vendor;', '- \tchar *data;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rlls"", &z_radh, &vendor, &type,', '-   \t\t&data, &len) == failure) {', '- \t\treturn;', '- \t}', '-   zend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '-   if (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {', '- \t\treturn_false;', '-   } else {', '- \t\treturn_true;', '-   }', '- \tint type, addrlen, vendor;', '- \tchar\t*addr;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tstruct in_addr intern_addr;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""rlls"", &z_radh, &vendor,', '-   \t\t&type, &addr, &addrlen) == failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (inet_aton(addr, &intern_addr) == 0) {', '- \t\tstrcpy(raddesc->errmsg, ""error converting address"");', '- \t\treturn_false;', '- \t}', '- \tif (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_true;', '- \t}', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tint res;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh)', '- \t\t== failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tres = rad_send_request(raddesc->radh);', '- \tif (res == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_long(res);', '- \t}', '- \tradius_descriptor *raddesc;', '- \tint res;', '- \tconst void *data;', '- \tsize_t len;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tres = rad_get_attr(raddesc->radh, &data, &len);', '- \tif (res == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\tif (res > 0) {', '- \t\t\tif(array_init(return_value) != success) {', '- \t\t\t\tzend_error(e_warning, ""could not initialize array"");', '- \t\t\t\treturn_false;', '- \t\t\t}', '- \t\t\tadd_assoc_long(return_value, ""attr"", res);', '- \t\t\tadd_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '- \t\t\treturn;', '- \t\t}', '- \t\treturn_long(res);', '- \t}', '- \tint res, vendor;', '- \tconst void *data;', '- \tsize_t len;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""s"", &data, &len) == failure) {', '- \t\treturn;', '- \t}', '- \tres = rad_get_vendor_attr(&vendor, &data, &len);', '- \tif (res == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\tif(array_init(return_value) != success) {', '- \t\t\tzend_error(e_warning, ""could not initialize array"");', '- \t\t\treturn_false;', '- \t\t}', '- \t\tadd_assoc_long(return_value, ""attr"", res);', '- \t\tadd_assoc_long(return_value, ""vendor"", vendor);', '- \t\tadd_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '- \t\treturn;', '- \t}', '-   const void *data;', '-   char *addr_dot;', '-   int len;', '-   struct in_addr addr;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""s"", &data, &len) == failure) {', '- \t\treturn;', '- \t}', '- \taddr = rad_cvt_addr(data);', '- \taddr_dot = inet_ntoa(addr);', '- \treturn_stringl(addr_dot, strlen(addr_dot), 1);', '- \tconst void *data;', '- \tint len, val;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""s"", &data, &len)', '- \t\t== failure) {', '-   \t\treturn;', '- \t}', '- \tval = rad_cvt_int(data);', '- \treturn_long(val);', '- \tconst void *data;', '- \tchar *val;', '- \tint len;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""s"", &data, &len)', '- \t\t== failure) {', '- \t\treturn;', '- \t}', '- \tval = rad_cvt_string(data, len);', '- \tif (val == null) return_false;', '- \tretval_stringl(val, strlen(val), 1);', '- \tfree(val);', '- \treturn;', '- \tradius_descriptor *raddesc;', '- \tssize_t res;', '- \tchar buf[len_auth];', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '- \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tres = rad_request_authenticator(raddesc->radh, buf, sizeof buf);', '- \tif (res == -1) {', '- \t\treturn_false;', '- \t} else {', '- \t\treturn_stringl(buf, res, 1);', '- \t}', '- \tchar *secret;', '- \tradius_descriptor *raddesc;', '-  \tzval *z_radh;', '-  \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""r"", &z_radh) == failure) {', '-   \t\treturn;', '- \t}', '- \tzend_fetch_resource(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tsecret = (char *)rad_server_secret(raddesc->radh);', '- \treturn_stringl(secret, strlen(secret), 1);', '- \tradius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;', '- \trad_close(raddesc->radh);', '- \tefree(raddesc);']","['+     PHP_FE(radius_auth_open,    NULL)', '+     PHP_FE(radius_acct_open,    NULL)', '+     PHP_FE(radius_close,        NULL)', '+     PHP_FE(radius_strerror,     NULL)', '+     PHP_FE(radius_config,       NULL)', '+     PHP_FE(radius_add_server,\tNULL)', '+     PHP_FE(radius_create_request,\tNULL)', '+     PHP_FE(radius_put_string,\tNULL)', '+     PHP_FE(radius_put_int,\tNULL)', '+     PHP_FE(radius_put_attr,\tNULL)', '+     PHP_FE(radius_put_addr,\tNULL)', '+     PHP_FE(radius_put_vendor_string,\tNULL)', '+     PHP_FE(radius_put_vendor_int,\tNULL)', '+     PHP_FE(radius_put_vendor_attr,\tNULL)', '+     PHP_FE(radius_put_vendor_addr,\tNULL)', '+     PHP_FE(radius_send_request,\tNULL)', '+     PHP_FE(radius_get_attr,\tNULL)', '+     PHP_FE(radius_get_vendor_attr,\tNULL)', '+     PHP_FE(radius_cvt_addr,\tNULL)', '+     PHP_FE(radius_cvt_int,\tNULL)', '+     PHP_FE(radius_cvt_string,\tNULL)', '+     PHP_FE(radius_request_authenticator,\tNULL)', '+     PHP_FE(radius_server_secret,\tNULL)', '+     STANDARD_MODULE_HEADER,', '+     ""radius"",', '+     radius_functions,', '+     PHP_MINIT(radius),', '+     PHP_MSHUTDOWN(radius),', '+     PHP_MINFO(radius),', '+     STANDARD_MODULE_PROPERTIES', '+     le_radius = zend_register_list_destructors_ex(_radius_close, NULL, ""rad_handle"", module_number);', '+     return SUCCESS;', '+     return SUCCESS;', '+     return SUCCESS;', '+     return SUCCESS;', '+     php_info_print_table_start();', '+     php_info_print_table_header(2, ""radius support"", ""enabled"");', '+     php_info_print_table_end();', '+     radius_descriptor *raddesc;', '+     raddesc = emalloc(sizeof(radius_descriptor));', '+     raddesc->radh = rad_auth_open();', '+     raddesc->request_created = 0;', '+     if (raddesc->radh != NULL) {', '+         ZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);', '+         raddesc->id = Z_LVAL_P(return_value);', '+     } else {', '+         RETURN_FALSE;', '+     }', '+     radius_descriptor *raddesc;', '+     raddesc = emalloc(sizeof(radius_descriptor));', '+     raddesc->radh = rad_acct_open();', '+     raddesc->request_created = 0;', '+     if (raddesc->radh != NULL) {', '+         ZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);', '+         raddesc->id = Z_LVAL_P(return_value);', '+     } else {', '+         RETURN_FALSE;', '+     }', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     zend_list_delete(raddesc->id);', '+     RETURN_TRUE;', '+     char *msg;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     msg = (char *)rad_strerror(raddesc->radh);', '+     RETURN_STRINGL(msg, strlen(msg), 1);', '+     char *filename;', '+     int filename_len;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &z_radh, &filename, &filename_len) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_config(raddesc->radh, filename) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     char *hostname, *secret;', '+     int hostname_len, secret_len, port, timeout, maxtries;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rslsll"", &z_radh,', '+                               &hostname, &hostname_len,', '+                               &port,', '+                               &secret, &secret_len,', '+                               &timeout, &maxtries) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int code;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &z_radh, &code) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_create_request(raddesc->radh, code) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         raddesc->request_created = 1;', '+         RETURN_TRUE;', '+     }', '+     char *str;', '+     int str_len, type;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &str, &str_len)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_string(raddesc->radh, type, str) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type;', '+     unsigned int val;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rll"", &z_radh, &type, &val)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_int(raddesc->radh, type, val) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, len;', '+     char *data;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &data, &len)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_attr(raddesc->radh, type, data, len) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, addrlen;', '+     char\t*addr;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     struct in_addr intern_addr;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &addr, &addrlen)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (inet_aton(addr, &intern_addr) == 0) {', '+         strcpy(raddesc->errmsg, ""Error converting Address"");', '+         RETURN_FALSE;', '+     }', '+     if (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     char *str;', '+     int str_len, type, vendor;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type, &str, &str_len)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, vendor;', '+     unsigned int val;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlll"", &z_radh, &vendor, &type, &val)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, len, vendor;', '+     char *data;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type,', '+                               &data, &len) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     int type, addrlen, vendor;', '+     char\t*addr;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     struct in_addr intern_addr;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor,', '+                               &type, &addr, &addrlen) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     if (inet_aton(addr, &intern_addr) == 0) {', '+         strcpy(raddesc->errmsg, ""Error converting Address"");', '+         RETURN_FALSE;', '+     }', '+     if (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_TRUE;', '+     }', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     int res;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh)', '+             == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     res = rad_send_request(raddesc->radh);', '+     if (res == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_LONG(res);', '+     }', '+     radius_descriptor *raddesc;', '+     int res;', '+     const void *data;', '+     size_t len;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     res = rad_get_attr(raddesc->radh, &data, &len);', '+     if (res == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         if (res > 0) {', '+             if(array_init(return_value) != SUCCESS) {', '+                 zend_error(E_WARNING, ""Could not initialize array"");', '+                 RETURN_FALSE;', '+             }', '+             add_assoc_long(return_value, ""attr"", res);', '+             add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '+             return;', '+         }', '+         RETURN_LONG(res);', '+     }', '+     int res, vendor;', '+     const void *data;', '+     size_t len;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {', '+         return;', '+     }', '+     res = rad_get_vendor_attr(&vendor, &data, &len);', '+     if (res == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         if(array_init(return_value) != SUCCESS) {', '+             zend_error(E_WARNING, ""Could not initialize array"");', '+             RETURN_FALSE;', '+         }', '+         add_assoc_long(return_value, ""attr"", res);', '+         add_assoc_long(return_value, ""vendor"", vendor);', '+         add_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '+         return;', '+     }', '+     const void *data;', '+     char *addr_dot;', '+     int len;', '+     struct in_addr addr;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {', '+         return;', '+     }', '+     addr = rad_cvt_addr(data);', '+     addr_dot = inet_ntoa(addr);', '+     RETURN_STRINGL(addr_dot, strlen(addr_dot), 1);', '+     const void *data;', '+     int len, val;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)', '+             == FAILURE) {', '+         return;', '+     }', '+     val = rad_cvt_int(data);', '+     RETURN_LONG(val);', '+     const void *data;', '+     char *val;', '+     int len;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)', '+             == FAILURE) {', '+         return;', '+     }', '+     val = rad_cvt_string(data, len);', '+     if (val == NULL) RETURN_FALSE;', '+     RETVAL_STRINGL(val, strlen(val), 1);', '+     free(val);', '+     return;', '+     radius_descriptor *raddesc;', '+     ssize_t res;', '+     char buf[LEN_AUTH];', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     res = rad_request_authenticator(raddesc->radh, buf, sizeof buf);', '+     if (res == -1) {', '+         RETURN_FALSE;', '+     } else {', '+         RETURN_STRINGL(buf, res, 1);', '+     }', '+     char *secret;', '+     radius_descriptor *raddesc;', '+     zval *z_radh;', '+     if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '+         return;', '+     }', '+     ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '+     secret = (char *)rad_server_secret(raddesc->radh);', '+     RETURN_STRINGL(secret, strlen(secret), 1);', '+     radius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;', '+     rad_close(raddesc->radh);', '+     efree(raddesc);']","['- \tPHP_FE(radius_auth_open,\tNULL)', '- \tPHP_FE(radius_acct_open,\tNULL)', '- \tPHP_FE(radius_close,\tNULL)', '- \tPHP_FE(radius_strerror,\tNULL)', '- \tPHP_FE(radius_config,\tNULL)', '- \tPHP_FE(radius_add_server,\tNULL)', '- \tPHP_FE(radius_create_request,\tNULL)', '- \tPHP_FE(radius_put_string,\tNULL)', '- \tPHP_FE(radius_put_int,\tNULL)', '- \tPHP_FE(radius_put_attr,\tNULL)', '- \tPHP_FE(radius_put_addr,\tNULL)', '- \tPHP_FE(radius_put_vendor_string,\tNULL)', '- \tPHP_FE(radius_put_vendor_int,\tNULL)', '- \tPHP_FE(radius_put_vendor_attr,\tNULL)', '- \tPHP_FE(radius_put_vendor_addr,\tNULL)', '- \tPHP_FE(radius_send_request,\tNULL)', '- \tPHP_FE(radius_get_attr,\tNULL)', '- \tPHP_FE(radius_get_vendor_attr,\tNULL)', '- \tPHP_FE(radius_cvt_addr,\tNULL)', '- \tPHP_FE(radius_cvt_int,\tNULL)', '- \tPHP_FE(radius_cvt_string,\tNULL)', '- \tPHP_FE(radius_request_authenticator,\tNULL)', '- \tPHP_FE(radius_server_secret,\tNULL)', '- \tSTANDARD_MODULE_HEADER,', '- \t""radius"",', '- \tradius_functions,', '- \tPHP_MINIT(radius),', '- \tPHP_MSHUTDOWN(radius),', '- \tPHP_MINFO(radius),', '- \tSTANDARD_MODULE_PROPERTIES', '-  \tle_radius = zend_register_list_destructors_ex(_radius_close, NULL, ""rad_handle"", module_number);', '- \treturn SUCCESS;', '- \treturn SUCCESS;', '- \treturn SUCCESS;', '- \treturn SUCCESS;', '- \tphp_info_print_table_start();', '- \tphp_info_print_table_header(2, ""radius support"", ""enabled"");', '- \tphp_info_print_table_end();', '- \tradius_descriptor *raddesc;', '- \traddesc = emalloc(sizeof(radius_descriptor));', '- \traddesc->radh = rad_auth_open();', '- \traddesc->request_created = 0;', '- \tif (raddesc->radh != NULL) {', '- \t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);', '- \t\traddesc->id = Z_LVAL_P(return_value);', '- \t} else {', '- \t\tRETURN_FALSE;', '- \t}', '- \tradius_descriptor *raddesc;', '- \traddesc = emalloc(sizeof(radius_descriptor));', '- \traddesc->radh = rad_acct_open();', '- \traddesc->request_created = 0;', '- \tif (raddesc->radh != NULL) {', '- \t\tZEND_REGISTER_RESOURCE(return_value, raddesc, le_radius);', '- \t\traddesc->id = Z_LVAL_P(return_value);', '- \t} else {', '- \t\tRETURN_FALSE;', '- \t}', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '-  \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '-   \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tzend_list_delete(raddesc->id);', '- \tRETURN_TRUE;', '- \tchar *msg;', '- \tradius_descriptor *raddesc;', '-  \tzval *z_radh;', '-  \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '-   \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tmsg = (char *)rad_strerror(raddesc->radh);', '- \tRETURN_STRINGL(msg, strlen(msg), 1);', '- \tchar *filename;', '- \tint filename_len;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs"", &z_radh, &filename, &filename_len) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_config(raddesc->radh, filename) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tchar *hostname, *secret;', '- \tint hostname_len, secret_len, port, timeout, maxtries;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rslsll"", &z_radh,', '- \t\t&hostname, &hostname_len,', '- \t\t&port,', '- \t\t&secret, &secret_len,', '- \t\t&timeout, &maxtries) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_add_server(raddesc->radh, hostname, port, secret, timeout, maxtries) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint code;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rl"", &z_radh, &code) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_create_request(raddesc->radh, code) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\traddesc->request_created = 1;', '- \t\tRETURN_TRUE;', '- \t}', '- \tchar *str;', '- \tint str_len, type;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &str, &str_len)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_string(raddesc->radh, type, str) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type;', '- \tunsigned int val;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rll"", &z_radh, &type, &val)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_int(raddesc->radh, type, val) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type, len;', '- \tchar *data;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &data, &len)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_attr(raddesc->radh, type, data, len) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type, addrlen;', '- \tchar\t*addr;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tstruct in_addr intern_addr;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rls"", &z_radh, &type, &addr, &addrlen)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (inet_aton(addr, &intern_addr) == 0) {', '- \t\tstrcpy(raddesc->errmsg, ""Error converting Address"");', '- \t\tRETURN_FALSE;', '- \t}', '- \tif (rad_put_addr(raddesc->radh, type, intern_addr) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tchar *str;', '- \tint str_len, type, vendor;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type, &str, &str_len)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_vendor_string(raddesc->radh, vendor, type, str) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type, vendor;', '- \tunsigned int val;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlll"", &z_radh, &vendor, &type, &val)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (rad_put_vendor_int(raddesc->radh, vendor, type, val) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tint type, len, vendor;', '- \tchar *data;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor, &type,', '-   \t\t&data, &len) == FAILURE) {', '- \t\treturn;', '- \t}', '-   ZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '-   if (rad_put_vendor_attr(raddesc->radh, vendor, type, data, len) == -1) {', '- \t\tRETURN_FALSE;', '-   } else {', '- \t\tRETURN_TRUE;', '-   }', '- \tint type, addrlen, vendor;', '- \tchar\t*addr;', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tstruct in_addr intern_addr;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rlls"", &z_radh, &vendor,', '-   \t\t&type, &addr, &addrlen) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tif (inet_aton(addr, &intern_addr) == 0) {', '- \t\tstrcpy(raddesc->errmsg, ""Error converting Address"");', '- \t\tRETURN_FALSE;', '- \t}', '- \tif (rad_put_vendor_addr(raddesc->radh, vendor, type, intern_addr) == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_TRUE;', '- \t}', '- \tradius_descriptor *raddesc;', '- \tzval *z_radh;', '- \tint res;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tres = rad_send_request(raddesc->radh);', '- \tif (res == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_LONG(res);', '- \t}', '- \tradius_descriptor *raddesc;', '- \tint res;', '- \tconst void *data;', '- \tsize_t len;', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tres = rad_get_attr(raddesc->radh, &data, &len);', '- \tif (res == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tif (res > 0) {', '- \t\t\tif(array_init(return_value) != SUCCESS) {', '- \t\t\t\tzend_error(E_WARNING, ""Could not initialize array"");', '- \t\t\t\tRETURN_FALSE;', '- \t\t\t}', '- \t\t\tadd_assoc_long(return_value, ""attr"", res);', '- \t\t\tadd_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '- \t\t\treturn;', '- \t\t}', '- \t\tRETURN_LONG(res);', '- \t}', '- \tint res, vendor;', '- \tconst void *data;', '- \tsize_t len;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tres = rad_get_vendor_attr(&vendor, &data, &len);', '- \tif (res == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tif(array_init(return_value) != SUCCESS) {', '- \t\t\tzend_error(E_WARNING, ""Could not initialize array"");', '- \t\t\tRETURN_FALSE;', '- \t\t}', '- \t\tadd_assoc_long(return_value, ""attr"", res);', '- \t\tadd_assoc_long(return_value, ""vendor"", vendor);', '- \t\tadd_assoc_stringl(return_value, ""data"", (char *) data, len, 1);', '- \t\treturn;', '- \t}', '-   const void *data;', '-   char *addr_dot;', '-   int len;', '-   struct in_addr addr;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len) == FAILURE) {', '- \t\treturn;', '- \t}', '- \taddr = rad_cvt_addr(data);', '- \taddr_dot = inet_ntoa(addr);', '- \tRETURN_STRINGL(addr_dot, strlen(addr_dot), 1);', '- \tconst void *data;', '- \tint len, val;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)', '- \t\t== FAILURE) {', '-   \t\treturn;', '- \t}', '- \tval = rad_cvt_int(data);', '- \tRETURN_LONG(val);', '- \tconst void *data;', '- \tchar *val;', '- \tint len;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &data, &len)', '- \t\t== FAILURE) {', '- \t\treturn;', '- \t}', '- \tval = rad_cvt_string(data, len);', '- \tif (val == NULL) RETURN_FALSE;', '- \tRETVAL_STRINGL(val, strlen(val), 1);', '- \tfree(val);', '- \treturn;', '- \tradius_descriptor *raddesc;', '- \tssize_t res;', '- \tchar buf[LEN_AUTH];', '- \tzval *z_radh;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '- \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tres = rad_request_authenticator(raddesc->radh, buf, sizeof buf);', '- \tif (res == -1) {', '- \t\tRETURN_FALSE;', '- \t} else {', '- \t\tRETURN_STRINGL(buf, res, 1);', '- \t}', '- \tchar *secret;', '- \tradius_descriptor *raddesc;', '-  \tzval *z_radh;', '-  \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""r"", &z_radh) == FAILURE) {', '-   \t\treturn;', '- \t}', '- \tZEND_FETCH_RESOURCE(raddesc, radius_descriptor *, &z_radh, -1, ""rad_handle"", le_radius);', '- \tsecret = (char *)rad_server_secret(raddesc->radh);', '- \tRETURN_STRINGL(secret, strlen(secret), 1);', '- \tradius_descriptor *raddesc = (radius_descriptor *)rsrc->ptr;', '- \trad_close(raddesc->radh);', '- \tefree(raddesc);']",353,353.0,706.0,f8974ca74f2342f574a877dd66fff91104a09997LawnGnome/php-radius,[]
ffd440f541000c365ce74bce4cef14e617283b51,quassel/quassel,main_mono.cpp,val,C++,0,"['@@ -36,10 +36,10 @@ int main(int argc, char **argv) {\n   Logger *logger = new Logger();\n   Quassel::setLogger(logger);\n \n-  Message *m = new Message(""admin"");\n+  //Message *m = new Message(""admin"");\n   //m->*(m->getCmdHandler())(QStringList(""""));\n-  (m->*(m->getCmdHandler()))(QStringList());\n-  exit(0);\n+  //(m->*(m->getCmdHandler()))(QStringList());\n+  //exit(0);\n   \n   QApplication app(argc, argv);\n \n']",,,"['-   Message *m = new Message(""admin"");', '-   (m->*(m->getCmdHandler()))(QStringList());', '-   exit(0);']","['-   message *m = new message(""admin"");', '-   (m->*(m->getcmdhandler()))(qstringlist());', '-   exit(0);']",[],"['-   Message *m = new Message(""admin"");', '-   (m->*(m->getCmdHandler()))(QStringList());', '-   exit(0);']",0,3.0,3.0,ffd440f541000c365ce74bce4cef14e617283b51quassel/quassel,[]
4e97fdb86d0a0141ec9a052c6e691fcd07bb45c8,phusion/passenger,src/agent/ExecHelper/ExecHelperMain.cpp,train,C++,1,"['@@ -201,6 +201,9 @@ switchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n \t\t\tif (ngroups <= NGROUPS_MAX) {\n \t\t\t\tsetgroupsCalled = true;\n \t\t\t\tgidset.reset(new gid_t[ngroups]);\n+\t\t\t\tfor (int i = 0; i < ngroups; i++) {\n+\t\t\t\t\tgidset[i] = groups[i];\n+\t\t\t\t}\n \t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n \t\t\t\t\tint e = errno;\n \t\t\t\t\tfprintf(stderr, ""ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n"",\n']",2018-05-29 15:33:50+02:00,ExecHelperMain: fix privilege lowering code,"[['+ \t\t\t\tfor (int i = 0; i < ngroups; i++) {', '+ \t\t\t\t\tgidset[i] = groups[i];', '+ \t\t\t\t}']]","[['+ \t\t\t\tfor (int i = 0; i < ngroups; i++) {', '+ \t\t\t\t\tgidset[i] = groups[i];', '+ \t\t\t\t}']]","[['+ \t\t\t\tfor (int i = 0; i < ngroups; i++) {', '+ \t\t\t\t\tgidset[i] = groups[i];', '+ \t\t\t\t}']]",[[]],3,0.0,3.0,4e97fdb86d0a0141ec9a052c6e691fcd07bb45c8phusion/passenger,['4e97fdb86d0a0141ec9a052c6e691fcd07bb45c8']
1b265ffa8c28e2cd72419dce4e6536a8c01aa8ec,mumble-voip/mumble,src/mumble/Database.cpp,train,C++,1,"['@@ -43,7 +43,7 @@ Database::Database() {\n \tdatapaths << QDir::currentPath();\n \tbool found = false;\n \n-\tfor(i = 0; (i < datapaths.size()) && ! found; i++) {\n+\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n \t\tif (!datapaths[i].isEmpty()) {\n \t\t\tQFile f(datapaths[i] + QLatin1String(""/mumble.sqlite""));\n \t\t\tif (f.exists()) {\n@@ -60,7 +60,7 @@ Database::Database() {\n \t}\n \n \tif (! found) {\n-\t\tfor(i = 0; (i < datapaths.size()) && ! found; i++) {\n+\t\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {\n \t\t\tif (!datapaths[i].isEmpty()) {\n \t\t\t\tQFile f(datapaths[i] + QLatin1String(""/.mumble.sqlite""));\n \t\t\t\tdb.setDatabaseName(f.fileName());\n@@ -84,23 +84,23 @@ Database::Database() {\n }\n \n const QString Database::getDigest(const QString &hostname, unsigned short port) {\n-    QSqlQuery query;\n-\n-    query.prepare(""SELECT digest FROM cert WHERE hostname = ? AND port = ?"");\n-    query.addBindValue(hostname);;\n-    query.addBindValue(port);\n-    query.exec();\n-    if (query.next()) {\n-\treturn query.value(0).toString();\n-    }\n-    return QString();\n+\tQSqlQuery query;\n+\n+\tquery.prepare(""SELECT digest FROM cert WHERE hostname = ? AND port = ?"");\n+\tquery.addBindValue(hostname);;\n+\tquery.addBindValue(port);\n+\tquery.exec();\n+\tif (query.next()) {\n+\t\treturn query.value(0).toString();\n+\t}\n+\treturn QString();\n }\n \n void Database::setDigest(const QString &hostname, unsigned short port, const QString &digest) {\n-    QSqlQuery query;\n-    query.prepare(""REPLACE INTO cert (hostname,port,digest) VALUES (?,?,?)"");\n-    query.addBindValue(hostname);\n-    query.addBindValue(port);\n-    query.addBindValue(digest);\n-    query.exec();\n+\tQSqlQuery query;\n+\tquery.prepare(""REPLACE INTO cert (hostname,port,digest) VALUES (?,?,?)"");\n+\tquery.addBindValue(hostname);\n+\tquery.addBindValue(port);\n+\tquery.addBindValue(digest);\n+\tquery.exec();\n }\n']",2007-07-17 23:12:38+00:00,"reindenting all the code

git-svn-id: https://mumble.svn.sourceforge.net/svnroot/mumble/trunk@622 05730e5d-ab1b-0410-a4ac-84af385074fa","[['+ \tfor (i = 0; (i < datapaths.size()) && ! found; i++) {', '+ \t\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {', '+ \tQSqlQuery query;', '+ ', '+ \tquery.prepare(""SELECT digest FROM cert WHERE hostname = ? AND port = ?"");', '+ \tquery.addBindValue(hostname);;', '+ \tquery.addBindValue(port);', '+ \tquery.exec();', '+ \tif (query.next()) {', '+ \t\treturn query.value(0).toString();', '+ \t}', '+ \treturn QString();', '+ \tQSqlQuery query;', '+ \tquery.prepare(""REPLACE INTO cert (hostname,port,digest) VALUES (?,?,?)"");', '+ \tquery.addBindValue(hostname);', '+ \tquery.addBindValue(port);', '+ \tquery.addBindValue(digest);', '+ \tquery.exec();', '- \tfor(i = 0; (i < datapaths.size()) && ! found; i++) {', '- \t\tfor(i = 0; (i < datapaths.size()) && ! found; i++) {', '-     QSqlQuery query;', '- ', '-     query.prepare(""SELECT digest FROM cert WHERE hostname = ? AND port = ?"");', '-     query.addBindValue(hostname);;', '-     query.addBindValue(port);', '-     query.exec();', '-     if (query.next()) {', '- \treturn query.value(0).toString();', '-     }', '-     return QString();', '-     QSqlQuery query;', '-     query.prepare(""REPLACE INTO cert (hostname,port,digest) VALUES (?,?,?)"");', '-     query.addBindValue(hostname);', '-     query.addBindValue(port);', '-     query.addBindValue(digest);', '-     query.exec();']]","[['+ \tfor (i = 0; (i < datapaths.size()) && ! found; i++) {', '+ \t\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {', '+ \tqsqlquery query;', '+ ', '+ \tquery.prepare(""select digest from cert where hostname = ? and port = ?"");', '+ \tquery.addbindvalue(hostname);;', '+ \tquery.addbindvalue(port);', '+ \tquery.exec();', '+ \tif (query.next()) {', '+ \t\treturn query.value(0).tostring();', '+ \t}', '+ \treturn qstring();', '+ \tqsqlquery query;', '+ \tquery.prepare(""replace into cert (hostname,port,digest) values (?,?,?)"");', '+ \tquery.addbindvalue(hostname);', '+ \tquery.addbindvalue(port);', '+ \tquery.addbindvalue(digest);', '+ \tquery.exec();', '- \tfor(i = 0; (i < datapaths.size()) && ! found; i++) {', '- \t\tfor(i = 0; (i < datapaths.size()) && ! found; i++) {', '-     qsqlquery query;', '- ', '-     query.prepare(""select digest from cert where hostname = ? and port = ?"");', '-     query.addbindvalue(hostname);;', '-     query.addbindvalue(port);', '-     query.exec();', '-     if (query.next()) {', '- \treturn query.value(0).tostring();', '-     }', '-     return qstring();', '-     qsqlquery query;', '-     query.prepare(""replace into cert (hostname,port,digest) values (?,?,?)"");', '-     query.addbindvalue(hostname);', '-     query.addbindvalue(port);', '-     query.addbindvalue(digest);', '-     query.exec();']]","[['+ \tfor (i = 0; (i < datapaths.size()) && ! found; i++) {', '+ \t\tfor (i = 0; (i < datapaths.size()) && ! found; i++) {', '+ \tQSqlQuery query;', '+ ', '+ \tquery.prepare(""SELECT digest FROM cert WHERE hostname = ? AND port = ?"");', '+ \tquery.addBindValue(hostname);;', '+ \tquery.addBindValue(port);', '+ \tquery.exec();', '+ \tif (query.next()) {', '+ \t\treturn query.value(0).toString();', '+ \t}', '+ \treturn QString();', '+ \tQSqlQuery query;', '+ \tquery.prepare(""REPLACE INTO cert (hostname,port,digest) VALUES (?,?,?)"");', '+ \tquery.addBindValue(hostname);', '+ \tquery.addBindValue(port);', '+ \tquery.addBindValue(digest);', '+ \tquery.exec();']]","[['- \tfor(i = 0; (i < datapaths.size()) && ! found; i++) {', '- \t\tfor(i = 0; (i < datapaths.size()) && ! found; i++) {', '-     QSqlQuery query;', '- ', '-     query.prepare(""SELECT digest FROM cert WHERE hostname = ? AND port = ?"");', '-     query.addBindValue(hostname);;', '-     query.addBindValue(port);', '-     query.exec();', '-     if (query.next()) {', '- \treturn query.value(0).toString();', '-     }', '-     return QString();', '-     QSqlQuery query;', '-     query.prepare(""REPLACE INTO cert (hostname,port,digest) VALUES (?,?,?)"");', '-     query.addBindValue(hostname);', '-     query.addBindValue(port);', '-     query.addBindValue(digest);', '-     query.exec();']]",18,18.0,36.0,1b265ffa8c28e2cd72419dce4e6536a8c01aa8ecmumble-voip/mumble,['5632c35d6759f5e13a7dfe78e4ee6403ff6a8e3e']
e9faf6971ce03082cf82bdfaea1fa06741753379,ivmai/bdwgc,mark.c,train,C,0,"['@@ -113,6 +113,9 @@ GC_bool GC_mark_stack_too_small = FALSE;\n GC_bool GC_objects_are_marked = FALSE;\t/* Are there collectable marked\t*/\n \t\t\t\t\t/* objects in the heap?\t\t*/\n \n+/* Is a collection in progress?  Note that this can return true in the\t*/\n+/* nonincremental case, if a collection has been abandoned and the\t*/\n+/* mark state is now MS_INVALID.\t\t\t\t\t*/\n GC_bool GC_collection_in_progress()\n {\n     return(GC_mark_state != MS_NONE);\n@@ -304,9 +307,12 @@ GC_bool GC_mark_some()\n     \t        GC_mark_from_mark_stack();\n     \t        return(FALSE);\n     \t    }\n-    \t    if (scan_ptr == 0\n-    \t        && (GC_mark_state == MS_INVALID || GC_mark_stack_too_small)) {\n-    \t        alloc_mark_stack(2*GC_mark_stack_size);\n+    \t    if (scan_ptr == 0 && GC_mark_state == MS_INVALID) {\n+\t\t/* About to start a heap scan for marked objects. */\n+\t\t/* Mark stack is empty.  OK to reallocate.\t  */\n+\t\tif (GC_mark_stack_too_small) {\n+    \t            alloc_mark_stack(2*GC_mark_stack_size);\n+\t\t}\n \t\tGC_mark_state = MS_PARTIALLY_INVALID;\n     \t    }\n     \t    scan_ptr = GC_push_next_marked(scan_ptr);\n@@ -393,6 +399,7 @@ mse * GC_signal_mark_stack_overflow(msp)\n mse * msp;\n {\n     GC_mark_state = MS_INVALID;\n+    GC_mark_stack_too_small = TRUE;\n #   ifdef PRINTSTATS\n \tGC_printf1(""Mark stack overflow; current size = %lu entries\\n"",\n \t    \t    GC_mark_stack_size);\n@@ -657,7 +664,7 @@ int all;\n # endif\n word p;\n {\n-    GC_PUSH_ONE_STACK(p);\n+    GC_PUSH_ONE_STACK(p, 0);\n }\n \n # ifdef __STDC__\n@@ -696,13 +703,18 @@ register GC_bool interior_ptrs;\n         displ = HBLKDISPL(p);\n         map_entry = MAP_ENTRY((hhdr -> hb_map), displ);\n         if (map_entry == OBJ_INVALID) {\n-          if (interior_ptrs) {\n-            r = BASE(p);\n-\t    displ = BYTES_TO_WORDS(HBLKDISPL(r));\n-\t    if (r == 0) hhdr = 0;\n-          } else {\n-            hhdr = 0;\n-          }\n+#\t  ifndef ALL_INTERIOR_POINTERS\n+            if (interior_ptrs) {\n+              r = BASE(p);\n+\t      displ = BYTES_TO_WORDS(HBLKDISPL(r));\n+\t      if (r == 0) hhdr = 0;\n+            } else {\n+              hhdr = 0;\n+            }\n+#\t  else\n+\t    /* map already reflects interior pointers */\n+\t    hhdr = 0;\n+#\t  endif\n         } else {\n           displ = BYTES_TO_WORDS(displ);\n           displ -= map_entry;\n@@ -778,17 +790,13 @@ void GC_print_trace(word gc_no, GC_bool lock)\n \n /*\n  * A version of GC_push_all that treats all interior pointers as valid\n+ * and scans the entire region immediately, in case the contents\n+ * change.\n  */\n-void GC_push_all_stack(bottom, top)\n+void GC_push_all_eager(bottom, top)\n ptr_t bottom;\n ptr_t top;\n {\n-# ifdef ALL_INTERIOR_POINTERS\n-    GC_push_all(bottom, top);\n-#   ifdef TRACE_BUF\n-        GC_add_trace_entry(""GC_push_all_stack"", bottom, top);\n-#   endif\n-# else\n     word * b = (word *)(((long) bottom + ALIGNMENT-1) & ~(ALIGNMENT-1));\n     word * t = (word *)(((long) top) & ~(ALIGNMENT-1));\n     register word *p;\n@@ -805,10 +813,49 @@ ptr_t top;\n       lim = t - 1 /* longword */;\n       for (p = b; p <= lim; p = (word *)(((char *)p) + ALIGNMENT)) {\n \tq = *p;\n-\tGC_PUSH_ONE_STACK(q);\n+\tGC_PUSH_ONE_STACK(q, p);\n       }\n #   undef GC_greatest_plausible_heap_addr\n #   undef GC_least_plausible_heap_addr\n+}\n+\n+/*\n+ * A version of GC_push_all that treats all interior pointers as valid\n+ * and scans part of the area immediately, to make sure that saved\n+ * register values are not lost.\n+ */\n+void GC_push_all_stack(bottom, top)\n+ptr_t bottom;\n+ptr_t top;\n+{\n+# ifdef ALL_INTERIOR_POINTERS\n+#   define EAGER_BYTES 1024\n+    /* Push the hot end of the stack eagerly, so that register values   */\n+    /* saved inside GC frames are marked before they disappear.\t\t*/\n+    /* The rest of the marking can be deferred until later.\t\t*/\n+    ptr_t mid;\n+#   ifdef STACK_GROWS_DOWN\n+\tmid = bottom + 1024;\n+\tif (mid < top) {\n+\t    GC_push_all_eager(bottom, mid);\n+\t    GC_push_all(mid - sizeof(ptr_t), top);\n+\t} else {\n+\t    GC_push_all_eager(bottom, top);\n+\t}\n+#   else /* STACK_GROWS_UP */\n+\tmid = top - 1024;\n+\tif (mid > bottom) {\n+\t    GC_push_all_eager(mid, top);\n+\t    GC_push_all(bottom, mid + sizeof(ptr_t));\n+\t} else {\n+\t    GC_push_all_eager(bottom, top);\n+\t}\n+#   endif /* STACK_GROWS_UP */\n+# else\n+    GC_push_all_eager(bottom, top);\n+# endif\n+# ifdef TRACE_BUF\n+      GC_add_trace_entry(""GC_push_all_stack"", bottom, top);\n # endif\n }\n \n@@ -840,7 +887,7 @@ register hdr * hhdr;\n \t    while(mark_word != 0) {\n \t      if (mark_word & 1) {\n \t          q = p[i];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i);\n \t      }\n \t      i++;\n \t      mark_word >>= 1;\n@@ -881,9 +928,9 @@ register hdr * hhdr;\n \t    while(mark_word != 0) {\n \t      if (mark_word & 1) {\n \t          q = p[i];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i);\n \t          q = p[i+1];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i);\n \t      }\n \t      i += 2;\n \t      mark_word >>= 2;\n@@ -923,13 +970,13 @@ register hdr * hhdr;\n \t    while(mark_word != 0) {\n \t      if (mark_word & 1) {\n \t          q = p[i];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i);\n \t          q = p[i+1];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i + 1);\n \t          q = p[i+2];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i + 2);\n \t          q = p[i+3];\n-\t          GC_PUSH_ONE_HEAP(q);\n+\t          GC_PUSH_ONE_HEAP(q, p + i + 3);\n \t      }\n \t      i += 4;\n \t      mark_word >>= 4;\n']",,,"['+     \t    if (scan_ptr == 0 && GC_mark_state == MS_INVALID) {', '+ \t\tif (GC_mark_stack_too_small) {', '+     \t            alloc_mark_stack(2*GC_mark_stack_size);', '+ \t\t}', '+     GC_mark_stack_too_small = TRUE;', '+     GC_PUSH_ONE_STACK(p, 0);', '+ #\t  ifndef ALL_INTERIOR_POINTERS', '+             if (interior_ptrs) {', '+               r = BASE(p);', '+ \t      displ = BYTES_TO_WORDS(HBLKDISPL(r));', '+ \t      if (r == 0) hhdr = 0;', '+             } else {', '+               hhdr = 0;', '+             }', '+ #\t  else', '+ \t    hhdr = 0;', '+ #\t  endif', '+ void GC_push_all_eager(bottom, top)', '+ \tGC_PUSH_ONE_STACK(q, p);', '+ }', '+ void GC_push_all_stack(bottom, top)', '+ ptr_t bottom;', '+ ptr_t top;', '+ {', '+ # ifdef ALL_INTERIOR_POINTERS', '+ #   define EAGER_BYTES 1024', '+     ptr_t mid;', '+ #   ifdef STACK_GROWS_DOWN', '+ \tmid = bottom + 1024;', '+ \tif (mid < top) {', '+ \t    GC_push_all_eager(bottom, mid);', '+ \t    GC_push_all(mid - sizeof(ptr_t), top);', '+ \t} else {', '+ \t    GC_push_all_eager(bottom, top);', '+ \t}', '+ \tmid = top - 1024;', '+ \tif (mid > bottom) {', '+ \t    GC_push_all_eager(mid, top);', '+ \t    GC_push_all(bottom, mid + sizeof(ptr_t));', '+ \t} else {', '+ \t    GC_push_all_eager(bottom, top);', '+ \t}', '+ # else', '+     GC_push_all_eager(bottom, top);', '+ # endif', '+ # ifdef TRACE_BUF', '+       GC_add_trace_entry(""GC_push_all_stack"", bottom, top);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i + 1);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i + 2);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i + 3);', '-     \t    if (scan_ptr == 0', '-     \t        && (GC_mark_state == MS_INVALID || GC_mark_stack_too_small)) {', '-     \t        alloc_mark_stack(2*GC_mark_stack_size);', '-     GC_PUSH_ONE_STACK(p);', '-           if (interior_ptrs) {', '-             r = BASE(p);', '- \t    displ = BYTES_TO_WORDS(HBLKDISPL(r));', '- \t    if (r == 0) hhdr = 0;', '-           } else {', '-             hhdr = 0;', '-           }', '- void GC_push_all_stack(bottom, top)', '- # ifdef ALL_INTERIOR_POINTERS', '-     GC_push_all(bottom, top);', '- #   ifdef TRACE_BUF', '-         GC_add_trace_entry(""GC_push_all_stack"", bottom, top);', '- #   endif', '- # else', '- \tGC_PUSH_ONE_STACK(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);']","['+     \t    if (scan_ptr == 0 && gc_mark_state == ms_invalid) {', '+ \t\tif (gc_mark_stack_too_small) {', '+     \t            alloc_mark_stack(2*gc_mark_stack_size);', '+ \t\t}', '+     gc_mark_stack_too_small = true;', '+     gc_push_one_stack(p, 0);', '+ #\t  ifndef all_interior_pointers', '+             if (interior_ptrs) {', '+               r = base(p);', '+ \t      displ = bytes_to_words(hblkdispl(r));', '+ \t      if (r == 0) hhdr = 0;', '+             } else {', '+               hhdr = 0;', '+             }', '+ #\t  else', '+ \t    hhdr = 0;', '+ #\t  endif', '+ void gc_push_all_eager(bottom, top)', '+ \tgc_push_one_stack(q, p);', '+ }', '+ void gc_push_all_stack(bottom, top)', '+ ptr_t bottom;', '+ ptr_t top;', '+ {', '+ # ifdef all_interior_pointers', '+ #   define eager_bytes 1024', '+     ptr_t mid;', '+ #   ifdef stack_grows_down', '+ \tmid = bottom + 1024;', '+ \tif (mid < top) {', '+ \t    gc_push_all_eager(bottom, mid);', '+ \t    gc_push_all(mid - sizeof(ptr_t), top);', '+ \t} else {', '+ \t    gc_push_all_eager(bottom, top);', '+ \t}', '+ \tmid = top - 1024;', '+ \tif (mid > bottom) {', '+ \t    gc_push_all_eager(mid, top);', '+ \t    gc_push_all(bottom, mid + sizeof(ptr_t));', '+ \t} else {', '+ \t    gc_push_all_eager(bottom, top);', '+ \t}', '+ # else', '+     gc_push_all_eager(bottom, top);', '+ # endif', '+ # ifdef trace_buf', '+       gc_add_trace_entry(""gc_push_all_stack"", bottom, top);', '+ \t          gc_push_one_heap(q, p + i);', '+ \t          gc_push_one_heap(q, p + i);', '+ \t          gc_push_one_heap(q, p + i);', '+ \t          gc_push_one_heap(q, p + i);', '+ \t          gc_push_one_heap(q, p + i + 1);', '+ \t          gc_push_one_heap(q, p + i + 2);', '+ \t          gc_push_one_heap(q, p + i + 3);', '-     \t    if (scan_ptr == 0', '-     \t        && (gc_mark_state == ms_invalid || gc_mark_stack_too_small)) {', '-     \t        alloc_mark_stack(2*gc_mark_stack_size);', '-     gc_push_one_stack(p);', '-           if (interior_ptrs) {', '-             r = base(p);', '- \t    displ = bytes_to_words(hblkdispl(r));', '- \t    if (r == 0) hhdr = 0;', '-           } else {', '-             hhdr = 0;', '-           }', '- void gc_push_all_stack(bottom, top)', '- # ifdef all_interior_pointers', '-     gc_push_all(bottom, top);', '- #   ifdef trace_buf', '-         gc_add_trace_entry(""gc_push_all_stack"", bottom, top);', '- #   endif', '- # else', '- \tgc_push_one_stack(q);', '- \t          gc_push_one_heap(q);', '- \t          gc_push_one_heap(q);', '- \t          gc_push_one_heap(q);', '- \t          gc_push_one_heap(q);', '- \t          gc_push_one_heap(q);', '- \t          gc_push_one_heap(q);', '- \t          gc_push_one_heap(q);']","['+     \t    if (scan_ptr == 0 && GC_mark_state == MS_INVALID) {', '+ \t\tif (GC_mark_stack_too_small) {', '+     \t            alloc_mark_stack(2*GC_mark_stack_size);', '+ \t\t}', '+     GC_mark_stack_too_small = TRUE;', '+     GC_PUSH_ONE_STACK(p, 0);', '+ #\t  ifndef ALL_INTERIOR_POINTERS', '+             if (interior_ptrs) {', '+               r = BASE(p);', '+ \t      displ = BYTES_TO_WORDS(HBLKDISPL(r));', '+ \t      if (r == 0) hhdr = 0;', '+             } else {', '+               hhdr = 0;', '+             }', '+ #\t  else', '+ \t    hhdr = 0;', '+ #\t  endif', '+ void GC_push_all_eager(bottom, top)', '+ \tGC_PUSH_ONE_STACK(q, p);', '+ }', '+ void GC_push_all_stack(bottom, top)', '+ ptr_t bottom;', '+ ptr_t top;', '+ {', '+ # ifdef ALL_INTERIOR_POINTERS', '+ #   define EAGER_BYTES 1024', '+     ptr_t mid;', '+ #   ifdef STACK_GROWS_DOWN', '+ \tmid = bottom + 1024;', '+ \tif (mid < top) {', '+ \t    GC_push_all_eager(bottom, mid);', '+ \t    GC_push_all(mid - sizeof(ptr_t), top);', '+ \t} else {', '+ \t    GC_push_all_eager(bottom, top);', '+ \t}', '+ \tmid = top - 1024;', '+ \tif (mid > bottom) {', '+ \t    GC_push_all_eager(mid, top);', '+ \t    GC_push_all(bottom, mid + sizeof(ptr_t));', '+ \t} else {', '+ \t    GC_push_all_eager(bottom, top);', '+ \t}', '+ # else', '+     GC_push_all_eager(bottom, top);', '+ # endif', '+ # ifdef TRACE_BUF', '+       GC_add_trace_entry(""GC_push_all_stack"", bottom, top);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i + 1);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i + 2);', '+ \t          GC_PUSH_ONE_HEAP(q, p + i + 3);']","['-     \t    if (scan_ptr == 0', '-     \t        && (GC_mark_state == MS_INVALID || GC_mark_stack_too_small)) {', '-     \t        alloc_mark_stack(2*GC_mark_stack_size);', '-     GC_PUSH_ONE_STACK(p);', '-           if (interior_ptrs) {', '-             r = BASE(p);', '- \t    displ = BYTES_TO_WORDS(HBLKDISPL(r));', '- \t    if (r == 0) hhdr = 0;', '-           } else {', '-             hhdr = 0;', '-           }', '- void GC_push_all_stack(bottom, top)', '- # ifdef ALL_INTERIOR_POINTERS', '-     GC_push_all(bottom, top);', '- #   ifdef TRACE_BUF', '-         GC_add_trace_entry(""GC_push_all_stack"", bottom, top);', '- #   endif', '- # else', '- \tGC_PUSH_ONE_STACK(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);', '- \t          GC_PUSH_ONE_HEAP(q);']",54,26.0,80.0,e9faf6971ce03082cf82bdfaea1fa06741753379ivmai/bdwgc,[]
b6f5873260732a5759f8d2653e2806dc1181a078,php/php-src,mod_php3.c,train,C,0,"['@@ -295,9 +295,6 @@ static void *php3_merge_dir(pool *p, void *basev, void *addv)\n \tif (add->sendmail_path != orig.sendmail_path) new->sendmail_path = add->sendmail_path;\n \tif (add->sendmail_from != orig.sendmail_from) new->sendmail_from = add->sendmail_from;\n \tif (add->errors != orig.errors) new->errors = add->errors;\n-\tif (add->magic_quotes_gpc != orig.magic_quotes_gpc) new->magic_quotes_gpc = add->magic_quotes_gpc;\n-\tif (add->magic_quotes_runtime != orig.magic_quotes_runtime) new->magic_quotes_runtime = add->magic_quotes_runtime;\n-\tif (add->magic_quotes_sybase != orig.magic_quotes_sybase) new->magic_quotes_sybase = add->magic_quotes_sybase;\n \tif (add->track_errors != orig.track_errors) new->track_errors = add->track_errors;\n \tif (add->display_errors != orig.display_errors) new->display_errors = add->display_errors;\n \tif (add->log_errors != orig.log_errors) new->log_errors = add->log_errors;\n@@ -316,8 +313,6 @@ static void *php3_merge_dir(pool *p, void *basev, void *addv)\n \tif (add->upload_max_filesize != orig.upload_max_filesize) new->upload_max_filesize = add->upload_max_filesize;\n \tif (add->extension_dir != orig.extension_dir) new->extension_dir = add->extension_dir;\n \tif (add->short_open_tag != orig.short_open_tag) new->short_open_tag = add->short_open_tag;\n-\tif (add->debugger_host != orig.debugger_host) new->debugger_host = add->debugger_host;\n-\tif (add->debugger_port != orig.debugger_port) new->debugger_port = add->debugger_port;\n \tif (add->error_log != orig.error_log) new->error_log = add->error_log;\n \t/* skip the highlight stuff */\n \tif (add->sql_safe_mode != orig.sql_safe_mode) new->sql_safe_mode = add->sql_safe_mode;\n@@ -352,12 +347,6 @@ char *php3flaghandler(cmd_parms * cmd, php3_ini_structure * conf, int val)\n \t\tcase 0:\n \t\t\tconf->track_errors = val;\n \t\t\tbreak;\n-\t\tcase 1:\n-\t\t\tconf->magic_quotes_gpc = val;\n-\t\t\tbreak;\n-\t\tcase 2:\n-\t\t\tconf->magic_quotes_runtime = val;\n-\t\t\tbreak;\n \t\tcase 3:\n \t\t\tconf->short_open_tag = val;\n \t\t\tbreak;\n@@ -385,9 +374,6 @@ char *php3flaghandler(cmd_parms * cmd, php3_ini_structure * conf, int val)\n \t\tcase 11:\n \t\t\tconf->display_errors = val;\n \t\t\tbreak;\n-\t\tcase 12:\n-\t\t\tconf->magic_quotes_sybase = val;\n-\t\t\tbreak;\n \t\tcase 13:\n \t\t\tconf->enable_dl = val;\n \t\t\tbreak;\n@@ -585,8 +571,6 @@ command_rec php3_commands[] =\n \t ""Lets PHP handle DAV requests by parsing this script.""},\n #endif\n \t{""php3_track_errors"", php3flaghandler, (void *)0, OR_OPTIONS, FLAG, ""on|off""},\n-\t{""php3_magic_quotes_gpc"", php3flaghandler, (void *)1, OR_OPTIONS, FLAG, ""on|off""},\n-\t{""php3_magic_quotes_runtime"", php3flaghandler, (void *)2, OR_OPTIONS, FLAG, ""on|off""},\n \t{""php3_short_open_tag"", php3flaghandler, (void *)3, OR_OPTIONS, FLAG, ""on|off""},\n \t{""php3_safe_mode"", php3flaghandler, (void *)4, ACCESS_CONF|RSRC_CONF, FLAG, ""on|off""},\n \t{""php3_track_vars"", php3flaghandler, (void *)5, OR_OPTIONS, FLAG, ""on|off""},\n@@ -596,7 +580,6 @@ command_rec php3_commands[] =\n \t{""php3_last_modified"", php3flaghandler, (void *)9, OR_OPTIONS, FLAG, ""on|off""},\n \t{""php3_log_errors"", php3flaghandler, (void *)10, OR_OPTIONS, FLAG, ""on|off""},\n \t{""php3_display_errors"", php3flaghandler, (void *)11, OR_OPTIONS, FLAG, ""on|off""},\n-\t{""php3_magic_quotes_sybase"", php3flaghandler, (void *)12, OR_OPTIONS, FLAG, ""on|off""},\n \t{""php3_enable_dl"", php3flaghandler, (void *)13, RSRC_CONF|ACCESS_CONF, FLAG, ""on|off""},\n \t{""php3_asp_tags"", php3flaghandler, (void *)14, OR_OPTIONS, FLAG, ""on|off""},\n \t{NULL}\n']",,,"['- \tif (add->magic_quotes_gpc != orig.magic_quotes_gpc) new->magic_quotes_gpc = add->magic_quotes_gpc;', '- \tif (add->magic_quotes_runtime != orig.magic_quotes_runtime) new->magic_quotes_runtime = add->magic_quotes_runtime;', '- \tif (add->magic_quotes_sybase != orig.magic_quotes_sybase) new->magic_quotes_sybase = add->magic_quotes_sybase;', '- \tif (add->debugger_host != orig.debugger_host) new->debugger_host = add->debugger_host;', '- \tif (add->debugger_port != orig.debugger_port) new->debugger_port = add->debugger_port;', '- \t\tcase 1:', '- \t\t\tconf->magic_quotes_gpc = val;', '- \t\t\tbreak;', '- \t\tcase 2:', '- \t\t\tconf->magic_quotes_runtime = val;', '- \t\t\tbreak;', '- \t\tcase 12:', '- \t\t\tconf->magic_quotes_sybase = val;', '- \t\t\tbreak;', '- \t{""php3_magic_quotes_gpc"", php3flaghandler, (void *)1, OR_OPTIONS, FLAG, ""on|off""},', '- \t{""php3_magic_quotes_runtime"", php3flaghandler, (void *)2, OR_OPTIONS, FLAG, ""on|off""},', '- \t{""php3_magic_quotes_sybase"", php3flaghandler, (void *)12, OR_OPTIONS, FLAG, ""on|off""},']","['- \tif (add->magic_quotes_gpc != orig.magic_quotes_gpc) new->magic_quotes_gpc = add->magic_quotes_gpc;', '- \tif (add->magic_quotes_runtime != orig.magic_quotes_runtime) new->magic_quotes_runtime = add->magic_quotes_runtime;', '- \tif (add->magic_quotes_sybase != orig.magic_quotes_sybase) new->magic_quotes_sybase = add->magic_quotes_sybase;', '- \tif (add->debugger_host != orig.debugger_host) new->debugger_host = add->debugger_host;', '- \tif (add->debugger_port != orig.debugger_port) new->debugger_port = add->debugger_port;', '- \t\tcase 1:', '- \t\t\tconf->magic_quotes_gpc = val;', '- \t\t\tbreak;', '- \t\tcase 2:', '- \t\t\tconf->magic_quotes_runtime = val;', '- \t\t\tbreak;', '- \t\tcase 12:', '- \t\t\tconf->magic_quotes_sybase = val;', '- \t\t\tbreak;', '- \t{""php3_magic_quotes_gpc"", php3flaghandler, (void *)1, or_options, flag, ""on|off""},', '- \t{""php3_magic_quotes_runtime"", php3flaghandler, (void *)2, or_options, flag, ""on|off""},', '- \t{""php3_magic_quotes_sybase"", php3flaghandler, (void *)12, or_options, flag, ""on|off""},']",[],"['- \tif (add->magic_quotes_gpc != orig.magic_quotes_gpc) new->magic_quotes_gpc = add->magic_quotes_gpc;', '- \tif (add->magic_quotes_runtime != orig.magic_quotes_runtime) new->magic_quotes_runtime = add->magic_quotes_runtime;', '- \tif (add->magic_quotes_sybase != orig.magic_quotes_sybase) new->magic_quotes_sybase = add->magic_quotes_sybase;', '- \tif (add->debugger_host != orig.debugger_host) new->debugger_host = add->debugger_host;', '- \tif (add->debugger_port != orig.debugger_port) new->debugger_port = add->debugger_port;', '- \t\tcase 1:', '- \t\t\tconf->magic_quotes_gpc = val;', '- \t\t\tbreak;', '- \t\tcase 2:', '- \t\t\tconf->magic_quotes_runtime = val;', '- \t\t\tbreak;', '- \t\tcase 12:', '- \t\t\tconf->magic_quotes_sybase = val;', '- \t\t\tbreak;', '- \t{""php3_magic_quotes_gpc"", php3flaghandler, (void *)1, OR_OPTIONS, FLAG, ""on|off""},', '- \t{""php3_magic_quotes_runtime"", php3flaghandler, (void *)2, OR_OPTIONS, FLAG, ""on|off""},', '- \t{""php3_magic_quotes_sybase"", php3flaghandler, (void *)12, OR_OPTIONS, FLAG, ""on|off""},']",0,17.0,17.0,b6f5873260732a5759f8d2653e2806dc1181a078php/php-src,[]
7ec8c806e260f047efa1b74211d83f7abe653676,LibRaw/LibRaw,simple_dcraw.cpp,train,C++,0,"['@@ -158,13 +158,6 @@ int main(int ac, char *av[])\n             if( LIBRAW_SUCCESS != (ret = RawProcessor.dcraw_ppm_tiff_writer(outfn)))\n                 fprintf(stderr,""Cannot write %s: %s\\n"",outfn,libraw_strerror(ret));\n \n-#ifndef WIN32            \n-            if(use_mmap && file_buffer)\n-                {\n-                    munmap(file_buffer,msize);\n-                    file_buffer=0;\n-                }\n-#endif\n             RawProcessor.recycle(); // just for show this call\n         }\n     return 0;\n']",,,"['- #ifndef WIN32', '-             if(use_mmap && file_buffer)', '-                 {', '-                     munmap(file_buffer,msize);', '-                     file_buffer=0;', '-                 }', '- #endif']","['- #ifndef win32', '-             if(use_mmap && file_buffer)', '-                 {', '-                     munmap(file_buffer,msize);', '-                     file_buffer=0;', '-                 }', '- #endif']",[],"['- #ifndef WIN32', '-             if(use_mmap && file_buffer)', '-                 {', '-                     munmap(file_buffer,msize);', '-                     file_buffer=0;', '-                 }', '- #endif']",0,7.0,7.0,7ec8c806e260f047efa1b74211d83f7abe653676LibRaw/LibRaw,[]
4bef229cdd2a1593836b7f180d61b7e529d4439e,libarchive/libarchive,util.c,train,C,0,"[""@@ -363,7 +363,7 @@ edit_pathname(struct bsdtar *bsdtar, struct archive_entry *entry)\n \t\treturn 1;\n \t}\n \tif (r == 1) {\n-\t\tarchive_entry_set_pathname(entry, subst_name);\n+\t\tarchive_entry_copy_pathname(entry, subst_name);\n \t\tfree(subst_name);\n \t\tif (*subst_name == '\\0')\n \t\t\treturn -1;\n@@ -377,7 +377,7 @@ edit_pathname(struct bsdtar *bsdtar, struct archive_entry *entry)\n \t\t\treturn 1;\n \t\t}\n \t\tif (r == 1) {\n-\t\t\tarchive_entry_set_hardlink(entry, subst_name);\n+\t\t\tarchive_entry_copy_hardlink(entry, subst_name);\n \t\t\tfree(subst_name);\n \t\t}\n \t}\n@@ -388,7 +388,7 @@ edit_pathname(struct bsdtar *bsdtar, struct archive_entry *entry)\n \t\t\treturn 1;\n \t\t}\n \t\tif (r == 1) {\n-\t\t\tarchive_entry_set_symlink(entry, subst_name);\n+\t\t\tarchive_entry_copy_symlink(entry, subst_name);\n \t\t\tfree(subst_name);\n \t\t}\n \t}\n""]",,,"['+ \t\tarchive_entry_copy_pathname(entry, subst_name);', '+ \t\t\tarchive_entry_copy_hardlink(entry, subst_name);', '+ \t\t\tarchive_entry_copy_symlink(entry, subst_name);', '- \t\tarchive_entry_set_pathname(entry, subst_name);', '- \t\t\tarchive_entry_set_hardlink(entry, subst_name);', '- \t\t\tarchive_entry_set_symlink(entry, subst_name);']","['+ \t\tarchive_entry_copy_pathname(entry, subst_name);', '+ \t\t\tarchive_entry_copy_hardlink(entry, subst_name);', '+ \t\t\tarchive_entry_copy_symlink(entry, subst_name);', '- \t\tarchive_entry_set_pathname(entry, subst_name);', '- \t\t\tarchive_entry_set_hardlink(entry, subst_name);', '- \t\t\tarchive_entry_set_symlink(entry, subst_name);']","['+ \t\tarchive_entry_copy_pathname(entry, subst_name);', '+ \t\t\tarchive_entry_copy_hardlink(entry, subst_name);', '+ \t\t\tarchive_entry_copy_symlink(entry, subst_name);']","['- \t\tarchive_entry_set_pathname(entry, subst_name);', '- \t\t\tarchive_entry_set_hardlink(entry, subst_name);', '- \t\t\tarchive_entry_set_symlink(entry, subst_name);']",3,3.0,6.0,4bef229cdd2a1593836b7f180d61b7e529d4439elibarchive/libarchive,[]
f7f4ba46573b1f7f4045ec0f20a60ff464ee6216,ivmai/bdwgc,os_dep.c,train,C,0,"['@@ -1551,7 +1551,7 @@ void GC_register_data_segments(void)\n \n # if !defined(OS2) && !defined(PCR) && !defined(AMIGA) \\\n \t&& !defined(MSWIN32) && !defined(MSWINCE) \\\n-\t&& !defined(MACOS) && !defined(DOS4GW)\n+\t&& !defined(MACOS) && !defined(DOS4GW) && !defined(NONSTOP)\n \n # define SBRK_ARG_T ptrdiff_t\n \n']",,,"['+ \t&& !defined(MACOS) && !defined(DOS4GW) && !defined(NONSTOP)', '- \t&& !defined(MACOS) && !defined(DOS4GW)']","['+ \t&& !defined(macos) && !defined(dos4gw) && !defined(nonstop)', '- \t&& !defined(macos) && !defined(dos4gw)']",['+ \t&& !defined(MACOS) && !defined(DOS4GW) && !defined(NONSTOP)'],['- \t&& !defined(MACOS) && !defined(DOS4GW)'],1,1.0,2.0,f7f4ba46573b1f7f4045ec0f20a60ff464ee6216ivmai/bdwgc,[]
f1351f9bbaae4fd923722f5563843f5d1c54a5f7,memcached/memcached,memcached.c,test,C,1,"['@@ -298,7 +298,7 @@ bool do_conn_add_to_freelist(conn *c) {\n     return true;\n }\n \n-static char *prot_text(enum protocol prot) {\n+static const char *prot_text(enum protocol prot) {\n     char *rv = ""unknown"";\n     switch(prot) {\n         case ascii_prot:\n@@ -383,12 +383,9 @@ conn *conn_new(const int sfd, enum conn_states init_state,\n                 prot_text(prot));\n         } else if (IS_UDP(prot)) {\n             fprintf(stderr, ""<%d server listening (udp)\\n"", sfd);\n-        } else if (prot == binary_prot) {\n-            fprintf(stderr, ""<%d new binary client connection\\n"", sfd);\n-        } else if (prot == ascii_prot) {\n-            fprintf(stderr, ""<%d new ascii client connection\\n"", sfd);\n         } else if (prot == negotiating_prot) {\n-            fprintf(stderr, ""<%d new auto-negotiating client connection\\n"", sfd);\n+            fprintf(stderr, ""<%d new auto-negotiating client connection\\n"",\n+                    sfd);\n         } else {\n             fprintf(stderr, ""<%d new unknown (%d) client connection\\n"",\n                 sfd, prot);\n@@ -517,31 +514,6 @@ static void conn_close(conn *c) {\n     return;\n }\n \n-static enum conn_states get_init_state(conn *c) {\n-    int rv = 0;\n-    assert(c != NULL);\n-\n-    switch(c->protocol) {\n-        case binary_prot:\n-            rv = conn_bin_init;\n-            break;\n-        case negotiating_prot:\n-            rv = conn_negotiate;\n-            break;\n-        default:\n-            rv = conn_read;\n-    }\n-    return rv;\n-}\n-\n-/* Set the given connection to its initial state.  The initial state will vary\n- * base don protocol type. */\n-static void conn_set_init_state(conn *c) {\n-    assert(c != NULL);\n-\n-    conn_set_state(c, get_init_state(c));\n-}\n-\n /*\n  * Shrinks a connection\'s buffers if they\'re too big.  This prevents\n  * periodic large ""get"" requests from permanently chewing lots of server\n@@ -600,6 +572,23 @@ static void conn_shrink(conn *c) {\n     }\n }\n \n+/**\n+ * Convert a state name to a human readable form.\n+ */\n+static const char *state_text(enum conn_states state) {\n+    const char* const statenames[] = { ""conn_listening"",\n+                                       ""conn_new_cmd"",\n+                                       ""conn_waiting"",\n+                                       ""conn_read"",\n+                                       ""conn_parse_cmd"",\n+                                       ""conn_write"",\n+                                       ""conn_nread"",\n+                                       ""conn_swallow"",\n+                                       ""conn_closing"",\n+                                       ""conn_mwrite"" };\n+    return statenames[state];\n+}\n+\n /*\n  * Sets a connection\'s current state in the state machine. Any special\n  * processing that needs to happen on certain state transitions can\n@@ -607,12 +596,15 @@ static void conn_shrink(conn *c) {\n  */\n static void conn_set_state(conn *c, enum conn_states state) {\n     assert(c != NULL);\n+    assert(state >= conn_listening && state < conn_max_state);\n \n     if (state != c->state) {\n-        if (state == conn_read) {\n-            conn_shrink(c);\n-            assoc_move_next_bucket();\n+        if (settings.verbose > 2) {\n+            fprintf(stderr, ""%d: going from %s to %s\\n"",\n+                    c->sfd, state_text(c->state),\n+                    state_text(state));\n         }\n+\n         c->state = state;\n     }\n }\n@@ -810,7 +802,7 @@ static void out_string(conn *c, const char *str) {\n         if (settings.verbose > 1)\n             fprintf(stderr, "">%d NOREPLY %s\\n"", c->sfd, str);\n         c->noreply = false;\n-        conn_set_state(c, conn_read);\n+        conn_set_state(c, conn_new_cmd);\n         return;\n     }\n \n@@ -830,7 +822,7 @@ static void out_string(conn *c, const char *str) {\n     c->wcurr = c->wbuf;\n \n     conn_set_state(c, conn_write);\n-    c->write_and_go = get_init_state(c);\n+    c->write_and_go = conn_new_cmd;\n     return;\n }\n \n@@ -908,8 +900,11 @@ static void add_bin_header(conn *c, int err, int hdr_len, int body_len) {\n }\n \n static void write_bin_error(conn *c, int err, int swallow) {\n-    char *errstr = ""Unknown error"";\n+    const char *errstr = ""Unknown error"";\n     switch(err) {\n+        case ERR_OUT_OF_MEMORY:\n+            errstr = ""Out of memory"";\n+            break;\n         case ERR_UNKNOWN_CMD:\n             errstr = ""Unknown command"";\n             break;\n@@ -943,7 +938,7 @@ static void write_bin_error(conn *c, int err, int swallow) {\n         c->sbytes = swallow;\n         c->write_and_go = conn_swallow;\n     } else {\n-        c->write_and_go = conn_bin_init;\n+        c->write_and_go = conn_new_cmd;\n     }\n }\n \n@@ -954,7 +949,7 @@ static void write_bin_response(conn *c, void *d, int hlen, int dlen) {\n         add_iov(c, d, dlen);\n     }\n     conn_set_state(c, conn_mwrite);\n-    c->write_and_go = conn_bin_init;\n+    c->write_and_go = conn_new_cmd;\n }\n \n /* Byte swap a 64-bit number */\n@@ -1112,7 +1107,7 @@ static void process_bin_get(conn *c) {\n         conn_set_state(c, conn_mwrite);\n     } else {\n         if(c->cmd == CMD_GETQ) {\n-            conn_set_state(c, conn_bin_init);\n+            conn_set_state(c, conn_new_cmd);\n         } else {\n             write_bin_error(c, ERR_NOT_FOUND, 0);\n         }\n@@ -1278,126 +1273,49 @@ static void process_bin_delete(conn *c) {\n \n static void complete_nread_binary(conn *c) {\n     assert(c != NULL);\n-\n-    if(c->cmd < 0) {\n-        /* No command defined.  Figure out what they\'re trying to say. */\n-        int i = 0;\n-        /* I did a bit of hard-coding around the packet sizes */\n-        assert(BIN_PKT_HDR_WORDS == 4);\n-        for(i = 0; i<BIN_PKT_HDR_WORDS; i++) {\n-            c->bin_header[i] = ntohl(c->bin_header[i]);\n-        }\n-        if(settings.verbose) {\n-            fprintf(stderr, ""Read binary protocol data:  %08x %08x %08x %08x\\n"",\n-                c->bin_header[0], c->bin_header[1], c->bin_header[2],\n-                c->bin_header[3]);\n-        }\n-        if((c->bin_header[0] >> 24) != BIN_REQ_MAGIC) {\n-            if(settings.verbose) {\n-                fprintf(stderr, ""Invalid magic:  %x\\n"", c->bin_header[0] >> 24);\n-            }\n-            conn_set_state(c, conn_closing);\n-            return;\n-        }\n-\n-        c->msgcurr = 0;\n-        c->msgused = 0;\n-        c->iovused = 0;\n-        if (add_msghdr(c) != 0) {\n-            out_string(c, ""SERVER_ERROR out of memory"");\n-            return;\n-        }\n-\n-        c->cmd = (c->bin_header[0] >> 16) & 0xff;\n-        c->keylen = c->bin_header[0] & 0xffff;\n-        c->opaque = c->bin_header[3];\n-        if(settings.verbose > 1) {\n-            fprintf(stderr,\n-                ""Command: %d, opaque=%08x, keylen=%d, total_len=%d\\n"", c->cmd,\n-                c->opaque, c->keylen, c->bin_header[2]);\n-        }\n-        dispatch_bin_command(c);\n-    } else {\n-        switch(c->substate) {\n-            case bin_reading_set_header:\n-                process_bin_update(c);\n-                break;\n-            case bin_read_set_value:\n-                complete_update_bin(c);\n-                break;\n-            case bin_reading_get_key:\n-                process_bin_get(c);\n-                break;\n-            case bin_reading_del_header:\n-                process_bin_delete(c);\n-                break;\n-            case bin_reading_incr_header:\n-                complete_incr_bin(c);\n-                break;\n-            default:\n-                fprintf(stderr, ""Not handling substate %d\\n"", c->substate);\n-                assert(0);\n-        }\n-    }\n-}\n-\n-static void reinit_bin_connection(conn *c) {\n-    if (settings.verbose > 1)\n-        fprintf(stderr, ""*** Reinitializing binary connection.\\n"");\n-    c->rlbytes = MIN_BIN_PKT_LENGTH;\n-    c->write_and_go = conn_bin_init;\n+    assert(c->cmd >= 0);\n+\n+    switch(c->substate) {\n+    case bin_reading_set_header:\n+        process_bin_update(c);\n+        break;\n+    case bin_read_set_value:\n+        complete_update_bin(c);\n+        break;\n+    case bin_reading_get_key:\n+        process_bin_get(c);\n+        break;\n+    case bin_reading_del_header:\n+        process_bin_delete(c);\n+        break;\n+    case bin_reading_incr_header:\n+        complete_incr_bin(c);\n+        break;\n+    default:\n+        fprintf(stderr, ""Not handling substate %d\\n"", c->substate);\n+        assert(0);\n+    }\n+}\n+\n+static void reset_cmd_handler(conn *c) {\n     c->cmd = -1;\n     c->substate = bin_no_state;\n-    c->rbytes = c->wbytes = 0;\n-    c->ritem = (char*)c->bin_header;\n-    c->rcurr = c->rbuf;\n-    c->wcurr = c->wbuf;\n     conn_shrink(c);\n-    conn_set_state(c, conn_nread);\n-}\n-\n-/* These do the initial protocol switch.  At this point, we should\'ve read\n- * exactly one byte, and must treat that byte as the beginning of a command. */\n-static void setup_bin_protocol(conn *c) {\n-    char *loc = (char*)c->bin_header;\n-    if (settings.verbose > 1)\n-        fprintf(stderr, ""Negotiated protocol as binary.\\n"");\n-\n-    c->protocol = binary_prot;\n-    reinit_bin_connection(c);\n-    /* Emulate a read of the first byte */\n-    c->ritem[0] = c->rbuf[0];\n-    c->ritem++;\n-    c->rlbytes--;\n-}\n-\n-static void setup_ascii_protocol(conn *c) {\n-    if (settings.verbose > 1)\n-        fprintf(stderr, ""Negotiated protocol as ascii.\\n"");\n-    c->protocol = ascii_prot;\n-\n-    /* We\'ve already got the first letter of the command, so pretend like we\n-     * Did a single byte read from try_read_command */\n-    c->rcurr = c->rbuf;\n-    c->rbytes = 1;\n-    conn_set_state(c, conn_read);\n+    if (c->rbytes > 0) {\n+        conn_set_state(c, conn_parse_cmd);\n+    } else {\n+        conn_set_state(c, conn_waiting);\n+    }\n }\n \n static void complete_nread(conn *c) {\n     assert(c != NULL);\n+    assert(c->protocol == ascii_prot || c->protocol == binary_prot);\n \n     if(c->protocol == ascii_prot) {\n         complete_nread_ascii(c);\n-    } else if(c->protocol == binary_prot) {\n+    } else if (c->protocol == binary_prot) {\n         complete_nread_binary(c);\n-    } else if(c->protocol == negotiating_prot) {\n-        /* The first byte is either BIN_REQ_MAGIC, or we\'re speaking ascii */\n-        if ((c->rbuf[0] & 0xff) == BIN_REQ_MAGIC)\n-            setup_bin_protocol(c);\n-        else\n-            setup_ascii_protocol(c);\n-    } else {\n-        assert(0); /* XXX:  Invalid case.  Should probably do more here. */\n     }\n }\n \n@@ -1578,7 +1496,7 @@ static void write_and_free(conn *c, char *buf, int bytes) {\n         c->wcurr = buf;\n         c->wbytes = bytes;\n         conn_set_state(c, conn_write);\n-        c->write_and_go = get_init_state(c);\n+        c->write_and_go = conn_new_cmd;\n     } else {\n         out_string(c, ""SERVER_ERROR out of memory writing stats"");\n     }\n@@ -1865,7 +1783,7 @@ static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens,\n                  *   "" "" + flags + "" "" + data length + ""\\r\\n"" + data (with \\r\\n)\n                  */\n \n-                if(return_cas == true)\n+                if (return_cas)\n                 {\n                   /* Goofy mid-flight realloc. */\n                   if (i >= c->suffixsize) {\n@@ -2361,7 +2279,7 @@ static void process_command(conn *c, char *command) {\n                 c->bucket = bucket;\n                 c->gen = gen;\n             }\n-            conn_set_init_state(c);\n+            conn_set_state(c, conn_new_cmd);\n             return;\n         } else {\n             out_string(c, ""CLIENT_ERROR bad format"");\n@@ -2455,30 +2373,97 @@ static void process_command(conn *c, char *command) {\n  * if we have a complete line in the buffer, process it.\n  */\n static int try_read_command(conn *c) {\n-    char *el, *cont;\n-\n     assert(c != NULL);\n     assert(c->rcurr <= (c->rbuf + c->rsize));\n+    assert(c->rbytes > 0);\n+\n+    if (c->protocol == negotiating_prot)  {\n+        if ((c->rbuf[0] & 0xff) == BIN_REQ_MAGIC) {\n+            c->protocol = binary_prot;\n+        } else {\n+            c->protocol = ascii_prot;\n+        }\n \n-    if (c->rbytes == 0)\n-        return 0;\n-    el = memchr(c->rcurr, \'\\n\', c->rbytes);\n-    if (!el)\n-        return 0;\n-    cont = el + 1;\n-    if ((el - c->rcurr) > 1 && *(el - 1) == \'\\r\') {\n-        el--;\n+        if (settings.verbose) {\n+            fprintf(stderr, ""%d: Client using the %s protocol\\n"", c->sfd,\n+                    prot_text(c->protocol));\n+        }\n     }\n-    *el = \'\\0\';\n \n-    assert(cont <= (c->rcurr + c->rbytes));\n+    if (c->protocol == binary_prot) {\n+        /* Do we have the complete packet header? */\n+        if (c->rbytes < MIN_BIN_PKT_LENGTH) {\n+            /* need more data! */\n+            return 0;\n+        } else {\n+            int i = 0;\n+            memcpy(c->bin_header, c->rcurr, sizeof(c->bin_header));\n+            assert(BIN_PKT_HDR_WORDS == 4);\n+            for (i = 0; i<BIN_PKT_HDR_WORDS; i++) {\n+                c->bin_header[i] = ntohl(c->bin_header[i]);\n+            }\n+\n+            if (settings.verbose) {\n+                fprintf(stderr,\n+                        ""Read binary protocol data:  %08x %08x %08x %08x\\n"",\n+                        c->bin_header[0], c->bin_header[1], c->bin_header[2],\n+                        c->bin_header[3]);\n+            }\n \n-    process_command(c, c->rcurr);\n+            if ((c->bin_header[0] >> 24) != BIN_REQ_MAGIC) {\n+                if (settings.verbose) {\n+                    fprintf(stderr, ""Invalid magic:  %x\\n"",\n+                            c->bin_header[0] >> 24);\n+                }\n+                conn_set_state(c, conn_closing);\n+                return 0;\n+            }\n \n-    c->rbytes -= (cont - c->rcurr);\n-    c->rcurr = cont;\n+            c->msgcurr = 0;\n+            c->msgused = 0;\n+            c->iovused = 0;\n+            if (add_msghdr(c) != 0) {\n+                out_string(c, ""SERVER_ERROR out of memory"");\n+                return 0;\n+            }\n \n-    assert(c->rcurr <= (c->rbuf + c->rsize));\n+            c->cmd = (c->bin_header[0] >> 16) & 0xff;\n+            c->keylen = c->bin_header[0] & 0xffff;\n+            c->opaque = c->bin_header[3];\n+            if (settings.verbose > 1) {\n+                fprintf(stderr,\n+                        ""Command: %d, opaque=%08x, keylen=%d, total_len=%d\\n"",\n+                        c->cmd, c->opaque, c->keylen, c->bin_header[2]);\n+            }\n+\n+            dispatch_bin_command(c);\n+\n+            c->rbytes -= MIN_BIN_PKT_LENGTH;\n+            c->rcurr += MIN_BIN_PKT_LENGTH;\n+        }\n+    } else {\n+        char *el, *cont;\n+\n+        if (c->rbytes == 0)\n+            return 0;\n+        el = memchr(c->rcurr, \'\\n\', c->rbytes);\n+        if (!el)\n+            return 0;\n+        cont = el + 1;\n+        if ((el - c->rcurr) > 1 && *(el - 1) == \'\\r\') {\n+            el--;\n+        }\n+        *el = \'\\0\';\n+\n+        assert(cont <= (c->rcurr + c->rbytes));\n+\n+        process_command(c, c->rcurr);\n+\n+        c->rbytes -= (cont - c->rcurr);\n+        c->rcurr = cont;\n+\n+        assert(c->rcurr <= (c->rbuf + c->rsize));\n+    }\n \n     return 1;\n }\n@@ -2526,7 +2511,10 @@ static int try_read_udp(conn *c) {\n  * close.\n  * before reading, move the remaining incomplete fragment of a command\n  * (if any) to the beginning of the buffer.\n- * return 0 if there\'s nothing to read on the first read.\n+ * @return 1 data received\n+ *         0 no data received\n+ *        -1 an error occured (on the socket) (or client closed connection)\n+ *        -2 memory error (failed to allocate more memory)\n  */\n static int try_read_network(conn *c) {\n     int gotdata = 0;\n@@ -2549,7 +2537,7 @@ static int try_read_network(conn *c) {\n                 c->rbytes = 0; /* ignore what we read */\n                 out_string(c, ""SERVER_ERROR out of memory reading request"");\n                 c->write_and_go = conn_closing;\n-                return 1;\n+                return -2;\n             }\n             c->rcurr = c->rbuf = new_rbuf;\n             c->rsize *= 2;\n@@ -2570,15 +2558,13 @@ static int try_read_network(conn *c) {\n             }\n         }\n         if (res == 0) {\n-            /* connection closed */\n-            conn_set_state(c, conn_closing);\n-            return 1;\n+            return -1;\n         }\n         if (res == -1) {\n-            if (errno == EAGAIN || errno == EWOULDBLOCK) break;\n-            /* Should close on unhandled errors. */\n-            conn_set_state(c, conn_closing);\n-            return 1;\n+            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n+                break;\n+            }\n+            return -1;\n         }\n     }\n     return gotdata;\n@@ -2693,7 +2679,6 @@ static int transmit(conn *c) {\n static void drive_machine(conn *c) {\n     bool stop = false;\n     int sfd, flags = 1;\n-    enum conn_states init_state; /* initial state for a new connection */\n     socklen_t addrlen;\n     struct sockaddr_storage addr;\n     int res;\n@@ -2726,42 +2711,53 @@ static void drive_machine(conn *c) {\n                 close(sfd);\n                 break;\n             }\n-            init_state = get_init_state(c);\n \n-            dispatch_conn_new(sfd, init_state, EV_READ | EV_PERSIST,\n+            dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                                      DATA_BUFFER_SIZE, c->protocol);\n-\n-            break;\n-\n-        case conn_negotiate:\n-            if (settings.verbose > 1)\n-                fprintf(stderr, ""Negotiating protocol for a new connection\\n"");\n-            c->rlbytes = 1;\n-            c->ritem = c->rbuf;\n-            c->rcurr = c->rbuf;\n-            c->wcurr = c->wbuf;\n-            conn_set_state(c, conn_nread);\n+            stop = true;\n             break;\n \n-        case conn_read:\n-            if (try_read_command(c) != 0) {\n-                continue;\n-            }\n-            if ((IS_UDP(c->protocol) ? try_read_udp(c) : try_read_network(c)) != 0) {\n-                continue;\n-            }\n-            /* we have no command line and no data to read from network */\n+        case conn_waiting:\n             if (!update_event(c, EV_READ | EV_PERSIST)) {\n                 if (settings.verbose > 0)\n                     fprintf(stderr, ""Couldn\'t update event\\n"");\n                 conn_set_state(c, conn_closing);\n                 break;\n             }\n+\n+            conn_set_state(c, conn_read);\n             stop = true;\n             break;\n \n-        case conn_bin_init: /* Reinitialize a binary connection */\n-            reinit_bin_connection(c);\n+        case conn_read:\n+            res = IS_UDP(c->protocol) ? try_read_udp(c) : try_read_network(c);\n+            switch (res) {\n+            case 0 :\n+                conn_set_state(c, conn_waiting);\n+                break;\n+            case 1:\n+                conn_set_state(c, conn_parse_cmd);\n+                break;\n+            case -1:\n+                conn_set_state(c, conn_closing);\n+                break;\n+            case -2: /* Failed to allocate more memory */\n+                /* State already set by try_read_network */\n+                break;\n+            }\n+            break;\n+\n+        case conn_parse_cmd :\n+            if (try_read_command(c) == 0) {\n+                /* wee need more data! */\n+                conn_set_state(c, conn_waiting);\n+            }\n+\n+            break;\n+\n+        case conn_new_cmd:\n+            reset_cmd_handler(c);\n+            assoc_move_next_bucket();\n             break;\n \n         case conn_nread:\n@@ -2772,12 +2768,14 @@ static void drive_machine(conn *c) {\n             /* first check if we have leftovers in the conn_read buffer */\n             if (c->rbytes > 0) {\n                 int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n-                memcpy(c->ritem, c->rcurr, tocopy);\n+                memmove(c->ritem, c->rcurr, tocopy);\n                 c->ritem += tocopy;\n                 c->rlbytes -= tocopy;\n                 c->rcurr += tocopy;\n                 c->rbytes -= tocopy;\n-                break;\n+                if (c->rlbytes == 0) {\n+                    break;\n+                }\n             }\n \n             /*  now try reading from the socket */\n@@ -2813,7 +2811,7 @@ static void drive_machine(conn *c) {\n         case conn_swallow:\n             /* we are reading sbytes and throwing them away */\n             if (c->sbytes == 0) {\n-                conn_set_init_state(c);\n+                conn_set_state(c, conn_new_cmd);\n                 break;\n             }\n \n@@ -2897,7 +2895,7 @@ static void drive_machine(conn *c) {\n                     if(c->protocol == binary_prot) {\n                         conn_set_state(c, c->write_and_go);\n                     } else {\n-                        conn_set_init_state(c);\n+                        conn_set_state(c, conn_new_cmd);\n                     }\n                 } else if (c->state == conn_write) {\n                     if (c->write_and_free) {\n@@ -3285,6 +3283,7 @@ static void usage(void) {\n            ""              under sh this is done with \'ulimit -S -l NUM_KB\').\\n""\n            ""-v            verbose (print errors/warnings while in event loop)\\n""\n            ""-vv           very verbose (also print client commands/reponses)\\n""\n+           ""-vvv          extremely verbose (also print internal state transitions)\\n""\n            ""-h            print this help and exit\\n""\n            ""-i            print memcached and libevent license\\n""\n            ""-b            run a managed instanced (mnemonic: buckets)\\n""\n@@ -3480,7 +3479,7 @@ int main (int argc, char **argv) {\n     setbuf(stderr, NULL);\n \n     /* process arguments */\n-    while ((c = getopt(argc, argv, ""a:bp:B:s:U:m:Mc:khirvdl:u:P:f:s:n:t:D:"")) != -1) {\n+    while ((c = getopt(argc, argv, ""a:bp:s:U:m:Mc:khirvdl:u:P:f:s:n:t:D:L"")) != -1) {\n         switch (c) {\n         case \'a\':\n             /* access for unix domain socket, as octal mask (like chmod)*/\n@@ -3564,13 +3563,13 @@ int main (int argc, char **argv) {\n             settings.prefix_delimiter = optarg[0];\n             settings.detail_enabled = 1;\n             break;\n-#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n         case \'L\' :\n+#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n             if (enable_large_pages() == 0) {\n                 preallocate = true;\n             }\n-            break;\n #endif\n+            break;\n         default:\n             fprintf(stderr, ""Illegal argument \\""%c\\""\\n"", c);\n             return 1;\n']",2008-04-27 16:37:47-07:00,"Syscall optimizations.

I have been using the last two days to test the modifications I have done to
the binary protocol, and I have not been able to find any new bugs. From my
testing the binary protocol now use the same amount of system calls as the
textual protocol.

I have tried to use a common state machine, and branch the execution path as
late as possible.

git-svn-id: http://code.sixapart.com/svn/memcached/branches/binary@775 b0b603af-a30f-0410-a34e-baf09ae79d0b","[['+ static const char *prot_text(enum protocol prot) {', '+             fprintf(stderr, ""<%d new auto-negotiating client connection\\n"",', '+                     sfd);', '+ static const char *state_text(enum conn_states state) {', '+     const char* const statenames[] = { ""conn_listening"",', '+                                        ""conn_new_cmd"",', '+                                        ""conn_waiting"",', '+                                        ""conn_read"",', '+                                        ""conn_parse_cmd"",', '+                                        ""conn_write"",', '+                                        ""conn_nread"",', '+                                        ""conn_swallow"",', '+                                        ""conn_closing"",', '+                                        ""conn_mwrite"" };', '+     return statenames[state];', '+ }', '+ ', '+     assert(state >= conn_listening && state < conn_max_state);', '+         if (settings.verbose > 2) {', '+             fprintf(stderr, ""%d: going from %s to %s\\n"",', '+                     c->sfd, state_text(c->state),', '+                     state_text(state));', '+ ', '+         conn_set_state(c, conn_new_cmd);', '+     c->write_and_go = conn_new_cmd;', '+     const char *errstr = ""Unknown error"";', '+         case ERR_OUT_OF_MEMORY:', '+             errstr = ""Out of memory"";', '+             break;', '+         c->write_and_go = conn_new_cmd;', '+     c->write_and_go = conn_new_cmd;', '+             conn_set_state(c, conn_new_cmd);', '+     assert(c->cmd >= 0);', '+ ', '+     switch(c->substate) {', '+     case bin_reading_set_header:', '+         process_bin_update(c);', '+         break;', '+     case bin_read_set_value:', '+         complete_update_bin(c);', '+         break;', '+     case bin_reading_get_key:', '+         process_bin_get(c);', '+         break;', '+     case bin_reading_del_header:', '+         process_bin_delete(c);', '+         break;', '+     case bin_reading_incr_header:', '+         complete_incr_bin(c);', '+         break;', '+     default:', '+         fprintf(stderr, ""Not handling substate %d\\n"", c->substate);', '+         assert(0);', '+     }', '+ }', '+ ', '+ static void reset_cmd_handler(conn *c) {', '+     if (c->rbytes > 0) {', '+         conn_set_state(c, conn_parse_cmd);', '+     } else {', '+         conn_set_state(c, conn_waiting);', '+     }', '+     assert(c->protocol == ascii_prot || c->protocol == binary_prot);', '+     } else if (c->protocol == binary_prot) {', '+         c->write_and_go = conn_new_cmd;', '+                 if (return_cas)', '+             conn_set_state(c, conn_new_cmd);', '+     assert(c->rbytes > 0);', '+ ', '+     if (c->protocol == negotiating_prot)  {', '+         if ((c->rbuf[0] & 0xff) == BIN_REQ_MAGIC) {', '+             c->protocol = binary_prot;', '+         } else {', '+             c->protocol = ascii_prot;', '+         }', '+         if (settings.verbose) {', '+             fprintf(stderr, ""%d: Client using the %s protocol\\n"", c->sfd,', '+                     prot_text(c->protocol));', '+         }', '+     if (c->protocol == binary_prot) {', '+         if (c->rbytes < MIN_BIN_PKT_LENGTH) {', '+             return 0;', '+         } else {', '+             int i = 0;', '+             memcpy(c->bin_header, c->rcurr, sizeof(c->bin_header));', '+             assert(BIN_PKT_HDR_WORDS == 4);', '+             for (i = 0; i<BIN_PKT_HDR_WORDS; i++) {', '+                 c->bin_header[i] = ntohl(c->bin_header[i]);', '+             }', '+ ', '+             if (settings.verbose) {', '+                 fprintf(stderr,', '+                         ""Read binary protocol data:  %08x %08x %08x %08x\\n"",', '+                         c->bin_header[0], c->bin_header[1], c->bin_header[2],', '+                         c->bin_header[3]);', '+             }', '+             if ((c->bin_header[0] >> 24) != BIN_REQ_MAGIC) {', '+                 if (settings.verbose) {', '+                     fprintf(stderr, ""Invalid magic:  %x\\n"",', '+                             c->bin_header[0] >> 24);', '+                 }', '+                 conn_set_state(c, conn_closing);', '+                 return 0;', '+             }', '+             c->msgcurr = 0;', '+             c->msgused = 0;', '+             c->iovused = 0;', '+             if (add_msghdr(c) != 0) {', '+                 out_string(c, ""SERVER_ERROR out of memory"");', '+                 return 0;', '+             }', '+             c->cmd = (c->bin_header[0] >> 16) & 0xff;', '+             c->keylen = c->bin_header[0] & 0xffff;', '+             c->opaque = c->bin_header[3];', '+             if (settings.verbose > 1) {', '+                 fprintf(stderr,', '+                         ""Command: %d, opaque=%08x, keylen=%d, total_len=%d\\n"",', '+                         c->cmd, c->opaque, c->keylen, c->bin_header[2]);', '+             }', '+ ', '+             dispatch_bin_command(c);', '+ ', '+             c->rbytes -= MIN_BIN_PKT_LENGTH;', '+             c->rcurr += MIN_BIN_PKT_LENGTH;', '+         }', '+     } else {', '+         char *el, *cont;', '+ ', '+         if (c->rbytes == 0)', '+             return 0;', ""+         el = memchr(c->rcurr, '\\n', c->rbytes);"", '+         if (!el)', '+             return 0;', '+         cont = el + 1;', ""+         if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {"", '+             el--;', '+         }', ""+         *el = '\\0';"", '+ ', '+         assert(cont <= (c->rcurr + c->rbytes));', '+ ', '+         process_command(c, c->rcurr);', '+ ', '+         c->rbytes -= (cont - c->rcurr);', '+         c->rcurr = cont;', '+ ', '+         assert(c->rcurr <= (c->rbuf + c->rsize));', '+     }', '+                 return -2;', '+             return -1;', '+             if (errno == EAGAIN || errno == EWOULDBLOCK) {', '+                 break;', '+             }', '+             return -1;', '+             dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,', '+             stop = true;', '+         case conn_waiting:', '+ ', '+             conn_set_state(c, conn_read);', '+         case conn_read:', '+             res = IS_UDP(c->protocol) ? try_read_udp(c) : try_read_network(c);', '+             switch (res) {', '+             case 0 :', '+                 conn_set_state(c, conn_waiting);', '+                 break;', '+             case 1:', '+                 conn_set_state(c, conn_parse_cmd);', '+                 break;', '+             case -1:', '+                 conn_set_state(c, conn_closing);', '+                 break;', '+                 break;', '+             }', '+             break;', '+ ', '+         case conn_parse_cmd :', '+             if (try_read_command(c) == 0) {', '+                 conn_set_state(c, conn_waiting);', '+             }', '+ ', '+             break;', '+ ', '+         case conn_new_cmd:', '+             reset_cmd_handler(c);', '+             assoc_move_next_bucket();', '+                 memmove(c->ritem, c->rcurr, tocopy);', '+                 if (c->rlbytes == 0) {', '+                     break;', '+                 }', '+                 conn_set_state(c, conn_new_cmd);', '+                         conn_set_state(c, conn_new_cmd);', '+            ""-vvv          extremely verbose (also print internal state transitions)\\n""', '+     while ((c = getopt(argc, argv, ""a:bp:s:U:m:Mc:khirvdl:u:P:f:s:n:t:D:L"")) != -1) {', '+ #if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)', '+             break;', '- static char *prot_text(enum protocol prot) {', '-         } else if (prot == binary_prot) {', '-             fprintf(stderr, ""<%d new binary client connection\\n"", sfd);', '-         } else if (prot == ascii_prot) {', '-             fprintf(stderr, ""<%d new ascii client connection\\n"", sfd);', '-             fprintf(stderr, ""<%d new auto-negotiating client connection\\n"", sfd);', '- static enum conn_states get_init_state(conn *c) {', '-     int rv = 0;', '-     assert(c != NULL);', '- ', '-     switch(c->protocol) {', '-         case binary_prot:', '-             rv = conn_bin_init;', '-             break;', '-         case negotiating_prot:', '-             rv = conn_negotiate;', '-             break;', '-         default:', '-             rv = conn_read;', '-     }', '-     return rv;', '- }', '- ', '- static void conn_set_init_state(conn *c) {', '-     assert(c != NULL);', '- ', '-     conn_set_state(c, get_init_state(c));', '- }', '- ', '-         if (state == conn_read) {', '-             conn_shrink(c);', '-             assoc_move_next_bucket();', '-         conn_set_state(c, conn_read);', '-     c->write_and_go = get_init_state(c);', '-     char *errstr = ""Unknown error"";', '-         c->write_and_go = conn_bin_init;', '-     c->write_and_go = conn_bin_init;', '-             conn_set_state(c, conn_bin_init);', '- ', '-     if(c->cmd < 0) {', '-         int i = 0;', '-         assert(BIN_PKT_HDR_WORDS == 4);', '-         for(i = 0; i<BIN_PKT_HDR_WORDS; i++) {', '-             c->bin_header[i] = ntohl(c->bin_header[i]);', '-         }', '-         if(settings.verbose) {', '-             fprintf(stderr, ""Read binary protocol data:  %08x %08x %08x %08x\\n"",', '-                 c->bin_header[0], c->bin_header[1], c->bin_header[2],', '-                 c->bin_header[3]);', '-         }', '-         if((c->bin_header[0] >> 24) != BIN_REQ_MAGIC) {', '-             if(settings.verbose) {', '-                 fprintf(stderr, ""Invalid magic:  %x\\n"", c->bin_header[0] >> 24);', '-             }', '-             conn_set_state(c, conn_closing);', '-             return;', '-         }', '- ', '-         c->msgcurr = 0;', '-         c->msgused = 0;', '-         c->iovused = 0;', '-         if (add_msghdr(c) != 0) {', '-             out_string(c, ""SERVER_ERROR out of memory"");', '-             return;', '-         }', '- ', '-         c->cmd = (c->bin_header[0] >> 16) & 0xff;', '-         c->keylen = c->bin_header[0] & 0xffff;', '-         c->opaque = c->bin_header[3];', '-         if(settings.verbose > 1) {', '-             fprintf(stderr,', '-                 ""Command: %d, opaque=%08x, keylen=%d, total_len=%d\\n"", c->cmd,', '-                 c->opaque, c->keylen, c->bin_header[2]);', '-         }', '-         dispatch_bin_command(c);', '-     } else {', '-         switch(c->substate) {', '-             case bin_reading_set_header:', '-                 process_bin_update(c);', '-                 break;', '-             case bin_read_set_value:', '-                 complete_update_bin(c);', '-                 break;', '-             case bin_reading_get_key:', '-                 process_bin_get(c);', '-                 break;', '-             case bin_reading_del_header:', '-                 process_bin_delete(c);', '-                 break;', '-             case bin_reading_incr_header:', '-                 complete_incr_bin(c);', '-                 break;', '-             default:', '-                 fprintf(stderr, ""Not handling substate %d\\n"", c->substate);', '-                 assert(0);', '-         }', '-     }', '- }', '- ', '- static void reinit_bin_connection(conn *c) {', '-     if (settings.verbose > 1)', '-         fprintf(stderr, ""*** Reinitializing binary connection.\\n"");', '-     c->rlbytes = MIN_BIN_PKT_LENGTH;', '-     c->write_and_go = conn_bin_init;', '-     c->rbytes = c->wbytes = 0;', '-     c->ritem = (char*)c->bin_header;', '-     c->rcurr = c->rbuf;', '-     c->wcurr = c->wbuf;', '-     conn_set_state(c, conn_nread);', '- }', '- ', '- static void setup_bin_protocol(conn *c) {', '-     char *loc = (char*)c->bin_header;', '-     if (settings.verbose > 1)', '-         fprintf(stderr, ""Negotiated protocol as binary.\\n"");', '- ', '-     c->protocol = binary_prot;', '-     reinit_bin_connection(c);', '-     c->ritem[0] = c->rbuf[0];', '-     c->ritem++;', '-     c->rlbytes--;', '- }', '- ', '- static void setup_ascii_protocol(conn *c) {', '-     if (settings.verbose > 1)', '-         fprintf(stderr, ""Negotiated protocol as ascii.\\n"");', '-     c->protocol = ascii_prot;', '- ', '-     c->rcurr = c->rbuf;', '-     c->rbytes = 1;', '-     conn_set_state(c, conn_read);', '-     } else if(c->protocol == binary_prot) {', '-     } else if(c->protocol == negotiating_prot) {', '-         if ((c->rbuf[0] & 0xff) == BIN_REQ_MAGIC)', '-             setup_bin_protocol(c);', '-         else', '-             setup_ascii_protocol(c);', '-     } else {', '-         c->write_and_go = get_init_state(c);', '-                 if(return_cas == true)', '-             conn_set_init_state(c);', '-     char *el, *cont;', '- ', '-     if (c->rbytes == 0)', '-         return 0;', ""-     el = memchr(c->rcurr, '\\n', c->rbytes);"", '-     if (!el)', '-         return 0;', '-     cont = el + 1;', ""-     if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {"", '-         el--;', ""-     *el = '\\0';"", '-     assert(cont <= (c->rcurr + c->rbytes));', '-     process_command(c, c->rcurr);', '-     c->rbytes -= (cont - c->rcurr);', '-     c->rcurr = cont;', '-     assert(c->rcurr <= (c->rbuf + c->rsize));', '-                 return 1;', '-             conn_set_state(c, conn_closing);', '-             return 1;', '-             if (errno == EAGAIN || errno == EWOULDBLOCK) break;', '-             conn_set_state(c, conn_closing);', '-             return 1;', '-             init_state = get_init_state(c);', '-             dispatch_conn_new(sfd, init_state, EV_READ | EV_PERSIST,', '- ', '-             break;', '- ', '-         case conn_negotiate:', '-             if (settings.verbose > 1)', '-                 fprintf(stderr, ""Negotiating protocol for a new connection\\n"");', '-             c->rlbytes = 1;', '-             c->ritem = c->rbuf;', '-             c->rcurr = c->rbuf;', '-             c->wcurr = c->wbuf;', '-             conn_set_state(c, conn_nread);', '-         case conn_read:', '-             if (try_read_command(c) != 0) {', '-                 continue;', '-             }', '-             if ((IS_UDP(c->protocol) ? try_read_udp(c) : try_read_network(c)) != 0) {', '-                 continue;', '-             }', '-             reinit_bin_connection(c);', '-                 memcpy(c->ritem, c->rcurr, tocopy);', '-                 break;', '-                 conn_set_init_state(c);', '-                         conn_set_init_state(c);', '-     while ((c = getopt(argc, argv, ""a:bp:B:s:U:m:Mc:khirvdl:u:P:f:s:n:t:D:"")) != -1) {', '- #if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)', '-             break;']]","[['+ static const char *prot_text(enum protocol prot) {', '+             fprintf(stderr, ""<%d new auto-negotiating client connection\\n"",', '+                     sfd);', '+ static const char *state_text(enum conn_states state) {', '+     const char* const statenames[] = { ""conn_listening"",', '+                                        ""conn_new_cmd"",', '+                                        ""conn_waiting"",', '+                                        ""conn_read"",', '+                                        ""conn_parse_cmd"",', '+                                        ""conn_write"",', '+                                        ""conn_nread"",', '+                                        ""conn_swallow"",', '+                                        ""conn_closing"",', '+                                        ""conn_mwrite"" };', '+     return statenames[state];', '+ }', '+ ', '+     assert(state >= conn_listening && state < conn_max_state);', '+         if (settings.verbose > 2) {', '+             fprintf(stderr, ""%d: going from %s to %s\\n"",', '+                     c->sfd, state_text(c->state),', '+                     state_text(state));', '+ ', '+         conn_set_state(c, conn_new_cmd);', '+     c->write_and_go = conn_new_cmd;', '+     const char *errstr = ""unknown error"";', '+         case err_out_of_memory:', '+             errstr = ""out of memory"";', '+             break;', '+         c->write_and_go = conn_new_cmd;', '+     c->write_and_go = conn_new_cmd;', '+             conn_set_state(c, conn_new_cmd);', '+     assert(c->cmd >= 0);', '+ ', '+     switch(c->substate) {', '+     case bin_reading_set_header:', '+         process_bin_update(c);', '+         break;', '+     case bin_read_set_value:', '+         complete_update_bin(c);', '+         break;', '+     case bin_reading_get_key:', '+         process_bin_get(c);', '+         break;', '+     case bin_reading_del_header:', '+         process_bin_delete(c);', '+         break;', '+     case bin_reading_incr_header:', '+         complete_incr_bin(c);', '+         break;', '+     default:', '+         fprintf(stderr, ""not handling substate %d\\n"", c->substate);', '+         assert(0);', '+     }', '+ }', '+ ', '+ static void reset_cmd_handler(conn *c) {', '+     if (c->rbytes > 0) {', '+         conn_set_state(c, conn_parse_cmd);', '+     } else {', '+         conn_set_state(c, conn_waiting);', '+     }', '+     assert(c->protocol == ascii_prot || c->protocol == binary_prot);', '+     } else if (c->protocol == binary_prot) {', '+         c->write_and_go = conn_new_cmd;', '+                 if (return_cas)', '+             conn_set_state(c, conn_new_cmd);', '+     assert(c->rbytes > 0);', '+ ', '+     if (c->protocol == negotiating_prot)  {', '+         if ((c->rbuf[0] & 0xff) == bin_req_magic) {', '+             c->protocol = binary_prot;', '+         } else {', '+             c->protocol = ascii_prot;', '+         }', '+         if (settings.verbose) {', '+             fprintf(stderr, ""%d: client using the %s protocol\\n"", c->sfd,', '+                     prot_text(c->protocol));', '+         }', '+     if (c->protocol == binary_prot) {', '+         if (c->rbytes < min_bin_pkt_length) {', '+             return 0;', '+         } else {', '+             int i = 0;', '+             memcpy(c->bin_header, c->rcurr, sizeof(c->bin_header));', '+             assert(bin_pkt_hdr_words == 4);', '+             for (i = 0; i<bin_pkt_hdr_words; i++) {', '+                 c->bin_header[i] = ntohl(c->bin_header[i]);', '+             }', '+ ', '+             if (settings.verbose) {', '+                 fprintf(stderr,', '+                         ""read binary protocol data:  %08x %08x %08x %08x\\n"",', '+                         c->bin_header[0], c->bin_header[1], c->bin_header[2],', '+                         c->bin_header[3]);', '+             }', '+             if ((c->bin_header[0] >> 24) != bin_req_magic) {', '+                 if (settings.verbose) {', '+                     fprintf(stderr, ""invalid magic:  %x\\n"",', '+                             c->bin_header[0] >> 24);', '+                 }', '+                 conn_set_state(c, conn_closing);', '+                 return 0;', '+             }', '+             c->msgcurr = 0;', '+             c->msgused = 0;', '+             c->iovused = 0;', '+             if (add_msghdr(c) != 0) {', '+                 out_string(c, ""server_error out of memory"");', '+                 return 0;', '+             }', '+             c->cmd = (c->bin_header[0] >> 16) & 0xff;', '+             c->keylen = c->bin_header[0] & 0xffff;', '+             c->opaque = c->bin_header[3];', '+             if (settings.verbose > 1) {', '+                 fprintf(stderr,', '+                         ""command: %d, opaque=%08x, keylen=%d, total_len=%d\\n"",', '+                         c->cmd, c->opaque, c->keylen, c->bin_header[2]);', '+             }', '+ ', '+             dispatch_bin_command(c);', '+ ', '+             c->rbytes -= min_bin_pkt_length;', '+             c->rcurr += min_bin_pkt_length;', '+         }', '+     } else {', '+         char *el, *cont;', '+ ', '+         if (c->rbytes == 0)', '+             return 0;', ""+         el = memchr(c->rcurr, '\\n', c->rbytes);"", '+         if (!el)', '+             return 0;', '+         cont = el + 1;', ""+         if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {"", '+             el--;', '+         }', ""+         *el = '\\0';"", '+ ', '+         assert(cont <= (c->rcurr + c->rbytes));', '+ ', '+         process_command(c, c->rcurr);', '+ ', '+         c->rbytes -= (cont - c->rcurr);', '+         c->rcurr = cont;', '+ ', '+         assert(c->rcurr <= (c->rbuf + c->rsize));', '+     }', '+                 return -2;', '+             return -1;', '+             if (errno == eagain || errno == ewouldblock) {', '+                 break;', '+             }', '+             return -1;', '+             dispatch_conn_new(sfd, conn_new_cmd, ev_read | ev_persist,', '+             stop = true;', '+         case conn_waiting:', '+ ', '+             conn_set_state(c, conn_read);', '+         case conn_read:', '+             res = is_udp(c->protocol) ? try_read_udp(c) : try_read_network(c);', '+             switch (res) {', '+             case 0 :', '+                 conn_set_state(c, conn_waiting);', '+                 break;', '+             case 1:', '+                 conn_set_state(c, conn_parse_cmd);', '+                 break;', '+             case -1:', '+                 conn_set_state(c, conn_closing);', '+                 break;', '+                 break;', '+             }', '+             break;', '+ ', '+         case conn_parse_cmd :', '+             if (try_read_command(c) == 0) {', '+                 conn_set_state(c, conn_waiting);', '+             }', '+ ', '+             break;', '+ ', '+         case conn_new_cmd:', '+             reset_cmd_handler(c);', '+             assoc_move_next_bucket();', '+                 memmove(c->ritem, c->rcurr, tocopy);', '+                 if (c->rlbytes == 0) {', '+                     break;', '+                 }', '+                 conn_set_state(c, conn_new_cmd);', '+                         conn_set_state(c, conn_new_cmd);', '+            ""-vvv          extremely verbose (also print internal state transitions)\\n""', '+     while ((c = getopt(argc, argv, ""a:bp:s:u:m:mc:khirvdl:u:p:f:s:n:t:d:l"")) != -1) {', '+ #if defined(have_getpagesizes) && defined(have_memcntl)', '+             break;', '- static char *prot_text(enum protocol prot) {', '-         } else if (prot == binary_prot) {', '-             fprintf(stderr, ""<%d new binary client connection\\n"", sfd);', '-         } else if (prot == ascii_prot) {', '-             fprintf(stderr, ""<%d new ascii client connection\\n"", sfd);', '-             fprintf(stderr, ""<%d new auto-negotiating client connection\\n"", sfd);', '- static enum conn_states get_init_state(conn *c) {', '-     int rv = 0;', '-     assert(c != null);', '- ', '-     switch(c->protocol) {', '-         case binary_prot:', '-             rv = conn_bin_init;', '-             break;', '-         case negotiating_prot:', '-             rv = conn_negotiate;', '-             break;', '-         default:', '-             rv = conn_read;', '-     }', '-     return rv;', '- }', '- ', '- static void conn_set_init_state(conn *c) {', '-     assert(c != null);', '- ', '-     conn_set_state(c, get_init_state(c));', '- }', '- ', '-         if (state == conn_read) {', '-             conn_shrink(c);', '-             assoc_move_next_bucket();', '-         conn_set_state(c, conn_read);', '-     c->write_and_go = get_init_state(c);', '-     char *errstr = ""unknown error"";', '-         c->write_and_go = conn_bin_init;', '-     c->write_and_go = conn_bin_init;', '-             conn_set_state(c, conn_bin_init);', '- ', '-     if(c->cmd < 0) {', '-         int i = 0;', '-         assert(bin_pkt_hdr_words == 4);', '-         for(i = 0; i<bin_pkt_hdr_words; i++) {', '-             c->bin_header[i] = ntohl(c->bin_header[i]);', '-         }', '-         if(settings.verbose) {', '-             fprintf(stderr, ""read binary protocol data:  %08x %08x %08x %08x\\n"",', '-                 c->bin_header[0], c->bin_header[1], c->bin_header[2],', '-                 c->bin_header[3]);', '-         }', '-         if((c->bin_header[0] >> 24) != bin_req_magic) {', '-             if(settings.verbose) {', '-                 fprintf(stderr, ""invalid magic:  %x\\n"", c->bin_header[0] >> 24);', '-             }', '-             conn_set_state(c, conn_closing);', '-             return;', '-         }', '- ', '-         c->msgcurr = 0;', '-         c->msgused = 0;', '-         c->iovused = 0;', '-         if (add_msghdr(c) != 0) {', '-             out_string(c, ""server_error out of memory"");', '-             return;', '-         }', '- ', '-         c->cmd = (c->bin_header[0] >> 16) & 0xff;', '-         c->keylen = c->bin_header[0] & 0xffff;', '-         c->opaque = c->bin_header[3];', '-         if(settings.verbose > 1) {', '-             fprintf(stderr,', '-                 ""command: %d, opaque=%08x, keylen=%d, total_len=%d\\n"", c->cmd,', '-                 c->opaque, c->keylen, c->bin_header[2]);', '-         }', '-         dispatch_bin_command(c);', '-     } else {', '-         switch(c->substate) {', '-             case bin_reading_set_header:', '-                 process_bin_update(c);', '-                 break;', '-             case bin_read_set_value:', '-                 complete_update_bin(c);', '-                 break;', '-             case bin_reading_get_key:', '-                 process_bin_get(c);', '-                 break;', '-             case bin_reading_del_header:', '-                 process_bin_delete(c);', '-                 break;', '-             case bin_reading_incr_header:', '-                 complete_incr_bin(c);', '-                 break;', '-             default:', '-                 fprintf(stderr, ""not handling substate %d\\n"", c->substate);', '-                 assert(0);', '-         }', '-     }', '- }', '- ', '- static void reinit_bin_connection(conn *c) {', '-     if (settings.verbose > 1)', '-         fprintf(stderr, ""*** reinitializing binary connection.\\n"");', '-     c->rlbytes = min_bin_pkt_length;', '-     c->write_and_go = conn_bin_init;', '-     c->rbytes = c->wbytes = 0;', '-     c->ritem = (char*)c->bin_header;', '-     c->rcurr = c->rbuf;', '-     c->wcurr = c->wbuf;', '-     conn_set_state(c, conn_nread);', '- }', '- ', '- static void setup_bin_protocol(conn *c) {', '-     char *loc = (char*)c->bin_header;', '-     if (settings.verbose > 1)', '-         fprintf(stderr, ""negotiated protocol as binary.\\n"");', '- ', '-     c->protocol = binary_prot;', '-     reinit_bin_connection(c);', '-     c->ritem[0] = c->rbuf[0];', '-     c->ritem++;', '-     c->rlbytes--;', '- }', '- ', '- static void setup_ascii_protocol(conn *c) {', '-     if (settings.verbose > 1)', '-         fprintf(stderr, ""negotiated protocol as ascii.\\n"");', '-     c->protocol = ascii_prot;', '- ', '-     c->rcurr = c->rbuf;', '-     c->rbytes = 1;', '-     conn_set_state(c, conn_read);', '-     } else if(c->protocol == binary_prot) {', '-     } else if(c->protocol == negotiating_prot) {', '-         if ((c->rbuf[0] & 0xff) == bin_req_magic)', '-             setup_bin_protocol(c);', '-         else', '-             setup_ascii_protocol(c);', '-     } else {', '-         c->write_and_go = get_init_state(c);', '-                 if(return_cas == true)', '-             conn_set_init_state(c);', '-     char *el, *cont;', '- ', '-     if (c->rbytes == 0)', '-         return 0;', ""-     el = memchr(c->rcurr, '\\n', c->rbytes);"", '-     if (!el)', '-         return 0;', '-     cont = el + 1;', ""-     if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {"", '-         el--;', ""-     *el = '\\0';"", '-     assert(cont <= (c->rcurr + c->rbytes));', '-     process_command(c, c->rcurr);', '-     c->rbytes -= (cont - c->rcurr);', '-     c->rcurr = cont;', '-     assert(c->rcurr <= (c->rbuf + c->rsize));', '-                 return 1;', '-             conn_set_state(c, conn_closing);', '-             return 1;', '-             if (errno == eagain || errno == ewouldblock) break;', '-             conn_set_state(c, conn_closing);', '-             return 1;', '-             init_state = get_init_state(c);', '-             dispatch_conn_new(sfd, init_state, ev_read | ev_persist,', '- ', '-             break;', '- ', '-         case conn_negotiate:', '-             if (settings.verbose > 1)', '-                 fprintf(stderr, ""negotiating protocol for a new connection\\n"");', '-             c->rlbytes = 1;', '-             c->ritem = c->rbuf;', '-             c->rcurr = c->rbuf;', '-             c->wcurr = c->wbuf;', '-             conn_set_state(c, conn_nread);', '-         case conn_read:', '-             if (try_read_command(c) != 0) {', '-                 continue;', '-             }', '-             if ((is_udp(c->protocol) ? try_read_udp(c) : try_read_network(c)) != 0) {', '-                 continue;', '-             }', '-             reinit_bin_connection(c);', '-                 memcpy(c->ritem, c->rcurr, tocopy);', '-                 break;', '-                 conn_set_init_state(c);', '-                         conn_set_init_state(c);', '-     while ((c = getopt(argc, argv, ""a:bp:b:s:u:m:mc:khirvdl:u:p:f:s:n:t:d:"")) != -1) {', '- #if defined(have_getpagesizes) && defined(have_memcntl)', '-             break;']]","[['+ static const char *prot_text(enum protocol prot) {', '+             fprintf(stderr, ""<%d new auto-negotiating client connection\\n"",', '+                     sfd);', '+ static const char *state_text(enum conn_states state) {', '+     const char* const statenames[] = { ""conn_listening"",', '+                                        ""conn_new_cmd"",', '+                                        ""conn_waiting"",', '+                                        ""conn_read"",', '+                                        ""conn_parse_cmd"",', '+                                        ""conn_write"",', '+                                        ""conn_nread"",', '+                                        ""conn_swallow"",', '+                                        ""conn_closing"",', '+                                        ""conn_mwrite"" };', '+     return statenames[state];', '+ }', '+ ', '+     assert(state >= conn_listening && state < conn_max_state);', '+         if (settings.verbose > 2) {', '+             fprintf(stderr, ""%d: going from %s to %s\\n"",', '+                     c->sfd, state_text(c->state),', '+                     state_text(state));', '+ ', '+         conn_set_state(c, conn_new_cmd);', '+     c->write_and_go = conn_new_cmd;', '+     const char *errstr = ""Unknown error"";', '+         case ERR_OUT_OF_MEMORY:', '+             errstr = ""Out of memory"";', '+             break;', '+         c->write_and_go = conn_new_cmd;', '+     c->write_and_go = conn_new_cmd;', '+             conn_set_state(c, conn_new_cmd);', '+     assert(c->cmd >= 0);', '+ ', '+     switch(c->substate) {', '+     case bin_reading_set_header:', '+         process_bin_update(c);', '+         break;', '+     case bin_read_set_value:', '+         complete_update_bin(c);', '+         break;', '+     case bin_reading_get_key:', '+         process_bin_get(c);', '+         break;', '+     case bin_reading_del_header:', '+         process_bin_delete(c);', '+         break;', '+     case bin_reading_incr_header:', '+         complete_incr_bin(c);', '+         break;', '+     default:', '+         fprintf(stderr, ""Not handling substate %d\\n"", c->substate);', '+         assert(0);', '+     }', '+ }', '+ ', '+ static void reset_cmd_handler(conn *c) {', '+     if (c->rbytes > 0) {', '+         conn_set_state(c, conn_parse_cmd);', '+     } else {', '+         conn_set_state(c, conn_waiting);', '+     }', '+     assert(c->protocol == ascii_prot || c->protocol == binary_prot);', '+     } else if (c->protocol == binary_prot) {', '+         c->write_and_go = conn_new_cmd;', '+                 if (return_cas)', '+             conn_set_state(c, conn_new_cmd);', '+     assert(c->rbytes > 0);', '+ ', '+     if (c->protocol == negotiating_prot)  {', '+         if ((c->rbuf[0] & 0xff) == BIN_REQ_MAGIC) {', '+             c->protocol = binary_prot;', '+         } else {', '+             c->protocol = ascii_prot;', '+         }', '+         if (settings.verbose) {', '+             fprintf(stderr, ""%d: Client using the %s protocol\\n"", c->sfd,', '+                     prot_text(c->protocol));', '+         }', '+     if (c->protocol == binary_prot) {', '+         if (c->rbytes < MIN_BIN_PKT_LENGTH) {', '+             return 0;', '+         } else {', '+             int i = 0;', '+             memcpy(c->bin_header, c->rcurr, sizeof(c->bin_header));', '+             assert(BIN_PKT_HDR_WORDS == 4);', '+             for (i = 0; i<BIN_PKT_HDR_WORDS; i++) {', '+                 c->bin_header[i] = ntohl(c->bin_header[i]);', '+             }', '+ ', '+             if (settings.verbose) {', '+                 fprintf(stderr,', '+                         ""Read binary protocol data:  %08x %08x %08x %08x\\n"",', '+                         c->bin_header[0], c->bin_header[1], c->bin_header[2],', '+                         c->bin_header[3]);', '+             }', '+             if ((c->bin_header[0] >> 24) != BIN_REQ_MAGIC) {', '+                 if (settings.verbose) {', '+                     fprintf(stderr, ""Invalid magic:  %x\\n"",', '+                             c->bin_header[0] >> 24);', '+                 }', '+                 conn_set_state(c, conn_closing);', '+                 return 0;', '+             }', '+             c->msgcurr = 0;', '+             c->msgused = 0;', '+             c->iovused = 0;', '+             if (add_msghdr(c) != 0) {', '+                 out_string(c, ""SERVER_ERROR out of memory"");', '+                 return 0;', '+             }', '+             c->cmd = (c->bin_header[0] >> 16) & 0xff;', '+             c->keylen = c->bin_header[0] & 0xffff;', '+             c->opaque = c->bin_header[3];', '+             if (settings.verbose > 1) {', '+                 fprintf(stderr,', '+                         ""Command: %d, opaque=%08x, keylen=%d, total_len=%d\\n"",', '+                         c->cmd, c->opaque, c->keylen, c->bin_header[2]);', '+             }', '+ ', '+             dispatch_bin_command(c);', '+ ', '+             c->rbytes -= MIN_BIN_PKT_LENGTH;', '+             c->rcurr += MIN_BIN_PKT_LENGTH;', '+         }', '+     } else {', '+         char *el, *cont;', '+ ', '+         if (c->rbytes == 0)', '+             return 0;', ""+         el = memchr(c->rcurr, '\\n', c->rbytes);"", '+         if (!el)', '+             return 0;', '+         cont = el + 1;', ""+         if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {"", '+             el--;', '+         }', ""+         *el = '\\0';"", '+ ', '+         assert(cont <= (c->rcurr + c->rbytes));', '+ ', '+         process_command(c, c->rcurr);', '+ ', '+         c->rbytes -= (cont - c->rcurr);', '+         c->rcurr = cont;', '+ ', '+         assert(c->rcurr <= (c->rbuf + c->rsize));', '+     }', '+                 return -2;', '+             return -1;', '+             if (errno == EAGAIN || errno == EWOULDBLOCK) {', '+                 break;', '+             }', '+             return -1;', '+             dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,', '+             stop = true;', '+         case conn_waiting:', '+ ', '+             conn_set_state(c, conn_read);', '+         case conn_read:', '+             res = IS_UDP(c->protocol) ? try_read_udp(c) : try_read_network(c);', '+             switch (res) {', '+             case 0 :', '+                 conn_set_state(c, conn_waiting);', '+                 break;', '+             case 1:', '+                 conn_set_state(c, conn_parse_cmd);', '+                 break;', '+             case -1:', '+                 conn_set_state(c, conn_closing);', '+                 break;', '+                 break;', '+             }', '+             break;', '+ ', '+         case conn_parse_cmd :', '+             if (try_read_command(c) == 0) {', '+                 conn_set_state(c, conn_waiting);', '+             }', '+ ', '+             break;', '+ ', '+         case conn_new_cmd:', '+             reset_cmd_handler(c);', '+             assoc_move_next_bucket();', '+                 memmove(c->ritem, c->rcurr, tocopy);', '+                 if (c->rlbytes == 0) {', '+                     break;', '+                 }', '+                 conn_set_state(c, conn_new_cmd);', '+                         conn_set_state(c, conn_new_cmd);', '+            ""-vvv          extremely verbose (also print internal state transitions)\\n""', '+     while ((c = getopt(argc, argv, ""a:bp:s:U:m:Mc:khirvdl:u:P:f:s:n:t:D:L"")) != -1) {', '+ #if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)', '+             break;']]","[['- static char *prot_text(enum protocol prot) {', '-         } else if (prot == binary_prot) {', '-             fprintf(stderr, ""<%d new binary client connection\\n"", sfd);', '-         } else if (prot == ascii_prot) {', '-             fprintf(stderr, ""<%d new ascii client connection\\n"", sfd);', '-             fprintf(stderr, ""<%d new auto-negotiating client connection\\n"", sfd);', '- static enum conn_states get_init_state(conn *c) {', '-     int rv = 0;', '-     assert(c != NULL);', '- ', '-     switch(c->protocol) {', '-         case binary_prot:', '-             rv = conn_bin_init;', '-             break;', '-         case negotiating_prot:', '-             rv = conn_negotiate;', '-             break;', '-         default:', '-             rv = conn_read;', '-     }', '-     return rv;', '- }', '- ', '- static void conn_set_init_state(conn *c) {', '-     assert(c != NULL);', '- ', '-     conn_set_state(c, get_init_state(c));', '- }', '- ', '-         if (state == conn_read) {', '-             conn_shrink(c);', '-             assoc_move_next_bucket();', '-         conn_set_state(c, conn_read);', '-     c->write_and_go = get_init_state(c);', '-     char *errstr = ""Unknown error"";', '-         c->write_and_go = conn_bin_init;', '-     c->write_and_go = conn_bin_init;', '-             conn_set_state(c, conn_bin_init);', '- ', '-     if(c->cmd < 0) {', '-         int i = 0;', '-         assert(BIN_PKT_HDR_WORDS == 4);', '-         for(i = 0; i<BIN_PKT_HDR_WORDS; i++) {', '-             c->bin_header[i] = ntohl(c->bin_header[i]);', '-         }', '-         if(settings.verbose) {', '-             fprintf(stderr, ""Read binary protocol data:  %08x %08x %08x %08x\\n"",', '-                 c->bin_header[0], c->bin_header[1], c->bin_header[2],', '-                 c->bin_header[3]);', '-         }', '-         if((c->bin_header[0] >> 24) != BIN_REQ_MAGIC) {', '-             if(settings.verbose) {', '-                 fprintf(stderr, ""Invalid magic:  %x\\n"", c->bin_header[0] >> 24);', '-             }', '-             conn_set_state(c, conn_closing);', '-             return;', '-         }', '- ', '-         c->msgcurr = 0;', '-         c->msgused = 0;', '-         c->iovused = 0;', '-         if (add_msghdr(c) != 0) {', '-             out_string(c, ""SERVER_ERROR out of memory"");', '-             return;', '-         }', '- ', '-         c->cmd = (c->bin_header[0] >> 16) & 0xff;', '-         c->keylen = c->bin_header[0] & 0xffff;', '-         c->opaque = c->bin_header[3];', '-         if(settings.verbose > 1) {', '-             fprintf(stderr,', '-                 ""Command: %d, opaque=%08x, keylen=%d, total_len=%d\\n"", c->cmd,', '-                 c->opaque, c->keylen, c->bin_header[2]);', '-         }', '-         dispatch_bin_command(c);', '-     } else {', '-         switch(c->substate) {', '-             case bin_reading_set_header:', '-                 process_bin_update(c);', '-                 break;', '-             case bin_read_set_value:', '-                 complete_update_bin(c);', '-                 break;', '-             case bin_reading_get_key:', '-                 process_bin_get(c);', '-                 break;', '-             case bin_reading_del_header:', '-                 process_bin_delete(c);', '-                 break;', '-             case bin_reading_incr_header:', '-                 complete_incr_bin(c);', '-                 break;', '-             default:', '-                 fprintf(stderr, ""Not handling substate %d\\n"", c->substate);', '-                 assert(0);', '-         }', '-     }', '- }', '- ', '- static void reinit_bin_connection(conn *c) {', '-     if (settings.verbose > 1)', '-         fprintf(stderr, ""*** Reinitializing binary connection.\\n"");', '-     c->rlbytes = MIN_BIN_PKT_LENGTH;', '-     c->write_and_go = conn_bin_init;', '-     c->rbytes = c->wbytes = 0;', '-     c->ritem = (char*)c->bin_header;', '-     c->rcurr = c->rbuf;', '-     c->wcurr = c->wbuf;', '-     conn_set_state(c, conn_nread);', '- }', '- ', '- static void setup_bin_protocol(conn *c) {', '-     char *loc = (char*)c->bin_header;', '-     if (settings.verbose > 1)', '-         fprintf(stderr, ""Negotiated protocol as binary.\\n"");', '- ', '-     c->protocol = binary_prot;', '-     reinit_bin_connection(c);', '-     c->ritem[0] = c->rbuf[0];', '-     c->ritem++;', '-     c->rlbytes--;', '- }', '- ', '- static void setup_ascii_protocol(conn *c) {', '-     if (settings.verbose > 1)', '-         fprintf(stderr, ""Negotiated protocol as ascii.\\n"");', '-     c->protocol = ascii_prot;', '- ', '-     c->rcurr = c->rbuf;', '-     c->rbytes = 1;', '-     conn_set_state(c, conn_read);', '-     } else if(c->protocol == binary_prot) {', '-     } else if(c->protocol == negotiating_prot) {', '-         if ((c->rbuf[0] & 0xff) == BIN_REQ_MAGIC)', '-             setup_bin_protocol(c);', '-         else', '-             setup_ascii_protocol(c);', '-     } else {', '-         c->write_and_go = get_init_state(c);', '-                 if(return_cas == true)', '-             conn_set_init_state(c);', '-     char *el, *cont;', '- ', '-     if (c->rbytes == 0)', '-         return 0;', ""-     el = memchr(c->rcurr, '\\n', c->rbytes);"", '-     if (!el)', '-         return 0;', '-     cont = el + 1;', ""-     if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {"", '-         el--;', ""-     *el = '\\0';"", '-     assert(cont <= (c->rcurr + c->rbytes));', '-     process_command(c, c->rcurr);', '-     c->rbytes -= (cont - c->rcurr);', '-     c->rcurr = cont;', '-     assert(c->rcurr <= (c->rbuf + c->rsize));', '-                 return 1;', '-             conn_set_state(c, conn_closing);', '-             return 1;', '-             if (errno == EAGAIN || errno == EWOULDBLOCK) break;', '-             conn_set_state(c, conn_closing);', '-             return 1;', '-             init_state = get_init_state(c);', '-             dispatch_conn_new(sfd, init_state, EV_READ | EV_PERSIST,', '- ', '-             break;', '- ', '-         case conn_negotiate:', '-             if (settings.verbose > 1)', '-                 fprintf(stderr, ""Negotiating protocol for a new connection\\n"");', '-             c->rlbytes = 1;', '-             c->ritem = c->rbuf;', '-             c->rcurr = c->rbuf;', '-             c->wcurr = c->wbuf;', '-             conn_set_state(c, conn_nread);', '-         case conn_read:', '-             if (try_read_command(c) != 0) {', '-                 continue;', '-             }', '-             if ((IS_UDP(c->protocol) ? try_read_udp(c) : try_read_network(c)) != 0) {', '-                 continue;', '-             }', '-             reinit_bin_connection(c);', '-                 memcpy(c->ritem, c->rcurr, tocopy);', '-                 break;', '-                 conn_set_init_state(c);', '-                         conn_set_init_state(c);', '-     while ((c = getopt(argc, argv, ""a:bp:B:s:U:m:Mc:khirvdl:u:P:f:s:n:t:D:"")) != -1) {', '- #if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)', '-             break;']]",195,191.0,386.0,f1351f9bbaae4fd923722f5563843f5d1c54a5f7memcached/memcached,['75cc83685e103bc8ba380a57468c8f04413033f9']
60511d72b8ca2d636624f5292d0cec7ad9742828,Dieterbe/uzbl,tests/test-command.c,train,C,1,"['@@ -178,9 +178,9 @@ test_set_variable (struct EventFixture *ef, const void *data) {\n     (void) data;\n \n     /* set a string */\n-    parse_cmd_line(""set status_message = A Simple Testing Message"", NULL);\n-    ASSERT_EVENT(ef, ""VARIABLE_SET status_message str A Simple Testing Message"");\n-    g_assert_cmpstr(""A Simple Testing Message"", ==, uzbl.gui.sbar.msg);\n+    parse_cmd_line(""set useragent = Uzbl browser kthxbye!"", NULL);\n+    ASSERT_EVENT(ef, ""VARIABLE_SET useragent str Uzbl browser kthxbye!"");\n+    g_assert_cmpstr(""Uzbl browser kthxbye!"", ==, uzbl.net.useragent);\n \n     /* set an int */\n     parse_cmd_line(""set forward_keys = 0"", NULL);\n@@ -306,9 +306,9 @@ test_js (void) {\n     g_assert_cmpstr(""X345"", ==, result->str);\n \n     /* uzbl commands can be run from javascript */\n-    uzbl.gui.sbar.msg = ""Test message"";\n-    parse_cmd_line(""js Uzbl.run(\'print @status_message\').toUpperCase();"", result);\n-    g_assert_cmpstr(""TEST MESSAGE"", ==, result->str);\n+    uzbl.net.useragent = ""Test useragent"";\n+    parse_cmd_line(""js Uzbl.run(\'print @useragent\').toUpperCase();"", result);\n+    g_assert_cmpstr(""TEST USERAGENT"", ==, result->str);\n \n     g_string_free(result, TRUE);\n }\n@@ -330,8 +330,8 @@ test_run_handler_arg_order (void) {\n \n void\n test_run_handler_expand (void) {\n-    uzbl.gui.sbar.msg = ""Test message"";\n-    run_handler(""sync_spawn echo @status_message"", ""result:"");\n+    uzbl.net.useragent = ""Test uzbl uzr agent"";\n+    run_handler(""sync_spawn echo @useragent"", ""result:"");\n \n     assert(uzbl.comm.sync_stdout);\n \n@@ -340,7 +340,7 @@ test_run_handler_expand (void) {\n \n     /* the rest of the result should be the arguments passed to run_handler. */\n     /* the user-specified arguments to the handler should have been expanded */\n-    g_assert_cmpstr(""result: Test message\\n"", ==, rest);\n+    g_assert_cmpstr(""result: Test uzbl uzr agent\\n"", ==, rest);\n }\n \n int\n']",2009-11-12 21:19:11+01:00,status_message is not a built-in variable anymore so the unit tests must use another built-in variable for testing built-in variable stuff,"[['+     parse_cmd_line(""set useragent = Uzbl browser kthxbye!"", NULL);', '+     ASSERT_EVENT(ef, ""VARIABLE_SET useragent str Uzbl browser kthxbye!"");', '+     g_assert_cmpstr(""Uzbl browser kthxbye!"", ==, uzbl.net.useragent);', '+     uzbl.net.useragent = ""Test useragent"";', '+     parse_cmd_line(""js Uzbl.run(\'print @useragent\').toUpperCase();"", result);', '+     g_assert_cmpstr(""TEST USERAGENT"", ==, result->str);', '+     uzbl.net.useragent = ""Test uzbl uzr agent"";', '+     run_handler(""sync_spawn echo @useragent"", ""result:"");', '+     g_assert_cmpstr(""result: Test uzbl uzr agent\\n"", ==, rest);', '-     parse_cmd_line(""set status_message = A Simple Testing Message"", NULL);', '-     ASSERT_EVENT(ef, ""VARIABLE_SET status_message str A Simple Testing Message"");', '-     g_assert_cmpstr(""A Simple Testing Message"", ==, uzbl.gui.sbar.msg);', '-     uzbl.gui.sbar.msg = ""Test message"";', '-     parse_cmd_line(""js Uzbl.run(\'print @status_message\').toUpperCase();"", result);', '-     g_assert_cmpstr(""TEST MESSAGE"", ==, result->str);', '-     uzbl.gui.sbar.msg = ""Test message"";', '-     run_handler(""sync_spawn echo @status_message"", ""result:"");', '-     g_assert_cmpstr(""result: Test message\\n"", ==, rest);']]","[['+     parse_cmd_line(""set useragent = uzbl browser kthxbye!"", null);', '+     assert_event(ef, ""variable_set useragent str uzbl browser kthxbye!"");', '+     g_assert_cmpstr(""uzbl browser kthxbye!"", ==, uzbl.net.useragent);', '+     uzbl.net.useragent = ""test useragent"";', '+     parse_cmd_line(""js uzbl.run(\'print @useragent\').touppercase();"", result);', '+     g_assert_cmpstr(""test useragent"", ==, result->str);', '+     uzbl.net.useragent = ""test uzbl uzr agent"";', '+     run_handler(""sync_spawn echo @useragent"", ""result:"");', '+     g_assert_cmpstr(""result: test uzbl uzr agent\\n"", ==, rest);', '-     parse_cmd_line(""set status_message = a simple testing message"", null);', '-     assert_event(ef, ""variable_set status_message str a simple testing message"");', '-     g_assert_cmpstr(""a simple testing message"", ==, uzbl.gui.sbar.msg);', '-     uzbl.gui.sbar.msg = ""test message"";', '-     parse_cmd_line(""js uzbl.run(\'print @status_message\').touppercase();"", result);', '-     g_assert_cmpstr(""test message"", ==, result->str);', '-     uzbl.gui.sbar.msg = ""test message"";', '-     run_handler(""sync_spawn echo @status_message"", ""result:"");', '-     g_assert_cmpstr(""result: test message\\n"", ==, rest);']]","[['+     parse_cmd_line(""set useragent = Uzbl browser kthxbye!"", NULL);', '+     ASSERT_EVENT(ef, ""VARIABLE_SET useragent str Uzbl browser kthxbye!"");', '+     g_assert_cmpstr(""Uzbl browser kthxbye!"", ==, uzbl.net.useragent);', '+     uzbl.net.useragent = ""Test useragent"";', '+     parse_cmd_line(""js Uzbl.run(\'print @useragent\').toUpperCase();"", result);', '+     g_assert_cmpstr(""TEST USERAGENT"", ==, result->str);', '+     uzbl.net.useragent = ""Test uzbl uzr agent"";', '+     run_handler(""sync_spawn echo @useragent"", ""result:"");', '+     g_assert_cmpstr(""result: Test uzbl uzr agent\\n"", ==, rest);']]","[['-     parse_cmd_line(""set status_message = A Simple Testing Message"", NULL);', '-     ASSERT_EVENT(ef, ""VARIABLE_SET status_message str A Simple Testing Message"");', '-     g_assert_cmpstr(""A Simple Testing Message"", ==, uzbl.gui.sbar.msg);', '-     uzbl.gui.sbar.msg = ""Test message"";', '-     parse_cmd_line(""js Uzbl.run(\'print @status_message\').toUpperCase();"", result);', '-     g_assert_cmpstr(""TEST MESSAGE"", ==, result->str);', '-     uzbl.gui.sbar.msg = ""Test message"";', '-     run_handler(""sync_spawn echo @status_message"", ""result:"");', '-     g_assert_cmpstr(""result: Test message\\n"", ==, rest);']]",9,9.0,18.0,60511d72b8ca2d636624f5292d0cec7ad9742828Dieterbe/uzbl,['1958b52d41cba96956dc1995660de49525ed1047']
42d9d6ab320ee3a661fe21472be542acd542d5be,krb5/krb5,src/plugins/kdb/ldap/libkdb_ldap/ldap_pwd_policy.c,train,C,1,"['@@ -0,0 +1,307 @@\n+/*\n+ * lib/kdb/kdb_ldap/ldap_pwd_policy.c\n+ *\n+ * Copyright (c) 2004-2005, Novell, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *   * Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *   * Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *   * The copyright holder\'s name is not used to endorse or promote products\n+ *       derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ""AS IS""\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+#include ""ldap_main.h""\n+#include ""kdb_ldap.h""\n+#include ""ldap_pwd_policy.h""\n+#include ""ldap_err.h""\n+\n+static char *password_policy_attributes[] = { ""krbmaxpwdlife"", ""krbminpwdlife"", ""krbpwdmindiffchars"",\n+\t\t\t\t\t      ""krbpwdminlength"", ""krbpwdhistorylength"", ""krbpwdpolicyrefcount"", \n+\t\t\t\t\t      NULL };\n+\n+/*\n+ * Function to create password policy object. \n+ */\n+\n+krb5_error_code\n+krb5_ldap_create_password_policy (context, policy)\n+    krb5_context                context;\n+    osa_policy_ent_t            policy;\n+{\n+    krb5_error_code \t        st=0;\n+    LDAP  \t\t        *ld=NULL;\n+    LDAPMod \t\t        **mods={NULL};\n+    kdb5_dal_handle             *dal_handle=NULL;\n+    krb5_ldap_context           *ldap_context=NULL;\n+    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n+    char                        **rdns=NULL, *strval[2]={NULL};\n+\n+    /* Clear the global error string */\n+    krb5_clear_error_message(context);\n+\n+    /* validate the input parameters */\n+    if (policy == NULL || policy->name == NULL) \n+\treturn EINVAL;\n+\n+    SETUP_CONTEXT();\n+    GET_HANDLE();\n+\n+    /* get the first component of the dn to set the cn attribute */\n+    rdns = ldap_explode_dn(policy->name, 1);\n+    if (rdns == NULL) {\n+        st = EINVAL;\n+        krb5_set_error_message(context, st, ""Invalid password policy DN syntax"");\n+\tgoto cleanup;\n+    }\n+    \n+    strval[0] = rdns[0];\n+    if ((st=krb5_add_str_mem_ldap_mod(&mods, ""cn"", LDAP_MOD_ADD, strval)) != 0)\n+      goto cleanup;\n+    \n+    strval[0] = ""krbPwdPolicy"";\n+    if ((st=krb5_add_str_mem_ldap_mod(&mods, ""objectclass"", LDAP_MOD_ADD, strval)) != 0)\n+      goto cleanup;\n+    \n+    if (((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxpwdlife"", LDAP_MOD_ADD, \n+\t\t\t\t       (signed) policy->pw_max_life)) != 0) \n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbminpwdlife"", LDAP_MOD_ADD,\n+\t\t\t\t\t  (signed) policy->pw_min_life)) != 0)\n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdmindiffchars"", LDAP_MOD_ADD,\n+\t\t\t\t\t  (signed) policy->pw_min_classes)) != 0)\n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdminlength"", LDAP_MOD_ADD,\n+\t\t\t\t\t  (signed) policy->pw_min_length)) != 0)\n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdhistorylength"", LDAP_MOD_ADD,\n+\t\t\t\t\t  (signed) policy->pw_history_num)) != 0)\n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdpolicyrefcount"", LDAP_MOD_ADD,\n+\t\t\t\t\t  (signed) policy->policy_refcnt)) != 0))\n+\tgoto cleanup;\n+\n+    /* password policy object creation */\n+    if ((st=ldap_add_s(ld, policy->name, mods)) != LDAP_SUCCESS) {\n+        st = set_ldap_error (context, st, OP_ADD);\n+\tgoto cleanup;\n+    }\n+    \n+ cleanup:\n+    if (rdns)\n+\tldap_value_free(rdns);\n+\n+    ldap_mods_free(mods, 1);\n+    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n+    return(st);\n+}\n+\n+/*\n+ * Function to modify password policy object.\n+ */\n+\n+krb5_error_code\n+krb5_ldap_put_password_policy (context, policy)\n+    krb5_context                context;\n+    osa_policy_ent_t            policy;\n+{\n+    krb5_error_code \t        st=0;\n+    LDAP  \t\t        *ld=NULL;\n+    LDAPMod \t\t        **mods=NULL;\n+    kdb5_dal_handle             *dal_handle=NULL;\n+    krb5_ldap_context           *ldap_context=NULL;\n+    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n+\n+    /* Clear the global error string */\n+    krb5_clear_error_message(context);\n+\n+    /* validate the input parameters */\n+    if (policy == NULL || policy->name == NULL) \n+\treturn EINVAL;\n+\n+    SETUP_CONTEXT();\n+    GET_HANDLE();\n+\n+    if (((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxpwdlife"", LDAP_MOD_REPLACE,\n+\t\t\t\t       (signed) policy->pw_max_life)) != 0)\n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbminpwdlife"", LDAP_MOD_REPLACE,\n+\t\t\t\t\t  (signed) policy->pw_min_life)) != 0)\n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdmindiffchars"", LDAP_MOD_REPLACE,\n+\t\t\t\t\t  (signed) policy->pw_min_classes)) != 0)\n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdminlength"", LDAP_MOD_REPLACE,\n+\t\t\t\t\t  (signed) policy->pw_min_length)) != 0)\n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdhistorylength"", LDAP_MOD_REPLACE,\n+\t\t\t\t\t  (signed) policy->pw_history_num)) != 0)\n+\t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdpolicyrefcount"", LDAP_MOD_REPLACE,\n+\t\t\t\t\t  (signed) policy->policy_refcnt)) != 0))\n+\tgoto cleanup;\n+    \n+    /* modify the password policy object. */\n+    if ((st=ldap_modify_s(ld, policy->name, mods)) != LDAP_SUCCESS) {\n+        st = set_ldap_error (context, st, OP_MOD);\n+\tgoto cleanup;\n+    }\n+    \n+ cleanup:\n+    ldap_mods_free(mods, 1);\n+    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);    \n+    return(st);\n+}\n+\n+krb5_error_code \n+krb5_ldap_get_password_policy (context, name, policy, cnt)\n+    krb5_context                context;\n+    char                        *name;\n+    osa_policy_ent_t            *policy;\n+    int                         *cnt;\n+{\n+    krb5_error_code             st=0, tempst=0;\n+    LDAP  \t\t        *ld=NULL;\n+    LDAPMessage                 *result=NULL,*ent=NULL;  \n+    kdb5_dal_handle             *dal_handle=NULL;\n+    krb5_ldap_context           *ldap_context=NULL;\n+    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n+\n+    /* Clear the global error string */\n+    krb5_clear_error_message(context);\n+\n+    /* validate the input parameters */\n+    if(name == NULL)\n+\treturn EINVAL;\n+    \n+    SETUP_CONTEXT();\n+    GET_HANDLE();\n+\n+    *cnt = 0;\n+    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n+    if (*policy == NULL) {\n+\t st = ENOMEM;\n+\t goto cleanup;\n+    }\n+    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n+\n+    LDAP_SEARCH(name, LDAP_SCOPE_BASE, ""(objectclass=krbPwdPolicy)"", password_policy_attributes);\n+    *cnt = 1;\n+    (*policy)->name = name;\n+    (*policy)->version = 1;\n+\n+    ent=ldap_first_entry(ld, result);\n+    if (ent != NULL) {\n+\tkrb5_ldap_get_value(ld, ent, ""krbmaxpwdlife"", &((*policy)->pw_max_life));\n+\tkrb5_ldap_get_value(ld, ent, ""krbminpwdlife"", &((*policy)->pw_min_life));\n+\tkrb5_ldap_get_value(ld, ent, ""krbpwdmindiffchars"", &((*policy)->pw_min_classes));\n+\tkrb5_ldap_get_value(ld, ent, ""krbpwdminlength"", &((*policy)->pw_min_length));\n+\tkrb5_ldap_get_value(ld, ent, ""krbpwdhistorylength"", &((*policy)->pw_history_num));\n+\tkrb5_ldap_get_value(ld, ent, ""krbpwdpolicyrefcount"", &((*policy)->policy_refcnt));\n+    }\n+\n+cleanup:\n+    ldap_msgfree(result);\n+    if (st != 0) {\n+\tif (*policy != NULL) {\n+\t    free (*policy);\n+\t    *policy = NULL;\n+\t}\n+    }\n+    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n+    return st;\n+}\n+\n+krb5_error_code\n+krb5_ldap_delete_password_policy (context, policy)\n+    krb5_context                context;\n+    char                        *policy;\n+{\n+    krb5_error_code             st=0;\n+    LDAP                        *ld=NULL;\n+    kdb5_dal_handle             *dal_handle=NULL;\n+    krb5_ldap_context           *ldap_context=NULL;\n+    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n+\n+    /* Clear the global error string */\n+    krb5_clear_error_message(context);\n+\n+    /* validate the input parameters */\n+    if(policy == NULL)\n+        return EINVAL;\n+\n+    SETUP_CONTEXT();\n+    GET_HANDLE();\n+\n+    if((st=ldap_delete_s(ld, policy)) != LDAP_SUCCESS) {\n+        st = set_ldap_error (context, st, OP_DEL);\n+        goto cleanup;\n+    }\n+\n+cleanup:\n+    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n+    return st;\n+}\n+\n+krb5_error_code\n+krb5_ldap_iterate_password_policy(context, match_expr, func, func_arg) \n+    krb5_context                context;\n+    char                        *match_expr;\n+    void                        (*func) (krb5_pointer, osa_policy_ent_t );\n+    krb5_pointer                func_arg;\n+{\n+    osa_policy_ent_rec          *entry=NULL;\n+    char\t\t        *attrs[] = { ""cn"", NULL };\n+    krb5_error_code             st=0, tempst=0;\n+    LDAP\t\t        *ld=NULL;\n+    LDAPMessage\t                *result=NULL, *ent=NULL;\n+    kdb5_dal_handle             *dal_handle=NULL;\n+    krb5_ldap_context           *ldap_context=NULL;\n+    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n+    char \t\t        *policy_dn=NULL;\n+\n+    /* Clear the global error string */\n+    krb5_clear_error_message(context);\n+\n+    SETUP_CONTEXT();\n+    GET_HANDLE();\n+\n+    entry = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n+    CHECK_NULL(entry);\n+    memset(entry, 0, sizeof(osa_policy_ent_rec));\n+\n+    LDAP_SEARCH(NULL, LDAP_SCOPE_SUBTREE, ""(objectclass=krbpwdpolicy)"", attrs);\n+    for(ent=ldap_first_entry(ld, result); ent != NULL; ent=ldap_next_entry(ld, ent)) {\n+\tif ((policy_dn=ldap_get_dn(ld, ent)) == NULL)\n+\t    continue;\n+\tentry->name = policy_dn;\n+\t(*func)(func_arg, entry);\n+\tldap_memfree(policy_dn);\n+    }\n+    ldap_msgfree(result);\n+     \n+ cleanup:\n+    if (entry)\n+\tfree (entry);\n+    \n+    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n+    return st;\n+}\n+\n+void \n+krb5_ldap_free_password_policy (context, entry)\n+    krb5_context                context;\n+    osa_policy_ent_t            entry;\n+{\n+    if(entry)\n+        free(entry);\n+    return;\n+}\n']",2006-07-18 00:40:19+00:00,"Merge remaining changes from LDAP integration branch
svn+ssh://svn.mit.edu/krb5/branches/ldap-integ@18333.

* plugins/kdb/ldap: New directory.

* aclocal.m4 (WITH_LDAP): New macro.
(CONFIG_RULES): Invoke it.
* configure.in: Test ldap option, maybe configure and generate makefiles for
new directories, and set and substitute ldap_plugin_dir.
* Makefile.in (SUBDIRS): Add @ldap_plugin_dir@.

* kdc/krb5kdc.M, kadmin/server/kadmind.M, kadmin/cli/kadmin.M,
config-files/krb5.conf.M: Document LDAP changes (new options, config file
entries, etc).

* lib/kdb/kdb5.c (kdb_load_library): Put more info in error message.

* lib/kadm5/admin.h (KADM5_CPW_FUNCTION, KADM5_RANDKEY_USED,
KADM5_CONFIG_PASSWD_SERVER): New macros, disabled for now.
(struct _kadm5_config_params): New field kpasswd_server, commented out for now.
* lib/krb5/error_tables/kdb5_err.et: Add error codes KRB5_KDB_ACCESS_ERROR,
KRB5_KDB_INTERNAL_ERROR, KRB5_KDB_CONSTRAINT_VIOLATION.

ticket: 2935

git-svn-id: svn://anonsvn.mit.edu/krb5/trunk@18334 dc483132-0cff-0310-8789-dd5450dbe970","[['+ ', '+ #include ""ldap_main.h""', '+ #include ""kdb_ldap.h""', '+ #include ""ldap_pwd_policy.h""', '+ #include ""ldap_err.h""', '+ ', '+ static char *password_policy_attributes[] = { ""krbmaxpwdlife"", ""krbminpwdlife"", ""krbpwdmindiffchars"",', '+ \t\t\t\t\t      ""krbpwdminlength"", ""krbpwdhistorylength"", ""krbpwdpolicyrefcount"",', '+ \t\t\t\t\t      NULL };', '+ ', '+ ', '+ krb5_error_code', '+ krb5_ldap_create_password_policy (context, policy)', '+     krb5_context                context;', '+     osa_policy_ent_t            policy;', '+ {', '+     krb5_error_code \t        st=0;', '+     LDAP  \t\t        *ld=NULL;', '+     LDAPMod \t\t        **mods={NULL};', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+     char                        **rdns=NULL, *strval[2]={NULL};', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if (policy == NULL || policy->name == NULL)', '+ \treturn EINVAL;', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     rdns = ldap_explode_dn(policy->name, 1);', '+     if (rdns == NULL) {', '+         st = EINVAL;', '+         krb5_set_error_message(context, st, ""Invalid password policy DN syntax"");', '+ \tgoto cleanup;', '+     }', '+ ', '+     strval[0] = rdns[0];', '+     if ((st=krb5_add_str_mem_ldap_mod(&mods, ""cn"", LDAP_MOD_ADD, strval)) != 0)', '+       goto cleanup;', '+ ', '+     strval[0] = ""krbPwdPolicy"";', '+     if ((st=krb5_add_str_mem_ldap_mod(&mods, ""objectclass"", LDAP_MOD_ADD, strval)) != 0)', '+       goto cleanup;', '+ ', '+     if (((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxpwdlife"", LDAP_MOD_ADD,', '+ \t\t\t\t       (signed) policy->pw_max_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbminpwdlife"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->pw_min_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdmindiffchars"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->pw_min_classes)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdminlength"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->pw_min_length)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdhistorylength"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->pw_history_num)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdpolicyrefcount"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->policy_refcnt)) != 0))', '+ \tgoto cleanup;', '+ ', '+     if ((st=ldap_add_s(ld, policy->name, mods)) != LDAP_SUCCESS) {', '+         st = set_ldap_error (context, st, OP_ADD);', '+ \tgoto cleanup;', '+     }', '+ ', '+  cleanup:', '+     if (rdns)', '+ \tldap_value_free(rdns);', '+ ', '+     ldap_mods_free(mods, 1);', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return(st);', '+ }', '+ ', '+ ', '+ krb5_error_code', '+ krb5_ldap_put_password_policy (context, policy)', '+     krb5_context                context;', '+     osa_policy_ent_t            policy;', '+ {', '+     krb5_error_code \t        st=0;', '+     LDAP  \t\t        *ld=NULL;', '+     LDAPMod \t\t        **mods=NULL;', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if (policy == NULL || policy->name == NULL)', '+ \treturn EINVAL;', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     if (((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxpwdlife"", LDAP_MOD_REPLACE,', '+ \t\t\t\t       (signed) policy->pw_max_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbminpwdlife"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->pw_min_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdmindiffchars"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->pw_min_classes)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdminlength"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->pw_min_length)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdhistorylength"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->pw_history_num)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdpolicyrefcount"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->policy_refcnt)) != 0))', '+ \tgoto cleanup;', '+ ', '+     if ((st=ldap_modify_s(ld, policy->name, mods)) != LDAP_SUCCESS) {', '+         st = set_ldap_error (context, st, OP_MOD);', '+ \tgoto cleanup;', '+     }', '+ ', '+  cleanup:', '+     ldap_mods_free(mods, 1);', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return(st);', '+ }', '+ ', '+ krb5_error_code', '+ krb5_ldap_get_password_policy (context, name, policy, cnt)', '+     krb5_context                context;', '+     char                        *name;', '+     osa_policy_ent_t            *policy;', '+     int                         *cnt;', '+ {', '+     krb5_error_code             st=0, tempst=0;', '+     LDAP  \t\t        *ld=NULL;', '+     LDAPMessage                 *result=NULL,*ent=NULL;', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if(name == NULL)', '+ \treturn EINVAL;', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     *cnt = 0;', '+     *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));', '+     if (*policy == NULL) {', '+ \t st = ENOMEM;', '+ \t goto cleanup;', '+     }', '+     memset(*policy, 0, sizeof(osa_policy_ent_rec));', '+ ', '+     LDAP_SEARCH(name, LDAP_SCOPE_BASE, ""(objectclass=krbPwdPolicy)"", password_policy_attributes);', '+     *cnt = 1;', '+     (*policy)->name = name;', '+     (*policy)->version = 1;', '+ ', '+     ent=ldap_first_entry(ld, result);', '+     if (ent != NULL) {', '+ \tkrb5_ldap_get_value(ld, ent, ""krbmaxpwdlife"", &((*policy)->pw_max_life));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbminpwdlife"", &((*policy)->pw_min_life));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdmindiffchars"", &((*policy)->pw_min_classes));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdminlength"", &((*policy)->pw_min_length));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdhistorylength"", &((*policy)->pw_history_num));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdpolicyrefcount"", &((*policy)->policy_refcnt));', '+     }', '+ ', '+ cleanup:', '+     ldap_msgfree(result);', '+     if (st != 0) {', '+ \tif (*policy != NULL) {', '+ \t    free (*policy);', '+ \t    *policy = NULL;', '+ \t}', '+     }', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return st;', '+ }', '+ ', '+ krb5_error_code', '+ krb5_ldap_delete_password_policy (context, policy)', '+     krb5_context                context;', '+     char                        *policy;', '+ {', '+     krb5_error_code             st=0;', '+     LDAP                        *ld=NULL;', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if(policy == NULL)', '+         return EINVAL;', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     if((st=ldap_delete_s(ld, policy)) != LDAP_SUCCESS) {', '+         st = set_ldap_error (context, st, OP_DEL);', '+         goto cleanup;', '+     }', '+ ', '+ cleanup:', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return st;', '+ }', '+ ', '+ krb5_error_code', '+ krb5_ldap_iterate_password_policy(context, match_expr, func, func_arg)', '+     krb5_context                context;', '+     char                        *match_expr;', '+     void                        (*func) (krb5_pointer, osa_policy_ent_t );', '+     krb5_pointer                func_arg;', '+ {', '+     osa_policy_ent_rec          *entry=NULL;', '+     char\t\t        *attrs[] = { ""cn"", NULL };', '+     krb5_error_code             st=0, tempst=0;', '+     LDAP\t\t        *ld=NULL;', '+     LDAPMessage\t                *result=NULL, *ent=NULL;', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+     char \t\t        *policy_dn=NULL;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     entry = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));', '+     CHECK_NULL(entry);', '+     memset(entry, 0, sizeof(osa_policy_ent_rec));', '+ ', '+     LDAP_SEARCH(NULL, LDAP_SCOPE_SUBTREE, ""(objectclass=krbpwdpolicy)"", attrs);', '+     for(ent=ldap_first_entry(ld, result); ent != NULL; ent=ldap_next_entry(ld, ent)) {', '+ \tif ((policy_dn=ldap_get_dn(ld, ent)) == NULL)', '+ \t    continue;', '+ \tentry->name = policy_dn;', '+ \t(*func)(func_arg, entry);', '+ \tldap_memfree(policy_dn);', '+     }', '+     ldap_msgfree(result);', '+ ', '+  cleanup:', '+     if (entry)', '+ \tfree (entry);', '+ ', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return st;', '+ }', '+ ', '+ void', '+ krb5_ldap_free_password_policy (context, entry)', '+     krb5_context                context;', '+     osa_policy_ent_t            entry;', '+ {', '+     if(entry)', '+         free(entry);', '+     return;', '+ }']]","[['+ ', '+ #include ""ldap_main.h""', '+ #include ""kdb_ldap.h""', '+ #include ""ldap_pwd_policy.h""', '+ #include ""ldap_err.h""', '+ ', '+ static char *password_policy_attributes[] = { ""krbmaxpwdlife"", ""krbminpwdlife"", ""krbpwdmindiffchars"",', '+ \t\t\t\t\t      ""krbpwdminlength"", ""krbpwdhistorylength"", ""krbpwdpolicyrefcount"",', '+ \t\t\t\t\t      null };', '+ ', '+ ', '+ krb5_error_code', '+ krb5_ldap_create_password_policy (context, policy)', '+     krb5_context                context;', '+     osa_policy_ent_t            policy;', '+ {', '+     krb5_error_code \t        st=0;', '+     ldap  \t\t        *ld=null;', '+     ldapmod \t\t        **mods={null};', '+     kdb5_dal_handle             *dal_handle=null;', '+     krb5_ldap_context           *ldap_context=null;', '+     krb5_ldap_server_handle     *ldap_server_handle=null;', '+     char                        **rdns=null, *strval[2]={null};', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if (policy == null || policy->name == null)', '+ \treturn einval;', '+ ', '+     setup_context();', '+     get_handle();', '+ ', '+     rdns = ldap_explode_dn(policy->name, 1);', '+     if (rdns == null) {', '+         st = einval;', '+         krb5_set_error_message(context, st, ""invalid password policy dn syntax"");', '+ \tgoto cleanup;', '+     }', '+ ', '+     strval[0] = rdns[0];', '+     if ((st=krb5_add_str_mem_ldap_mod(&mods, ""cn"", ldap_mod_add, strval)) != 0)', '+       goto cleanup;', '+ ', '+     strval[0] = ""krbpwdpolicy"";', '+     if ((st=krb5_add_str_mem_ldap_mod(&mods, ""objectclass"", ldap_mod_add, strval)) != 0)', '+       goto cleanup;', '+ ', '+     if (((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxpwdlife"", ldap_mod_add,', '+ \t\t\t\t       (signed) policy->pw_max_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbminpwdlife"", ldap_mod_add,', '+ \t\t\t\t\t  (signed) policy->pw_min_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdmindiffchars"", ldap_mod_add,', '+ \t\t\t\t\t  (signed) policy->pw_min_classes)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdminlength"", ldap_mod_add,', '+ \t\t\t\t\t  (signed) policy->pw_min_length)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdhistorylength"", ldap_mod_add,', '+ \t\t\t\t\t  (signed) policy->pw_history_num)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdpolicyrefcount"", ldap_mod_add,', '+ \t\t\t\t\t  (signed) policy->policy_refcnt)) != 0))', '+ \tgoto cleanup;', '+ ', '+     if ((st=ldap_add_s(ld, policy->name, mods)) != ldap_success) {', '+         st = set_ldap_error (context, st, op_add);', '+ \tgoto cleanup;', '+     }', '+ ', '+  cleanup:', '+     if (rdns)', '+ \tldap_value_free(rdns);', '+ ', '+     ldap_mods_free(mods, 1);', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return(st);', '+ }', '+ ', '+ ', '+ krb5_error_code', '+ krb5_ldap_put_password_policy (context, policy)', '+     krb5_context                context;', '+     osa_policy_ent_t            policy;', '+ {', '+     krb5_error_code \t        st=0;', '+     ldap  \t\t        *ld=null;', '+     ldapmod \t\t        **mods=null;', '+     kdb5_dal_handle             *dal_handle=null;', '+     krb5_ldap_context           *ldap_context=null;', '+     krb5_ldap_server_handle     *ldap_server_handle=null;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if (policy == null || policy->name == null)', '+ \treturn einval;', '+ ', '+     setup_context();', '+     get_handle();', '+ ', '+     if (((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxpwdlife"", ldap_mod_replace,', '+ \t\t\t\t       (signed) policy->pw_max_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbminpwdlife"", ldap_mod_replace,', '+ \t\t\t\t\t  (signed) policy->pw_min_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdmindiffchars"", ldap_mod_replace,', '+ \t\t\t\t\t  (signed) policy->pw_min_classes)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdminlength"", ldap_mod_replace,', '+ \t\t\t\t\t  (signed) policy->pw_min_length)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdhistorylength"", ldap_mod_replace,', '+ \t\t\t\t\t  (signed) policy->pw_history_num)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdpolicyrefcount"", ldap_mod_replace,', '+ \t\t\t\t\t  (signed) policy->policy_refcnt)) != 0))', '+ \tgoto cleanup;', '+ ', '+     if ((st=ldap_modify_s(ld, policy->name, mods)) != ldap_success) {', '+         st = set_ldap_error (context, st, op_mod);', '+ \tgoto cleanup;', '+     }', '+ ', '+  cleanup:', '+     ldap_mods_free(mods, 1);', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return(st);', '+ }', '+ ', '+ krb5_error_code', '+ krb5_ldap_get_password_policy (context, name, policy, cnt)', '+     krb5_context                context;', '+     char                        *name;', '+     osa_policy_ent_t            *policy;', '+     int                         *cnt;', '+ {', '+     krb5_error_code             st=0, tempst=0;', '+     ldap  \t\t        *ld=null;', '+     ldapmessage                 *result=null,*ent=null;', '+     kdb5_dal_handle             *dal_handle=null;', '+     krb5_ldap_context           *ldap_context=null;', '+     krb5_ldap_server_handle     *ldap_server_handle=null;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if(name == null)', '+ \treturn einval;', '+ ', '+     setup_context();', '+     get_handle();', '+ ', '+     *cnt = 0;', '+     *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));', '+     if (*policy == null) {', '+ \t st = enomem;', '+ \t goto cleanup;', '+     }', '+     memset(*policy, 0, sizeof(osa_policy_ent_rec));', '+ ', '+     ldap_search(name, ldap_scope_base, ""(objectclass=krbpwdpolicy)"", password_policy_attributes);', '+     *cnt = 1;', '+     (*policy)->name = name;', '+     (*policy)->version = 1;', '+ ', '+     ent=ldap_first_entry(ld, result);', '+     if (ent != null) {', '+ \tkrb5_ldap_get_value(ld, ent, ""krbmaxpwdlife"", &((*policy)->pw_max_life));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbminpwdlife"", &((*policy)->pw_min_life));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdmindiffchars"", &((*policy)->pw_min_classes));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdminlength"", &((*policy)->pw_min_length));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdhistorylength"", &((*policy)->pw_history_num));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdpolicyrefcount"", &((*policy)->policy_refcnt));', '+     }', '+ ', '+ cleanup:', '+     ldap_msgfree(result);', '+     if (st != 0) {', '+ \tif (*policy != null) {', '+ \t    free (*policy);', '+ \t    *policy = null;', '+ \t}', '+     }', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return st;', '+ }', '+ ', '+ krb5_error_code', '+ krb5_ldap_delete_password_policy (context, policy)', '+     krb5_context                context;', '+     char                        *policy;', '+ {', '+     krb5_error_code             st=0;', '+     ldap                        *ld=null;', '+     kdb5_dal_handle             *dal_handle=null;', '+     krb5_ldap_context           *ldap_context=null;', '+     krb5_ldap_server_handle     *ldap_server_handle=null;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if(policy == null)', '+         return einval;', '+ ', '+     setup_context();', '+     get_handle();', '+ ', '+     if((st=ldap_delete_s(ld, policy)) != ldap_success) {', '+         st = set_ldap_error (context, st, op_del);', '+         goto cleanup;', '+     }', '+ ', '+ cleanup:', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return st;', '+ }', '+ ', '+ krb5_error_code', '+ krb5_ldap_iterate_password_policy(context, match_expr, func, func_arg)', '+     krb5_context                context;', '+     char                        *match_expr;', '+     void                        (*func) (krb5_pointer, osa_policy_ent_t );', '+     krb5_pointer                func_arg;', '+ {', '+     osa_policy_ent_rec          *entry=null;', '+     char\t\t        *attrs[] = { ""cn"", null };', '+     krb5_error_code             st=0, tempst=0;', '+     ldap\t\t        *ld=null;', '+     ldapmessage\t                *result=null, *ent=null;', '+     kdb5_dal_handle             *dal_handle=null;', '+     krb5_ldap_context           *ldap_context=null;', '+     krb5_ldap_server_handle     *ldap_server_handle=null;', '+     char \t\t        *policy_dn=null;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     setup_context();', '+     get_handle();', '+ ', '+     entry = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));', '+     check_null(entry);', '+     memset(entry, 0, sizeof(osa_policy_ent_rec));', '+ ', '+     ldap_search(null, ldap_scope_subtree, ""(objectclass=krbpwdpolicy)"", attrs);', '+     for(ent=ldap_first_entry(ld, result); ent != null; ent=ldap_next_entry(ld, ent)) {', '+ \tif ((policy_dn=ldap_get_dn(ld, ent)) == null)', '+ \t    continue;', '+ \tentry->name = policy_dn;', '+ \t(*func)(func_arg, entry);', '+ \tldap_memfree(policy_dn);', '+     }', '+     ldap_msgfree(result);', '+ ', '+  cleanup:', '+     if (entry)', '+ \tfree (entry);', '+ ', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return st;', '+ }', '+ ', '+ void', '+ krb5_ldap_free_password_policy (context, entry)', '+     krb5_context                context;', '+     osa_policy_ent_t            entry;', '+ {', '+     if(entry)', '+         free(entry);', '+     return;', '+ }']]","[['+ ', '+ #include ""ldap_main.h""', '+ #include ""kdb_ldap.h""', '+ #include ""ldap_pwd_policy.h""', '+ #include ""ldap_err.h""', '+ ', '+ static char *password_policy_attributes[] = { ""krbmaxpwdlife"", ""krbminpwdlife"", ""krbpwdmindiffchars"",', '+ \t\t\t\t\t      ""krbpwdminlength"", ""krbpwdhistorylength"", ""krbpwdpolicyrefcount"",', '+ \t\t\t\t\t      NULL };', '+ ', '+ ', '+ krb5_error_code', '+ krb5_ldap_create_password_policy (context, policy)', '+     krb5_context                context;', '+     osa_policy_ent_t            policy;', '+ {', '+     krb5_error_code \t        st=0;', '+     LDAP  \t\t        *ld=NULL;', '+     LDAPMod \t\t        **mods={NULL};', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+     char                        **rdns=NULL, *strval[2]={NULL};', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if (policy == NULL || policy->name == NULL)', '+ \treturn EINVAL;', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     rdns = ldap_explode_dn(policy->name, 1);', '+     if (rdns == NULL) {', '+         st = EINVAL;', '+         krb5_set_error_message(context, st, ""Invalid password policy DN syntax"");', '+ \tgoto cleanup;', '+     }', '+ ', '+     strval[0] = rdns[0];', '+     if ((st=krb5_add_str_mem_ldap_mod(&mods, ""cn"", LDAP_MOD_ADD, strval)) != 0)', '+       goto cleanup;', '+ ', '+     strval[0] = ""krbPwdPolicy"";', '+     if ((st=krb5_add_str_mem_ldap_mod(&mods, ""objectclass"", LDAP_MOD_ADD, strval)) != 0)', '+       goto cleanup;', '+ ', '+     if (((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxpwdlife"", LDAP_MOD_ADD,', '+ \t\t\t\t       (signed) policy->pw_max_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbminpwdlife"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->pw_min_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdmindiffchars"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->pw_min_classes)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdminlength"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->pw_min_length)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdhistorylength"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->pw_history_num)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdpolicyrefcount"", LDAP_MOD_ADD,', '+ \t\t\t\t\t  (signed) policy->policy_refcnt)) != 0))', '+ \tgoto cleanup;', '+ ', '+     if ((st=ldap_add_s(ld, policy->name, mods)) != LDAP_SUCCESS) {', '+         st = set_ldap_error (context, st, OP_ADD);', '+ \tgoto cleanup;', '+     }', '+ ', '+  cleanup:', '+     if (rdns)', '+ \tldap_value_free(rdns);', '+ ', '+     ldap_mods_free(mods, 1);', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return(st);', '+ }', '+ ', '+ ', '+ krb5_error_code', '+ krb5_ldap_put_password_policy (context, policy)', '+     krb5_context                context;', '+     osa_policy_ent_t            policy;', '+ {', '+     krb5_error_code \t        st=0;', '+     LDAP  \t\t        *ld=NULL;', '+     LDAPMod \t\t        **mods=NULL;', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if (policy == NULL || policy->name == NULL)', '+ \treturn EINVAL;', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     if (((st=krb5_add_int_mem_ldap_mod(&mods, ""krbmaxpwdlife"", LDAP_MOD_REPLACE,', '+ \t\t\t\t       (signed) policy->pw_max_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbminpwdlife"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->pw_min_life)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdmindiffchars"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->pw_min_classes)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdminlength"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->pw_min_length)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdhistorylength"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->pw_history_num)) != 0)', '+ \t|| ((st=krb5_add_int_mem_ldap_mod(&mods, ""krbpwdpolicyrefcount"", LDAP_MOD_REPLACE,', '+ \t\t\t\t\t  (signed) policy->policy_refcnt)) != 0))', '+ \tgoto cleanup;', '+ ', '+     if ((st=ldap_modify_s(ld, policy->name, mods)) != LDAP_SUCCESS) {', '+         st = set_ldap_error (context, st, OP_MOD);', '+ \tgoto cleanup;', '+     }', '+ ', '+  cleanup:', '+     ldap_mods_free(mods, 1);', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return(st);', '+ }', '+ ', '+ krb5_error_code', '+ krb5_ldap_get_password_policy (context, name, policy, cnt)', '+     krb5_context                context;', '+     char                        *name;', '+     osa_policy_ent_t            *policy;', '+     int                         *cnt;', '+ {', '+     krb5_error_code             st=0, tempst=0;', '+     LDAP  \t\t        *ld=NULL;', '+     LDAPMessage                 *result=NULL,*ent=NULL;', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if(name == NULL)', '+ \treturn EINVAL;', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     *cnt = 0;', '+     *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));', '+     if (*policy == NULL) {', '+ \t st = ENOMEM;', '+ \t goto cleanup;', '+     }', '+     memset(*policy, 0, sizeof(osa_policy_ent_rec));', '+ ', '+     LDAP_SEARCH(name, LDAP_SCOPE_BASE, ""(objectclass=krbPwdPolicy)"", password_policy_attributes);', '+     *cnt = 1;', '+     (*policy)->name = name;', '+     (*policy)->version = 1;', '+ ', '+     ent=ldap_first_entry(ld, result);', '+     if (ent != NULL) {', '+ \tkrb5_ldap_get_value(ld, ent, ""krbmaxpwdlife"", &((*policy)->pw_max_life));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbminpwdlife"", &((*policy)->pw_min_life));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdmindiffchars"", &((*policy)->pw_min_classes));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdminlength"", &((*policy)->pw_min_length));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdhistorylength"", &((*policy)->pw_history_num));', '+ \tkrb5_ldap_get_value(ld, ent, ""krbpwdpolicyrefcount"", &((*policy)->policy_refcnt));', '+     }', '+ ', '+ cleanup:', '+     ldap_msgfree(result);', '+     if (st != 0) {', '+ \tif (*policy != NULL) {', '+ \t    free (*policy);', '+ \t    *policy = NULL;', '+ \t}', '+     }', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return st;', '+ }', '+ ', '+ krb5_error_code', '+ krb5_ldap_delete_password_policy (context, policy)', '+     krb5_context                context;', '+     char                        *policy;', '+ {', '+     krb5_error_code             st=0;', '+     LDAP                        *ld=NULL;', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     if(policy == NULL)', '+         return EINVAL;', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     if((st=ldap_delete_s(ld, policy)) != LDAP_SUCCESS) {', '+         st = set_ldap_error (context, st, OP_DEL);', '+         goto cleanup;', '+     }', '+ ', '+ cleanup:', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return st;', '+ }', '+ ', '+ krb5_error_code', '+ krb5_ldap_iterate_password_policy(context, match_expr, func, func_arg)', '+     krb5_context                context;', '+     char                        *match_expr;', '+     void                        (*func) (krb5_pointer, osa_policy_ent_t );', '+     krb5_pointer                func_arg;', '+ {', '+     osa_policy_ent_rec          *entry=NULL;', '+     char\t\t        *attrs[] = { ""cn"", NULL };', '+     krb5_error_code             st=0, tempst=0;', '+     LDAP\t\t        *ld=NULL;', '+     LDAPMessage\t                *result=NULL, *ent=NULL;', '+     kdb5_dal_handle             *dal_handle=NULL;', '+     krb5_ldap_context           *ldap_context=NULL;', '+     krb5_ldap_server_handle     *ldap_server_handle=NULL;', '+     char \t\t        *policy_dn=NULL;', '+ ', '+     krb5_clear_error_message(context);', '+ ', '+     SETUP_CONTEXT();', '+     GET_HANDLE();', '+ ', '+     entry = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));', '+     CHECK_NULL(entry);', '+     memset(entry, 0, sizeof(osa_policy_ent_rec));', '+ ', '+     LDAP_SEARCH(NULL, LDAP_SCOPE_SUBTREE, ""(objectclass=krbpwdpolicy)"", attrs);', '+     for(ent=ldap_first_entry(ld, result); ent != NULL; ent=ldap_next_entry(ld, ent)) {', '+ \tif ((policy_dn=ldap_get_dn(ld, ent)) == NULL)', '+ \t    continue;', '+ \tentry->name = policy_dn;', '+ \t(*func)(func_arg, entry);', '+ \tldap_memfree(policy_dn);', '+     }', '+     ldap_msgfree(result);', '+ ', '+  cleanup:', '+     if (entry)', '+ \tfree (entry);', '+ ', '+     krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);', '+     return st;', '+ }', '+ ', '+ void', '+ krb5_ldap_free_password_policy (context, entry)', '+     krb5_context                context;', '+     osa_policy_ent_t            entry;', '+ {', '+     if(entry)', '+         free(entry);', '+     return;', '+ }']]",[[]],260,0.0,260.0,42d9d6ab320ee3a661fe21472be542acd542d5bekrb5/krb5,['d1f707024f1d0af6e54a18885322d70fa15ec4d3']
7e0859f1375e3b661c244d8a6ac0420d1d912563,vadz/libtiff,tif_win32.c,train,C,0,"['@@ -174,7 +174,7 @@ TIFFOpen(const char* name, const char* mode)\n \t\tdwMode = OPEN_ALWAYS;\n \t\tbreak;\n \tcase O_RDWR|O_CREAT:\n-\t\tdwMode = CREATE_NEW;\n+\t\tdwMode = OPEN_ALWAYS;\n \t\tbreak;\n \tcase O_RDWR|O_TRUNC:\n \t\tdwMode = CREATE_ALWAYS;\n']",,,"['+ \t\tdwMode = OPEN_ALWAYS;', '- \t\tdwMode = CREATE_NEW;']","['+ \t\tdwmode = open_always;', '- \t\tdwmode = create_new;']",['+ \t\tdwMode = OPEN_ALWAYS;'],['- \t\tdwMode = CREATE_NEW;'],1,1.0,2.0,7e0859f1375e3b661c244d8a6ac0420d1d912563vadz/libtiff,[]
3bb13e37def9fdcd0b4524265b5a952f38933e43,libarchive/libarchive,archive_write_set_compression_program.c,train,C,0,"['@@ -27,6 +27,23 @@\n \n __FBSDID(""$FreeBSD: src/lib/libarchive/archive_write_set_compression_program.c,v 1.1 2007/05/29 01:00:19 kientzle Exp $"");\n \n+/* This capability is only available on POSIX systems. */\n+#if !defined(HAVE_PIPE) || !defined(HAVE_VFORK) || !defined(HAVE_FCNTL)\n+\n+/*\n+ * On non-Posix systems, allow the program to build, but choke if\n+ * this function is actually invoked.\n+ */\n+int\n+archive_write_set_compression_program(struct archive *_a, const char *cmd)\n+{\n+\tarchive_set_error(_a, -1,\n+\t    ""External compression programs not supported on this platform"");\n+\treturn (ARCHIVE_FATAL);\n+}\n+\n+#else\n+\n #ifdef HAVE_SYS_WAIT_H\n #  include <sys/wait.h>\n #endif\n@@ -320,3 +337,5 @@ cleanup:\n \tfree(state);\n \treturn (ret);\n }\n+\n+#endif /* !defined(HAVE_PIPE) || !defined(HAVE_VFORK) || !defined(HAVE_FCNTL) */\n']",,,"['+ #if !defined(HAVE_PIPE) || !defined(HAVE_VFORK) || !defined(HAVE_FCNTL)', '+ int', '+ archive_write_set_compression_program(struct archive *_a, const char *cmd)', '+ {', '+ \tarchive_set_error(_a, -1,', '+ \t    ""External compression programs not supported on this platform"");', '+ \treturn (ARCHIVE_FATAL);', '+ }', '+ #else']","['+ #if !defined(have_pipe) || !defined(have_vfork) || !defined(have_fcntl)', '+ int', '+ archive_write_set_compression_program(struct archive *_a, const char *cmd)', '+ {', '+ \tarchive_set_error(_a, -1,', '+ \t    ""external compression programs not supported on this platform"");', '+ \treturn (archive_fatal);', '+ }', '+ #else']","['+ #if !defined(HAVE_PIPE) || !defined(HAVE_VFORK) || !defined(HAVE_FCNTL)', '+ int', '+ archive_write_set_compression_program(struct archive *_a, const char *cmd)', '+ {', '+ \tarchive_set_error(_a, -1,', '+ \t    ""External compression programs not supported on this platform"");', '+ \treturn (ARCHIVE_FATAL);', '+ }', '+ #else']",[],9,0.0,9.0,3bb13e37def9fdcd0b4524265b5a952f38933e43libarchive/libarchive,[]
1434df3b93fde086be729d174ffbbee1e25792b3,FFmpeg/FFmpeg,libavcodec/jpeg2000dec.c,train,C,1,"['@@ -1292,14 +1292,20 @@ static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n             uint16_t *linel;\n             int cbps = s->cbps[compno];\n             int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n+            int planar = !!picture->data[2];\n+            int pixelsize = planar ? 1 : s->ncomponents;\n+            int plane = 0;\n+\n+            if (planar)\n+                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n \n             y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n-            linel = (uint16_t *)picture->data[0] + y * (picture->linesize[0] >> 1);\n+            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\n             for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n                 uint16_t *dst;\n \n                 x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n-                dst = linel + (x * s->ncomponents + compno);\n+                dst = linel + (x * pixelsize + compno*!planar);\n                 if (codsty->transform == FF_DWT97) {\n                     for (; x < w; x += s-> cdx[compno]) {\n                         int  val = lrintf(*datap) + (1 << (cbps - 1));\n@@ -1308,7 +1314,7 @@ static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n                         /* align 12 bit values in little-endian mode */\n                         *dst = val << (16 - cbps);\n                         datap++;\n-                        dst += s->ncomponents;\n+                        dst += pixelsize;\n                     }\n                 } else {\n                     for (; x < w; x += s-> cdx[compno]) {\n@@ -1318,10 +1324,10 @@ static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n                         /* align 12 bit values in little-endian mode */\n                         *dst = val << (16 - cbps);\n                         i_datap++;\n-                        dst += s->ncomponents;\n+                        dst += pixelsize;\n                     }\n                 }\n-                linel += picture->linesize[0] >> 1;\n+                linel += picture->linesize[plane] >> 1;\n             }\n         }\n     }\n']",2013-07-21 04:16:53+02:00,"jpeg2000dec: Support non subsampled 9-16bit planar pixel formats

This applies changes similar to fc6de70c44be05eb0368ab519bfb790431d8dee5
to the >8bit codepath

Signed-off-by: Michael Niedermayer <michaelni@gmx.at>","[['+             int planar = !!picture->data[2];', '+             int pixelsize = planar ? 1 : s->ncomponents;', '+             int plane = 0;', '+ ', '+             if (planar)', '+                 plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);', '+             linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);', '+                 dst = linel + (x * pixelsize + compno*!planar);', '+                         dst += pixelsize;', '+                         dst += pixelsize;', '+                 linel += picture->linesize[plane] >> 1;', '-             linel = (uint16_t *)picture->data[0] + y * (picture->linesize[0] >> 1);', '-                 dst = linel + (x * s->ncomponents + compno);', '-                         dst += s->ncomponents;', '-                         dst += s->ncomponents;', '-                 linel += picture->linesize[0] >> 1;']]","[['+             int planar = !!picture->data[2];', '+             int pixelsize = planar ? 1 : s->ncomponents;', '+             int plane = 0;', '+ ', '+             if (planar)', '+                 plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);', '+             linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);', '+                 dst = linel + (x * pixelsize + compno*!planar);', '+                         dst += pixelsize;', '+                         dst += pixelsize;', '+                 linel += picture->linesize[plane] >> 1;', '-             linel = (uint16_t *)picture->data[0] + y * (picture->linesize[0] >> 1);', '-                 dst = linel + (x * s->ncomponents + compno);', '-                         dst += s->ncomponents;', '-                         dst += s->ncomponents;', '-                 linel += picture->linesize[0] >> 1;']]","[['+             int planar = !!picture->data[2];', '+             int pixelsize = planar ? 1 : s->ncomponents;', '+             int plane = 0;', '+ ', '+             if (planar)', '+                 plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);', '+             linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);', '+                 dst = linel + (x * pixelsize + compno*!planar);', '+                         dst += pixelsize;', '+                         dst += pixelsize;', '+                 linel += picture->linesize[plane] >> 1;']]","[['-             linel = (uint16_t *)picture->data[0] + y * (picture->linesize[0] >> 1);', '-                 dst = linel + (x * s->ncomponents + compno);', '-                         dst += s->ncomponents;', '-                         dst += s->ncomponents;', '-                 linel += picture->linesize[0] >> 1;']]",11,5.0,16.0,1434df3b93fde086be729d174ffbbee1e25792b3FFmpeg/FFmpeg,['fe448cd28d674c3eff3072552eae366d0b659ce9']
2874c81cc80b7f1005073748e8f1877055bf97a7,FFmpeg/FFmpeg,libavformat/ape.c,test,C,1,"['@@ -248,7 +248,7 @@ static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n     }\n     ape->frames       = av_malloc(ape->totalframes * sizeof(APEFrame));\n     if(!ape->frames)\n-        return AVERROR_NOMEM;\n+        return AVERROR(ENOMEM);\n     ape->firstframe   = ape->junklength + ape->descriptorlength + ape->headerlength + ape->seektablelength + ape->wavheaderlength;\n     ape->currentframe = 0;\n \n@@ -351,7 +351,7 @@ static int ape_read_packet(AVFormatContext * s, AVPacket * pkt)\n         nblocks = ape->blocksperframe;\n \n     if (av_new_packet(pkt,  ape->frames[ape->currentframe].size + extra_size) < 0)\n-        return AVERROR_NOMEM;\n+        return AVERROR(ENOMEM);\n \n     AV_WL32(pkt->data    , nblocks);\n     AV_WL32(pkt->data + 4, ape->frames[ape->currentframe].skip);\n']",2010-04-03 14:15:00+00:00,"Replace all remaining occurrences of AVERROR_NOMEM with
AVERROR(ENOMEM).

AVERROR_NOMEM is deprecated and will be dropped at the next libavutil
major bump.

Originally committed as revision 22791 to svn://svn.ffmpeg.org/ffmpeg/trunk","[['+         return AVERROR(ENOMEM);', '+         return AVERROR(ENOMEM);', '-         return AVERROR_NOMEM;', '-         return AVERROR_NOMEM;']]","[['+         return averror(enomem);', '+         return averror(enomem);', '-         return averror_nomem;', '-         return averror_nomem;']]","[['+         return AVERROR(ENOMEM);', '+         return AVERROR(ENOMEM);']]","[['-         return AVERROR_NOMEM;', '-         return AVERROR_NOMEM;']]",2,2.0,4.0,2874c81cc80b7f1005073748e8f1877055bf97a7FFmpeg/FFmpeg,['8312e3fc9041027a33c8bc667bb99740fdf41dd5']
8c1f95681caa2bfc84740391fe13dbd57e332e54,ClusterLabs/pacemaker,crmutils.c,train,C,0,"['@@ -1,4 +1,4 @@\n-/* $Id: crmutils.c,v 1.6 2004/02/17 22:11:56 lars Exp $ */\n+/* $Id: crmutils.c,v 1.7 2004/02/29 19:40:56 andrew Exp $ */\n /* \n  * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n  * \n@@ -87,9 +87,6 @@ register_pid(const char *pid_file,\n \t}\n \n \tumask(022);\n-/*     if (!crm_debug()) { */\n-/* \tcl_log_enable_stderr(FALSE); */\n-/*     } */\n \n \tfor (j=0; j < 3; ++j) {\n \t\tclose(j);\n@@ -127,6 +124,8 @@ get_running_pid(const char *pid_file, gboolean* anypidfile)\n int\n init_stop(const char *pid_file)\n {\n+\tFNIN();\n+\t\n \tif (pid_file == NULL) {\n \t\tcl_log(LOG_ERR, ""No pid file specified to kill process"");\n \t\treturn LSB_EXIT_GENERIC;\n@@ -141,12 +140,17 @@ init_stop(const char *pid_file)\n \t\t\t      ?\tLSB_EXIT_EPERM : LSB_EXIT_GENERIC);\n \t\t\tfprintf(stderr, ""Cannot kill pid %ld\\n"", pid);\n \t\t}else{\n+\t\t\tcl_log(LOG_INFO,\n+\t\t\t       ""Signal sent to pid=%ld,""\n+\t\t\t       "" waiting for process to exit"",\n+\t\t\t       pid);\n+\t\t\t\n \t\t\twhile (CL_PID_EXISTS(pid)) {\n \t\t\t\tsleep(1);\n \t\t\t}\n \t\t}\n \t}\n-\treturn rc;\n+\tFNRET(rc);\n }\n int\n init_status(const char *pid_file, const char *client_name)\n']",,,"['+ \tFNIN();', '+ \t\t\tcl_log(LOG_INFO,', '+ \t\t\t       ""Signal sent to pid=%ld,""', '+ \t\t\t       "" waiting for process to exit"",', '+ \t\t\t       pid);', '+ \tFNRET(rc);', '- \treturn rc;']","['+ \tfnin();', '+ \t\t\tcl_log(log_info,', '+ \t\t\t       ""signal sent to pid=%ld,""', '+ \t\t\t       "" waiting for process to exit"",', '+ \t\t\t       pid);', '+ \tfnret(rc);', '- \treturn rc;']","['+ \tFNIN();', '+ \t\t\tcl_log(LOG_INFO,', '+ \t\t\t       ""Signal sent to pid=%ld,""', '+ \t\t\t       "" waiting for process to exit"",', '+ \t\t\t       pid);', '+ \tFNRET(rc);']",['- \treturn rc;'],6,1.0,7.0,8c1f95681caa2bfc84740391fe13dbd57e332e54ClusterLabs/pacemaker,[]
64485737cf5e0251ab82d0a2d50e9903ab9ac588,file/file,src/funcs.c,test,C,1,"['@@ -27,7 +27,7 @@\n #include ""file.h""\n \n #ifndef\tlint\n-FILE_RCSID(""@(#)$File: funcs.c,v 1.71 2014/05/05 20:53:10 christos Exp $"")\n+FILE_RCSID(""@(#)$File: funcs.c,v 1.72 2014/05/14 23:15:42 christos Exp $"")\n #endif\t/* lint */\n \n #include ""magic.h""\n@@ -45,9 +45,6 @@ FILE_RCSID(""@(#)$File: funcs.c,v 1.71 2014/05/05 20:53:10 christos Exp $"")\n #if defined(HAVE_LIMITS_H)\n #include <limits.h>\n #endif\n-#if defined(HAVE_LOCALE_H)\n-#include <locale.h>\n-#endif\n \n #ifndef SIZE_MAX\n #define SIZE_MAX\t((size_t)~0)\n@@ -455,13 +452,14 @@ out:\n protected int\n file_regcomp(file_regex_t *rx, const char *pat, int flags)\n {\n-\trx->old_lc_ctype = setlocale(LC_CTYPE, NULL);\n-\tassert(rx->old_lc_ctype != NULL);\n-\trx->old_lc_ctype = strdup(rx->old_lc_ctype);\n+#ifdef USE_C_LOCALE\n+\trx->c_lc_ctype = newlocale(LC_CTYPE_MASK, ""C"", 0);\n+\tassert(rx->c_lc_ctype != NULL);\n+\trx->old_lc_ctype = uselocale(rx->c_lc_ctype);\n \tassert(rx->old_lc_ctype != NULL);\n+#endif\n \trx->pat = pat;\n \n-\t(void)setlocale(LC_CTYPE, ""C"");\n \treturn rx->rc = regcomp(&rx->rx, pat, flags);\n }\n \n@@ -478,8 +476,10 @@ file_regfree(file_regex_t *rx)\n {\n \tif (rx->rc == 0)\n \t\tregfree(&rx->rx);\n-\t(void)setlocale(LC_CTYPE, rx->old_lc_ctype);\n-\tfree(rx->old_lc_ctype);\n+#ifdef USE_C_LOCALE\n+\t(void)uselocale(rx->old_lc_ctype);\n+\tfreelocale(rx->c_lc_ctype);\n+#endif\n }\n \n protected void\n']",2014-09-10 18:41:51+00:00,don't use setlocale(3); it is not thread-safe.,"[['+ FILE_RCSID(""@(#)$File: funcs.c,v 1.72 2014/05/14 23:15:42 christos Exp $"")', '+ #ifdef USE_C_LOCALE', '+ \trx->c_lc_ctype = newlocale(LC_CTYPE_MASK, ""C"", 0);', '+ \tassert(rx->c_lc_ctype != NULL);', '+ \trx->old_lc_ctype = uselocale(rx->c_lc_ctype);', '+ #endif', '+ #ifdef USE_C_LOCALE', '+ \t(void)uselocale(rx->old_lc_ctype);', '+ \tfreelocale(rx->c_lc_ctype);', '+ #endif', '- FILE_RCSID(""@(#)$File: funcs.c,v 1.71 2014/05/05 20:53:10 christos Exp $"")', '- #if defined(HAVE_LOCALE_H)', '- #include <locale.h>', '- #endif', '- \trx->old_lc_ctype = setlocale(LC_CTYPE, NULL);', '- \tassert(rx->old_lc_ctype != NULL);', '- \trx->old_lc_ctype = strdup(rx->old_lc_ctype);', '- \t(void)setlocale(LC_CTYPE, ""C"");', '- \t(void)setlocale(LC_CTYPE, rx->old_lc_ctype);', '- \tfree(rx->old_lc_ctype);']]","[['+ file_rcsid(""@(#)$file: funcs.c,v 1.72 2014/05/14 23:15:42 christos exp $"")', '+ #ifdef use_c_locale', '+ \trx->c_lc_ctype = newlocale(lc_ctype_mask, ""c"", 0);', '+ \tassert(rx->c_lc_ctype != null);', '+ \trx->old_lc_ctype = uselocale(rx->c_lc_ctype);', '+ #endif', '+ #ifdef use_c_locale', '+ \t(void)uselocale(rx->old_lc_ctype);', '+ \tfreelocale(rx->c_lc_ctype);', '+ #endif', '- file_rcsid(""@(#)$file: funcs.c,v 1.71 2014/05/05 20:53:10 christos exp $"")', '- #if defined(have_locale_h)', '- #include <locale.h>', '- #endif', '- \trx->old_lc_ctype = setlocale(lc_ctype, null);', '- \tassert(rx->old_lc_ctype != null);', '- \trx->old_lc_ctype = strdup(rx->old_lc_ctype);', '- \t(void)setlocale(lc_ctype, ""c"");', '- \t(void)setlocale(lc_ctype, rx->old_lc_ctype);', '- \tfree(rx->old_lc_ctype);']]","[['+ FILE_RCSID(""@(#)$File: funcs.c,v 1.72 2014/05/14 23:15:42 christos Exp $"")', '+ #ifdef USE_C_LOCALE', '+ \trx->c_lc_ctype = newlocale(LC_CTYPE_MASK, ""C"", 0);', '+ \tassert(rx->c_lc_ctype != NULL);', '+ \trx->old_lc_ctype = uselocale(rx->c_lc_ctype);', '+ #endif', '+ #ifdef USE_C_LOCALE', '+ \t(void)uselocale(rx->old_lc_ctype);', '+ \tfreelocale(rx->c_lc_ctype);', '+ #endif']]","[['- FILE_RCSID(""@(#)$File: funcs.c,v 1.71 2014/05/05 20:53:10 christos Exp $"")', '- #if defined(HAVE_LOCALE_H)', '- #include <locale.h>', '- #endif', '- \trx->old_lc_ctype = setlocale(LC_CTYPE, NULL);', '- \tassert(rx->old_lc_ctype != NULL);', '- \trx->old_lc_ctype = strdup(rx->old_lc_ctype);', '- \t(void)setlocale(LC_CTYPE, ""C"");', '- \t(void)setlocale(LC_CTYPE, rx->old_lc_ctype);', '- \tfree(rx->old_lc_ctype);']]",10,10.0,20.0,64485737cf5e0251ab82d0a2d50e9903ab9ac588file/file,['6f737ddfadb596d7d4a993f7ed2141ffd664a81c']
13501024f21c52342c250866ead3e41eb521035c,dajobe/raptor,src/raptor_turtle_writer.c,test,C,1,"['@@ -633,85 +633,85 @@ raptor_turtle_writer_comment(raptor_turtle_writer* turtle_writer,\n \n \n /**\n- * raptor_turtle_writer_set_feature:\n+ * raptor_turtle_writer_set_option:\n  * @turtle_writer: #raptor_turtle_writer turtle_writer object\n- * @feature: feature to set from enumerated #raptor_feature values\n- * @value: integer feature value (0 or larger)\n+ * @option: option to set from enumerated #raptor_option values\n+ * @value: integer option value (0 or larger)\n  *\n- * Set turtle_writer features with integer values.\n+ * Set turtle_writer options with integer values.\n  * \n- * The allowed features are available via \n- * raptor_world_enumerate_turtle_writer_features()\n+ * The allowed options are available via \n+ * raptor_world_enumerate_turtle_writer_options()\n  *\n- * Return value: non 0 on failure or if the feature is unknown\n+ * Return value: non 0 on failure or if the option is unknown\n  **/\n int\n-raptor_turtle_writer_set_feature(raptor_turtle_writer *turtle_writer, \n-                                 raptor_feature feature, int value)\n+raptor_turtle_writer_set_option(raptor_turtle_writer *turtle_writer, \n+                                 raptor_option option, int value)\n {\n   if(value < 0 ||\n-     !raptor_feature_is_valid_for_area(feature, RAPTOR_FEATURE_AREA_TURTLE_WRITER))\n+     !raptor_option_is_valid_for_area(option, RAPTOR_OPTION_AREA_TURTLE_WRITER))\n     return 1;\n   \n-  switch(feature) {\n-    case RAPTOR_FEATURE_WRITER_AUTO_INDENT:\n+  switch(option) {\n+    case RAPTOR_OPTION_WRITER_AUTO_INDENT:\n       if(value)\n         turtle_writer->flags |= TURTLE_WRITER_AUTO_INDENT;\n       else\n         turtle_writer->flags &= ~TURTLE_WRITER_AUTO_INDENT;        \n       break;\n \n-    case RAPTOR_FEATURE_WRITER_INDENT_WIDTH:\n+    case RAPTOR_OPTION_WRITER_INDENT_WIDTH:\n       turtle_writer->indent = value;\n       break;\n     \n-    case RAPTOR_FEATURE_WRITER_AUTO_EMPTY:\n-    case RAPTOR_FEATURE_WRITER_XML_VERSION:\n-    case RAPTOR_FEATURE_WRITER_XML_DECLARATION:\n+    case RAPTOR_OPTION_WRITER_AUTO_EMPTY:\n+    case RAPTOR_OPTION_WRITER_XML_VERSION:\n+    case RAPTOR_OPTION_WRITER_XML_DECLARATION:\n       break;\n         \n-    /* parser features */\n-    case RAPTOR_FEATURE_SCANNING:\n-    case RAPTOR_FEATURE_ALLOW_NON_NS_ATTRIBUTES:\n-    case RAPTOR_FEATURE_ALLOW_OTHER_PARSETYPES:\n-    case RAPTOR_FEATURE_ALLOW_BAGID:\n-    case RAPTOR_FEATURE_ALLOW_RDF_TYPE_RDF_LIST:\n-    case RAPTOR_FEATURE_NORMALIZE_LANGUAGE:\n-    case RAPTOR_FEATURE_NON_NFC_FATAL:\n-    case RAPTOR_FEATURE_WARN_OTHER_PARSETYPES:\n-    case RAPTOR_FEATURE_CHECK_RDF_ID:\n-    case RAPTOR_FEATURE_HTML_TAG_SOUP:\n-    case RAPTOR_FEATURE_MICROFORMATS:\n-    case RAPTOR_FEATURE_HTML_LINK:\n-    case RAPTOR_FEATURE_WWW_TIMEOUT:\n+    /* parser options */\n+    case RAPTOR_OPTION_SCANNING:\n+    case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES:\n+    case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES:\n+    case RAPTOR_OPTION_ALLOW_BAGID:\n+    case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST:\n+    case RAPTOR_OPTION_NORMALIZE_LANGUAGE:\n+    case RAPTOR_OPTION_NON_NFC_FATAL:\n+    case RAPTOR_OPTION_WARN_OTHER_PARSETYPES:\n+    case RAPTOR_OPTION_CHECK_RDF_ID:\n+    case RAPTOR_OPTION_HTML_TAG_SOUP:\n+    case RAPTOR_OPTION_MICROFORMATS:\n+    case RAPTOR_OPTION_HTML_LINK:\n+    case RAPTOR_OPTION_WWW_TIMEOUT:\n \n     /* Shared */\n-    case RAPTOR_FEATURE_NO_NET:\n-\n-    /* XML writer features */\n-    case RAPTOR_FEATURE_RELATIVE_URIS:\n-\n-    /* DOT serializer features */\n-    case RAPTOR_FEATURE_RESOURCE_BORDER:\n-    case RAPTOR_FEATURE_LITERAL_BORDER:\n-    case RAPTOR_FEATURE_BNODE_BORDER:\n-    case RAPTOR_FEATURE_RESOURCE_FILL:\n-    case RAPTOR_FEATURE_LITERAL_FILL:\n-    case RAPTOR_FEATURE_BNODE_FILL:\n-\n-    /* JSON serializer features */\n-    case RAPTOR_FEATURE_JSON_CALLBACK:\n-    case RAPTOR_FEATURE_JSON_EXTRA_DATA:\n-    case RAPTOR_FEATURE_RSS_TRIPLES:\n-    case RAPTOR_FEATURE_ATOM_ENTRY_URI:\n-    case RAPTOR_FEATURE_PREFIX_ELEMENTS:\n+    case RAPTOR_OPTION_NO_NET:\n+\n+    /* XML writer options */\n+    case RAPTOR_OPTION_RELATIVE_URIS:\n+\n+    /* DOT serializer options */\n+    case RAPTOR_OPTION_RESOURCE_BORDER:\n+    case RAPTOR_OPTION_LITERAL_BORDER:\n+    case RAPTOR_OPTION_BNODE_BORDER:\n+    case RAPTOR_OPTION_RESOURCE_FILL:\n+    case RAPTOR_OPTION_LITERAL_FILL:\n+    case RAPTOR_OPTION_BNODE_FILL:\n+\n+    /* JSON serializer options */\n+    case RAPTOR_OPTION_JSON_CALLBACK:\n+    case RAPTOR_OPTION_JSON_EXTRA_DATA:\n+    case RAPTOR_OPTION_RSS_TRIPLES:\n+    case RAPTOR_OPTION_ATOM_ENTRY_URI:\n+    case RAPTOR_OPTION_PREFIX_ELEMENTS:\n     \n-    /* Turtle serializer feature */\n-    case RAPTOR_FEATURE_WRITE_BASE_URI:\n+    /* Turtle serializer option */\n+    case RAPTOR_OPTION_WRITE_BASE_URI:\n \n-    /* WWW feature */\n-    case RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL:\n-    case RAPTOR_FEATURE_WWW_HTTP_USER_AGENT:\n+    /* WWW option */\n+    case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL:\n+    case RAPTOR_OPTION_WWW_HTTP_USER_AGENT:\n       \n     default:\n       return -1;\n@@ -723,30 +723,30 @@ raptor_turtle_writer_set_feature(raptor_turtle_writer *turtle_writer,\n \n \n /**\n- * raptor_turtle_writer_set_feature_string:\n+ * raptor_turtle_writer_set_option_string:\n  * @turtle_writer: #raptor_turtle_writer turtle_writer object\n- * @feature: feature to set from enumerated #raptor_feature values\n- * @value: feature value\n+ * @option: option to set from enumerated #raptor_option values\n+ * @value: option value\n  *\n- * Set turtle_writer features with string values.\n+ * Set turtle_writer options with string values.\n  * \n- * The allowed features are available via\n- * raptor_world_enumerate_turtle_writer_features().  If the feature\n+ * The allowed options are available via\n+ * raptor_world_enumerate_turtle_writer_options().  If the option\n  * type is integer, the value is interpreted as an integer.\n  *\n- * Return value: non 0 on failure or if the feature is unknown\n+ * Return value: non 0 on failure or if the option is unknown\n  **/\n int\n-raptor_turtle_writer_set_feature_string(raptor_turtle_writer *turtle_writer, \n-                                        raptor_feature feature, \n+raptor_turtle_writer_set_option_string(raptor_turtle_writer *turtle_writer, \n+                                        raptor_option option, \n                                         const unsigned char *value)\n {\n   if(!value ||\n-     !raptor_feature_is_valid_for_area(feature, RAPTOR_FEATURE_AREA_TURTLE_WRITER))\n+     !raptor_option_is_valid_for_area(option, RAPTOR_OPTION_AREA_TURTLE_WRITER))\n     return 1;\n \n-  if(raptor_feature_value_is_numeric(feature))\n-    return raptor_turtle_writer_set_feature(turtle_writer, feature, \n+  if(raptor_option_value_is_numeric(option))\n+    return raptor_turtle_writer_set_option(turtle_writer, option, \n                                             atoi((const char*)value));\n \n   return 1;\n@@ -754,80 +754,80 @@ raptor_turtle_writer_set_feature_string(raptor_turtle_writer *turtle_writer,\n \n \n /**\n- * raptor_turtle_writer_get_feature:\n+ * raptor_turtle_writer_get_option:\n  * @turtle_writer: #raptor_turtle_writer serializer object\n- * @feature: feature to get value\n+ * @option: option to get value\n  *\n- * Get various turtle_writer features.\n+ * Get various turtle_writer options.\n  * \n- * The allowed features are available via raptor_features_enumerate().\n+ * The allowed options are available via raptor_options_enumerate().\n  *\n- * Note: no feature value is negative\n+ * Note: no option value is negative\n  *\n- * Return value: feature value or < 0 for an illegal feature\n+ * Return value: option value or < 0 for an illegal option\n  **/\n int\n-raptor_turtle_writer_get_feature(raptor_turtle_writer *turtle_writer, \n-                                 raptor_feature feature)\n+raptor_turtle_writer_get_option(raptor_turtle_writer *turtle_writer, \n+                                 raptor_option option)\n {\n   int result= -1;\n \n-  switch(feature) {\n-    case RAPTOR_FEATURE_WRITER_AUTO_INDENT:\n+  switch(option) {\n+    case RAPTOR_OPTION_WRITER_AUTO_INDENT:\n       result = TURTLE_WRITER_AUTO_INDENT(turtle_writer);\n       break;\n \n-    case RAPTOR_FEATURE_WRITER_INDENT_WIDTH:\n+    case RAPTOR_OPTION_WRITER_INDENT_WIDTH:\n       result = turtle_writer->indent;\n       break;\n     \n-    /* writer features */\n-    case RAPTOR_FEATURE_WRITER_AUTO_EMPTY:\n-    case RAPTOR_FEATURE_WRITER_XML_VERSION:\n-    case RAPTOR_FEATURE_WRITER_XML_DECLARATION:\n+    /* writer options */\n+    case RAPTOR_OPTION_WRITER_AUTO_EMPTY:\n+    case RAPTOR_OPTION_WRITER_XML_VERSION:\n+    case RAPTOR_OPTION_WRITER_XML_DECLARATION:\n       \n-    /* parser features */\n-    case RAPTOR_FEATURE_SCANNING:\n-    case RAPTOR_FEATURE_ALLOW_NON_NS_ATTRIBUTES:\n-    case RAPTOR_FEATURE_ALLOW_OTHER_PARSETYPES:\n-    case RAPTOR_FEATURE_ALLOW_BAGID:\n-    case RAPTOR_FEATURE_ALLOW_RDF_TYPE_RDF_LIST:\n-    case RAPTOR_FEATURE_NORMALIZE_LANGUAGE:\n-    case RAPTOR_FEATURE_NON_NFC_FATAL:\n-    case RAPTOR_FEATURE_WARN_OTHER_PARSETYPES:\n-    case RAPTOR_FEATURE_CHECK_RDF_ID:\n-    case RAPTOR_FEATURE_HTML_TAG_SOUP:\n-    case RAPTOR_FEATURE_MICROFORMATS:\n-    case RAPTOR_FEATURE_HTML_LINK:\n-    case RAPTOR_FEATURE_WWW_TIMEOUT:\n+    /* parser options */\n+    case RAPTOR_OPTION_SCANNING:\n+    case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES:\n+    case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES:\n+    case RAPTOR_OPTION_ALLOW_BAGID:\n+    case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST:\n+    case RAPTOR_OPTION_NORMALIZE_LANGUAGE:\n+    case RAPTOR_OPTION_NON_NFC_FATAL:\n+    case RAPTOR_OPTION_WARN_OTHER_PARSETYPES:\n+    case RAPTOR_OPTION_CHECK_RDF_ID:\n+    case RAPTOR_OPTION_HTML_TAG_SOUP:\n+    case RAPTOR_OPTION_MICROFORMATS:\n+    case RAPTOR_OPTION_HTML_LINK:\n+    case RAPTOR_OPTION_WWW_TIMEOUT:\n \n     /* Shared */\n-    case RAPTOR_FEATURE_NO_NET:\n-\n-    /* XML writer features */\n-    case RAPTOR_FEATURE_RELATIVE_URIS:\n-\n-    /* DOT serializer features */\n-    case RAPTOR_FEATURE_RESOURCE_BORDER:\n-    case RAPTOR_FEATURE_LITERAL_BORDER:\n-    case RAPTOR_FEATURE_BNODE_BORDER:\n-    case RAPTOR_FEATURE_RESOURCE_FILL:\n-    case RAPTOR_FEATURE_LITERAL_FILL:\n-    case RAPTOR_FEATURE_BNODE_FILL:\n-\n-    /* JSON serializer features */\n-    case RAPTOR_FEATURE_JSON_CALLBACK:\n-    case RAPTOR_FEATURE_JSON_EXTRA_DATA:\n-    case RAPTOR_FEATURE_RSS_TRIPLES:\n-    case RAPTOR_FEATURE_ATOM_ENTRY_URI:\n-    case RAPTOR_FEATURE_PREFIX_ELEMENTS:\n+    case RAPTOR_OPTION_NO_NET:\n+\n+    /* XML writer options */\n+    case RAPTOR_OPTION_RELATIVE_URIS:\n+\n+    /* DOT serializer options */\n+    case RAPTOR_OPTION_RESOURCE_BORDER:\n+    case RAPTOR_OPTION_LITERAL_BORDER:\n+    case RAPTOR_OPTION_BNODE_BORDER:\n+    case RAPTOR_OPTION_RESOURCE_FILL:\n+    case RAPTOR_OPTION_LITERAL_FILL:\n+    case RAPTOR_OPTION_BNODE_FILL:\n+\n+    /* JSON serializer options */\n+    case RAPTOR_OPTION_JSON_CALLBACK:\n+    case RAPTOR_OPTION_JSON_EXTRA_DATA:\n+    case RAPTOR_OPTION_RSS_TRIPLES:\n+    case RAPTOR_OPTION_ATOM_ENTRY_URI:\n+    case RAPTOR_OPTION_PREFIX_ELEMENTS:\n     \n-    /* Turtle serializer feature */\n-    case RAPTOR_FEATURE_WRITE_BASE_URI:\n+    /* Turtle serializer option */\n+    case RAPTOR_OPTION_WRITE_BASE_URI:\n \n-    /* WWW feature */\n-    case RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL:\n-    case RAPTOR_FEATURE_WWW_HTTP_USER_AGENT:\n+    /* WWW option */\n+    case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL:\n+    case RAPTOR_OPTION_WWW_HTTP_USER_AGENT:\n       \n     default:\n       break;\n@@ -838,19 +838,19 @@ raptor_turtle_writer_get_feature(raptor_turtle_writer *turtle_writer,\n \n \n /**\n- * raptor_turtle_writer_get_feature_string:\n+ * raptor_turtle_writer_get_option_string:\n  * @turtle_writer: #raptor_turtle_writer serializer object\n- * @feature: feature to get value\n+ * @option: option to get value\n  *\n- * Get turtle_writer features with string values.\n+ * Get turtle_writer options with string values.\n  * \n- * The allowed features are available via raptor_features_enumerate().\n+ * The allowed options are available via raptor_options_enumerate().\n  *\n- * Return value: feature value or NULL for an illegal feature or no value\n+ * Return value: option value or NULL for an illegal option or no value\n  **/\n const unsigned char *\n-raptor_turtle_writer_get_feature_string(raptor_turtle_writer *turtle_writer, \n-                                        raptor_feature feature)\n+raptor_turtle_writer_get_option_string(raptor_turtle_writer *turtle_writer, \n+                                        raptor_option option)\n {\n   return NULL;\n }\n@@ -909,8 +909,8 @@ main(int argc, char *argv[])\n     exit(1);\n   }\n \n-  raptor_turtle_writer_set_feature(turtle_writer, \n-                                   RAPTOR_FEATURE_WRITER_AUTO_INDENT, 1);\n+  raptor_turtle_writer_set_option(turtle_writer, \n+                                   RAPTOR_OPTION_WRITER_AUTO_INDENT, 1);\n \n   ex_ns = raptor_new_namespace(nstack,\n                               (const unsigned char*)""ex"",\n']",2010-02-05 19:36:00-08:00,Rename feature to option,"[['+ raptor_turtle_writer_set_option(raptor_turtle_writer *turtle_writer,', '+                                  raptor_option option, int value)', '+      !raptor_option_is_valid_for_area(option, RAPTOR_OPTION_AREA_TURTLE_WRITER))', '+   switch(option) {', '+     case RAPTOR_OPTION_WRITER_AUTO_INDENT:', '+     case RAPTOR_OPTION_WRITER_INDENT_WIDTH:', '+     case RAPTOR_OPTION_WRITER_AUTO_EMPTY:', '+     case RAPTOR_OPTION_WRITER_XML_VERSION:', '+     case RAPTOR_OPTION_WRITER_XML_DECLARATION:', '+     case RAPTOR_OPTION_SCANNING:', '+     case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES:', '+     case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES:', '+     case RAPTOR_OPTION_ALLOW_BAGID:', '+     case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST:', '+     case RAPTOR_OPTION_NORMALIZE_LANGUAGE:', '+     case RAPTOR_OPTION_NON_NFC_FATAL:', '+     case RAPTOR_OPTION_WARN_OTHER_PARSETYPES:', '+     case RAPTOR_OPTION_CHECK_RDF_ID:', '+     case RAPTOR_OPTION_HTML_TAG_SOUP:', '+     case RAPTOR_OPTION_MICROFORMATS:', '+     case RAPTOR_OPTION_HTML_LINK:', '+     case RAPTOR_OPTION_WWW_TIMEOUT:', '+     case RAPTOR_OPTION_NO_NET:', '+ ', '+     case RAPTOR_OPTION_RELATIVE_URIS:', '+ ', '+     case RAPTOR_OPTION_RESOURCE_BORDER:', '+     case RAPTOR_OPTION_LITERAL_BORDER:', '+     case RAPTOR_OPTION_BNODE_BORDER:', '+     case RAPTOR_OPTION_RESOURCE_FILL:', '+     case RAPTOR_OPTION_LITERAL_FILL:', '+     case RAPTOR_OPTION_BNODE_FILL:', '+ ', '+     case RAPTOR_OPTION_JSON_CALLBACK:', '+     case RAPTOR_OPTION_JSON_EXTRA_DATA:', '+     case RAPTOR_OPTION_RSS_TRIPLES:', '+     case RAPTOR_OPTION_ATOM_ENTRY_URI:', '+     case RAPTOR_OPTION_PREFIX_ELEMENTS:', '+     case RAPTOR_OPTION_WRITE_BASE_URI:', '+     case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL:', '+     case RAPTOR_OPTION_WWW_HTTP_USER_AGENT:', '+ raptor_turtle_writer_set_option_string(raptor_turtle_writer *turtle_writer,', '+                                         raptor_option option,', '+      !raptor_option_is_valid_for_area(option, RAPTOR_OPTION_AREA_TURTLE_WRITER))', '+   if(raptor_option_value_is_numeric(option))', '+     return raptor_turtle_writer_set_option(turtle_writer, option,', '+ raptor_turtle_writer_get_option(raptor_turtle_writer *turtle_writer,', '+                                  raptor_option option)', '+   switch(option) {', '+     case RAPTOR_OPTION_WRITER_AUTO_INDENT:', '+     case RAPTOR_OPTION_WRITER_INDENT_WIDTH:', '+     case RAPTOR_OPTION_WRITER_AUTO_EMPTY:', '+     case RAPTOR_OPTION_WRITER_XML_VERSION:', '+     case RAPTOR_OPTION_WRITER_XML_DECLARATION:', '+     case RAPTOR_OPTION_SCANNING:', '+     case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES:', '+     case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES:', '+     case RAPTOR_OPTION_ALLOW_BAGID:', '+     case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST:', '+     case RAPTOR_OPTION_NORMALIZE_LANGUAGE:', '+     case RAPTOR_OPTION_NON_NFC_FATAL:', '+     case RAPTOR_OPTION_WARN_OTHER_PARSETYPES:', '+     case RAPTOR_OPTION_CHECK_RDF_ID:', '+     case RAPTOR_OPTION_HTML_TAG_SOUP:', '+     case RAPTOR_OPTION_MICROFORMATS:', '+     case RAPTOR_OPTION_HTML_LINK:', '+     case RAPTOR_OPTION_WWW_TIMEOUT:', '+     case RAPTOR_OPTION_NO_NET:', '+ ', '+     case RAPTOR_OPTION_RELATIVE_URIS:', '+ ', '+     case RAPTOR_OPTION_RESOURCE_BORDER:', '+     case RAPTOR_OPTION_LITERAL_BORDER:', '+     case RAPTOR_OPTION_BNODE_BORDER:', '+     case RAPTOR_OPTION_RESOURCE_FILL:', '+     case RAPTOR_OPTION_LITERAL_FILL:', '+     case RAPTOR_OPTION_BNODE_FILL:', '+ ', '+     case RAPTOR_OPTION_JSON_CALLBACK:', '+     case RAPTOR_OPTION_JSON_EXTRA_DATA:', '+     case RAPTOR_OPTION_RSS_TRIPLES:', '+     case RAPTOR_OPTION_ATOM_ENTRY_URI:', '+     case RAPTOR_OPTION_PREFIX_ELEMENTS:', '+     case RAPTOR_OPTION_WRITE_BASE_URI:', '+     case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL:', '+     case RAPTOR_OPTION_WWW_HTTP_USER_AGENT:', '+ raptor_turtle_writer_get_option_string(raptor_turtle_writer *turtle_writer,', '+                                         raptor_option option)', '+   raptor_turtle_writer_set_option(turtle_writer,', '+                                    RAPTOR_OPTION_WRITER_AUTO_INDENT, 1);', '- raptor_turtle_writer_set_feature(raptor_turtle_writer *turtle_writer,', '-                                  raptor_feature feature, int value)', '-      !raptor_feature_is_valid_for_area(feature, RAPTOR_FEATURE_AREA_TURTLE_WRITER))', '-   switch(feature) {', '-     case RAPTOR_FEATURE_WRITER_AUTO_INDENT:', '-     case RAPTOR_FEATURE_WRITER_INDENT_WIDTH:', '-     case RAPTOR_FEATURE_WRITER_AUTO_EMPTY:', '-     case RAPTOR_FEATURE_WRITER_XML_VERSION:', '-     case RAPTOR_FEATURE_WRITER_XML_DECLARATION:', '-     case RAPTOR_FEATURE_SCANNING:', '-     case RAPTOR_FEATURE_ALLOW_NON_NS_ATTRIBUTES:', '-     case RAPTOR_FEATURE_ALLOW_OTHER_PARSETYPES:', '-     case RAPTOR_FEATURE_ALLOW_BAGID:', '-     case RAPTOR_FEATURE_ALLOW_RDF_TYPE_RDF_LIST:', '-     case RAPTOR_FEATURE_NORMALIZE_LANGUAGE:', '-     case RAPTOR_FEATURE_NON_NFC_FATAL:', '-     case RAPTOR_FEATURE_WARN_OTHER_PARSETYPES:', '-     case RAPTOR_FEATURE_CHECK_RDF_ID:', '-     case RAPTOR_FEATURE_HTML_TAG_SOUP:', '-     case RAPTOR_FEATURE_MICROFORMATS:', '-     case RAPTOR_FEATURE_HTML_LINK:', '-     case RAPTOR_FEATURE_WWW_TIMEOUT:', '-     case RAPTOR_FEATURE_NO_NET:', '- ', '-     case RAPTOR_FEATURE_RELATIVE_URIS:', '- ', '-     case RAPTOR_FEATURE_RESOURCE_BORDER:', '-     case RAPTOR_FEATURE_LITERAL_BORDER:', '-     case RAPTOR_FEATURE_BNODE_BORDER:', '-     case RAPTOR_FEATURE_RESOURCE_FILL:', '-     case RAPTOR_FEATURE_LITERAL_FILL:', '-     case RAPTOR_FEATURE_BNODE_FILL:', '- ', '-     case RAPTOR_FEATURE_JSON_CALLBACK:', '-     case RAPTOR_FEATURE_JSON_EXTRA_DATA:', '-     case RAPTOR_FEATURE_RSS_TRIPLES:', '-     case RAPTOR_FEATURE_ATOM_ENTRY_URI:', '-     case RAPTOR_FEATURE_PREFIX_ELEMENTS:', '-     case RAPTOR_FEATURE_WRITE_BASE_URI:', '-     case RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL:', '-     case RAPTOR_FEATURE_WWW_HTTP_USER_AGENT:', '- raptor_turtle_writer_set_feature_string(raptor_turtle_writer *turtle_writer,', '-                                         raptor_feature feature,', '-      !raptor_feature_is_valid_for_area(feature, RAPTOR_FEATURE_AREA_TURTLE_WRITER))', '-   if(raptor_feature_value_is_numeric(feature))', '-     return raptor_turtle_writer_set_feature(turtle_writer, feature,', '- raptor_turtle_writer_get_feature(raptor_turtle_writer *turtle_writer,', '-                                  raptor_feature feature)', '-   switch(feature) {', '-     case RAPTOR_FEATURE_WRITER_AUTO_INDENT:', '-     case RAPTOR_FEATURE_WRITER_INDENT_WIDTH:', '-     case RAPTOR_FEATURE_WRITER_AUTO_EMPTY:', '-     case RAPTOR_FEATURE_WRITER_XML_VERSION:', '-     case RAPTOR_FEATURE_WRITER_XML_DECLARATION:', '-     case RAPTOR_FEATURE_SCANNING:', '-     case RAPTOR_FEATURE_ALLOW_NON_NS_ATTRIBUTES:', '-     case RAPTOR_FEATURE_ALLOW_OTHER_PARSETYPES:', '-     case RAPTOR_FEATURE_ALLOW_BAGID:', '-     case RAPTOR_FEATURE_ALLOW_RDF_TYPE_RDF_LIST:', '-     case RAPTOR_FEATURE_NORMALIZE_LANGUAGE:', '-     case RAPTOR_FEATURE_NON_NFC_FATAL:', '-     case RAPTOR_FEATURE_WARN_OTHER_PARSETYPES:', '-     case RAPTOR_FEATURE_CHECK_RDF_ID:', '-     case RAPTOR_FEATURE_HTML_TAG_SOUP:', '-     case RAPTOR_FEATURE_MICROFORMATS:', '-     case RAPTOR_FEATURE_HTML_LINK:', '-     case RAPTOR_FEATURE_WWW_TIMEOUT:', '-     case RAPTOR_FEATURE_NO_NET:', '- ', '-     case RAPTOR_FEATURE_RELATIVE_URIS:', '- ', '-     case RAPTOR_FEATURE_RESOURCE_BORDER:', '-     case RAPTOR_FEATURE_LITERAL_BORDER:', '-     case RAPTOR_FEATURE_BNODE_BORDER:', '-     case RAPTOR_FEATURE_RESOURCE_FILL:', '-     case RAPTOR_FEATURE_LITERAL_FILL:', '-     case RAPTOR_FEATURE_BNODE_FILL:', '- ', '-     case RAPTOR_FEATURE_JSON_CALLBACK:', '-     case RAPTOR_FEATURE_JSON_EXTRA_DATA:', '-     case RAPTOR_FEATURE_RSS_TRIPLES:', '-     case RAPTOR_FEATURE_ATOM_ENTRY_URI:', '-     case RAPTOR_FEATURE_PREFIX_ELEMENTS:', '-     case RAPTOR_FEATURE_WRITE_BASE_URI:', '-     case RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL:', '-     case RAPTOR_FEATURE_WWW_HTTP_USER_AGENT:', '- raptor_turtle_writer_get_feature_string(raptor_turtle_writer *turtle_writer,', '-                                         raptor_feature feature)', '-   raptor_turtle_writer_set_feature(turtle_writer,', '-                                    RAPTOR_FEATURE_WRITER_AUTO_INDENT, 1);']]","[['+ raptor_turtle_writer_set_option(raptor_turtle_writer *turtle_writer,', '+                                  raptor_option option, int value)', '+      !raptor_option_is_valid_for_area(option, raptor_option_area_turtle_writer))', '+   switch(option) {', '+     case raptor_option_writer_auto_indent:', '+     case raptor_option_writer_indent_width:', '+     case raptor_option_writer_auto_empty:', '+     case raptor_option_writer_xml_version:', '+     case raptor_option_writer_xml_declaration:', '+     case raptor_option_scanning:', '+     case raptor_option_allow_non_ns_attributes:', '+     case raptor_option_allow_other_parsetypes:', '+     case raptor_option_allow_bagid:', '+     case raptor_option_allow_rdf_type_rdf_list:', '+     case raptor_option_normalize_language:', '+     case raptor_option_non_nfc_fatal:', '+     case raptor_option_warn_other_parsetypes:', '+     case raptor_option_check_rdf_id:', '+     case raptor_option_html_tag_soup:', '+     case raptor_option_microformats:', '+     case raptor_option_html_link:', '+     case raptor_option_www_timeout:', '+     case raptor_option_no_net:', '+ ', '+     case raptor_option_relative_uris:', '+ ', '+     case raptor_option_resource_border:', '+     case raptor_option_literal_border:', '+     case raptor_option_bnode_border:', '+     case raptor_option_resource_fill:', '+     case raptor_option_literal_fill:', '+     case raptor_option_bnode_fill:', '+ ', '+     case raptor_option_json_callback:', '+     case raptor_option_json_extra_data:', '+     case raptor_option_rss_triples:', '+     case raptor_option_atom_entry_uri:', '+     case raptor_option_prefix_elements:', '+     case raptor_option_write_base_uri:', '+     case raptor_option_www_http_cache_control:', '+     case raptor_option_www_http_user_agent:', '+ raptor_turtle_writer_set_option_string(raptor_turtle_writer *turtle_writer,', '+                                         raptor_option option,', '+      !raptor_option_is_valid_for_area(option, raptor_option_area_turtle_writer))', '+   if(raptor_option_value_is_numeric(option))', '+     return raptor_turtle_writer_set_option(turtle_writer, option,', '+ raptor_turtle_writer_get_option(raptor_turtle_writer *turtle_writer,', '+                                  raptor_option option)', '+   switch(option) {', '+     case raptor_option_writer_auto_indent:', '+     case raptor_option_writer_indent_width:', '+     case raptor_option_writer_auto_empty:', '+     case raptor_option_writer_xml_version:', '+     case raptor_option_writer_xml_declaration:', '+     case raptor_option_scanning:', '+     case raptor_option_allow_non_ns_attributes:', '+     case raptor_option_allow_other_parsetypes:', '+     case raptor_option_allow_bagid:', '+     case raptor_option_allow_rdf_type_rdf_list:', '+     case raptor_option_normalize_language:', '+     case raptor_option_non_nfc_fatal:', '+     case raptor_option_warn_other_parsetypes:', '+     case raptor_option_check_rdf_id:', '+     case raptor_option_html_tag_soup:', '+     case raptor_option_microformats:', '+     case raptor_option_html_link:', '+     case raptor_option_www_timeout:', '+     case raptor_option_no_net:', '+ ', '+     case raptor_option_relative_uris:', '+ ', '+     case raptor_option_resource_border:', '+     case raptor_option_literal_border:', '+     case raptor_option_bnode_border:', '+     case raptor_option_resource_fill:', '+     case raptor_option_literal_fill:', '+     case raptor_option_bnode_fill:', '+ ', '+     case raptor_option_json_callback:', '+     case raptor_option_json_extra_data:', '+     case raptor_option_rss_triples:', '+     case raptor_option_atom_entry_uri:', '+     case raptor_option_prefix_elements:', '+     case raptor_option_write_base_uri:', '+     case raptor_option_www_http_cache_control:', '+     case raptor_option_www_http_user_agent:', '+ raptor_turtle_writer_get_option_string(raptor_turtle_writer *turtle_writer,', '+                                         raptor_option option)', '+   raptor_turtle_writer_set_option(turtle_writer,', '+                                    raptor_option_writer_auto_indent, 1);', '- raptor_turtle_writer_set_feature(raptor_turtle_writer *turtle_writer,', '-                                  raptor_feature feature, int value)', '-      !raptor_feature_is_valid_for_area(feature, raptor_feature_area_turtle_writer))', '-   switch(feature) {', '-     case raptor_feature_writer_auto_indent:', '-     case raptor_feature_writer_indent_width:', '-     case raptor_feature_writer_auto_empty:', '-     case raptor_feature_writer_xml_version:', '-     case raptor_feature_writer_xml_declaration:', '-     case raptor_feature_scanning:', '-     case raptor_feature_allow_non_ns_attributes:', '-     case raptor_feature_allow_other_parsetypes:', '-     case raptor_feature_allow_bagid:', '-     case raptor_feature_allow_rdf_type_rdf_list:', '-     case raptor_feature_normalize_language:', '-     case raptor_feature_non_nfc_fatal:', '-     case raptor_feature_warn_other_parsetypes:', '-     case raptor_feature_check_rdf_id:', '-     case raptor_feature_html_tag_soup:', '-     case raptor_feature_microformats:', '-     case raptor_feature_html_link:', '-     case raptor_feature_www_timeout:', '-     case raptor_feature_no_net:', '- ', '-     case raptor_feature_relative_uris:', '- ', '-     case raptor_feature_resource_border:', '-     case raptor_feature_literal_border:', '-     case raptor_feature_bnode_border:', '-     case raptor_feature_resource_fill:', '-     case raptor_feature_literal_fill:', '-     case raptor_feature_bnode_fill:', '- ', '-     case raptor_feature_json_callback:', '-     case raptor_feature_json_extra_data:', '-     case raptor_feature_rss_triples:', '-     case raptor_feature_atom_entry_uri:', '-     case raptor_feature_prefix_elements:', '-     case raptor_feature_write_base_uri:', '-     case raptor_feature_www_http_cache_control:', '-     case raptor_feature_www_http_user_agent:', '- raptor_turtle_writer_set_feature_string(raptor_turtle_writer *turtle_writer,', '-                                         raptor_feature feature,', '-      !raptor_feature_is_valid_for_area(feature, raptor_feature_area_turtle_writer))', '-   if(raptor_feature_value_is_numeric(feature))', '-     return raptor_turtle_writer_set_feature(turtle_writer, feature,', '- raptor_turtle_writer_get_feature(raptor_turtle_writer *turtle_writer,', '-                                  raptor_feature feature)', '-   switch(feature) {', '-     case raptor_feature_writer_auto_indent:', '-     case raptor_feature_writer_indent_width:', '-     case raptor_feature_writer_auto_empty:', '-     case raptor_feature_writer_xml_version:', '-     case raptor_feature_writer_xml_declaration:', '-     case raptor_feature_scanning:', '-     case raptor_feature_allow_non_ns_attributes:', '-     case raptor_feature_allow_other_parsetypes:', '-     case raptor_feature_allow_bagid:', '-     case raptor_feature_allow_rdf_type_rdf_list:', '-     case raptor_feature_normalize_language:', '-     case raptor_feature_non_nfc_fatal:', '-     case raptor_feature_warn_other_parsetypes:', '-     case raptor_feature_check_rdf_id:', '-     case raptor_feature_html_tag_soup:', '-     case raptor_feature_microformats:', '-     case raptor_feature_html_link:', '-     case raptor_feature_www_timeout:', '-     case raptor_feature_no_net:', '- ', '-     case raptor_feature_relative_uris:', '- ', '-     case raptor_feature_resource_border:', '-     case raptor_feature_literal_border:', '-     case raptor_feature_bnode_border:', '-     case raptor_feature_resource_fill:', '-     case raptor_feature_literal_fill:', '-     case raptor_feature_bnode_fill:', '- ', '-     case raptor_feature_json_callback:', '-     case raptor_feature_json_extra_data:', '-     case raptor_feature_rss_triples:', '-     case raptor_feature_atom_entry_uri:', '-     case raptor_feature_prefix_elements:', '-     case raptor_feature_write_base_uri:', '-     case raptor_feature_www_http_cache_control:', '-     case raptor_feature_www_http_user_agent:', '- raptor_turtle_writer_get_feature_string(raptor_turtle_writer *turtle_writer,', '-                                         raptor_feature feature)', '-   raptor_turtle_writer_set_feature(turtle_writer,', '-                                    raptor_feature_writer_auto_indent, 1);']]","[['+ raptor_turtle_writer_set_option(raptor_turtle_writer *turtle_writer,', '+                                  raptor_option option, int value)', '+      !raptor_option_is_valid_for_area(option, RAPTOR_OPTION_AREA_TURTLE_WRITER))', '+   switch(option) {', '+     case RAPTOR_OPTION_WRITER_AUTO_INDENT:', '+     case RAPTOR_OPTION_WRITER_INDENT_WIDTH:', '+     case RAPTOR_OPTION_WRITER_AUTO_EMPTY:', '+     case RAPTOR_OPTION_WRITER_XML_VERSION:', '+     case RAPTOR_OPTION_WRITER_XML_DECLARATION:', '+     case RAPTOR_OPTION_SCANNING:', '+     case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES:', '+     case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES:', '+     case RAPTOR_OPTION_ALLOW_BAGID:', '+     case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST:', '+     case RAPTOR_OPTION_NORMALIZE_LANGUAGE:', '+     case RAPTOR_OPTION_NON_NFC_FATAL:', '+     case RAPTOR_OPTION_WARN_OTHER_PARSETYPES:', '+     case RAPTOR_OPTION_CHECK_RDF_ID:', '+     case RAPTOR_OPTION_HTML_TAG_SOUP:', '+     case RAPTOR_OPTION_MICROFORMATS:', '+     case RAPTOR_OPTION_HTML_LINK:', '+     case RAPTOR_OPTION_WWW_TIMEOUT:', '+     case RAPTOR_OPTION_NO_NET:', '+ ', '+     case RAPTOR_OPTION_RELATIVE_URIS:', '+ ', '+     case RAPTOR_OPTION_RESOURCE_BORDER:', '+     case RAPTOR_OPTION_LITERAL_BORDER:', '+     case RAPTOR_OPTION_BNODE_BORDER:', '+     case RAPTOR_OPTION_RESOURCE_FILL:', '+     case RAPTOR_OPTION_LITERAL_FILL:', '+     case RAPTOR_OPTION_BNODE_FILL:', '+ ', '+     case RAPTOR_OPTION_JSON_CALLBACK:', '+     case RAPTOR_OPTION_JSON_EXTRA_DATA:', '+     case RAPTOR_OPTION_RSS_TRIPLES:', '+     case RAPTOR_OPTION_ATOM_ENTRY_URI:', '+     case RAPTOR_OPTION_PREFIX_ELEMENTS:', '+     case RAPTOR_OPTION_WRITE_BASE_URI:', '+     case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL:', '+     case RAPTOR_OPTION_WWW_HTTP_USER_AGENT:', '+ raptor_turtle_writer_set_option_string(raptor_turtle_writer *turtle_writer,', '+                                         raptor_option option,', '+      !raptor_option_is_valid_for_area(option, RAPTOR_OPTION_AREA_TURTLE_WRITER))', '+   if(raptor_option_value_is_numeric(option))', '+     return raptor_turtle_writer_set_option(turtle_writer, option,', '+ raptor_turtle_writer_get_option(raptor_turtle_writer *turtle_writer,', '+                                  raptor_option option)', '+   switch(option) {', '+     case RAPTOR_OPTION_WRITER_AUTO_INDENT:', '+     case RAPTOR_OPTION_WRITER_INDENT_WIDTH:', '+     case RAPTOR_OPTION_WRITER_AUTO_EMPTY:', '+     case RAPTOR_OPTION_WRITER_XML_VERSION:', '+     case RAPTOR_OPTION_WRITER_XML_DECLARATION:', '+     case RAPTOR_OPTION_SCANNING:', '+     case RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES:', '+     case RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES:', '+     case RAPTOR_OPTION_ALLOW_BAGID:', '+     case RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST:', '+     case RAPTOR_OPTION_NORMALIZE_LANGUAGE:', '+     case RAPTOR_OPTION_NON_NFC_FATAL:', '+     case RAPTOR_OPTION_WARN_OTHER_PARSETYPES:', '+     case RAPTOR_OPTION_CHECK_RDF_ID:', '+     case RAPTOR_OPTION_HTML_TAG_SOUP:', '+     case RAPTOR_OPTION_MICROFORMATS:', '+     case RAPTOR_OPTION_HTML_LINK:', '+     case RAPTOR_OPTION_WWW_TIMEOUT:', '+     case RAPTOR_OPTION_NO_NET:', '+ ', '+     case RAPTOR_OPTION_RELATIVE_URIS:', '+ ', '+     case RAPTOR_OPTION_RESOURCE_BORDER:', '+     case RAPTOR_OPTION_LITERAL_BORDER:', '+     case RAPTOR_OPTION_BNODE_BORDER:', '+     case RAPTOR_OPTION_RESOURCE_FILL:', '+     case RAPTOR_OPTION_LITERAL_FILL:', '+     case RAPTOR_OPTION_BNODE_FILL:', '+ ', '+     case RAPTOR_OPTION_JSON_CALLBACK:', '+     case RAPTOR_OPTION_JSON_EXTRA_DATA:', '+     case RAPTOR_OPTION_RSS_TRIPLES:', '+     case RAPTOR_OPTION_ATOM_ENTRY_URI:', '+     case RAPTOR_OPTION_PREFIX_ELEMENTS:', '+     case RAPTOR_OPTION_WRITE_BASE_URI:', '+     case RAPTOR_OPTION_WWW_HTTP_CACHE_CONTROL:', '+     case RAPTOR_OPTION_WWW_HTTP_USER_AGENT:', '+ raptor_turtle_writer_get_option_string(raptor_turtle_writer *turtle_writer,', '+                                         raptor_option option)', '+   raptor_turtle_writer_set_option(turtle_writer,', '+                                    RAPTOR_OPTION_WRITER_AUTO_INDENT, 1);']]","[['- raptor_turtle_writer_set_feature(raptor_turtle_writer *turtle_writer,', '-                                  raptor_feature feature, int value)', '-      !raptor_feature_is_valid_for_area(feature, RAPTOR_FEATURE_AREA_TURTLE_WRITER))', '-   switch(feature) {', '-     case RAPTOR_FEATURE_WRITER_AUTO_INDENT:', '-     case RAPTOR_FEATURE_WRITER_INDENT_WIDTH:', '-     case RAPTOR_FEATURE_WRITER_AUTO_EMPTY:', '-     case RAPTOR_FEATURE_WRITER_XML_VERSION:', '-     case RAPTOR_FEATURE_WRITER_XML_DECLARATION:', '-     case RAPTOR_FEATURE_SCANNING:', '-     case RAPTOR_FEATURE_ALLOW_NON_NS_ATTRIBUTES:', '-     case RAPTOR_FEATURE_ALLOW_OTHER_PARSETYPES:', '-     case RAPTOR_FEATURE_ALLOW_BAGID:', '-     case RAPTOR_FEATURE_ALLOW_RDF_TYPE_RDF_LIST:', '-     case RAPTOR_FEATURE_NORMALIZE_LANGUAGE:', '-     case RAPTOR_FEATURE_NON_NFC_FATAL:', '-     case RAPTOR_FEATURE_WARN_OTHER_PARSETYPES:', '-     case RAPTOR_FEATURE_CHECK_RDF_ID:', '-     case RAPTOR_FEATURE_HTML_TAG_SOUP:', '-     case RAPTOR_FEATURE_MICROFORMATS:', '-     case RAPTOR_FEATURE_HTML_LINK:', '-     case RAPTOR_FEATURE_WWW_TIMEOUT:', '-     case RAPTOR_FEATURE_NO_NET:', '- ', '-     case RAPTOR_FEATURE_RELATIVE_URIS:', '- ', '-     case RAPTOR_FEATURE_RESOURCE_BORDER:', '-     case RAPTOR_FEATURE_LITERAL_BORDER:', '-     case RAPTOR_FEATURE_BNODE_BORDER:', '-     case RAPTOR_FEATURE_RESOURCE_FILL:', '-     case RAPTOR_FEATURE_LITERAL_FILL:', '-     case RAPTOR_FEATURE_BNODE_FILL:', '- ', '-     case RAPTOR_FEATURE_JSON_CALLBACK:', '-     case RAPTOR_FEATURE_JSON_EXTRA_DATA:', '-     case RAPTOR_FEATURE_RSS_TRIPLES:', '-     case RAPTOR_FEATURE_ATOM_ENTRY_URI:', '-     case RAPTOR_FEATURE_PREFIX_ELEMENTS:', '-     case RAPTOR_FEATURE_WRITE_BASE_URI:', '-     case RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL:', '-     case RAPTOR_FEATURE_WWW_HTTP_USER_AGENT:', '- raptor_turtle_writer_set_feature_string(raptor_turtle_writer *turtle_writer,', '-                                         raptor_feature feature,', '-      !raptor_feature_is_valid_for_area(feature, RAPTOR_FEATURE_AREA_TURTLE_WRITER))', '-   if(raptor_feature_value_is_numeric(feature))', '-     return raptor_turtle_writer_set_feature(turtle_writer, feature,', '- raptor_turtle_writer_get_feature(raptor_turtle_writer *turtle_writer,', '-                                  raptor_feature feature)', '-   switch(feature) {', '-     case RAPTOR_FEATURE_WRITER_AUTO_INDENT:', '-     case RAPTOR_FEATURE_WRITER_INDENT_WIDTH:', '-     case RAPTOR_FEATURE_WRITER_AUTO_EMPTY:', '-     case RAPTOR_FEATURE_WRITER_XML_VERSION:', '-     case RAPTOR_FEATURE_WRITER_XML_DECLARATION:', '-     case RAPTOR_FEATURE_SCANNING:', '-     case RAPTOR_FEATURE_ALLOW_NON_NS_ATTRIBUTES:', '-     case RAPTOR_FEATURE_ALLOW_OTHER_PARSETYPES:', '-     case RAPTOR_FEATURE_ALLOW_BAGID:', '-     case RAPTOR_FEATURE_ALLOW_RDF_TYPE_RDF_LIST:', '-     case RAPTOR_FEATURE_NORMALIZE_LANGUAGE:', '-     case RAPTOR_FEATURE_NON_NFC_FATAL:', '-     case RAPTOR_FEATURE_WARN_OTHER_PARSETYPES:', '-     case RAPTOR_FEATURE_CHECK_RDF_ID:', '-     case RAPTOR_FEATURE_HTML_TAG_SOUP:', '-     case RAPTOR_FEATURE_MICROFORMATS:', '-     case RAPTOR_FEATURE_HTML_LINK:', '-     case RAPTOR_FEATURE_WWW_TIMEOUT:', '-     case RAPTOR_FEATURE_NO_NET:', '- ', '-     case RAPTOR_FEATURE_RELATIVE_URIS:', '- ', '-     case RAPTOR_FEATURE_RESOURCE_BORDER:', '-     case RAPTOR_FEATURE_LITERAL_BORDER:', '-     case RAPTOR_FEATURE_BNODE_BORDER:', '-     case RAPTOR_FEATURE_RESOURCE_FILL:', '-     case RAPTOR_FEATURE_LITERAL_FILL:', '-     case RAPTOR_FEATURE_BNODE_FILL:', '- ', '-     case RAPTOR_FEATURE_JSON_CALLBACK:', '-     case RAPTOR_FEATURE_JSON_EXTRA_DATA:', '-     case RAPTOR_FEATURE_RSS_TRIPLES:', '-     case RAPTOR_FEATURE_ATOM_ENTRY_URI:', '-     case RAPTOR_FEATURE_PREFIX_ELEMENTS:', '-     case RAPTOR_FEATURE_WRITE_BASE_URI:', '-     case RAPTOR_FEATURE_WWW_HTTP_CACHE_CONTROL:', '-     case RAPTOR_FEATURE_WWW_HTTP_USER_AGENT:', '- raptor_turtle_writer_get_feature_string(raptor_turtle_writer *turtle_writer,', '-                                         raptor_feature feature)', '-   raptor_turtle_writer_set_feature(turtle_writer,', '-                                    RAPTOR_FEATURE_WRITER_AUTO_INDENT, 1);']]",90,90.0,180.0,13501024f21c52342c250866ead3e41eb521035cdajobe/raptor,['a676f235309a59d4aa78eeffd2574ae5d341fcb0']
cdf21bc22a50f471a2fca385227c8016e738f23d,mumble-voip/mumble,src/mumble/Database.cpp,test,C++,1,"['@@ -81,14 +81,14 @@ Database::Database() {\n \t}\n \n \tif (! found) {\n-\t\tQMessageBox::critical(NULL, tr(""Mumble""), tr(""Mumble failed to initialize a database in any\\nof the possible locations.""), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n+\t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""Mumble failed to initialize a database in any\\nof the possible locations.""), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n \t\tqFatal(""Database: Failed initialization"");\n \t}\n \n \tQFileInfo fi(db.databaseName());\n \n \tif (! fi.isWritable()) {\n-\t\tQMessageBox::critical(NULL, tr(""Mumble""), tr(""The database \'%1\' is read-only. Mumble can not store server settings (ie. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n+\t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""The database \'%1\' is read-only. Mumble can not store server settings (ie. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);\n \t\tqWarning(""Database: Database is read-only"");\n \t}\n \n']",2010-01-27 23:19:48+01:00,Some untranslatable strings were marked translatable,"[['+ \t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""Mumble failed to initialize a database in any\\nof the possible locations.""), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);', '+ \t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""The database \'%1\' is read-only. Mumble can not store server settings (ie. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);', '- \t\tQMessageBox::critical(NULL, tr(""Mumble""), tr(""Mumble failed to initialize a database in any\\nof the possible locations.""), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);', '- \t\tQMessageBox::critical(NULL, tr(""Mumble""), tr(""The database \'%1\' is read-only. Mumble can not store server settings (ie. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);']]","[['+ \t\tqmessagebox::critical(null, qlatin1string(""mumble""), tr(""mumble failed to initialize a database in any\\nof the possible locations.""), qmessagebox::ok | qmessagebox::default, qmessagebox::nobutton);', '+ \t\tqmessagebox::critical(null, qlatin1string(""mumble""), tr(""the database \'%1\' is read-only. mumble can not store server settings (ie. ssl certificates) until you fix this problem."").arg(fi.filepath()), qmessagebox::ok | qmessagebox::default, qmessagebox::nobutton);', '- \t\tqmessagebox::critical(null, tr(""mumble""), tr(""mumble failed to initialize a database in any\\nof the possible locations.""), qmessagebox::ok | qmessagebox::default, qmessagebox::nobutton);', '- \t\tqmessagebox::critical(null, tr(""mumble""), tr(""the database \'%1\' is read-only. mumble can not store server settings (ie. ssl certificates) until you fix this problem."").arg(fi.filepath()), qmessagebox::ok | qmessagebox::default, qmessagebox::nobutton);']]","[['+ \t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""Mumble failed to initialize a database in any\\nof the possible locations.""), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);', '+ \t\tQMessageBox::critical(NULL, QLatin1String(""Mumble""), tr(""The database \'%1\' is read-only. Mumble can not store server settings (ie. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);']]","[['- \t\tQMessageBox::critical(NULL, tr(""Mumble""), tr(""Mumble failed to initialize a database in any\\nof the possible locations.""), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);', '- \t\tQMessageBox::critical(NULL, tr(""Mumble""), tr(""The database \'%1\' is read-only. Mumble can not store server settings (ie. SSL certificates) until you fix this problem."").arg(fi.filePath()), QMessageBox::Ok | QMessageBox::Default, QMessageBox::NoButton);']]",2,2.0,4.0,cdf21bc22a50f471a2fca385227c8016e738f23dmumble-voip/mumble,['5632c35d6759f5e13a7dfe78e4ee6403ff6a8e3e']
2c85e77c20699c02859eb1eb517831cab23eac55,file/file,src/cdf.c,train,C,1,"['@@ -35,7 +35,7 @@\n #include ""file.h""\n \n #ifndef lint\n-FILE_RCSID(""@(#)$File: cdf.c,v 1.49 2012/02/20 20:04:37 christos Exp $"")\n+FILE_RCSID(""@(#)$File: cdf.c,v 1.50 2012/02/20 22:35:29 christos Exp $"")\n #endif\n \n #include <assert.h>\n@@ -268,10 +268,10 @@ cdf_check_stream_offset(const cdf_stream_t *sst, const cdf_header_t *h,\n \tconst char *b = (const char *)sst->sst_tab;\n \tconst char *e = ((const char *)p) + tail;\n \t(void)&line;\n-\tif (e >= b && (size_t)(e - b) < CDF_SEC_SIZE(h) * sst->sst_len)\n+\tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)\n \t\treturn 0;\n-\tDPRINTF((""%d: offset begin %p end %p %"" SIZE_T_FORMAT ""u""\n-\t    "" >= %"" SIZE_T_FORMAT ""u [%"" SIZE_T_FORMAT ""u %""\n+\tDPRINTF((""%d: offset begin %p < end %p || %"" SIZE_T_FORMAT ""u""\n+\t    "" > %"" SIZE_T_FORMAT ""u [%"" SIZE_T_FORMAT ""u %""\n \t    SIZE_T_FORMAT ""u]\\n"", line, b, e, (size_t)(e - b),\n \t    CDF_SEC_SIZE(h) * sst->sst_len, CDF_SEC_SIZE(h), sst->sst_len));\n \terrno = EFTYPE;\n']",2012-03-20 18:28:02+00:00,allow size <= to the size we have not just <,"[['+ FILE_RCSID(""@(#)$File: cdf.c,v 1.50 2012/02/20 22:35:29 christos Exp $"")', '+ \tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)', '+ \tDPRINTF((""%d: offset begin %p < end %p || %"" SIZE_T_FORMAT ""u""', '+ \t    "" > %"" SIZE_T_FORMAT ""u [%"" SIZE_T_FORMAT ""u %""', '- FILE_RCSID(""@(#)$File: cdf.c,v 1.49 2012/02/20 20:04:37 christos Exp $"")', '- \tif (e >= b && (size_t)(e - b) < CDF_SEC_SIZE(h) * sst->sst_len)', '- \tDPRINTF((""%d: offset begin %p end %p %"" SIZE_T_FORMAT ""u""', '- \t    "" >= %"" SIZE_T_FORMAT ""u [%"" SIZE_T_FORMAT ""u %""']]","[['+ file_rcsid(""@(#)$file: cdf.c,v 1.50 2012/02/20 22:35:29 christos exp $"")', '+ \tif (e >= b && (size_t)(e - b) <= cdf_sec_size(h) * sst->sst_len)', '+ \tdprintf((""%d: offset begin %p < end %p || %"" size_t_format ""u""', '+ \t    "" > %"" size_t_format ""u [%"" size_t_format ""u %""', '- file_rcsid(""@(#)$file: cdf.c,v 1.49 2012/02/20 20:04:37 christos exp $"")', '- \tif (e >= b && (size_t)(e - b) < cdf_sec_size(h) * sst->sst_len)', '- \tdprintf((""%d: offset begin %p end %p %"" size_t_format ""u""', '- \t    "" >= %"" size_t_format ""u [%"" size_t_format ""u %""']]","[['+ FILE_RCSID(""@(#)$File: cdf.c,v 1.50 2012/02/20 22:35:29 christos Exp $"")', '+ \tif (e >= b && (size_t)(e - b) <= CDF_SEC_SIZE(h) * sst->sst_len)', '+ \tDPRINTF((""%d: offset begin %p < end %p || %"" SIZE_T_FORMAT ""u""', '+ \t    "" > %"" SIZE_T_FORMAT ""u [%"" SIZE_T_FORMAT ""u %""']]","[['- FILE_RCSID(""@(#)$File: cdf.c,v 1.49 2012/02/20 20:04:37 christos Exp $"")', '- \tif (e >= b && (size_t)(e - b) < CDF_SEC_SIZE(h) * sst->sst_len)', '- \tDPRINTF((""%d: offset begin %p end %p %"" SIZE_T_FORMAT ""u""', '- \t    "" >= %"" SIZE_T_FORMAT ""u [%"" SIZE_T_FORMAT ""u %""']]",4,4.0,8.0,2c85e77c20699c02859eb1eb517831cab23eac55file/file,['36fadd29849b8087af9f4586f89dbf74ea45be67']
e38f8cad76f0a6d0f674aa39c1af45f8e3500049,LibRaw/LibRaw,internal/dcraw_common.cpp,train,C++,1,"['@@ -634,19 +634,6 @@ int CLASS ljpeg_diff_new (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushor\n   return diff;\n }\n \n-int CLASS ljpeg_diff_pef (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)\n-{\n-  int len, diff;\n-\n-  len = bits._gethuff(buf,*huff,huff+1,zero_after_ff);\n-  if (len == 16 && (!dng_version || dng_version >= 0x1010000))\n-    return -32768;\n-  diff = bits._getbits(buf,len,zero_after_ff);\n-  if ((diff & (1 << (len-1))) == 0)\n-    diff -= (1 << len) - 1;\n-  return diff;\n-}\n-\n ushort * CLASS ljpeg_row_new (int jrow, struct jhead *jh, LibRaw_bit_buffer& bits,LibRaw_byte_buffer* bytes)\n {\n   int col, c, diff, pred, spred=0;\n@@ -1128,30 +1115,15 @@ void CLASS pentax_load_raw()\n       huff[++i] = bit[1][c] << 8 | c;\n   huff[0] = 12;\n   fseek (ifp, data_offset, SEEK_SET);\n-#ifdef LIBRAW_LIBRARY_BUILDA\n-  if(!data_size)\n-      throw LIBRAW_EXCEPTION_IO_BADFILE;\n-  LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);\n-  LibRaw_bit_buffer bits;\n-  bits.reset();\n-#else\n   getbits(-1);\n-#endif\n   for (row=0; row < raw_height; row++)\n     for (col=0; col < raw_width; col++) {\n-#ifdef LIBRAW_LIBRARY_BUILDA\n-      diff = ljpeg_diff_pef(bits,buf,huff);\n-#else\n       diff = ljpeg_diff (huff);\n-#endif\n       if (col < 2) hpred[col] = vpred[row & 1][col] += diff;\n       else\t   hpred[col & 1] += diff;\n       RAW(row,col) = hpred[col & 1];\n       if (hpred[col & 1] >> tiff_bps) derror();\n     }\n-#ifdef LIBRAW_LIBRARY_BUILDA\n-  delete buf;\n-#endif\n }\n \n void CLASS nikon_load_raw()\n@@ -1311,7 +1283,7 @@ int CLASS minolta_z2()\n     if (tail[i]) nz++;\n   return nz > 20;\n }\n-#line 1585 ""dcraw/dcraw.c""\n+#line 1557 ""dcraw/dcraw.c""\n void CLASS ppm_thumb()\n {\n   char *thumb;\n@@ -2893,7 +2865,7 @@ void CLASS redcine_load_raw()\n   jas_stream_close (in);\n #endif\n }\n-#line 3874 ""dcraw/dcraw.c""\n+#line 3846 ""dcraw/dcraw.c""\n void CLASS crop_masked_pixels()\n {\n   int row, col;\n@@ -2993,7 +2965,7 @@ void CLASS remove_zeroes()\n   RUN_CALLBACK(LIBRAW_PROGRESS_REMOVE_ZEROES,1,2);\n #endif\n }\n-#line 4139 ""dcraw/dcraw.c""\n+#line 4111 ""dcraw/dcraw.c""\n void CLASS gamma_curve (double pwr, double ts, int mode, int imax)\n {\n   int i;\n@@ -4488,7 +4460,7 @@ void CLASS parse_thumb_note (int base, unsigned toff, unsigned tlen)\n     fseek (ifp, save, SEEK_SET);\n   }\n }\n-#line 5638 ""dcraw/dcraw.c""\n+#line 5610 ""dcraw/dcraw.c""\n void CLASS parse_makernote (int base, int uptag)\n {\n   static const uchar xlat[2][256] = {\n@@ -5003,7 +4975,7 @@ void CLASS parse_kodak_ifd (int base)\n     fseek (ifp, save, SEEK_SET);\n   }\n }\n-#line 6158 ""dcraw/dcraw.c""\n+#line 6130 ""dcraw/dcraw.c""\n int CLASS parse_tiff_ifd (int base)\n {\n   unsigned entries, tag, type, len, plen=16, save;\n@@ -6261,7 +6233,7 @@ void CLASS parse_redcine()\n     data_offset = get4();\n   }\n }\n-#line 7418 ""dcraw/dcraw.c""\n+#line 7390 ""dcraw/dcraw.c""\n char * CLASS foveon_gets (int offset, char *str, int len)\n {\n   int i;\n@@ -6362,7 +6334,7 @@ void CLASS parse_foveon()\n   }\n   is_foveon = 1;\n }\n-#line 7521 ""dcraw/dcraw.c""\n+#line 7493 ""dcraw/dcraw.c""\n /*\n    All matrices are from Adobe DNG Converter unless otherwise noted.\n  */\n@@ -8999,7 +8971,7 @@ c603:\n }\n \n \n-#line 10249 ""dcraw/dcraw.c""\n+#line 10221 ""dcraw/dcraw.c""\n void CLASS convert_to_rgb()\n {\n #ifndef LIBRAW_LIBRARY_BUILD\n@@ -9230,7 +9202,7 @@ int CLASS flip_index (int row, int col)\n   if (flip & 1) col = iwidth  - 1 - col;\n   return row * iwidth + col;\n }\n-#line 10505 ""dcraw/dcraw.c""\n+#line 10477 ""dcraw/dcraw.c""\n void CLASS tiff_set (ushort *ntag,\n \tushort tag, ushort type, int count, int val)\n {\n']",2013-07-04 07:26:01+04:00,pentax pef decoder final fixes,"[['+ #line 1557 ""dcraw/dcraw.c""', '+ #line 3846 ""dcraw/dcraw.c""', '+ #line 4111 ""dcraw/dcraw.c""', '+ #line 5610 ""dcraw/dcraw.c""', '+ #line 6130 ""dcraw/dcraw.c""', '+ #line 7390 ""dcraw/dcraw.c""', '+ #line 7493 ""dcraw/dcraw.c""', '+ #line 10221 ""dcraw/dcraw.c""', '+ #line 10477 ""dcraw/dcraw.c""', '- int CLASS ljpeg_diff_pef (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)', '- {', '-   int len, diff;', '- ', '-   len = bits._gethuff(buf,*huff,huff+1,zero_after_ff);', '-   if (len == 16 && (!dng_version || dng_version >= 0x1010000))', '-     return -32768;', '-   diff = bits._getbits(buf,len,zero_after_ff);', '-   if ((diff & (1 << (len-1))) == 0)', '-     diff -= (1 << len) - 1;', '-   return diff;', '- }', '- ', '- #ifdef LIBRAW_LIBRARY_BUILDA', '-   if(!data_size)', '-       throw LIBRAW_EXCEPTION_IO_BADFILE;', '-   LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);', '-   LibRaw_bit_buffer bits;', '-   bits.reset();', '- #else', '- #endif', '- #ifdef LIBRAW_LIBRARY_BUILDA', '-       diff = ljpeg_diff_pef(bits,buf,huff);', '- #else', '- #endif', '- #ifdef LIBRAW_LIBRARY_BUILDA', '-   delete buf;', '- #endif', '- #line 1585 ""dcraw/dcraw.c""', '- #line 3874 ""dcraw/dcraw.c""', '- #line 4139 ""dcraw/dcraw.c""', '- #line 5638 ""dcraw/dcraw.c""', '- #line 6158 ""dcraw/dcraw.c""', '- #line 7418 ""dcraw/dcraw.c""', '- #line 7521 ""dcraw/dcraw.c""', '- #line 10249 ""dcraw/dcraw.c""', '- #line 10505 ""dcraw/dcraw.c""']]","[['+ #line 1557 ""dcraw/dcraw.c""', '+ #line 3846 ""dcraw/dcraw.c""', '+ #line 4111 ""dcraw/dcraw.c""', '+ #line 5610 ""dcraw/dcraw.c""', '+ #line 6130 ""dcraw/dcraw.c""', '+ #line 7390 ""dcraw/dcraw.c""', '+ #line 7493 ""dcraw/dcraw.c""', '+ #line 10221 ""dcraw/dcraw.c""', '+ #line 10477 ""dcraw/dcraw.c""', '- int class ljpeg_diff_pef (libraw_bit_buffer& bits, libraw_byte_buffer* buf,ushort *huff)', '- {', '-   int len, diff;', '- ', '-   len = bits._gethuff(buf,*huff,huff+1,zero_after_ff);', '-   if (len == 16 && (!dng_version || dng_version >= 0x1010000))', '-     return -32768;', '-   diff = bits._getbits(buf,len,zero_after_ff);', '-   if ((diff & (1 << (len-1))) == 0)', '-     diff -= (1 << len) - 1;', '-   return diff;', '- }', '- ', '- #ifdef libraw_library_builda', '-   if(!data_size)', '-       throw libraw_exception_io_badfile;', '-   libraw_byte_buffer *buf = ifp->make_byte_buffer(data_size);', '-   libraw_bit_buffer bits;', '-   bits.reset();', '- #else', '- #endif', '- #ifdef libraw_library_builda', '-       diff = ljpeg_diff_pef(bits,buf,huff);', '- #else', '- #endif', '- #ifdef libraw_library_builda', '-   delete buf;', '- #endif', '- #line 1585 ""dcraw/dcraw.c""', '- #line 3874 ""dcraw/dcraw.c""', '- #line 4139 ""dcraw/dcraw.c""', '- #line 5638 ""dcraw/dcraw.c""', '- #line 6158 ""dcraw/dcraw.c""', '- #line 7418 ""dcraw/dcraw.c""', '- #line 7521 ""dcraw/dcraw.c""', '- #line 10249 ""dcraw/dcraw.c""', '- #line 10505 ""dcraw/dcraw.c""']]","[['+ #line 1557 ""dcraw/dcraw.c""', '+ #line 3846 ""dcraw/dcraw.c""', '+ #line 4111 ""dcraw/dcraw.c""', '+ #line 5610 ""dcraw/dcraw.c""', '+ #line 6130 ""dcraw/dcraw.c""', '+ #line 7390 ""dcraw/dcraw.c""', '+ #line 7493 ""dcraw/dcraw.c""', '+ #line 10221 ""dcraw/dcraw.c""', '+ #line 10477 ""dcraw/dcraw.c""']]","[['- int CLASS ljpeg_diff_pef (LibRaw_bit_buffer& bits, LibRaw_byte_buffer* buf,ushort *huff)', '- {', '-   int len, diff;', '- ', '-   len = bits._gethuff(buf,*huff,huff+1,zero_after_ff);', '-   if (len == 16 && (!dng_version || dng_version >= 0x1010000))', '-     return -32768;', '-   diff = bits._getbits(buf,len,zero_after_ff);', '-   if ((diff & (1 << (len-1))) == 0)', '-     diff -= (1 << len) - 1;', '-   return diff;', '- }', '- ', '- #ifdef LIBRAW_LIBRARY_BUILDA', '-   if(!data_size)', '-       throw LIBRAW_EXCEPTION_IO_BADFILE;', '-   LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);', '-   LibRaw_bit_buffer bits;', '-   bits.reset();', '- #else', '- #endif', '- #ifdef LIBRAW_LIBRARY_BUILDA', '-       diff = ljpeg_diff_pef(bits,buf,huff);', '- #else', '- #endif', '- #ifdef LIBRAW_LIBRARY_BUILDA', '-   delete buf;', '- #endif', '- #line 1585 ""dcraw/dcraw.c""', '- #line 3874 ""dcraw/dcraw.c""', '- #line 4139 ""dcraw/dcraw.c""', '- #line 5638 ""dcraw/dcraw.c""', '- #line 6158 ""dcraw/dcraw.c""', '- #line 7418 ""dcraw/dcraw.c""', '- #line 7521 ""dcraw/dcraw.c""', '- #line 10249 ""dcraw/dcraw.c""', '- #line 10505 ""dcraw/dcraw.c""']]",9,37.0,46.0,e38f8cad76f0a6d0f674aa39c1af45f8e3500049LibRaw/LibRaw,"['11909cc59e712e09b508dda729b99aeaac2b29ad', '11909cc59e712e09b508dda729b99aeaac2b29ad']"
4ead2345d5162f48c7c02e6fd75fbbb131979cda,libarchive/libarchive,read.c,val,C,0,"['@@ -98,7 +98,6 @@ read_archive(struct bsdtar *bsdtar, char mode)\n \tstruct archive_entry\t *entry;\n \tconst struct stat\t *st;\n \tint\t\t\t  r;\n-\tchar\t\t\t *subst_name;\n \n \twhile (*bsdtar->argv) {\n \t\tinclude(bsdtar, *bsdtar->argv);\n']",,,['- \tchar\t\t\t *subst_name;'],['- \tchar\t\t\t *subst_name;'],[],['- \tchar\t\t\t *subst_name;'],0,1.0,1.0,4ead2345d5162f48c7c02e6fd75fbbb131979cdalibarchive/libarchive,[]
9d165ef722d6c1817d72d07d59e1b9372b00e15b,davidben/nspluginwrapper,npw-config.c,train,C,0,"['@@ -124,6 +124,14 @@ static const char *get_system_mozilla_plugin_dir(void)\n \t  };\n \t  dirs = freebsd_dirs;\n \t}\n+#elif defined(__DragonFly__)\n+\t{\n+\t  static const char *dragonfly_dirs[] = {\n+\t\t""/usr/pkg/"" LIB ""/mozilla/plugins"",\n+\t\t""/usr/pkg/"" LIB ""/firefox/plugins"",\n+\t  };\n+\t  dirs = dragonfly_dirs;\n+\t}\n #elif defined(__NetBSD__)\n \t{\n \t  static const char *netbsd_dirs[] = {\n@@ -206,6 +214,13 @@ static const char **get_mozilla_plugin_dirs(void)\n \t""/usr/local/lib/npapi/linux-flashplugin"",\n \t""/usr/X11R6/Adobe/Acrobat7.0/ENU/Browser/intellinux"",\n #endif\n+#if defined(__DragonFly__)\n+\t""/usr/pkg/lib/netscape/plugins"",\n+\t""/usr/pkg/lib/firefox/plugins"",\n+\t""/usr/pkg/lib/RealPlayer/mozilla"",\n+\t""/usr/pkg/Acrobat5/Browsers/intellinux"",\n+\t""/usr/pkg/Acrobat7/Browser/intellinux"",\n+#endif\n #if defined(__NetBSD__)\n \t""/usr/pkg/lib/netscape/plugins"",\n \t""/usr/pkg/lib/firefox/plugins"",\n@@ -500,7 +515,14 @@ static bool is_plugin_fd(int fd, NPW_PluginInfo *out_plugin_info)\n   return ret;\n }\n \n-static bool is_plugin_viewer_available(const char *filename, NPW_PluginInfo *out_plugin_info)\n+enum {\n+  EXIT_VIEWER_NOT_FOUND\t= -2,\n+  EXIT_VIEWER_ERROR\t\t= -1,\n+  EXIT_VIEWER_OK\t\t= 0,\n+  EXIT_VIEWER_NATIVE\t= 20\n+};\n+\n+static int detect_plugin_viewer(const char *filename, NPW_PluginInfo *out_plugin_info)\n {\n   static const char *target_arch_table[] = {\n \tNULL,\n@@ -541,7 +563,7 @@ static bool is_plugin_viewer_available(const char *filename, NPW_PluginInfo *out\n \t  if (target_os == NULL)\n \t\tcontinue;\n \t  if (strcmp(target_arch, HOST_ARCH) == 0 && strcmp(target_os, HOST_OS) == 0)\n-\t\tcontinue;\t\t\t\t\t\t// skip viewers that match host OS/ARCH pairs\n+\t\treturn EXIT_VIEWER_NATIVE;\t\t// don\'t wrap plugins for host OS/ARCH\n \t  char viewer_path[PATH_MAX];\n \t  sprintf(viewer_path, ""%s/%s/%s"", viewer_arch_path, target_os, NPW_VIEWER);\n \t  if (access(viewer_path, F_OK) != 0)\n@@ -557,17 +579,24 @@ static bool is_plugin_viewer_available(const char *filename, NPW_PluginInfo *out\n \t\tint status;\n \t\twhile (waitpid(pid, &status, 0) != pid)\n \t\t  ;\n-\t\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n-\t\t  if (out_plugin_info) {\n+\t\tif (WIFEXITED(status)) {\n+\t\t  status = WEXITSTATUS(status);\n+\t\t  if (status == EXIT_VIEWER_OK && out_plugin_info) {\n \t\t\tstrcpy(out_plugin_info->target_arch, target_arch);\n \t\t\tstrcpy(out_plugin_info->target_os, target_os);\n \t\t  }\n-\t\t  return true;\n+\t\t  return status;\n \t\t}\n+\t\treturn EXIT_VIEWER_ERROR;\n \t  }\n \t}\n   }\n-  return false;\n+  return EXIT_VIEWER_NOT_FOUND;\n+}\n+\n+static bool is_plugin_viewer_available(const char *filename, NPW_PluginInfo *out_plugin_info)\n+{\n+  return detect_plugin_viewer(filename, out_plugin_info) == EXIT_VIEWER_OK;\n }\n \n static bool is_plugin(const char *filename, NPW_PluginInfo *out_plugin_info)\n@@ -997,7 +1026,7 @@ static int process_update(int argc, char *argv[])\n \n static int process_install(int argc, char *argv[])\n {\n-  int i;\n+  int i, ret;\n \n   if (g_auto)\n \treturn auto_install_plugins();\n@@ -1008,9 +1037,15 @@ static int process_install(int argc, char *argv[])\n   for (i = 0; i < argc; i++) {\n \tNPW_PluginInfo plugin_info;\n \tconst char *plugin_path = argv[i];\n-\tif (!is_compatible_plugin(plugin_path, &plugin_info))\n+\tif (!is_plugin(plugin_path, &plugin_info))\n \t  error(""%s is not a valid NPAPI plugin"", plugin_path);\n-\tint ret = install_plugin(plugin_path, &plugin_info);\n+\tret = detect_plugin_viewer(plugin_path, &plugin_info);\n+\tif (ret != EXIT_VIEWER_OK) {\n+\t  if (ret == EXIT_VIEWER_NATIVE)\n+\t\treturn 0; /* silently ignore exit status */\n+\t  error(""no appropriate viewer found for %s"", plugin_path);\n+\t}\n+\tret = install_plugin(plugin_path, &plugin_info);\n \tif (ret != 0)\n \t  return ret;\n   }\n']",,,"['+ #elif defined(__DragonFly__)', '+ \t{', '+ \t  static const char *dragonfly_dirs[] = {', '+ \t\t""/usr/pkg/"" LIB ""/mozilla/plugins"",', '+ \t\t""/usr/pkg/"" LIB ""/firefox/plugins"",', '+ \t  };', '+ \t  dirs = dragonfly_dirs;', '+ \t}', '+ #if defined(__DragonFly__)', '+ \t""/usr/pkg/lib/netscape/plugins"",', '+ \t""/usr/pkg/lib/firefox/plugins"",', '+ \t""/usr/pkg/lib/RealPlayer/mozilla"",', '+ \t""/usr/pkg/Acrobat5/Browsers/intellinux"",', '+ \t""/usr/pkg/Acrobat7/Browser/intellinux"",', '+ #endif', '+ enum {', '+   EXIT_VIEWER_NOT_FOUND\t= -2,', '+   EXIT_VIEWER_ERROR\t\t= -1,', '+   EXIT_VIEWER_OK\t\t= 0,', '+   EXIT_VIEWER_NATIVE\t= 20', '+ };', '+ static int detect_plugin_viewer(const char *filename, NPW_PluginInfo *out_plugin_info)', '+ \t\tif (WIFEXITED(status)) {', '+ \t\t  status = WEXITSTATUS(status);', '+ \t\t  if (status == EXIT_VIEWER_OK && out_plugin_info) {', '+ \t\t  return status;', '+ \t\treturn EXIT_VIEWER_ERROR;', '+   return EXIT_VIEWER_NOT_FOUND;', '+ }', '+ static bool is_plugin_viewer_available(const char *filename, NPW_PluginInfo *out_plugin_info)', '+ {', '+   return detect_plugin_viewer(filename, out_plugin_info) == EXIT_VIEWER_OK;', '+   int i, ret;', '+ \tif (!is_plugin(plugin_path, &plugin_info))', '+ \tret = detect_plugin_viewer(plugin_path, &plugin_info);', '+ \tif (ret != EXIT_VIEWER_OK) {', '+ \t  if (ret == EXIT_VIEWER_NATIVE)', '+ \t  error(""no appropriate viewer found for %s"", plugin_path);', '+ \t}', '+ \tret = install_plugin(plugin_path, &plugin_info);', '- static bool is_plugin_viewer_available(const char *filename, NPW_PluginInfo *out_plugin_info)', '- \t\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {', '- \t\t  if (out_plugin_info) {', '- \t\t  return true;', '-   return false;', '-   int i;', '- \tif (!is_compatible_plugin(plugin_path, &plugin_info))', '- \tint ret = install_plugin(plugin_path, &plugin_info);']","['+ #elif defined(__dragonfly__)', '+ \t{', '+ \t  static const char *dragonfly_dirs[] = {', '+ \t\t""/usr/pkg/"" lib ""/mozilla/plugins"",', '+ \t\t""/usr/pkg/"" lib ""/firefox/plugins"",', '+ \t  };', '+ \t  dirs = dragonfly_dirs;', '+ \t}', '+ #if defined(__dragonfly__)', '+ \t""/usr/pkg/lib/netscape/plugins"",', '+ \t""/usr/pkg/lib/firefox/plugins"",', '+ \t""/usr/pkg/lib/realplayer/mozilla"",', '+ \t""/usr/pkg/acrobat5/browsers/intellinux"",', '+ \t""/usr/pkg/acrobat7/browser/intellinux"",', '+ #endif', '+ enum {', '+   exit_viewer_not_found\t= -2,', '+   exit_viewer_error\t\t= -1,', '+   exit_viewer_ok\t\t= 0,', '+   exit_viewer_native\t= 20', '+ };', '+ static int detect_plugin_viewer(const char *filename, npw_plugininfo *out_plugin_info)', '+ \t\tif (wifexited(status)) {', '+ \t\t  status = wexitstatus(status);', '+ \t\t  if (status == exit_viewer_ok && out_plugin_info) {', '+ \t\t  return status;', '+ \t\treturn exit_viewer_error;', '+   return exit_viewer_not_found;', '+ }', '+ static bool is_plugin_viewer_available(const char *filename, npw_plugininfo *out_plugin_info)', '+ {', '+   return detect_plugin_viewer(filename, out_plugin_info) == exit_viewer_ok;', '+   int i, ret;', '+ \tif (!is_plugin(plugin_path, &plugin_info))', '+ \tret = detect_plugin_viewer(plugin_path, &plugin_info);', '+ \tif (ret != exit_viewer_ok) {', '+ \t  if (ret == exit_viewer_native)', '+ \t  error(""no appropriate viewer found for %s"", plugin_path);', '+ \t}', '+ \tret = install_plugin(plugin_path, &plugin_info);', '- static bool is_plugin_viewer_available(const char *filename, npw_plugininfo *out_plugin_info)', '- \t\tif (wifexited(status) && wexitstatus(status) == 0) {', '- \t\t  if (out_plugin_info) {', '- \t\t  return true;', '-   return false;', '-   int i;', '- \tif (!is_compatible_plugin(plugin_path, &plugin_info))', '- \tint ret = install_plugin(plugin_path, &plugin_info);']","['+ #elif defined(__DragonFly__)', '+ \t{', '+ \t  static const char *dragonfly_dirs[] = {', '+ \t\t""/usr/pkg/"" LIB ""/mozilla/plugins"",', '+ \t\t""/usr/pkg/"" LIB ""/firefox/plugins"",', '+ \t  };', '+ \t  dirs = dragonfly_dirs;', '+ \t}', '+ #if defined(__DragonFly__)', '+ \t""/usr/pkg/lib/netscape/plugins"",', '+ \t""/usr/pkg/lib/firefox/plugins"",', '+ \t""/usr/pkg/lib/RealPlayer/mozilla"",', '+ \t""/usr/pkg/Acrobat5/Browsers/intellinux"",', '+ \t""/usr/pkg/Acrobat7/Browser/intellinux"",', '+ #endif', '+ enum {', '+   EXIT_VIEWER_NOT_FOUND\t= -2,', '+   EXIT_VIEWER_ERROR\t\t= -1,', '+   EXIT_VIEWER_OK\t\t= 0,', '+   EXIT_VIEWER_NATIVE\t= 20', '+ };', '+ static int detect_plugin_viewer(const char *filename, NPW_PluginInfo *out_plugin_info)', '+ \t\tif (WIFEXITED(status)) {', '+ \t\t  status = WEXITSTATUS(status);', '+ \t\t  if (status == EXIT_VIEWER_OK && out_plugin_info) {', '+ \t\t  return status;', '+ \t\treturn EXIT_VIEWER_ERROR;', '+   return EXIT_VIEWER_NOT_FOUND;', '+ }', '+ static bool is_plugin_viewer_available(const char *filename, NPW_PluginInfo *out_plugin_info)', '+ {', '+   return detect_plugin_viewer(filename, out_plugin_info) == EXIT_VIEWER_OK;', '+   int i, ret;', '+ \tif (!is_plugin(plugin_path, &plugin_info))', '+ \tret = detect_plugin_viewer(plugin_path, &plugin_info);', '+ \tif (ret != EXIT_VIEWER_OK) {', '+ \t  if (ret == EXIT_VIEWER_NATIVE)', '+ \t  error(""no appropriate viewer found for %s"", plugin_path);', '+ \t}', '+ \tret = install_plugin(plugin_path, &plugin_info);']","['- static bool is_plugin_viewer_available(const char *filename, NPW_PluginInfo *out_plugin_info)', '- \t\tif (WIFEXITED(status) && WEXITSTATUS(status) == 0) {', '- \t\t  if (out_plugin_info) {', '- \t\t  return true;', '-   return false;', '-   int i;', '- \tif (!is_compatible_plugin(plugin_path, &plugin_info))', '- \tint ret = install_plugin(plugin_path, &plugin_info);']",40,8.0,48.0,9d165ef722d6c1817d72d07d59e1b9372b00e15bdavidben/nspluginwrapper,[]
0205ccd7efb6ec1dab25d4641e42a684a2749a1c,file/file,fsmagic.c,train,C,0,"['@@ -7,7 +7,7 @@\n #ifndef\tmajor\t\t\t/* if `major\' not defined in types.h, */\n #include <sys/sysmacros.h>\t/* try this one. */\n #endif\n-#ifndef\tmajor\n+#ifndef\tmajor\t/* still not defined? give up, manual intervention needed */\n \t\t/* If cc tries to compile this, read and act on it. */\n \t\t/* On most systems cpp will discard it automatically */\n \t\tCongratulations, you have found a portability bug.\n@@ -42,6 +42,13 @@ char *fn;\n \t\t\twarning(""can\'t stat"");\n \t\t\treturn -1;\n \t\t}\n+\n+#ifdef\tPRINT_STAT_BITS\n+\tif (statbuf.st_mode & S_ISUID) ckfputs(""suid "", stdout);\n+\tif (statbuf.st_mode & S_ISGID) ckfputs(""sgid "", stdout);\n+\tif (statbuf.st_mode & S_ISVTX) ckfputs(""sticky "", stdout);\n+#endif\t/* PRINT_STAT_BITS */\n+\t\n \tswitch (statbuf.st_mode & S_IFMT) {\n \tcase S_IFDIR:\n \t\tckfputs(""directory"", stdout);\n']",,,"['+ #ifdef\tPRINT_STAT_BITS', '+ \tif (statbuf.st_mode & S_ISUID) ckfputs(""suid "", stdout);', '+ \tif (statbuf.st_mode & S_ISGID) ckfputs(""sgid "", stdout);', '+ \tif (statbuf.st_mode & S_ISVTX) ckfputs(""sticky "", stdout);', '- #ifndef\tmajor']","['+ #ifdef\tprint_stat_bits', '+ \tif (statbuf.st_mode & s_isuid) ckfputs(""suid "", stdout);', '+ \tif (statbuf.st_mode & s_isgid) ckfputs(""sgid "", stdout);', '+ \tif (statbuf.st_mode & s_isvtx) ckfputs(""sticky "", stdout);', '- #ifndef\tmajor']","['+ #ifdef\tPRINT_STAT_BITS', '+ \tif (statbuf.st_mode & S_ISUID) ckfputs(""suid "", stdout);', '+ \tif (statbuf.st_mode & S_ISGID) ckfputs(""sgid "", stdout);', '+ \tif (statbuf.st_mode & S_ISVTX) ckfputs(""sticky "", stdout);']",['- #ifndef\tmajor'],4,1.0,5.0,0205ccd7efb6ec1dab25d4641e42a684a2749a1cfile/file,[]
49474bd58e58e379e0262da1bbdda298bd8ae6d3,LibRaw/LibRaw,dcraw_emu.cpp,train,C++,0,"['@@ -169,7 +169,7 @@ int main(int argc, char *argv[])\n   for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == \'+\'; ) \n       {\n           opt = argv[arg++][1];\n-          if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt)))\n+          if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt))!=0)\n               for (i=0; i < ""111411111142""[cp-sp]-\'0\'; i++)\n                   if (!isdigit(argv[arg+i][0])) \n                       {\n']",,,"['+           if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt))!=0)', '-           if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt)))']","['+           if ((cp = strchr (sp=(char*)""cnbrkstqmhabcgu"", opt))!=0)', '-           if ((cp = strchr (sp=(char*)""cnbrkstqmhabcgu"", opt)))']","['+           if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt))!=0)']","['-           if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt)))']",1,1.0,2.0,49474bd58e58e379e0262da1bbdda298bd8ae6d3LibRaw/LibRaw,[]
6b6496bb513826866bfd5fdc71f81566b7e5e924,vadz/libtiff,tools/tiffcrop.c,val,C,1,"['@@ -6,6 +6,7 @@\n  * Original code:\n  * Copyright (c) 1988-1997 Sam Leffler\n  * Copyright (c) 1991-1997 Silicon Graphics, Inc.\n+ * Additions (c) Richard Nolde 2006-2009 \n  *\n  * Permission to use, copy, modify, distribute, and sell this software and \n  * its documentation for any purpose is hereby granted without fee, provided\n@@ -19,25 +20,18 @@\n  * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY \n  * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  \n  * \n- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR\n- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF \n- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE \n- * OF THIS SOFTWARE.\n+ * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS OR ANY OTHER COPYRIGHT  \n+ * HOLDERS BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL \n+ * DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, \n+ * DATA OR PROFITS, WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND \n+ * ON ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE\n+ * OR PERFORMANCE OF THIS SOFTWARE.\n  *\n- * The portions of the current code that are derived from tiffcp are primarly \n- * in the areas of lowlevel reading and writing of scanlines and tiles though\n+ * Some portions of the current code are derived from tiffcp, primarly in \n+ * the areas of lowlevel reading and writing of TAGSscanlines and tiles though\n  * some of the original functions have been extended to support arbitrary bit\n  * depths. These functions are presented at the top of this file.\n  *\n- * Additions (c) Richard Nolde 2006-2009 Last Updated 1/6/2009 \n- * IN NO EVENT SHALL RICHARD NOLDE BE LIABLE FOR ANY SPECIAL, INCIDENTAL, \n- * INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER \n- * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER OR NOT ADVISED OF \n- * THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF  LIABILITY, ARISING OUT \n- * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n- *\n  * Add support for the options below to extract sections of image(s) \n  * and to modify the whole image or selected portions of each image by\n  * rotations, mirroring, and colorscale/colormap inversion of selected\n@@ -45,9 +39,9 @@\n  * functions are restricted to bilevel or 8 bit per sample data.\n  * See the man page for the full explanations.\n  *\n- * Options: \n+ * New Options: \n  * -h             Display the syntax guide.\n- * -v             Report the version and last build date for tiffcrop\n+ * -v             Report the version and last build date for tiffcrop and libtiff.\n  * -z x1,y1,x2,y2:x3,y3,x4,y4:..xN,yN,xN + 1, yN + 1 \n  *                Specify a series of coordinates to define rectangular\n  *                regions by the top left and lower right corners.\n@@ -65,9 +59,11 @@\n  * -H #           Set horizontal resolution of output images to #\n  * -V #           Set vertical resolution of output images to #\n  * -J #           Horizontal margin of output page to # expressed in current\n- *                units\n+ *                units when sectioning image into columns x rows \n+ *                using the -S cols:rows option.\n  * -K #           Vertical margin of output page to # expressed in current\n- *                units\n+ *                units when sectioning image into columns x rows\n+ *                using the -S cols:rows option.\n  * -X #           Horizontal dimension of region to extract expressed in current\n  *                units\n  * -Y #           Vertical dimension of region to extract expressed in current\n@@ -109,8 +105,13 @@\n  *                selects which functions dump data, with higher numbers selecting\n  *                lower level, scanline level routines. Debug reports a limited set\n  *                of messages to monitor progess without enabling dump logs.\n+ * -c for compression extended to allow explicit specification of RAW or AUTO mode\n+ *                with JPEG compression.\n  */\n \n+static   char tiffcrop_version_id[] = ""2.1"";\n+static   char tiffcrop_rev_date[] = ""09-18-2009"";\n+\n #include ""tif_config.h""\n #include ""tiffiop.h""\n \n@@ -202,7 +203,7 @@ extern int getopt(int, char**, char*);\n #define MAX_REGIONS   8  /* number of regions to extract from a single page */\n #define MAX_OUTBUFFS  8  /* must match larger of zones or regions */\n #define MAX_SECTIONS 32  /* number of sections per page to write to output */\n-#define MAX_IMAGES 1024  /* number of images in descrete list, not in the file */\n+#define MAX_IMAGES 2048  /* number of images in descrete list, not in the file */\n #define MAX_SAMPLES   8  /* maximum number of samples per pixel supported */\n #define MAX_BITS_PER_SAMPLE 64 /* maximum bit depth supported */\n \n@@ -268,7 +269,10 @@ struct  region {\n   unsigned char *buffptr; /* address of start of the region */\n };\n \n-/* Cropping parameters from command line and image data */\n+/* Cropping parameters from command line and image data \n+ * Note: This should be renamed to proc_opts and expanded to include all current globals\n+ * if possible, but each function that accesses global variables will have to be redone.\n+ */\n struct crop_mask {\n   double width;           /* Selection width for master crop region in requested units */\n   double length;          /* Selection length for master crop region in requesed units */\n@@ -422,43 +426,39 @@ struct dump_opts {\n \n /* globals */\n static int    outtiled = -1;\n-static uint32 tilewidth;\n-static uint32 tilelength;\n-\n-static uint16 config;\n-static uint16 compression;\n-static uint16 predictor;\n-static uint16 fillorder;\n-static uint32 rowsperstrip;\n-static uint32 g3opts;\n+static uint32 tilewidth = 0;\n+static uint32 tilelength = 0;\n+\n+static uint16 config = 0;\n+static uint16 compression = 0;\n+static uint16 predictor = 0;\n+static uint16 fillorder = 0;\n+static uint32 rowsperstrip = 0;\n+static uint32 g3opts = 0;\n static int    ignore = FALSE;\t\t/* if true, ignore read errors */\n static uint32 defg3opts = (uint32) -1;\n-static int    quality = 75;\t\t/* JPEG quality */\n-static int    jpegcolormode = JPEGCOLORMODE_RGB;\n+static int    quality = 100;\t\t/* JPEG quality */\n+static int    jpegcolormode = -1;       /* was JPEGCOLORMODE_RGB; */\n static uint16 defcompression = (uint16) -1;\n static uint16 defpredictor = (uint16) -1;\n static int    pageNum = 0;\n static int    little_endian = 1;\n \n-/* Functions adapted from tiffcp with additions or modifications */\n-static int readContigStripsIntoBuffer   (TIFF*, uint8*, uint32, uint32, tsample_t);\n-static int readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\n-static int readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, tsample_t);\n-static int readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, tsample_t);\n-static int writeBufferToContigStrips    (TIFF*, uint8*, uint32, uint32, tsample_t);\n-static int writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t);\n-static int writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\n-static int writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\n-static int extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, int, int, \n-                                         tsample_t, uint16, uint16, struct dump_opts *);\n-static void cpStripToTile (uint8*, uint8*, uint32, uint32, int, int);\n-static void cpSeparateBufToContigBuf(uint8 *, uint8 *, uint32, uint32 , \n-\t\t\t\t     int, int, tsample_t, int);\n-\n+/* Functions adapted from tiffcp with additions or significant modifications */\n+static int  readContigStripsIntoBuffer   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\n+static int  readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\n+static int  readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);\n+static int  readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);\n+static int  writeBufferToContigStrips    (TIFF*, uint8*, uint32);\n+static int  writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\n+static int  writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\n+static int  writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);\n+static int  extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, tsample_t, \n+                                         uint16, uint16, struct dump_opts *);\n static int processCompressOptions(char*);\n static void usage(void);\n \n-/* New functions by Richard Nolde  not found in tiffcp */\n+/* All other functions by Richard Nolde,  not found in tiffcp */\n static void initImageData (struct image_data *);\n static void initCropMasks (struct crop_mask *);\n static void initPageSetup (struct pagedef *, struct pageseg *, struct buffinfo []);\n@@ -566,6 +566,10 @@ static int extractContigSamplesShifted32bits (uint8 *, uint8 *, uint32,\n \t                                      tsample_t, uint16, uint16, \n \t\t\t\t              tsample_t, uint32, uint32,\n                                               int);\n+static int extractContigSamplesToTileBuffer(uint8 *, uint8 *, uint32, uint32,\n+  \t                                    uint32, uint32, tsample_t, uint16,\n+\t\t\t\t\t    uint16, uint16, struct dump_opts *);\n+\n /* Functions to combine separate planes into interleaved planes */\n static int combineSeparateSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n                                         uint16, uint16, FILE *, int, int);\n@@ -576,8 +580,24 @@ static int combineSeparateSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n static int combineSeparateSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n                                          uint16, uint16, FILE *, int, int);\n static int combineSeparateSamplesBytes (unsigned char *[], unsigned char *,\n-                                       uint32, uint32, tsample_t, uint16, \n-                                       FILE *, int, int);\n+\t\t\t\t\tuint32, uint32, tsample_t, uint16,\n+                                        FILE *, int, int);\n+\n+static int combineSeparateTileSamples8bits (uint8 *[], uint8 *, uint32, uint32,\n+                                            uint32, uint32, uint16, uint16, \n+                                            FILE *, int, int);\n+static int combineSeparateTileSamples16bits (uint8 *[], uint8 *, uint32, uint32,\n+                                             uint32, uint32, uint16, uint16,\n+                                             FILE *, int, int);\n+static int combineSeparateTileSamples24bits (uint8 *[], uint8 *, uint32, uint32,\n+                                             uint32, uint32, uint16, uint16,\n+                                             FILE *, int, int);\n+static int combineSeparateTileSamples32bits (uint8 *[], uint8 *, uint32, uint32,\n+                                             uint32, uint32, uint16, uint16,\n+                                             FILE *, int, int);\n+static int combineSeparateTileSamplesBytes (unsigned char *[], unsigned char *,\n+\t\t\t  \t\t    uint32, uint32, uint32, uint32, \n+                                            tsample_t, uint16, FILE *, int, int);\n \n /* Dump functions for debugging */\n static void dump_info  (FILE *, int, char *, char *, ...);\n@@ -590,11 +610,8 @@ static int  dump_buffer (FILE *, int, uint32, uint32, uint32, unsigned char *);\n \n /* End function declarations */\n /* Functions derived in whole or in part from tiffcp */\n-\n /* The following functions are taken largely intact from tiffcp */\n \n-static   char tiffcrop_version_id[] = ""2.0"";\n-static   char tiffcrop_rev_date[] = ""01-06-2009"";\n static   char* stuff[] = {\n ""usage: tiffcrop [options] source1 ... sourceN  destination"",\n ""where options are:"",\n@@ -631,8 +648,9 @@ static   char* stuff[] = {\n ""For example, -c g3:2d:fill to get G3-2D-encoded data with byte-aligned EOLs"",\n "" "",\n ""JPEG options:"",\n-"" #\t\tSet compression quality level (0-100, default 75)"",\n-"" r\t\tOutput color image as RGB rather than YCbCr"",\n+"" #\t\tSet compression quality level (0-100, default 100)"",\n+"" r\t\tOutput color image as raw RGB rather than YCbCr"",\n+"" a\t\tOutput color image as RGB or YCbCr with auto detection"",\n ""For example, -c jpeg:r:50 to get JPEG-encoded RGB data with 50% comp. quality"",\n "" "",\n ""LZW and deflate options:"",\n@@ -676,7 +694,9 @@ static   char* stuff[] = {\n "" -H #        Set horizontal resolution of output images to #"",\n "" -V #        Set vertical resolution of output images to #"",\n "" -J #        Set horizontal margin of output page to # expressed in current units"",\n+""             when sectioning image into columns x rows using the -S cols:rows option"",\n "" -K #        Set verticalal margin of output page to # expressed in current units"",\n+""             when sectioning image into columns x rows using the -S cols:rows option"",\n "" "",\n "" -O orient    orientation for output image, portrait, landscape, auto"",\n "" -P page      page size for output image segments, eg letter, legal, tabloid, etc"",\n@@ -700,10 +720,10 @@ static   char* stuff[] = {\n ""             program debugging and development of future options."",\n "" "",\n ""   debug:N   Display limited program progress indicators where larger N"",\n-""             increase the level of detail. The program must be compiled with"",\n-""             -DDEBUG -DDEBUG2 to enable full debug reporting"",\n+""             increase the level of detail. Note: Tiffcrop may be compiled with"",\n+""             -DDEVELMODE to enable additional very low level debug reporting."",\n """",\n-""   format:txt|raw  Format any logged data as ASCII text or raw binary "",\n+""   Format:txt|raw  Format any logged data as ASCII text or raw binary "",\n ""             values. ASCII text dumps include strings of ones and zeroes"",\n ""             representing the binary values in the image data plus identifying headers."",\n "" "",\n@@ -725,157 +745,376 @@ static   char* stuff[] = {\n NULL\n };\n \n+/* This function could be modified to pass starting sample offset \n+ * and number of samples as args to select fewer than spp\n+ * from input image. These would then be passed to individual \n+ * extractContigSampleXX routines.\n+ */\n static int readContigTilesIntoBuffer (TIFF* in, uint8* buf, \n                                       uint32 imagelength, \n                                       uint32 imagewidth, \n-                                      tsample_t spp)\n-{\n-\tint status = 1;\n-\ttdata_t tilebuf = _TIFFmalloc(TIFFTileSize(in));\n-\tuint32 imagew = TIFFScanlineSize(in);\n-\tuint32 tilew  = TIFFTileRowSize(in);\n-\tint iskew = imagew - tilew;\n-\tuint8* bufp = (uint8*) buf;\n-\tuint32 tw, tl;\n-\tuint32 row;\n-\n-\t(void) spp;\n-\tif (tilebuf == 0)\n-\t\treturn 0;\n-\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n-\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n-        \n-\tfor (row = 0; row < imagelength; row += tl) {\n-\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n-\t\tuint32 colb = 0;\n-\t\tuint32 col;\n-\n-\t\tfor (col = 0; col < imagewidth; col += tw) {\n-\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0\n-\t\t\t    && !ignore) {\n-\t\t\t\tTIFFError(TIFFFileName(in),\n-\t\t\t\t\t  ""Error, can\'t read tile at %lu %lu"",\n-\t\t\t\t\t  (unsigned long) col,\n-\t\t\t\t\t  (unsigned long) row);\n-\t\t\t\tstatus = 0;\n-\t\t\t\tgoto done;\n-\t\t\t}\n-\t\t\tif (colb + tilew > imagew) {\n-\t\t\t\tuint32 width = imagew - colb;\n-\t\t\t\tuint32 oskew = tilew - width;\n-\t\t\t\tcpStripToTile(bufp + colb,\n-                                              tilebuf, nrow, width,\n-                                              oskew + iskew, oskew );\n-\t\t\t} else\n-\t\t\t\tcpStripToTile(bufp + colb,\n-                                              tilebuf, nrow, tilew,\n-                                              iskew, 0);\n-\t\t\tcolb += tilew;\n-\t\t}\n-\t\tbufp += imagew * nrow;\n+                                      uint32 tw, uint32 tl,\n+                                      tsample_t spp, uint16 bps)\n+  {\n+  int status = 1;\n+  tsample_t sample = 0;\n+  tsample_t count = spp; \n+  uint32 row, col, trow;\n+  uint32 nrow, ncol;\n+  uint32 dst_rowsize, shift_width;\n+  uint32 bytes_per_sample, bytes_per_pixel;\n+  uint32 trailing_bits, prev_trailing_bits;\n+  uint32 tile_rowsize  = TIFFTileRowSize(in);\n+  uint32 src_offset, dst_offset;\n+  uint32 row_offset, col_offset;\n+  uint8 *bufp = (uint8*) buf;\n+  unsigned char *src = NULL;\n+  unsigned char *dst = NULL;\n+  tsize_t tbytes = 0, tile_buffsize = 0;\n+  tsize_t tilesize = TIFFTileSize(in);\n+  unsigned char *tilebuf = NULL;\n+\n+  bytes_per_sample = (bps + 7) / 8; \n+  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n+\n+  if ((bps % 8) == 0)\n+    shift_width = 0;\n+  else\n+    {\n+    if (bytes_per_pixel < (bytes_per_sample + 1))\n+      shift_width = bytes_per_pixel;\n+    else\n+      shift_width = bytes_per_sample + 1;\n+    }\n+\n+  tile_buffsize = tilesize;\n+\n+  if (tilesize < (tsize_t)(tl * tile_rowsize))\n+    {\n+#ifdef DEBUG2\n+    TIFFError(""readContigTilesIntoBuffer"",\n+\t      ""Tilesize %lu is too small, using alternate calculation %u"",\n+              tilesize, tl * tile_rowsize);\n+#endif\n+    tile_buffsize = tl * tile_rowsize;\n+    } \n+\n+  tilebuf = _TIFFmalloc(tile_buffsize);\n+  if (tilebuf == 0)\n+    return 0;\n+\n+  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;  \n+  for (row = 0; row < imagelength; row += tl)\n+    {\n+    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n+    for (col = 0; col < imagewidth; col += tw)\n+      {\n+      tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);\n+      if (tbytes < tilesize  && !ignore)\n+        {\n+\tTIFFError(TIFFFileName(in),\n+\t\t  ""Error, can\'t read tile at row %lu col %lu, Read %lu bytes of %lu"",\n+\t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,\n+                  (unsigned long)tilesize);\n+\t\t  status = 0;\n+                  _TIFFfree(tilebuf);\n+\t\t  return status;\n \t}\n-done:\n-\t_TIFFfree(tilebuf);\n-\treturn status;\n-}\n+      \n+      row_offset = row * dst_rowsize;\n+      col_offset = ((col * bps * spp) + 7)/ 8;\n+      bufp = buf + row_offset + col_offset;\n \n-static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *buf, \n-            uint32 imagelength, uint32 imagewidth, uint16 spp)\n-{\n-\tint status = 1;\n-\tuint32 imagew = TIFFRasterScanlineSize(in);\n-\tuint32 tilew = TIFFTileRowSize(in);\n-\tint iskew  = imagew - tilew*spp;\n-\ttdata_t tilebuf = _TIFFmalloc(TIFFTileSize(in));\n-\tuint8* bufp = (uint8*) buf;\n-\tuint32 tw, tl;\n-\tuint32 row;\n-        uint16 bps, bytes_per_sample;\n-\n-\tif (tilebuf == 0)\n-\t\treturn 0;\n-\t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n-\t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n-\t(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n-        assert( bps % 8 == 0 );\n-        bytes_per_sample = bps/8;\n-\n-\tfor (row = 0; row < imagelength; row += tl) {\n-\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n-\t\tuint32 colb = 0;\n-\t\tuint32 col;\n-\n-\t\tfor (col = 0; col < imagewidth; col += tw) {\n-\t\t\ttsample_t s;\n-\n-\t\t\tfor (s = 0; s < spp; s++) {\n-\t\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0\n-\t\t\t\t    && !ignore) {\n-\t\t\t\t\tTIFFError(TIFFFileName(in),\n-\t\t\t\t\t  ""Error, can\'t read tile at %lu %lu, ""\n-\t\t\t\t\t  ""sample %lu"",\n-\t\t\t\t\t  (unsigned long) col,\n-\t\t\t\t\t  (unsigned long) row,\n-\t\t\t\t\t  (unsigned long) s);\n-\t\t\t\t\tstatus = 0;\n-\t\t\t\t\tgoto done;\n-\t\t\t\t}\n-\t\t\t\t/*\n-\t\t\t\t * Tile is clipped horizontally.  Calculate\n-\t\t\t\t * visible portion and skewing factors.\n-\t\t\t\t */\n-\t\t\t\tif (colb + tilew*spp > imagew) {\n-\t\t\t\t\tuint32 width = imagew - colb;\n-\t\t\t\t\tint oskew = tilew*spp - width;\n-\t\t\t\t\tcpSeparateBufToContigBuf(\n-                                            bufp+colb+s*bytes_per_sample,\n-\t\t\t\t\t    tilebuf, nrow,\n-                                            width/(spp*bytes_per_sample),\n-\t\t\t\t\t    oskew + iskew,\n-                                            oskew/spp, spp,\n-                                            bytes_per_sample);\n-\t\t\t\t} else\n-\t\t\t\t\tcpSeparateBufToContigBuf(\n-                                            bufp+colb+s*bytes_per_sample,\n-\t\t\t\t\t    tilebuf, nrow, tw,\n-\t\t\t\t\t    iskew, 0, spp,\n-                                            bytes_per_sample);\n-\t\t\t}\n-\t\t\tcolb += tilew*spp;\n-\t\t}\n-\t\tbufp += imagew * nrow;\n+      if (col + tw > imagewidth)\n+\tncol = imagewidth - col;\n+      else\n+        ncol = tw;\n+\n+      /* Each tile scanline will start on a byte boundary but it\n+       * has to be merged into the scanline for the entire\n+       * image buffer and the previous segment may not have\n+       * ended on a byte boundary\n+       */\n+      /* Optimization for common bit depths, all samples */\n+      if (((bps % 8) == 0) && (count == spp))\n+        {\n+\tfor (trow = 0; trow < nrow; trow++)\n+          {\n+\t  src_offset = trow * tile_rowsize;\n+\t  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);\n+          bufp += (imagewidth * bps * spp) / 8;\n+\t  }\n+        }\n+      else\n+        {\n+\t/* Bit depths not a multiple of 8 and/or extract fewer than spp samples */\n+        prev_trailing_bits = trailing_bits = 0;\n+        trailing_bits = (ncol * bps * spp) % 8;\n+\n+\t/*\tfor (trow = 0; tl < nrow; trow++) */\n+\tfor (trow = 0; trow < nrow; trow++)\n+          {\n+\t  src_offset = trow * tile_rowsize;\n+          src = tilebuf + src_offset;\n+\t  dst_offset = (row + trow) * dst_rowsize;\n+          dst = buf + dst_offset + col_offset;\n+          switch (shift_width)\n+            {\n+            case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,\n+                                                   spp, bps, count, 0, ncol))\n+                      {\n+\t\t      TIFFError(""readContigTilesIntoBuffer"",\n+                                ""Unable to extract row %d from tile %lu"", \n+\t\t\t\trow, (unsigned long)TIFFCurrentTile(in));\n+\t\t      return (1);\n+\t\t      }\n+\t\t    break;\n+            case 1: if (bps == 1)\n+                      { \n+                      if (extractContigSamplesShifted8bits (src, dst, ncol,\n+                                                            sample, spp,\n+                                                            bps, count,\n+                                                            0, ncol,\n+                                                            prev_trailing_bits))\n+                        {\n+\t\t        TIFFError(""readContigTilesIntoBuffer"",\n+                                  ""Unable to extract row %d from tile %lu"", \n+\t\t\t\t  row, (unsigned long)TIFFCurrentTile(in));\n+\t\t        return (1);\n+\t\t        }\n+\t\t      break;\n+\t\t      }\n+                    else\n+                      if (extractContigSamplesShifted16bits (src, dst, ncol,\n+                                                             sample, spp,\n+                                                             bps, count,\n+                                                             0, ncol,\n+                                                             prev_trailing_bits))\n+                        {\n+\t\t        TIFFError(""readContigTilesIntoBuffer"",\n+                                  ""Unable to extract row %d from tile %lu"", \n+\t\t\t  \t  row, (unsigned long)TIFFCurrentTile(in));\n+\t\t        return (1);\n+\t\t        }\n+\t            break;\n+            case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,\n+                                                           sample, spp,\n+                                                           bps, count,\n+                                                           0, ncol,\n+                                                           prev_trailing_bits))\n+                      {\n+\t\t      TIFFError(""readContigTilesIntoBuffer"",\n+                                ""Unable to extract row %d from tile %lu"", \n+\t\t  \t        row, (unsigned long)TIFFCurrentTile(in));\n+\t\t      return (1);\n+\t\t      }\n+\t\t    break;\n+            case 3:\n+            case 4:\n+            case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,\n+                                                           sample, spp,\n+                                                           bps, count,\n+                                                           0, ncol,\n+                                                           prev_trailing_bits))\n+                      {\n+\t\t      TIFFError(""readContigTilesIntoBuffer"",\n+                                ""Unable to extract row %d from tile %lu"", \n+\t\t\t        row, (unsigned long)TIFFCurrentTile(in));\n+\t\t      return (1);\n+\t\t      }\n+\t\t    break;\n+            default: TIFFError(""readContigTilesIntoBuffer"", ""Unsupported bit depth %d"", bps);\n+\t\t     return (1);\n+\t    }\n+          }\n+        prev_trailing_bits += trailing_bits;\n+        if (prev_trailing_bits > 7)\n+\t  prev_trailing_bits-= 8;\n \t}\n-done:\n-\t_TIFFfree(tilebuf);\n-\treturn status;\n-}\n+      }\n+    }\n \n-static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength, \n-                                     uint32 imagewidth, tsample_t spp)\n-{\n-\tuint32 row, rowsperstrip;\n-\ttstrip_t strip = 0;\n-\n-\t(void) imagewidth; (void) spp;\n-\t(void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n-\tfor (row = 0; row < imagelength; row += rowsperstrip) {\n-\t\tuint32 nrows = (row+rowsperstrip > imagelength) ?\n-\t\t    imagelength-row : rowsperstrip;\n-\t\ttsize_t stripsize = TIFFVStripSize(out, nrows);\n-\t\tif (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0) {\n-\t\t\tTIFFError(TIFFFileName(out),\n-\t\t\t\t  ""Error, can\'t write strip %u"", strip - 1);\n-\t\t\treturn 0;\n-\t\t}\n-\t\tbuf += stripsize;\n+  _TIFFfree(tilebuf);\n+  return status;\n+  }\n+\n+static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf, \n+\t\t\t\t\t uint32 imagelength, uint32 imagewidth, \n+                                         uint32 tw, uint32 tl,\n+                                         uint16 spp, uint16 bps)\n+  {\n+  int     i, status = 1, sample;\n+  int     shift_width, bytes_per_pixel;\n+  uint16  bytes_per_sample;\n+  uint32  row, col;     /* Current row and col of image */\n+  uint32  nrow, ncol;   /* Number of rows and cols in current tile */\n+  uint32  row_offset, col_offset; /* Output buffer offsets */\n+  tsize_t tbytes = 0, tilesize = TIFFTileSize(in);\n+  tsample_t s;\n+  uint8*  bufp = (uint8*)obuf;\n+  unsigned char *srcbuffs[MAX_SAMPLES];\n+  unsigned char *tbuff = NULL;\n+\n+  bytes_per_sample = (bps + 7) / 8;\n+\n+  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n+    {\n+    srcbuffs[sample] = NULL;\n+    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);\n+    if (!tbuff)\n+      {\n+      TIFFError (""readSeparateStripsIntoBuffer"", \n+                 ""Unable to allocate tile read buffer for sample %d"", sample);\n+      for (i = 0; i < sample; i++)\n+        _TIFFfree (srcbuffs[i]);\n+      return 0;\n+      }\n+    srcbuffs[sample] = tbuff;\n+    } \n+  /* Each tile contains only the data for a single plane\n+   * arranged in scanlines of tw * bytes_per_sample bytes.\n+   */\n+  for (row = 0; row < imagelength; row += tl)\n+    {\n+    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n+    for (col = 0; col < imagewidth; col += tw)\n+      {\n+      for (s = 0; s < spp; s++)\n+        {  /* Read each plane of a tile set into srcbuffs[s] */\n+\ttbytes = TIFFReadTile(in, srcbuffs[s], col, row, 0, s);\n+        if (tbytes < 0  && !ignore)\n+          {\n+\t  TIFFError(TIFFFileName(in),\n+                 ""Error, can\'t read tile for row %lu col %lu, ""\n+\t\t ""sample %lu"",\n+\t\t (unsigned long) col, (unsigned long) row,\n+\t\t (unsigned long) s);\n+\t\t status = 0;\n+          for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n+            {\n+            tbuff = srcbuffs[sample];\n+            if (tbuff != NULL)\n+              _TIFFfree(tbuff);\n+            }\n+          return status;\n+\t  }\n \t}\n-\treturn 1;\n-}\n+     /* Tiles on the right edge may be padded out to tw \n+      * which must be a multiple of 16.\n+      * Ncol represents the visible (non padding) portion.  \n+      */\n+      if (col + tw > imagewidth)\n+        ncol = imagewidth - col;\n+      else\n+        ncol = tw;\n+\n+      row_offset = row * (((imagewidth * spp * bps) + 7) / 8);\n+      col_offset = ((col * spp * bps) + 7) / 8;\n+      bufp = obuf + row_offset + col_offset;\n+\n+      if ((bps % 8) == 0)\n+        {\n+        if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,\n+\t\t\t\t\t    tw, spp, bps, NULL, 0, 0))\n+\t  {\n+          status = 0;\n+          break;\n+      \t  }\n+\t}\n+      else\n+        {\n+        bytes_per_pixel  = ((bps * spp) + 7) / 8;\n+        if (bytes_per_pixel < (bytes_per_sample + 1))\n+          shift_width = bytes_per_pixel;\n+        else\n+          shift_width = bytes_per_sample + 1;\n+\n+        switch (shift_width)\n+          {\n+          case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,\n+                                                       imagewidth, tw, spp, bps, \n+\t\t\t\t\t\t       NULL, 0, 0))\n+\t            {\n+                    status = 0;\n+                    break;\n+      \t            }\n+\t          break;\n+          case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,\n+                                                       imagewidth, tw, spp, bps, \n+\t\t\t\t\t\t       NULL, 0, 0))\n+\t            {\n+                    status = 0;\n+                    break;\n+\t\t    }\n+\t          break;\n+          case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,\n+                                                       imagewidth, tw, spp, bps, \n+\t\t\t\t\t\t       NULL, 0, 0))\n+\t            {\n+                    status = 0;\n+                    break;\n+       \t            }\n+                  break;\n+          case 4: \n+          case 5:\n+          case 6:\n+          case 7:\n+          case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,\n+                                                       imagewidth, tw, spp, bps, \n+\t\t\t\t\t\t       NULL, 0, 0))\n+\t            {\n+                    status = 0;\n+                    break;\n+\t\t    }\n+\t          break;\n+          default: TIFFError (""readSeparateTilesIntoBuffer"", ""Unsupported bit depth: %d"", bps);\n+                  status = 0;\n+                  break;\n+          }\n+        }\n+      }\n+    }\n+\n+  for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)\n+    {\n+    tbuff = srcbuffs[sample];\n+    if (tbuff != NULL)\n+      _TIFFfree(tbuff);\n+    }\n+ \n+  return status;\n+  }\n+\n+static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)\n+  {\n+  uint32 row, nrows, rowsperstrip;\n+  tstrip_t strip = 0;\n+  tsize_t stripsize;\n+\n+  TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);\n+  for (row = 0; row < imagelength; row += rowsperstrip)\n+    {\n+    nrows = (row + rowsperstrip > imagelength) ?\n+\t     imagelength - row : rowsperstrip;\n+    stripsize = TIFFVStripSize(out, nrows);\n+    if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0)\n+      {\n+      TIFFError(TIFFFileName(out), ""Error, can\'t write strip %u"", strip - 1);\n+      return 0;\n+      }\n+    buf += stripsize;\n+    }\n \n-/* Function modified from original tiffcp version with plans to\n- * extend so that plannar orientation separate images do not have \n- * all samples for each channel written before all sampels for the\n- * next channel. Current code is very similar in design to original.\n+  return 1;\n+  }\n+\n+/* Abandon plans to modify code so that plannar orientation separate images\n+ * do not have all samples for each channel written before all samples\n+ * for the next channel have been abandoned.\n+ * Libtiff internals seem to depend on all data for a given sample\n+ * being contiguous within a strip or tile when PLANAR_CONFIG is \n+ * separate. All strips or tiles of a given plane are written\n+ * before any strips or tiles of a different plane are stored.\n  */\n static int \n writeBufferToSeparateStrips (TIFF* out, uint8* buf, \n@@ -913,7 +1152,7 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,\n       src = buf + (row * rowsize);\n       total_bytes += stripsize;\n       memset (obuf, \'\\0\', rowstripsize);\n-      if (extractContigSamplesToBuffer(obuf, src, nrows, width, 0, 0, s, spp, bps, dump))\n+      if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))\n         {\n         _TIFFfree(obuf);\n         return (0);\n@@ -935,170 +1174,150 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,\n       }\n     }      \n \n-  /*  Abandoning this code for now.  Would be nice to be able to write\n-   *  one or more rows of each color to successive strips, rather than\n-   *  all the rows of a given color before any rows of the next color.\n+  _TIFFfree(obuf);\n+  return 1;\n+}\n \n-  tsize_t row_buffsize;\n-  row_buffsize = scanlinesize + (((spp + bps) + 7) / 8);\n-  obuf = _TIFFmalloc (row_buffsize);\n-  if (obuf == NULL)\n-    return (0);\n+/* Extract all planes from contiguous buffer into a single tile buffer \n+ * to be written out as a tile.\n+ */\n+static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,\n+\t\t\t\t       uint32 imagewidth, tsample_t spp, \n+                                       struct dump_opts* dump)\n+  {\n+  uint16 bps;\n+  uint32 tl, tw;\n+  uint32 row, col, nrow, ncol;\n+  uint32 src_rowsize, col_offset;\n+  uint32 tile_rowsize  = TIFFTileRowSize(out);\n+  uint8* bufp = (uint8*) buf;\n+  tsize_t tile_buffsize = 0;\n+  tsize_t tilesize = TIFFTileSize(out);\n+  unsigned char *tilebuf = NULL;\n+\n+  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n+  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n+  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n+\n+  tile_buffsize = tilesize;\n+  if (tilesize < (tsize_t)(tl * tile_rowsize))\n+    {\n+#ifdef DEBUG2\n+    TIFFError(""writeBufferToContigTiles"",\n+\t      ""Tilesize %lu is too small, using alternate calculation %u"",\n+              tilesize, tl * tile_rowsize);\n+#endif\n+    tile_buffsize = tl * tile_rowsize;\n+    }\n \n+  tilebuf = _TIFFmalloc(tile_buffsize);\n+  if (tilebuf == 0)\n+    return 0;\n \n- TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip); \n-  for (row = 0; row < length; row++)\n+  src_rowsize = ((imagewidth * spp * bps) + 7) / 8;\n+  for (row = 0; row < imagelength; row += tl)\n     {\n-    src = buf + (row * rowsize);\n-    total_bytes += scanlinesize;\n-    for (s = 0; s < spp; s++)\n+    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n+    for (col = 0; col < imagewidth; col += tw)\n       {\n-      memset (obuf, \'\\0\', row_buffsize);\n-      if (extractContigSamplesToBuffer(obuf, src, 1, width, 0, 0, s, spp, bps, dump))\n-        {\n-        _TIFFfree(obuf);\n-        return (0);\n-\t}\n-      if ((dump->outfile != NULL) && (dump->level == 1))\n+      /* Calculate visible portion of tile. */\n+      if (col + tw > imagewidth)\n+\tncol = imagewidth - col;\n+      else\n+        ncol = tw;\n+\n+      col_offset = (((col * bps * spp) + 7) / 8);\n+      bufp = buf + (row * src_rowsize) + col_offset;\n+      if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,\n+\t\t\t\t\t   tw, 0, spp, spp, bps, dump) > 0)\n         {\n-        dump_info(dump->outfile, dump->format,"""", \n-                  ""Row %4d, Sample %2d, bytes: %4d, Input offset: %6d"", \n-                  row + 1, s + 1, scanlinesize, src - buf);\n-        dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);\n-\t}\n+\tTIFFError(""writeBufferToContigTiles"", \n+                  ""Unable to extract data to tile for row %lu, col %lu"",\n+                  (unsigned long) row, (unsigned long)col);\n+\t_TIFFfree(tilebuf);\n+\treturn (0);\n+        }\n \n-      if (TIFFWriteScanline(out, obuf, row, s) < 0)\n+      if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0)\n         {\n-\tTIFFError(TIFFFileName(out), ""Error, can\'t write scanline %lu"", row + 1);\n-\t_TIFFfree(obuf);\n+\tTIFFError(""writeBufferToContigTiles"",\n+\t          ""Cannot write tile at %lu %lu"",\n+\t          (unsigned long) col, (unsigned long) row);\n+\t _TIFFfree(tilebuf);\n \treturn 0;\n \t}\n       }\n-    } \n-*/   \n+    }\n+  _TIFFfree(tilebuf);\n \n-  _TIFFfree(obuf);\n   return 1;\n-}\n-\n-static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,\n-                                     uint32 imagewidth, tsample_t spp)\n-{\n-\tuint32 imagew = TIFFScanlineSize(out);\n-\tuint32 tilew  = TIFFTileRowSize(out);\n-\tint iskew = imagew - tilew;\n-\ttdata_t obuf = _TIFFmalloc(TIFFTileSize(out));\n-\tuint8* bufp = (uint8*) buf;\n-\tuint32 tl, tw;\n-\tuint32 row;\n-\n-\t(void) spp;\n-\tif (obuf == NULL)\n-\t\treturn 0;\n-\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n-\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n-\tfor (row = 0; row < imagelength; row += tilelength) {\n-\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n-\t\tuint32 colb = 0;\n-\t\tuint32 col;\n-\n-\t\tfor (col = 0; col < imagewidth; col += tw) {\n-\t\t\t/*\n-\t\t\t * Tile is clipped horizontally.  Calculate\n-\t\t\t * visible portion and skewing factors.\n-\t\t\t */\n-\t\t\tif (colb + tilew > imagew) {\n-\t\t\t\tuint32 width = imagew - colb;\n-\t\t\t\tint oskew = tilew - width;\n-\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,\n-\t\t\t\t    oskew, oskew + iskew);\n-\t\t\t} else\n-\t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,\n-\t\t\t\t    0, iskew);\n-\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {\n-\t\t\t\tTIFFError(TIFFFileName(out),\n-\t\t\t\t\t  ""Error, can\'t write tile at %lu %lu"",\n-\t\t\t\t\t  (unsigned long) col,\n-\t\t\t\t\t  (unsigned long) row);\n-\t\t\t\t_TIFFfree(obuf);\n-\t\t\t\treturn 0;\n-\t\t\t}\n-\t\t\tcolb += tilew;\n-\t\t}\n-\t\tbufp += nrow * imagew;\n-\t}\n-\t_TIFFfree(obuf);\n-\treturn 1;\n-}\n+  } /* end writeBufferToContigTiles */\n \n+/* Extract each plane from contiguous buffer into a single tile buffer \n+ * to be written out as a tile.\n+ */\n static int writeBufferToSeparateTiles (TIFF* out, uint8* buf, uint32 imagelength,\n \t\t\t\t       uint32 imagewidth, tsample_t spp, \n                                        struct dump_opts * dump)\n   {\n-\tuint32 imagew = TIFFScanlineSize(out);\n-\ttsize_t tilew  = TIFFTileRowSize(out);\n-\tuint32 iimagew = TIFFRasterScanlineSize(out);\n-\tint iskew = iimagew - tilew*spp;\n-\ttdata_t obuf = _TIFFmalloc(TIFFTileSize(out));\n-\tuint8* bufp = (uint8*) buf;\n-\tuint32 tl, tw;\n-\tuint32 row;\n-        uint16 bps, bytes_per_sample;\n-\n-\tif (obuf == NULL)\n-\t\treturn 0;\n-\t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n-\t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n-\t(void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n-        assert( bps % 8 == 0 );\n-        bytes_per_sample = (bps + 7)/8;\n-        \n-\tfor (row = 0; row < imagelength; row += tl) {\n-\t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;\n-\t\tuint32 colb = 0;\n-\t\tuint32 col;\n-\n-\t\tfor (col = 0; col < imagewidth; col += tw) {\n-\t\t\ttsample_t s;\n-\t\t\tfor (s = 0; s < spp; s++) {\n-\t\t\t\t/*\n-\t\t\t\t * Tile is clipped horizontally.  Calculate\n-\t\t\t\t * visible portion and skewing factors.\n-\t\t\t\t */\n-\t\t\t\tif (colb + tilew > imagew) {\n-\t\t\t\t\tuint32 width = (imagew - colb);\n-\t\t\t\t\tint oskew = tilew - width;\n-\n-\t\t\t\t  extractContigSamplesToBuffer(obuf,\n-\t\t\t\t\t    bufp + (colb*spp) + s,\n-\t\t\t\t\t    nrow, width/bytes_per_sample,\n-\t\t\t\t\t    oskew, (oskew*spp)+iskew, s,\n-\t\t\t\t\t    spp, bps, dump);\n-\t\t\t\t} else\n-\t\t\t\t    extractContigSamplesToBuffer(obuf,\n-\t\t\t\t\t    bufp + (colb*spp) + s,\n-\t\t\t\t\t    nrow, tilewidth,\n-\t\t\t\t\t    0, iskew, s, spp,\n-\t\t\t\t\t    bps, dump);\n-\t\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {\n-\t\t\t\t\tTIFFError(TIFFFileName(out),\n-\t\t\t\t\t""Error, can\'t write tile at %lu %lu ""\n-\t\t\t\t\t""sample %lu"",\n-\t\t\t\t\t(unsigned long) col,\n-\t\t\t\t\t(unsigned long) row,\n-\t\t\t\t\t(unsigned long) s);\n-\t\t\t\t\t_TIFFfree(obuf);\n-\t\t\t\t\treturn 0;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcolb += tilew;\n-\t\t}\n-\t\tbufp += nrow * iimagew;\n+  tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));\n+  uint32 tl, tw;\n+  uint32 row, col, nrow, ncol;\n+  uint32 src_rowsize, col_offset;\n+  uint16 bps;\n+  tsample_t s;\n+  uint8* bufp = (uint8*) buf;\n+\n+  if (obuf == NULL)\n+    return 0;\n+\n+  TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n+  TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n+  TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);\n+  src_rowsize = ((imagewidth * spp * bps) + 7) / 8;\n+         \n+  for (row = 0; row < imagelength; row += tl)\n+    {\n+    nrow = (row + tl > imagelength) ? imagelength - row : tl;\n+    for (col = 0; col < imagewidth; col += tw)\n+      {\n+      /* Calculate visible portion of tile. */\n+      if (col + tw > imagewidth)\n+\tncol = imagewidth - col;\n+      else\n+        ncol = tw;\n+\n+      col_offset = (((col * bps * spp) + 7) / 8);\n+      bufp = buf + (row * src_rowsize) + col_offset;\n+\n+      for (s = 0; s < spp; s++)\n+        {\n+\tif (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,\n+\t\t\t\t\t     tw, s, 1, spp, bps, dump) > 0)\n+          {\n+\t  TIFFError(""writeBufferToSeparateTiles"", \n+                    ""Unable to extract data to tile for row %lu, col %lu sample %d"",\n+                    (unsigned long) row, (unsigned long)col, (int)s);\n+\t  _TIFFfree(obuf);\n+\t  return (0);\n+          }\n+\n+\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0)\n+          {\n+\t   TIFFError(""writeBufferToseparateTiles"",\n+\t             ""Cannot write tile at %lu %lu sample %lu"",\n+\t             (unsigned long) col, (unsigned long) row,\n+\t             (unsigned long) s);\n+\t   _TIFFfree(obuf);\n+\t  return 0;\n+\t  }\n \t}\n-\t_TIFFfree(obuf);\n-\treturn 1;\n-}\n+      }\n+    }\n+  _TIFFfree(obuf);\n \n+  return 1;\n+  } /* end writeBufferToSeparateTiles */\n \n static void\n processG3Options(char* cp)\n@@ -1122,59 +1341,85 @@ processG3Options(char* cp)\n \n static int\n processCompressOptions(char* opt)\n-{\n-\tif (streq(opt, ""none"")) {\n-\t\tdefcompression = COMPRESSION_NONE;\n-\t} else if (streq(opt, ""packbits"")) {\n-\t\tdefcompression = COMPRESSION_PACKBITS;\n-\t} else if (strneq(opt, ""jpeg"", 4)) {\n-\t\tchar* cp = strchr(opt, \':\');\n-\n-                defcompression = COMPRESSION_JPEG;\n-                while( cp )\n-                {\n-                    if (isdigit((int)cp[1]))\n-\t\t\tquality = atoi(cp+1);\n-                    else if (cp[1] == \'r\' )\n-\t\t\tjpegcolormode = JPEGCOLORMODE_RAW;\n-                    else\n-                        usage();\n+  {\n+  char* cp = NULL;\n \n-                    cp = strchr(cp+1,\':\');\n-                }\n-\t} else if (strneq(opt, ""g3"", 2)) {\n-\t\tprocessG3Options(opt);\n-\t\tdefcompression = COMPRESSION_CCITTFAX3;\n-\t} else if (streq(opt, ""g4"")) {\n-\t\tdefcompression = COMPRESSION_CCITTFAX4;\n-\t} else if (strneq(opt, ""lzw"", 3)) {\n-\t\tchar* cp = strchr(opt, \':\');\n-\t\tif (cp)\n-\t\t\tdefpredictor = atoi(cp+1);\n-\t\tdefcompression = COMPRESSION_LZW;\n-\t} else if (strneq(opt, ""zip"", 3)) {\n-\t\tchar* cp = strchr(opt, \':\');\n-\t\tif (cp)\n-\t\t\tdefpredictor = atoi(cp+1);\n-\t\tdefcompression = COMPRESSION_ADOBE_DEFLATE;\n-\t} else\n-\t\treturn (0);\n-\treturn (1);\n-}\n+  if (strneq(opt, ""none"",4))\n+    {\n+    defcompression = COMPRESSION_NONE;\n+    /* DELETE ME:  This should not be needed */\n+    cp = strchr(opt, \':\');\n+    if (cp)\n+      {\n+      if (cp[1] == \'r\' )\n+\tjpegcolormode = JPEGCOLORMODE_RAW;\n+      else if (cp[1] == \'a\' )\n+\tjpegcolormode = JPEGCOLORMODE_RGB;\n+      }\n+    /* end DELETE ME: */\n+    }\n+  else if (streq(opt, ""packbits""))\n+    {\n+    defcompression = COMPRESSION_PACKBITS;\n+    }\n+  else if (strneq(opt, ""jpeg"", 4))\n+    {\n+    cp = strchr(opt, \':\');\n+    defcompression = COMPRESSION_JPEG;\n+    while ( cp )\n+      {\n+      if (isdigit((int)cp[1]))\n+\tquality = atoi(cp+1);\n+      else if (cp[1] == \'r\' )\n+\tjpegcolormode = JPEGCOLORMODE_RAW;\n+      else if (cp[1] == \'a\' )\n+\tjpegcolormode = JPEGCOLORMODE_RGB;\n+      else\n+        usage();\n+      cp = strchr(cp+1,\':\');\n+      }\n+    }\n+  else if (strneq(opt, ""g3"", 2))\n+    {\n+    processG3Options(opt);\n+    defcompression = COMPRESSION_CCITTFAX3;\n+    }\n+  else if (streq(opt, ""g4""))\n+    {\n+    defcompression = COMPRESSION_CCITTFAX4;\n+    }\n+  else if (strneq(opt, ""lzw"", 3))\n+    {\n+    cp = strchr(opt, \':\');\n+    if (cp)\n+      defpredictor = atoi(cp+1);\n+    defcompression = COMPRESSION_LZW;\n+    }\n+  else if (strneq(opt, ""zip"", 3))\n+    {\n+    cp = strchr(opt, \':\');\n+    if (cp)\n+      defpredictor = atoi(cp+1);\n+    defcompression = COMPRESSION_ADOBE_DEFLATE;\n+   }\n+  else\n+    return (0);\n \n+  return (1);\n+  }\n \n static void\n usage(void)\n-{\n-\tchar buf[BUFSIZ];\n-\tint i;\n-\n-\tsetbuf(stderr, buf);\n-        fprintf(stderr, ""\\n%s\\n"", TIFFGetVersion());\n-\tfor (i = 0; stuff[i] != NULL; i++)\n-\t\tfprintf(stderr, ""%s\\n"", stuff[i]);\n-\texit(-1);\n-}\n+  {\n+  char buf[BUFSIZ];\n+  int i;\n+\n+  setbuf(stderr, buf);\n+  fprintf(stderr, ""\\n%s\\n"", TIFFGetVersion());\n+  for (i = 0; stuff[i] != NULL; i++)\n+    fprintf(stderr, ""%s\\n"", stuff[i]);\n+  exit(-1);\n+  }\n \n #define\tCopyField(tag, v) \\\n     if (TIFFGetField(in, tag, &v)) TIFFSetField(out, tag, v)\n@@ -1283,20 +1528,6 @@ static struct cpTag {\n \n #define\tCopyTag(tag, count, type)\tcpTag(in, out, tag, count, type)\n \n-static void\n-cpStripToTile(uint8* out, uint8* in,\n-\tuint32 rows, uint32 cols, int outskew, int inskew)\n-{\n-\twhile (rows-- > 0) {\n-\t\tuint32 j = cols;\n-\t\twhile (j-- > 0)\n-\t\t\t*out++ = *in++;\n-\t\tout += outskew;\n-\t\tin += inskew;\n-\t}\n-}\n-\n-\n /* Fucntions written by Richard Nolde, with exceptions noted. */\n void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32 *dirnum,\n \t                    uint16 *defconfig, uint16 *deffillorder, uint32 *deftilewidth,\n@@ -1399,7 +1630,8 @@ void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32\n       case \'t\':\t/* generate tiled output */\n \t\touttiled = TRUE;\n \t\tbreak;\n-      case \'v\': TIFFError (""Tiffcrop version"", ""%s, last updated: %s"", \n+      case \'v\': TIFFError(""Library Release"", ""%s"", TIFFGetVersion());\n+                TIFFError (""Tiffcrop version"", ""%s, last updated: %s"", \n \t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n  \t        TIFFError (""Tiffcp code"", ""Copyright (c) 1988-1997 Sam Leffler"");\n \t\tTIFFError (""           "", ""Copyright (c) 1991-1997 Silicon Graphics, Inc"");\n@@ -1635,7 +1867,7 @@ void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32\n \t\t\t   {\n \t\t\t   sep = strpbrk(opt_ptr, "":-"");\n \t\t\t   if (!sep)\n-\t\t\t     imagelist[i++] = atoi(opt_ptr) - 1;\n+\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                            else\n                              {\n \t\t\t     *sep = \'\\0\';\n@@ -1645,7 +1877,7 @@ void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32\n                              else\n                                end = atoi (sep + 1);\n                              for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n-\t\t\t       imagelist[i++] = j - 1;\n+\t\t\t       imagelist[i++] = j;\n \t\t\t     }\n \t\t\t   }\n \t\t\t }\n@@ -1854,11 +2086,10 @@ main(int argc, char* argv[])\n   {\n   uint16 defconfig = (uint16) -1;\n   uint16 deffillorder = 0;\n-  uint32 deftilewidth = (uint32) -1;\n-  uint32 deftilelength = (uint32) -1;\n+  uint32 deftilewidth = (uint32) 0;\n+  uint32 deftilelength = (uint32) 0;\n   uint32 defrowsperstrip = (uint32) 0;\n   uint32 dirnum = 0;\n-  extern int   optind;\n \n   TIFF *in = NULL;\n   TIFF *out = NULL;\n@@ -1981,7 +2212,7 @@ main(int argc, char* argv[])\n                   (dump.format == DUMP_TEXT) ? ""txt"" : ""raw"");\n           if ((dump.infile = fopen(temp_filename, dump.mode)) == NULL)\n             {\n-\t    TIFFError (""Unable to open dump file %s for writing"", ""%s"", temp_filename);\n+\t    TIFFError (""Unable to open dump file for writing"", ""%s"", temp_filename);\n \t    exit (-1);\n             }\n           dump_info(dump.infile, dump.format, ""Reading image"",""%d from %s"", \n@@ -1997,7 +2228,7 @@ main(int argc, char* argv[])\n                   (dump.format == DUMP_TEXT) ? ""txt"" : ""raw"");\n           if ((dump.outfile = fopen(temp_filename, dump.mode)) == NULL)\n             {\n-\t    TIFFError (""Unable to open dump file %s for writing"", ""%s"", temp_filename);\n+\t      TIFFError (""Unable to open dump file for writing"", ""%s"", temp_filename);\n \t    exit (-1);\n             }\n           dump_info(dump.outfile, dump.format, ""Writing image"",""%d from %s"", \n@@ -3270,11 +3501,10 @@ extractContigSamplesShifted32bits (uint8 *in, uint8 *out, uint32 cols,\n   return (0);\n   } /* end extractContigSamplesShifted32bits */\n \n-\n static int\n extractContigSamplesToBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n-  \t                     int outskew, int inskew, tsample_t sample,\n-                             uint16 spp, uint16 bps, struct dump_opts *dump)\n+  \t                     tsample_t sample, uint16 spp, uint16 bps, \n+                             struct dump_opts *dump)\n   {\n   int    shift_width, bytes_per_sample, bytes_per_pixel;\n   uint32 src_rowsize, src_offset, row, first_col = 0;\n@@ -3315,18 +3545,23 @@ extractContigSamplesToBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n                                              spp, bps,  count, first_col, cols))  \n                 return (1);\n  \t      break;\n-      case 1: if (extractContigSamples8bits (src, dst, cols, sample,\n-                                             spp, bps, count, first_col, cols))\n+      case 1: if (bps == 1)\n+                {\n+                if (extractContigSamples8bits (src, dst, cols, sample,\n+                                               spp, bps, count, first_col, cols))\n+\t          return (1);\n+\t        break;\n+\t\t}\n+\t      else\n+                 if (extractContigSamples16bits (src, dst, cols, sample,\n+                                                 spp, bps, count, first_col, cols))\n \t         return (1);\n \t      break;\n-      case 2: if (extractContigSamples16bits (src, dst, cols, sample,\n+      case 2: if (extractContigSamples24bits (src, dst, cols, sample,\n                                               spp, bps,  count, first_col, cols))\n \t         return (1);\n \t      break;\n-      case 3: if (extractContigSamples24bits (src, dst, cols, sample,\n-                                              spp, bps,  count, first_col, cols))\n-\t         return (1);\n-              break;\n+      case 3:\n       case 4: \n       case 5: if (extractContigSamples32bits (src, dst, cols, sample,\n                                               spp, bps,  count, first_col, cols))\n@@ -3337,70 +3572,187 @@ extractContigSamplesToBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n       }\n     if ((dump->outfile != NULL) && (dump->level == 4))\n       dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);\n-    \n-    out += outskew;\n-    in += inskew;\n     }\n \n   return (0);\n   } /* end extractContigSamplesToBuffer */\n \n-/* This will not work unless bps is a multiple of 8 */\n-static void\n-cpSeparateBufToContigBuf(uint8  *out, uint8 *in, uint32 rows, uint32 cols, \n-                         int outskew, int inskew, tsample_t spp,\n-                         int bytes_per_sample)\n+static int\n+extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,\n+  \t                         uint32 imagewidth, uint32 tilewidth, tsample_t sample,\n+\t\t\t\t uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump)\n   {\n-  while (rows-- > 0)\n+  int    shift_width, bytes_per_sample, bytes_per_pixel;\n+  uint32 src_rowsize, src_offset, row;\n+  uint32 dst_rowsize, dst_offset;\n+  uint8 *src, *dst;\n+\n+  bytes_per_sample = (bps + 7) / 8; \n+  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n+  if ((bps % 8) == 0)\n+    shift_width = 0;\n+  else\n     {\n-    uint32 j = cols;\n-    while (j-- > 0)\n-      {\n-      int n = bytes_per_sample;\n-      while( n-- )\n-        {\n-        *out++ = *in++;\n-        }\n-      out += (spp-1)*bytes_per_sample;\n+    if (bytes_per_pixel < (bytes_per_sample + 1))\n+      shift_width = bytes_per_pixel;\n+    else\n+      shift_width = bytes_per_sample + 1;\n+    }\n+\n+  if ((dump->outfile != NULL) && (dump->level == 4))\n+    {\n+    dump_info  (dump->outfile, dump->format, ""extractContigSamplesToTileBuffer"", \n+                ""Sample %d, %d rows"", sample + 1, rows + 1);\n+    }\n+\n+  src_rowsize = ((bps * spp * imagewidth) + 7) / 8;\n+  dst_rowsize = ((bps * tilewidth * count) + 7) / 8;\n+\n+  for (row = 0; row < rows; row++)\n+    {\n+    src_offset = row * src_rowsize;\n+    dst_offset = row * dst_rowsize;\n+    src = in + src_offset;\n+    dst = out + dst_offset;\n+\n+    /* pack the data into the scanline */\n+    switch (shift_width)\n+      {  \n+      case 0: if (extractContigSamplesBytes (src, dst, cols, sample,\n+                                             spp, bps,  count, 0, cols))  \n+                return (1);\n+ \t      break;\n+      case 1: if (bps == 1)\n+                {\n+                if (extractContigSamples8bits (src, dst, cols, sample,\n+                                               spp, bps, count, 0, cols))\n+\t          return (1);\n+\t        break;\n+\t\t}\n+\t      else\n+                 if (extractContigSamples16bits (src, dst, cols, sample,\n+                                                 spp, bps, count, 0, cols))\n+\t         return (1);\n+\t      break;\n+      case 2: if (extractContigSamples24bits (src, dst, cols, sample,\n+                                              spp, bps,  count, 0, cols))\n+\t         return (1);\n+\t      break;\n+      case 3:\n+      case 4: \n+      case 5: if (extractContigSamples32bits (src, dst, cols, sample,\n+                                              spp, bps,  count, 0, cols))\n+\t         return (1);\n+\t      break;\n+      default: TIFFError (""extractContigSamplesToTileBuffer"", ""Unsupported bit depth: %d"", bps);\n+\t       return (1);\n       }\n-    out += outskew;\n-    in += inskew;\n+    if ((dump->outfile != NULL) && (dump->level == 4))\n+      dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);\n     }\n-  } /* end of cpSeparateBufToContifBuf */\n \n-static int readContigStripsIntoBuffer (TIFF* in, uint8* buf, uint32 imagelength, \n-                                         uint32 imagewidth, tsample_t spp)\n+  return (0);\n+  } /* end extractContigSamplesToTileBuffer */\n+\n+static int readContigStripsIntoBuffer (TIFF* in, uint8* buf, uint32 length, uint32 width, \n+                                       tsample_t spp, struct dump_opts * dump)\n   {\n-  tsize_t scanlinesize = TIFFScanlineSize(in);\n   uint8* bufp = buf;\n-  uint32 row;\n-\n- (void) imagewidth; (void) spp;\n- for (row = 0; row < imagelength; row++)\n-   {\n-   if (TIFFReadScanline(in, (tdata_t) bufp, row, 0) < 0\n-\t && !ignore)\n-     {\n-     TIFFError(TIFFFileName(in),""Error, can\'t read scanline %lu"",\n-\t       (unsigned long) row);\n-     return 0;\n-     }\n-   bufp += scanlinesize;\n-   }\n+  int32  bytes_read = 0;\n+  uint16 nstrips   = TIFFNumberOfStrips(in);\n+  uint32 stripsize = TIFFStripSize(in);\n+  uint32 rows = 0, strip;\n+  uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n+  tsize_t scanline_size = TIFFScanlineSize(in);\n+\n+  for (strip = 0; strip < nstrips; strip++)\n+    {\n+    bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);\n+    rows = bytes_read / scanline_size;\n+    if (bytes_read != (int32)stripsize)\n+      TIFFError("""", ""Bytes read %lu does not match reported strip size %lu"",\n+\t\t(unsigned long) bytes_read, (unsigned long)stripsize);\n+\n+    if (bytes_read < 0 && !ignore)\n+      {\n+      TIFFError("""", ""Error reading strip %lu after %lu rows"",\n+\t\t(unsigned long) strip, (unsigned long)rows);\n+      return 0;\n+      }\n+    bufp += bytes_read;\n+    }\n \n  return 1;\n   } /* end readContigStripsIntoBuffer */\n \n+static int \n+combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n+                             uint32 cols, uint32 rows, uint16 spp, uint16 bps,\n+                             FILE *dumpfile, int format, int level)\n+  {\n+  int i, bytes_per_sample;\n+  uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;\n+  unsigned char *src;\n+  unsigned char *dst;\n+  tsample_t s;\n+\n+  src = srcbuffs[0];\n+  dst = out;\n+  if ((src == NULL) || (dst == NULL))\n+    {\n+    TIFFError(""combineSeparateSamplesBytes"",""Invalid buffer address"");\n+    return (1);\n+    }\n+\n+  bytes_per_sample = (bps + 7) / 8; \n+\n+  src_rowsize = ((bps * cols) + 7) / 8;\n+  dst_rowsize = ((bps * spp * cols) + 7) / 8;\n+  for (row = 0; row < rows; row++)\n+    {\n+    if ((dumpfile != NULL) && (level == 2))\n+      {\n+      for (s = 0; s < spp; s++)\n+        {\n+        dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Input data, Sample %d"", s);\n+        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));\n+        }\n+      }\n+    dst = out + (row * dst_rowsize);\n+    row_offset = row * src_rowsize;\n+    for (col = 0; col < cols; col++)\n+      {\n+      col_offset = row_offset + (col * (bps / 8)); \n+      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n+        {\n+        src = srcbuffs[s] + col_offset; \n+        for (i = 0; i < bytes_per_sample; i++)\n+          *(dst + i) = *(src + i);\n+        src += bytes_per_sample;\n+        dst += bytes_per_sample;\n+        }   \n+      }\n+\n+    if ((dumpfile != NULL) && (level == 2))\n+      {\n+      dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Output data, combined samples"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n+      }\n+    }\n+\n+  return (0);\n+  } /* end combineSeparateSamplesBytes */\n+\n static int\n-combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 row,\n-                            uint32 cols, uint16 spp, uint16 bps, \n+combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols,\n+                            uint32 rows, uint16 spp, uint16 bps, \n  \t                    FILE *dumpfile, int format, int level)\n   {\n   int    ready_bits = 0;\n   int    bytes_per_sample = 0;\n-  uint32 dst_rowsize; \n+  uint32 src_rowsize, dst_rowsize, src_offset; \n   uint32 bit_offset;\n-  uint32 col, src_byte = 0, src_bit = 0;\n+  uint32 row, col, src_byte = 0, src_bit = 0;\n   uint8  maskbits = 0, matchbits = 0;\n   uint8  buff1 = 0, buff2 = 0;\n   tsample_t s;\n@@ -3415,86 +3767,91 @@ combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 row,\n     }\n \n   bytes_per_sample = (bps + 7) / 8; \n+  src_rowsize = ((bps * cols) + 7) / 8;\n   dst_rowsize = ((bps * cols * spp) + 7) / 8;\n   maskbits =  (uint8)-1 >> ( 8 - bps);\n \n-  ready_bits = 0;\n-  buff1 = buff2 = 0;\n-\n-  for (col = 0; col < cols; col++)\n+  for (row = 0; row < rows; row++)\n     {\n-    /* Compute src byte(s) and bits within byte(s) */\n-    bit_offset = col * bps;\n-    src_byte = bit_offset / 8;\n-    src_bit  = bit_offset % 8;\n-\n-    matchbits = maskbits << (8 - src_bit - bps); \n-    /* load up next sample from each plane */\n-    for (s = 0; s < spp; s++)\n+    ready_bits = 0;\n+    buff1 = buff2 = 0;\n+    dst = out + (row * dst_rowsize);\n+    src_offset = row * src_rowsize;\n+    for (col = 0; col < cols; col++)\n       {\n-      src = in[s] + src_byte;\n-      buff1 = ((*src) & matchbits) << (src_bit);\n+      /* Compute src byte(s) and bits within byte(s) */\n+      bit_offset = col * bps;\n+      src_byte = bit_offset / 8;\n+      src_bit  = bit_offset % 8;\n \n-      /* If we have a full buffer\'s worth, write it out */\n-      if (ready_bits >= 8)\n-        {\n-        *dst++ = buff2;\n-        buff2 = buff1;\n-        ready_bits -= 8;\n-        strcpy (action, ""Flush"");\n-        }\n-      else\n+      matchbits = maskbits << (8 - src_bit - bps); \n+      /* load up next sample from each plane */\n+      for (s = 0; s < spp; s++)\n         {\n-        buff2 = (buff2 | (buff1 >> ready_bits));\n-        strcpy (action, ""Update"");\n-        }\n-      ready_bits += bps;\n+\tsrc = in[s] + src_offset + src_byte;\n+        buff1 = ((*src) & matchbits) << (src_bit);\n+\n+        /* If we have a full buffer\'s worth, write it out */\n+        if (ready_bits >= 8)\n+          {\n+          *dst++ = buff2;\n+          buff2 = buff1;\n+          ready_bits -= 8;\n+          strcpy (action, ""Flush"");\n+          }\n+        else\n+          {\n+          buff2 = (buff2 | (buff1 >> ready_bits));\n+          strcpy (action, ""Update"");\n+          }\n+        ready_bits += bps;\n  \n-      if ((dumpfile != NULL) && (level == 3))\n-        {\n-        dump_info (dumpfile, format, """",\n+        if ((dumpfile != NULL) && (level == 3))\n+          {\n+          dump_info (dumpfile, format, """",\n                    ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n-        dump_byte (dumpfile, format, ""Match bits"", matchbits);\n-        dump_byte (dumpfile, format, ""Src   bits"", *src);\n-        dump_byte (dumpfile, format, ""Buff1 bits"", buff1);\n-        dump_byte (dumpfile, format, ""Buff2 bits"", buff2);\n-        dump_info (dumpfile, format, """",""%s"", action); \n-\t}\n+          dump_byte (dumpfile, format, ""Match bits"", matchbits);\n+          dump_byte (dumpfile, format, ""Src   bits"", *src);\n+          dump_byte (dumpfile, format, ""Buff1 bits"", buff1);\n+          dump_byte (dumpfile, format, ""Buff2 bits"", buff2);\n+          dump_info (dumpfile, format, """",""%s"", action); \n+\t  }\n+        }\n       }\n-    }\n \n-  if (ready_bits > 0)\n-    {\n-    buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n-    *dst++ = buff1;\n-    if ((dumpfile != NULL) && (level == 3))\n+    if (ready_bits > 0)\n       {\n-      dump_info (dumpfile, format, """",\n+      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n+      *dst++ = buff1;\n+      if ((dumpfile != NULL) && (level == 3))\n+        {\n+        dump_info (dumpfile, format, """",\n \t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n \t         row + 1, col + 1, src_byte, src_bit, dst - out);\n                  dump_byte (dumpfile, format, ""Final bits"", buff1);\n+        }\n       }\n-    }\n \n-  if ((dumpfile != NULL) && (level == 2))\n-    {\n-    dump_info (dumpfile, format, ""combineSeparateSamples8bits"",""Output data"");\n-    dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n+    if ((dumpfile != NULL) && (level >= 2))\n+      {\n+      dump_info (dumpfile, format, ""combineSeparateSamples8bits"",""Output data"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n+      }\n     }\n-  \n+\n   return (0);\n   } /* end combineSeparateSamples8bits */\n \n static int\n-combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 row,\n-                              uint32 cols, uint16 spp, uint16 bps, \n+combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols,\n+                              uint32 rows, uint16 spp, uint16 bps, \n  \t                      FILE *dumpfile, int format, int level)\n   {\n   int    ready_bits = 0, bytes_per_sample = 0;\n-  uint32 dst_rowsize; \n-  uint32 bit_offset;\n-  uint32 col, src_byte = 0, src_bit = 0;\n+  uint32 src_rowsize, dst_rowsize; \n+  uint32 bit_offset, src_offset;\n+  uint32 row, col, src_byte = 0, src_bit = 0;\n   uint16 maskbits = 0, matchbits = 0;\n   uint16 buff1 = 0, buff2 = 0;\n   uint8  bytebuff = 0;\n@@ -3511,101 +3868,680 @@ combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 row,\n     }\n \n   bytes_per_sample = (bps + 7) / 8; \n+  src_rowsize = ((bps * cols) + 7) / 8;\n   dst_rowsize = ((bps * cols * spp) + 7) / 8;\n   maskbits = (uint16)-1 >> (16 - bps);\n \n-  ready_bits = 0;\n-  buff1 = buff2 = 0;\n-  for (col = 0; col < cols; col++)\n+  for (row = 0; row < rows; row++)\n     {\n-    /* Compute src byte(s) and bits within byte(s) */\n-    bit_offset = col * bps;\n-    src_byte = bit_offset / 8;\n-    src_bit  = bit_offset % 8;\n-\n-    matchbits = maskbits << (16 - src_bit - bps); \n-    for (s = 0; s < spp; s++)\n+    ready_bits = 0;\n+    buff1 = buff2 = 0;\n+    dst = out + (row * dst_rowsize);\n+    src_offset = row * src_rowsize;\n+    for (col = 0; col < cols; col++)\n       {\n-      src = in[s] + src_byte;\n-      if (little_endian)\n+      /* Compute src byte(s) and bits within byte(s) */\n+      bit_offset = col * bps;\n+      src_byte = bit_offset / 8;\n+      src_bit  = bit_offset % 8;\n+\n+      matchbits = maskbits << (16 - src_bit - bps); \n+      for (s = 0; s < spp; s++)\n         {\n-        swapbuff[1] = *src;\n-        swapbuff[0] = *(src + 1);\n-        }\n-      else\n+\tsrc = in[s] + src_offset + src_byte;\n+        if (little_endian)\n+          {\n+          swapbuff[1] = *src;\n+          swapbuff[0] = *(src + 1);\n+          }\n+        else\n+          {\n+          swapbuff[0] = *src;\n+          swapbuff[1] = *(src + 1);\n+\t  }\n+\n+\tbuff1 = *((uint16 *)swapbuff);\n+\tbuff1 = (buff1 & matchbits) << (src_bit);\n+\n+\t/* If we have a full buffer\'s worth, write it out */\n+\tif (ready_bits >= 8)\n+\t  {\n+\t    bytebuff = (buff2 >> 8);\n+\t    *dst++ = bytebuff;\n+\t    ready_bits -= 8;\n+\t    /* shift in new bits */\n+\t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n+\t    strcpy (action, ""Flush"");\n+\t  }\n+\telse\n+\t  { /* add another bps bits to the buffer */\n+\t    bytebuff = 0;\n+\t    buff2 = (buff2 | (buff1 >> ready_bits));\n+\t    strcpy (action, ""Update"");\n+\t  }\n+\tready_bits += bps;\n+\n+\tif ((dumpfile != NULL) && (level == 3))\n+\t  {\n+\t  dump_info (dumpfile, format, """",\n+\t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n+\n+\t  dump_short (dumpfile, format, ""Match bits"", matchbits);\n+\t  dump_data  (dumpfile, format, ""Src   bits"", src, 2);\n+\t  dump_short (dumpfile, format, ""Buff1 bits"", buff1);\n+\t  dump_short (dumpfile, format, ""Buff2 bits"", buff2);\n+\t  dump_byte  (dumpfile, format, ""Write byte"", bytebuff);\n+\t  dump_info  (dumpfile, format, """",""Ready bits:  %d, %s"", ready_bits, action); \n+\t  }\n+\t}\n+      }\n+\n+    /* catch any trailing bits at the end of the line */\n+    if (ready_bits > 0)\n+      {\n+      bytebuff = (buff2 >> 8);\n+      *dst++ = bytebuff;\n+      if ((dumpfile != NULL) && (level == 3))\n+\t{\n+\tdump_info (dumpfile, format, """",\n+\t\t       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\n+\tdump_byte (dumpfile, format, ""Final bits"", bytebuff);\n+\t}\n+      }\n+\n+    if ((dumpfile != NULL) && (level == 2))\n+      {\n+      dump_info (dumpfile, format, ""combineSeparateSamples16bits"",""Output data"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n+      }\n+    }\n+\n+  return (0);\n+  } /* end combineSeparateSamples16bits */\n+\n+static int\n+combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols,\n+                              uint32 rows, uint16 spp, uint16 bps, \n+\t                      FILE *dumpfile, int format, int level)\n+  {\n+  int    ready_bits = 0, bytes_per_sample = 0;\n+  uint32 src_rowsize, dst_rowsize; \n+  uint32 bit_offset, src_offset;\n+  uint32 row, col, src_byte = 0, src_bit = 0;\n+  uint32 maskbits = 0, matchbits = 0;\n+  uint32 buff1 = 0, buff2 = 0;\n+  uint8  bytebuff1 = 0, bytebuff2 = 0;\n+  tsample_t s;\n+  unsigned char *src = in[0];\n+  unsigned char *dst = out;\n+  unsigned char  swapbuff[4];\n+  char           action[8];\n+\n+  if ((src == NULL) || (dst == NULL))\n+    {\n+    TIFFError(""combineSeparateSamples24bits"",""Invalid input or output buffer"");\n+    return (1);\n+    }\n+\n+  bytes_per_sample = (bps + 7) / 8; \n+  src_rowsize = ((bps * cols) + 7) / 8;\n+  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n+  maskbits =  (uint32)-1 >> ( 32 - bps);\n+\n+  for (row = 0; row < rows; row++)\n+    {\n+    ready_bits = 0;\n+    buff1 = buff2 = 0;\n+    dst = out + (row * dst_rowsize);\n+    src_offset = row * src_rowsize;\n+    for (col = 0; col < cols; col++)\n+      {\n+      /* Compute src byte(s) and bits within byte(s) */\n+      bit_offset = col * bps;\n+      src_byte = bit_offset / 8;\n+      src_bit  = bit_offset % 8;\n+\n+      matchbits = maskbits << (32 - src_bit - bps); \n+      for (s = 0; s < spp; s++)\n         {\n-        swapbuff[0] = *src;\n-        swapbuff[1] = *(src + 1);\n+\tsrc = in[s] + src_offset + src_byte;\n+        if (little_endian)\n+          {\n+          swapbuff[3] = *src;\n+          swapbuff[2] = *(src + 1);\n+          swapbuff[1] = *(src + 2);\n+          swapbuff[0] = *(src + 3);\n+          }\n+        else\n+          {\n+          swapbuff[0] = *src;\n+          swapbuff[1] = *(src + 1);\n+          swapbuff[2] = *(src + 2);\n+          swapbuff[3] = *(src + 3);\n+\t  }\n+\n+\tbuff1 = *((uint32 *)swapbuff);\n+\tbuff1 = (buff1 & matchbits) << (src_bit);\n+\n+\t/* If we have a full buffer\'s worth, write it out */\n+\tif (ready_bits >= 16)\n+\t  {\n+\t    bytebuff1 = (buff2 >> 24);\n+\t    *dst++ = bytebuff1;\n+\t    bytebuff2 = (buff2 >> 16);\n+\t    *dst++ = bytebuff2;\n+\t    ready_bits -= 16;\n+\n+\t    /* shift in new bits */\n+\t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n+\t    strcpy (action, ""Flush"");\n+\t  }\n+\telse\n+\t  { /* add another bps bits to the buffer */\n+\t    bytebuff1 = bytebuff2 = 0;\n+\t    buff2 = (buff2 | (buff1 >> ready_bits));\n+\t    strcpy (action, ""Update"");\n+\t  }\n+\tready_bits += bps;\n+\n+\tif ((dumpfile != NULL) && (level == 3))\n+\t  {\n+\t  dump_info (dumpfile, format, """",\n+\t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n+\t  dump_long (dumpfile, format, ""Match bits "", matchbits);\n+\t  dump_data (dumpfile, format, ""Src   bits "", src, 4);\n+\t  dump_long (dumpfile, format, ""Buff1 bits "", buff1);\n+\t  dump_long (dumpfile, format, ""Buff2 bits "", buff2);\n+\t  dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);\n+\t  dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);\n+\t  dump_info (dumpfile, format, """",""Ready bits:   %d, %s"", ready_bits, action); \n+\t  }\n \t}\n+      }\n \n-      buff1 = *((uint16 *)swapbuff);\n-      buff1 = (buff1 & matchbits) << (src_bit);\n+    /* catch any trailing bits at the end of the line */\n+    while (ready_bits > 0)\n+      {\n+\tbytebuff1 = (buff2 >> 24);\n+\t*dst++ = bytebuff1;\n \n-      /* If we have a full buffer\'s worth, write it out */\n-      if (ready_bits >= 8)\n+\tbuff2 = (buff2 << 8);\n+\tbytebuff2 = bytebuff1;\n+\tready_bits -= 8;\n+      }\n+ \n+    if ((dumpfile != NULL) && (level == 3))\n+      {\n+      dump_info (dumpfile, format, """",\n+\t\t   ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);\n+\n+      dump_long (dumpfile, format, ""Match bits "", matchbits);\n+      dump_data (dumpfile, format, ""Src   bits "", src, 4);\n+      dump_long (dumpfile, format, ""Buff1 bits "", buff1);\n+      dump_long (dumpfile, format, ""Buff2 bits "", buff2);\n+      dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);\n+      dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);\n+      dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits); \n+      }\n+\n+    if ((dumpfile != NULL) && (level == 2))\n+      {\n+      dump_info (dumpfile, format, ""combineSeparateSamples24bits"",""Output data"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n+      }\n+    }\n+  \n+  return (0);\n+  } /* end combineSeparateSamples24bits */\n+\n+static int\n+combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,\n+                              uint32 rows, uint16 spp, uint16 bps, \n+\t                      FILE *dumpfile, int format, int level)\n+  {\n+  int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;\n+  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;\n+  uint32 src_byte = 0, src_bit = 0;\n+  uint32 row, col;\n+  uint32 longbuff1 = 0, longbuff2 = 0;\n+  uint64 maskbits = 0, matchbits = 0;\n+  uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n+  uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n+  tsample_t s;\n+  unsigned char *src = in[0];\n+  unsigned char *dst = out;\n+  unsigned char  swapbuff1[4];\n+  unsigned char  swapbuff2[4];\n+  char           action[8];\n+\n+  if ((src == NULL) || (dst == NULL))\n+    {\n+    TIFFError(""combineSeparateSamples32bits"",""Invalid input or output buffer"");\n+    return (1);\n+    }\n+\n+  bytes_per_sample = (bps + 7) / 8; \n+  src_rowsize = ((bps * cols) + 7) / 8;\n+  dst_rowsize = ((bps * cols * spp) + 7) / 8;\n+  maskbits =  (uint64)-1 >> ( 64 - bps);\n+  shift_width = ((bps + 7) / 8) + 1; \n+\n+  for (row = 0; row < rows; row++)\n+    {\n+    ready_bits = 0;\n+    buff1 = buff2 = 0;\n+    dst = out + (row * dst_rowsize);\n+    src_offset = row * src_rowsize;\n+    for (col = 0; col < cols; col++)\n+      {\n+      /* Compute src byte(s) and bits within byte(s) */\n+      bit_offset = col * bps;\n+      src_byte = bit_offset / 8;\n+      src_bit  = bit_offset % 8;\n+\n+      matchbits = maskbits << (64 - src_bit - bps); \n+      for (s = 0; s < spp; s++)\n+\t{\n+\tsrc = in[s] + src_offset + src_byte;\n+\tif (little_endian)\n+\t  {\n+\t  swapbuff1[3] = *src;\n+\t  swapbuff1[2] = *(src + 1);\n+\t  swapbuff1[1] = *(src + 2);\n+\t  swapbuff1[0] = *(src + 3);\n+\t  }\n+\telse\n+\t  {\n+\t  swapbuff1[0] = *src;\n+\t  swapbuff1[1] = *(src + 1);\n+\t  swapbuff1[2] = *(src + 2);\n+\t  swapbuff1[3] = *(src + 3);\n+\t  }\n+        longbuff1 = *((uint32 *)swapbuff1);                  \n+\n+\tmemset (swapbuff2, \'\\0\', sizeof(swapbuff2));\n+\tif (little_endian)\n+\t  {\n+\t  swapbuff2[3] = *src;\n+\t  swapbuff2[2] = *(src + 1);\n+\t  swapbuff2[1] = *(src + 2);\n+\t  swapbuff2[0] = *(src + 3);\n+\t  }\n+\telse\n+\t  {\n+\t  swapbuff2[0] = *src;\n+\t  swapbuff2[1] = *(src + 1);\n+\t  swapbuff2[2] = *(src + 2);\n+\t  swapbuff2[3] = *(src + 3);\n+\t  }\n+\n+\tlongbuff2 = *((uint32 *)swapbuff2);\n+\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\n+\tbuff1 = (buff3 & matchbits) << (src_bit);\n+\n+\t/* If we have a full buffer\'s worth, write it out */\n+\tif (ready_bits >= 32)\n+\t  {\n+\t  bytebuff1 = (buff2 >> 56);\n+\t  *dst++ = bytebuff1;\n+\t  bytebuff2 = (buff2 >> 48);\n+\t  *dst++ = bytebuff2;\n+\t  bytebuff3 = (buff2 >> 40);\n+\t  *dst++ = bytebuff3;\n+\t  bytebuff4 = (buff2 >> 32);\n+\t  *dst++ = bytebuff4;\n+\t  ready_bits -= 32;\n+                    \n+\t  /* shift in new bits */\n+\t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n+\t  strcpy (action, ""Flush"");\n+\t  }\n+\telse\n+\t  { /* add another bps bits to the buffer */\n+\t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n+\t  buff2 = (buff2 | (buff1 >> ready_bits));\n+\t  strcpy (action, ""Update"");\n+\t  }\n+\tready_bits += bps;\n+\n+\tif ((dumpfile != NULL) && (level == 3))\n+\t  { \n+\t  dump_info (dumpfile, format, """",\n+\t\t     ""Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\n+\t  dump_wide (dumpfile, format, ""Match bits "", matchbits);\n+\t  dump_data (dumpfile, format, ""Src   bits "", src, 8);\n+\t  dump_wide (dumpfile, format, ""Buff1 bits "", buff1);\n+\t  dump_wide (dumpfile, format, ""Buff2 bits "", buff2);\n+\t  dump_info (dumpfile, format, """", ""Ready bits:   %d, %s"", ready_bits, action); \n+\t  }\n+\t}\n+      }\n+    while (ready_bits > 0)\n+      {\n+      bytebuff1 = (buff2 >> 56);\n+      *dst++ = bytebuff1;\n+      buff2 = (buff2 << 8);\n+      ready_bits -= 8;\n+      }\n+\n+    if ((dumpfile != NULL) && (level == 3))\n+      {\n+      dump_info (dumpfile, format, """",\n+\t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t row + 1, col + 1, src_byte, src_bit, dst - out);\n+\n+      dump_long (dumpfile, format, ""Match bits "", matchbits);\n+      dump_data (dumpfile, format, ""Src   bits "", src, 4);\n+      dump_long (dumpfile, format, ""Buff1 bits "", buff1);\n+      dump_long (dumpfile, format, ""Buff2 bits "", buff2);\n+      dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);\n+      dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);\n+      dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits); \n+      }\n+\n+    if ((dumpfile != NULL) && (level == 2))\n+      {\n+      dump_info (dumpfile, format, ""combineSeparateSamples32bits"",""Output data"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n+      }\n+    }\n+  \n+  return (0);\n+  } /* end combineSeparateSamples32bits */\n+\n+static int \n+combineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n+                                 uint32 cols, uint32 rows, uint32 imagewidth,\n+                                 uint32 tw, uint16 spp, uint16 bps,\n+                                 FILE *dumpfile, int format, int level)\n+  {\n+  int i, bytes_per_sample;\n+  uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;\n+  unsigned char *src;\n+  unsigned char *dst;\n+  tsample_t s;\n+\n+  src = srcbuffs[0];\n+  dst = out;\n+  if ((src == NULL) || (dst == NULL))\n+    {\n+    TIFFError(""combineSeparateTileSamplesBytes"",""Invalid buffer address"");\n+    return (1);\n+    }\n+\n+  bytes_per_sample = (bps + 7) / 8; \n+  src_rowsize = ((bps * tw) + 7) / 8;\n+  dst_rowsize = imagewidth * bytes_per_sample * spp;\n+  for (row = 0; row < rows; row++)\n+    {\n+    if ((dumpfile != NULL) && (level == 2))\n+      {\n+      for (s = 0; s < spp; s++)\n         {\n-        bytebuff = (buff2 >> 8);\n-        *dst++ = bytebuff;\n-        ready_bits -= 8;\n-        /* shift in new bits */\n-        buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n-        strcpy (action, ""Flush"");\n+        dump_info (dumpfile, format, ""combineSeparateTileSamplesBytes"",""Input data, Sample %d"", s);\n+        dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));\n         }\n-      else\n-        { /* add another bps bits to the buffer */\n-        bytebuff = 0;\n-        buff2 = (buff2 | (buff1 >> ready_bits));\n-        strcpy (action, ""Update"");\n+      }\n+    dst = out + (row * dst_rowsize);\n+    src_offset = row * src_rowsize;\n+#ifdef DEVELMODE\n+    TIFFError("""",""Tile row %4d, Src offset %6d   Dst offset %6d"", \n+              row, src_offset, dst - out);\n+#endif\n+    for (col = 0; col < cols; col++)\n+      {\n+      col_offset = src_offset + (col * (bps / 8)); \n+      for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n+        {\n+        src = srcbuffs[s] + col_offset; \n+        for (i = 0; i < bytes_per_sample; i++)\n+          *(dst + i) = *(src + i);\n+        dst += bytes_per_sample;\n+        }   \n+      }\n+\n+    if ((dumpfile != NULL) && (level == 2))\n+      {\n+      dump_info (dumpfile, format, ""combineSeparateTileSamplesBytes"",""Output data, combined samples"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n+      }\n+    }\n+\n+  return (0);\n+  } /* end combineSeparateTileSamplesBytes */\n+\n+static int\n+combineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,\n+                                 uint32 rows, uint32 imagewidth, \n+                                 uint32 tw, uint16 spp, uint16 bps, \n+ \t                         FILE *dumpfile, int format, int level)\n+  {\n+  int    ready_bits = 0;\n+  uint32 src_rowsize, dst_rowsize, src_offset; \n+  uint32 bit_offset;\n+  uint32 row, col, src_byte = 0, src_bit = 0;\n+  uint8  maskbits = 0, matchbits = 0;\n+  uint8  buff1 = 0, buff2 = 0;\n+  tsample_t s;\n+  unsigned char *src = in[0];\n+  unsigned char *dst = out;\n+  char           action[32];\n+\n+  if ((src == NULL) || (dst == NULL))\n+    {\n+    TIFFError(""combineSeparateTileSamples8bits"",""Invalid input or output buffer"");\n+    return (1);\n+    }\n+\n+  src_rowsize = ((bps * tw) + 7) / 8;\n+  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n+  maskbits =  (uint8)-1 >> ( 8 - bps);\n+\n+  for (row = 0; row < rows; row++)\n+    {\n+    ready_bits = 0;\n+    buff1 = buff2 = 0;\n+    dst = out + (row * dst_rowsize);\n+    src_offset = row * src_rowsize;\n+    for (col = 0; col < cols; col++)\n+      {\n+      /* Compute src byte(s) and bits within byte(s) */\n+      bit_offset = col * bps;\n+      src_byte = bit_offset / 8;\n+      src_bit  = bit_offset % 8;\n+\n+      matchbits = maskbits << (8 - src_bit - bps); \n+      /* load up next sample from each plane */\n+      for (s = 0; s < spp; s++)\n+        {\n+\tsrc = in[s] + src_offset + src_byte;\n+        buff1 = ((*src) & matchbits) << (src_bit);\n+\n+        /* If we have a full buffer\'s worth, write it out */\n+        if (ready_bits >= 8)\n+          {\n+          *dst++ = buff2;\n+          buff2 = buff1;\n+          ready_bits -= 8;\n+          strcpy (action, ""Flush"");\n+          }\n+        else\n+          {\n+          buff2 = (buff2 | (buff1 >> ready_bits));\n+          strcpy (action, ""Update"");\n+          }\n+        ready_bits += bps;\n+ \n+        if ((dumpfile != NULL) && (level == 3))\n+          {\n+          dump_info (dumpfile, format, """",\n+                   ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n+          dump_byte (dumpfile, format, ""Match bits"", matchbits);\n+          dump_byte (dumpfile, format, ""Src   bits"", *src);\n+          dump_byte (dumpfile, format, ""Buff1 bits"", buff1);\n+          dump_byte (dumpfile, format, ""Buff2 bits"", buff2);\n+          dump_info (dumpfile, format, """",""%s"", action); \n+\t  }\n         }\n-      ready_bits += bps;\n+      }\n \n+    if (ready_bits > 0)\n+      {\n+      buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));\n+      *dst++ = buff1;\n       if ((dumpfile != NULL) && (level == 3))\n         {\n         dump_info (dumpfile, format, """",\n-\t    ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n-\t    row + 1, col + 1, s, src_byte, src_bit, dst - out);\n-\n-        dump_short (dumpfile, format, ""Match bits"", matchbits);\n-        dump_data  (dumpfile, format, ""Src   bits"", src, 2);\n-        dump_short (dumpfile, format, ""Buff1 bits"", buff1);\n-        dump_short (dumpfile, format, ""Buff2 bits"", buff2);\n-        dump_byte  (dumpfile, format, ""Write byte"", bytebuff);\n-        dump_info  (dumpfile, format, """",""Ready bits:  %d, %s"", ready_bits, action); \n+\t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t         row + 1, col + 1, src_byte, src_bit, dst - out);\n+                 dump_byte (dumpfile, format, ""Final bits"", buff1);\n         }\n       }\n-    }\n-  /* catch any trailing bits at the end of the line */\n-  if (ready_bits > 0)\n-    {\n-    bytebuff = (buff2 >> 8);\n-    *dst++ = bytebuff;\n-    if ((dumpfile != NULL) && (level == 3))\n+\n+    if ((dumpfile != NULL) && (level >= 2))\n+      {\n+      dump_info (dumpfile, format, ""combineSeparateTileSamples8bits"",""Output data"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n+      }\n+    }\n+\n+  return (0);\n+  } /* end combineSeparateTileSamples8bits */\n+\n+static int\n+combineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols,\n+                                  uint32 rows, uint32 imagewidth, \n+                                  uint32 tw, uint16 spp, uint16 bps, \n+ \t                          FILE *dumpfile, int format, int level)\n+  {\n+  int    ready_bits = 0;\n+  uint32 src_rowsize, dst_rowsize; \n+  uint32 bit_offset, src_offset;\n+  uint32 row, col, src_byte = 0, src_bit = 0;\n+  uint16 maskbits = 0, matchbits = 0;\n+  uint16 buff1 = 0, buff2 = 0;\n+  uint8  bytebuff = 0;\n+  tsample_t s;\n+  unsigned char *src = in[0];\n+  unsigned char *dst = out;\n+  unsigned char  swapbuff[2];\n+  char           action[8];\n+\n+  if ((src == NULL) || (dst == NULL))\n+    {\n+    TIFFError(""combineSeparateTileSamples16bits"",""Invalid input or output buffer"");\n+    return (1);\n+    }\n+\n+  src_rowsize = ((bps * tw) + 7) / 8;\n+  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n+  maskbits = (uint16)-1 >> (16 - bps);\n+\n+  for (row = 0; row < rows; row++)\n+    {\n+    ready_bits = 0;\n+    buff1 = buff2 = 0;\n+    dst = out + (row * dst_rowsize);\n+    src_offset = row * src_rowsize;\n+    for (col = 0; col < cols; col++)\n+      {\n+      /* Compute src byte(s) and bits within byte(s) */\n+      bit_offset = col * bps;\n+      src_byte = bit_offset / 8;\n+      src_bit  = bit_offset % 8;\n+\n+      matchbits = maskbits << (16 - src_bit - bps); \n+      for (s = 0; s < spp; s++)\n+        {\n+\tsrc = in[s] + src_offset + src_byte;\n+        if (little_endian)\n+          {\n+          swapbuff[1] = *src;\n+          swapbuff[0] = *(src + 1);\n+          }\n+        else\n+          {\n+          swapbuff[0] = *src;\n+          swapbuff[1] = *(src + 1);\n+\t  }\n+\n+\tbuff1 = *((uint16 *)swapbuff);\n+\tbuff1 = (buff1 & matchbits) << (src_bit);\n+\n+\t/* If we have a full buffer\'s worth, write it out */\n+\tif (ready_bits >= 8)\n+\t  {\n+\t    bytebuff = (buff2 >> 8);\n+\t    *dst++ = bytebuff;\n+\t    ready_bits -= 8;\n+\t    /* shift in new bits */\n+\t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));\n+\t    strcpy (action, ""Flush"");\n+\t  }\n+\telse\n+\t  { /* add another bps bits to the buffer */\n+\t    bytebuff = 0;\n+\t    buff2 = (buff2 | (buff1 >> ready_bits));\n+\t    strcpy (action, ""Update"");\n+\t  }\n+\tready_bits += bps;\n+\n+\tif ((dumpfile != NULL) && (level == 3))\n+\t  {\n+\t  dump_info (dumpfile, format, """",\n+\t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n+\n+\t  dump_short (dumpfile, format, ""Match bits"", matchbits);\n+\t  dump_data  (dumpfile, format, ""Src   bits"", src, 2);\n+\t  dump_short (dumpfile, format, ""Buff1 bits"", buff1);\n+\t  dump_short (dumpfile, format, ""Buff2 bits"", buff2);\n+\t  dump_byte  (dumpfile, format, ""Write byte"", bytebuff);\n+\t  dump_info  (dumpfile, format, """",""Ready bits:  %d, %s"", ready_bits, action); \n+\t  }\n+\t}\n+      }\n+\n+    /* catch any trailing bits at the end of the line */\n+    if (ready_bits > 0)\n+      {\n+      bytebuff = (buff2 >> 8);\n+      *dst++ = bytebuff;\n+      if ((dumpfile != NULL) && (level == 3))\n+\t{\n+\tdump_info (dumpfile, format, """",\n+\t\t       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t       row + 1, col + 1, src_byte, src_bit, dst - out);\n+\tdump_byte (dumpfile, format, ""Final bits"", bytebuff);\n+\t}\n+      }\n+\n+    if ((dumpfile != NULL) && (level == 2))\n       {\n-      dump_info (dumpfile, format, """",\n-\t  ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n-\t  row + 1, col + 1, src_byte, src_bit, dst - out);\n-      dump_byte (dumpfile, format, ""Final bits"", bytebuff);\n+      dump_info (dumpfile, format, ""combineSeparateTileSamples16bits"",""Output data"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n       }\n     }\n \n-  if ((dumpfile != NULL) && (level == 2))\n-    {\n-    dump_info (dumpfile, format, ""combineSeparateSamples16bits"",""Output data"");\n-    dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n-    }\n-  \n   return (0);\n-  } /* end combineSeparateSamples16bits */\n+  } /* end combineSeparateTileSamples16bits */\n \n static int\n-combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 row,\n-                              uint32 cols, uint16 spp, uint16 bps, \n-\t                      FILE *dumpfile, int format, int level)\n+combineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols,\n+                                  uint32 rows, uint32 imagewidth, \n+                                  uint32 tw, uint16 spp, uint16 bps, \n+ \t                          FILE *dumpfile, int format, int level)\n   {\n-  int    ready_bits = 0, bytes_per_sample = 0;\n-  uint32 dst_rowsize; \n-  uint32 bit_offset;\n-  uint32 col, src_byte = 0, src_bit = 0;\n+  int    ready_bits = 0;\n+  uint32 src_rowsize, dst_rowsize; \n+  uint32 bit_offset, src_offset;\n+  uint32 row, col, src_byte = 0, src_bit = 0;\n   uint32 maskbits = 0, matchbits = 0;\n   uint32 buff1 = 0, buff2 = 0;\n   uint8  bytebuff1 = 0, bytebuff2 = 0;\n@@ -3617,127 +4553,132 @@ combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 row,\n \n   if ((src == NULL) || (dst == NULL))\n     {\n-    TIFFError(""combineSeparateSamples24bits"",""Invalid input or output buffer"");\n+    TIFFError(""combineSeparateTileSamples24bits"",""Invalid input or output buffer"");\n     return (1);\n     }\n \n-  bytes_per_sample = (bps + 7) / 8; \n-  dst_rowsize = ((bps * cols) + 7) / 8;\n+  src_rowsize = ((bps * tw) + 7) / 8;\n+  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n   maskbits =  (uint32)-1 >> ( 32 - bps);\n \n-  ready_bits = 0;\n-  buff1 = buff2 = 0;\n-  for (col = 0; col < cols; col++)\n+  for (row = 0; row < rows; row++)\n     {\n-    /* Compute src byte(s) and bits within byte(s) */\n-    bit_offset = col * bps;\n-    src_byte = bit_offset / 8;\n-    src_bit  = bit_offset % 8;\n-\n-    matchbits = maskbits << (32 - src_bit - bps); \n-    for (s = 0; s < spp; s++)\n+    ready_bits = 0;\n+    buff1 = buff2 = 0;\n+    dst = out + (row * dst_rowsize);\n+    src_offset = row * src_rowsize;\n+    for (col = 0; col < cols; col++)\n       {\n-      src = in[s] + src_byte;\n-      if (little_endian)\n-        {\n-        swapbuff[3] = *src;\n-        swapbuff[2] = *(src + 1);\n-        swapbuff[1] = *(src + 2);\n-        swapbuff[0] = *(src + 3);\n-        }\n-      else\n-        {\n-        swapbuff[0] = *src;\n-        swapbuff[1] = *(src + 1);\n-        swapbuff[2] = *(src + 2);\n-        swapbuff[3] = *(src + 3);\n-\t}\n-\n-      buff1 = *((uint32 *)swapbuff);\n-      buff1 = (buff1 & matchbits) << (src_bit);\n+      /* Compute src byte(s) and bits within byte(s) */\n+      bit_offset = col * bps;\n+      src_byte = bit_offset / 8;\n+      src_bit  = bit_offset % 8;\n \n-      /* If we have a full buffer\'s worth, write it out */\n-      if (ready_bits >= 16)\n+      matchbits = maskbits << (32 - src_bit - bps); \n+      for (s = 0; s < spp; s++)\n         {\n-        bytebuff1 = (buff2 >> 24);\n-        *dst++ = bytebuff1;\n-        bytebuff2 = (buff2 >> 16);\n-        *dst++ = bytebuff2;\n-        ready_bits -= 16;\n-\n-        /* shift in new bits */\n-        buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n-        strcpy (action, ""Flush"");\n-        }\n-      else\n-        { /* add another bps bits to the buffer */\n-        bytebuff1 = bytebuff2 = 0;\n-        buff2 = (buff2 | (buff1 >> ready_bits));\n-        strcpy (action, ""Update"");\n-        }\n-      ready_bits += bps;\n+\tsrc = in[s] + src_offset + src_byte;\n+        if (little_endian)\n+          {\n+          swapbuff[3] = *src;\n+          swapbuff[2] = *(src + 1);\n+          swapbuff[1] = *(src + 2);\n+          swapbuff[0] = *(src + 3);\n+          }\n+        else\n+          {\n+          swapbuff[0] = *src;\n+          swapbuff[1] = *(src + 1);\n+          swapbuff[2] = *(src + 2);\n+          swapbuff[3] = *(src + 3);\n+\t  }\n \n-      if ((dumpfile != NULL) && (level == 3))\n-        {\n-        dump_info (dumpfile, format, """",\n-\t        ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n-\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n-        dump_long (dumpfile, format, ""Match bits "", matchbits);\n-        dump_data (dumpfile, format, ""Src   bits "", src, 4);\n-        dump_long (dumpfile, format, ""Buff1 bits "", buff1);\n-        dump_long (dumpfile, format, ""Buff2 bits "", buff2);\n-        dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);\n-        dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);\n-        dump_info (dumpfile, format, """",""Ready bits:   %d, %s"", ready_bits, action); \n-        }\n+\tbuff1 = *((uint32 *)swapbuff);\n+\tbuff1 = (buff1 & matchbits) << (src_bit);\n+\n+\t/* If we have a full buffer\'s worth, write it out */\n+\tif (ready_bits >= 16)\n+\t  {\n+\t    bytebuff1 = (buff2 >> 24);\n+\t    *dst++ = bytebuff1;\n+\t    bytebuff2 = (buff2 >> 16);\n+\t    *dst++ = bytebuff2;\n+\t    ready_bits -= 16;\n+\n+\t    /* shift in new bits */\n+\t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));\n+\t    strcpy (action, ""Flush"");\n+\t  }\n+\telse\n+\t  { /* add another bps bits to the buffer */\n+\t    bytebuff1 = bytebuff2 = 0;\n+\t    buff2 = (buff2 | (buff1 >> ready_bits));\n+\t    strcpy (action, ""Update"");\n+\t  }\n+\tready_bits += bps;\n+\n+\tif ((dumpfile != NULL) && (level == 3))\n+\t  {\n+\t  dump_info (dumpfile, format, """",\n+\t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);\n+\t  dump_long (dumpfile, format, ""Match bits "", matchbits);\n+\t  dump_data (dumpfile, format, ""Src   bits "", src, 4);\n+\t  dump_long (dumpfile, format, ""Buff1 bits "", buff1);\n+\t  dump_long (dumpfile, format, ""Buff2 bits "", buff2);\n+\t  dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);\n+\t  dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);\n+\t  dump_info (dumpfile, format, """",""Ready bits:   %d, %s"", ready_bits, action); \n+\t  }\n+\t}\n       }\n-    }\n \n-  /* catch any trailing bits at the end of the line */\n-  while (ready_bits > 0)\n-    {\n-    bytebuff1 = (buff2 >> 24);\n-    *dst++ = bytebuff1;\n+    /* catch any trailing bits at the end of the line */\n+    while (ready_bits > 0)\n+      {\n+\tbytebuff1 = (buff2 >> 24);\n+\t*dst++ = bytebuff1;\n \n-    buff2 = (buff2 << 8);\n-    bytebuff2 = bytebuff1;\n-    ready_bits -= 8;\n-    }\n+\tbuff2 = (buff2 << 8);\n+\tbytebuff2 = bytebuff1;\n+\tready_bits -= 8;\n+      }\n  \n-  if ((dumpfile != NULL) && (level == 3))\n-    {\n-    dump_info (dumpfile, format, """",\n-      ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n-      row + 1, col + 1, src_byte, src_bit, dst - out);\n-\n-    dump_long (dumpfile, format, ""Match bits "", matchbits);\n-    dump_data (dumpfile, format, ""Src   bits "", src, 4);\n-    dump_long (dumpfile, format, ""Buff1 bits "", buff1);\n-    dump_long (dumpfile, format, ""Buff2 bits "", buff2);\n-    dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);\n-    dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);\n-    dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits); \n-    }\n+    if ((dumpfile != NULL) && (level == 3))\n+      {\n+      dump_info (dumpfile, format, """",\n+\t\t   ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t   row + 1, col + 1, src_byte, src_bit, dst - out);\n+\n+      dump_long (dumpfile, format, ""Match bits "", matchbits);\n+      dump_data (dumpfile, format, ""Src   bits "", src, 4);\n+      dump_long (dumpfile, format, ""Buff1 bits "", buff1);\n+      dump_long (dumpfile, format, ""Buff2 bits "", buff2);\n+      dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);\n+      dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);\n+      dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits); \n+      }\n \n-  if ((dumpfile != NULL) && (level == 2))\n-    {\n-    dump_info (dumpfile, format, ""combineSeparateSamples24bits"",""Output data"");\n-    dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n+    if ((dumpfile != NULL) && (level == 2))\n+      {\n+      dump_info (dumpfile, format, ""combineSeparateTileSamples24bits"",""Output data"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));\n+      }\n     }\n   \n   return (0);\n-  } /* end combineSeparateSamples24bits */\n+  } /* end combineSeparateTileSamples24bits */\n \n static int\n-combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 row,\n-                              uint32 cols, uint16 spp, uint16 bps, \n-\t                      FILE *dumpfile, int format, int level)\n+combineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,\n+                                  uint32 rows, uint32 imagewidth, \n+                                  uint32 tw, uint16 spp, uint16 bps, \n+ \t                          FILE *dumpfile, int format, int level)\n   {\n-  int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;\n-  uint32 dst_rowsize; \n-  uint32 bit_offset;\n+  int    ready_bits = 0, shift_width = 0;\n+  uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;\n   uint32 src_byte = 0, src_bit = 0;\n-  uint32 col;\n+  uint32 row, col;\n   uint32 longbuff1 = 0, longbuff2 = 0;\n   uint64 maskbits = 0, matchbits = 0;\n   uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n@@ -3751,213 +4692,170 @@ combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 row,\n \n   if ((src == NULL) || (dst == NULL))\n     {\n-    TIFFError(""combineSeparateSamples32bits"",""Invalid input or output buffer"");\n+    TIFFError(""combineSeparateTileSamples32bits"",""Invalid input or output buffer"");\n     return (1);\n     }\n \n-  bytes_per_sample = (bps + 7) / 8; \n-  dst_rowsize = ((bps * cols) + 7) / 8;\n+  src_rowsize = ((bps * tw) + 7) / 8;\n+  dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;\n   maskbits =  (uint64)-1 >> ( 64 - bps);\n   shift_width = ((bps + 7) / 8) + 1; \n \n-  ready_bits = 0;\n-  buff1 = buff2 = 0;\n-  for (col = 0; col < cols; col++)\n+  for (row = 0; row < rows; row++)\n     {\n-    /* Compute src byte(s) and bits within byte(s) */\n-    bit_offset = col * bps;\n-    src_byte = bit_offset / 8;\n-    src_bit  = bit_offset % 8;\n-\n-    matchbits = maskbits << (64 - src_bit - bps); \n-    for (s = 0; s < spp; s++)\n+    ready_bits = 0;\n+    buff1 = buff2 = 0;\n+    dst = out + (row * dst_rowsize);\n+    src_offset = row * src_rowsize;\n+    for (col = 0; col < cols; col++)\n       {\n-      src = in[s] + src_byte;\n-      if (little_endian)\n-        {\n-        swapbuff1[3] = *src;\n-        swapbuff1[2] = *(src + 1);\n-        swapbuff1[1] = *(src + 2);\n-        swapbuff1[0] = *(src + 3);\n-        }\n-      else\n-        {\n-        swapbuff1[0] = *src;\n-        swapbuff1[1] = *(src + 1);\n-        swapbuff1[2] = *(src + 2);\n-        swapbuff1[3] = *(src + 3);\n-\t}\n-      longbuff1 = *((uint32 *)swapbuff1);                  \n-\n-      memset (swapbuff2, \'\\0\', sizeof(swapbuff2));\n-      if (little_endian)\n-        {\n-        swapbuff2[3] = *src;\n-        swapbuff2[2] = *(src + 1);\n-        swapbuff2[1] = *(src + 2);\n-        swapbuff2[0] = *(src + 3);\n-        }\n-      else\n-        {\n-        swapbuff2[0] = *src;\n-        swapbuff2[1] = *(src + 1);\n-        swapbuff2[2] = *(src + 2);\n-        swapbuff2[3] = *(src + 3);\n-\t}\n+      /* Compute src byte(s) and bits within byte(s) */\n+      bit_offset = col * bps;\n+      src_byte = bit_offset / 8;\n+      src_bit  = bit_offset % 8;\n \n-      longbuff2 = *((uint32 *)swapbuff2);\n-      buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n-      buff1 = (buff3 & matchbits) << (src_bit);\n+      matchbits = maskbits << (64 - src_bit - bps); \n+      for (s = 0; s < spp; s++)\n+\t{\n+\tsrc = in[s] + src_offset + src_byte;\n+\tif (little_endian)\n+\t  {\n+\t  swapbuff1[3] = *src;\n+\t  swapbuff1[2] = *(src + 1);\n+\t  swapbuff1[1] = *(src + 2);\n+\t  swapbuff1[0] = *(src + 3);\n+\t  }\n+\telse\n+\t  {\n+\t  swapbuff1[0] = *src;\n+\t  swapbuff1[1] = *(src + 1);\n+\t  swapbuff1[2] = *(src + 2);\n+\t  swapbuff1[3] = *(src + 3);\n+\t  }\n+        longbuff1 = *((uint32 *)swapbuff1);                  \n+\n+\tmemset (swapbuff2, \'\\0\', sizeof(swapbuff2));\n+\tif (little_endian)\n+\t  {\n+\t  swapbuff2[3] = *src;\n+\t  swapbuff2[2] = *(src + 1);\n+\t  swapbuff2[1] = *(src + 2);\n+\t  swapbuff2[0] = *(src + 3);\n+\t  }\n+\telse\n+\t  {\n+\t  swapbuff2[0] = *src;\n+\t  swapbuff2[1] = *(src + 1);\n+\t  swapbuff2[2] = *(src + 2);\n+\t  swapbuff2[3] = *(src + 3);\n+\t  }\n \n-      /* If we have a full buffer\'s worth, write it out */\n-      if (ready_bits >= 32)\n-        {\n-        bytebuff1 = (buff2 >> 56);\n-        *dst++ = bytebuff1;\n-        bytebuff2 = (buff2 >> 48);\n-        *dst++ = bytebuff2;\n-        bytebuff3 = (buff2 >> 40);\n-        *dst++ = bytebuff3;\n-        bytebuff4 = (buff2 >> 32);\n-        *dst++ = bytebuff4;\n-        ready_bits -= 32;\n+\tlongbuff2 = *((uint32 *)swapbuff2);\n+\tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;\n+\tbuff1 = (buff3 & matchbits) << (src_bit);\n+\n+\t/* If we have a full buffer\'s worth, write it out */\n+\tif (ready_bits >= 32)\n+\t  {\n+\t  bytebuff1 = (buff2 >> 56);\n+\t  *dst++ = bytebuff1;\n+\t  bytebuff2 = (buff2 >> 48);\n+\t  *dst++ = bytebuff2;\n+\t  bytebuff3 = (buff2 >> 40);\n+\t  *dst++ = bytebuff3;\n+\t  bytebuff4 = (buff2 >> 32);\n+\t  *dst++ = bytebuff4;\n+\t  ready_bits -= 32;\n                     \n-        /* shift in new bits */\n-        buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n-        strcpy (action, ""Flush"");\n-        }\n-      else\n-        { /* add another bps bits to the buffer */\n-        bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n-        buff2 = (buff2 | (buff1 >> ready_bits));\n-        strcpy (action, ""Update"");\n-        }\n-      ready_bits += bps;\n-\n-      if ((dumpfile != NULL) && (level == 3))\n-        { \n-        dump_info (dumpfile, format, """",\n-\t    ""Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n-\t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);\n-        dump_wide (dumpfile, format, ""Match bits "", matchbits);\n-        dump_data (dumpfile, format, ""Src   bits "", src, 8);\n-        dump_wide (dumpfile, format, ""Buff1 bits "", buff1);\n-        dump_wide (dumpfile, format, ""Buff2 bits "", buff2);\n-        dump_info (dumpfile, format, """", ""Ready bits:   %d, %s"", ready_bits, action); \n-        }\n+\t  /* shift in new bits */\n+\t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));\n+\t  strcpy (action, ""Flush"");\n+\t  }\n+\telse\n+\t  { /* add another bps bits to the buffer */\n+\t  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;\n+\t  buff2 = (buff2 | (buff1 >> ready_bits));\n+\t  strcpy (action, ""Update"");\n+\t  }\n+\tready_bits += bps;\n+\n+\tif ((dumpfile != NULL) && (level == 3))\n+\t  { \n+\t  dump_info (dumpfile, format, """",\n+\t\t     ""Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);\n+\t  dump_wide (dumpfile, format, ""Match bits "", matchbits);\n+\t  dump_data (dumpfile, format, ""Src   bits "", src, 8);\n+\t  dump_wide (dumpfile, format, ""Buff1 bits "", buff1);\n+\t  dump_wide (dumpfile, format, ""Buff2 bits "", buff2);\n+\t  dump_info (dumpfile, format, """", ""Ready bits:   %d, %s"", ready_bits, action); \n+\t  }\n+\t}\n       }\n-    }\n-  while (ready_bits > 0)\n-    {\n-    bytebuff1 = (buff2 >> 56);\n-    *dst++ = bytebuff1;\n-    buff2 = (buff2 << 8);\n-    ready_bits -= 8;\n-    }\n-\n-  if ((dumpfile != NULL) && (level == 3))\n-    {\n-    dump_info (dumpfile, format, """",\n-      ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n-      row + 1, col + 1, src_byte, src_bit, dst - out);\n-\n-    dump_long (dumpfile, format, ""Match bits "", matchbits);\n-    dump_data (dumpfile, format, ""Src   bits "", src, 4);\n-    dump_long (dumpfile, format, ""Buff1 bits "", buff1);\n-    dump_long (dumpfile, format, ""Buff2 bits "", buff2);\n-    dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);\n-    dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);\n-    dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits); \n-    }\n-\n-  if ((dumpfile != NULL) && (level == 2))\n-    {\n-    dump_info (dumpfile, format, ""combineSeparateSamples32bits"",""Output data"");\n-    dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n-    }\n-  \n-  return (0);\n-  } /* end combineSeparateSamples32bits */\n-\n-static int \n-combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,\n-                             uint32 row, uint32 width, uint16 spp, uint16 bps, \n-                             FILE *dumpfile, int format, int level)\n-  {\n-  int i, bytes_per_sample, bytes_per_pixel, dst_rowsize, shift_width;\n-  uint32 col, col_offset;\n-  unsigned char *src;\n-  unsigned char *dst;\n-  tsample_t s;\n-\n-  src = srcbuffs[0];\n-  dst = out;\n-  if ((src == NULL) || (dst == NULL))\n-    {\n-    TIFFError(""combineSeparateSamplesBytes"",""Invalid buffer address"");\n-    return (1);\n-    }\n-\n-  bytes_per_sample = (bps + 7) / 8; \n-  bytes_per_pixel  = ((bps * spp) + 7) / 8;\n-  if (bytes_per_pixel < (bytes_per_sample + 1))\n-    shift_width = bytes_per_sample;\n-  else\n-    shift_width = bytes_per_pixel;\n-\n-  if ((dumpfile != NULL) && (level == 2))\n-    {\n-    for (s = 0; s < spp; s++)\n+    while (ready_bits > 0)\n       {\n-      dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Input data, Sample %d"", s);\n-      dump_buffer(dumpfile, format, 1, width, row, srcbuffs[s]);\n+      bytebuff1 = (buff2 >> 56);\n+      *dst++ = bytebuff1;\n+      buff2 = (buff2 << 8);\n+      ready_bits -= 8;\n       }\n-    }\n \n-  dst_rowsize = ((bps * spp * width) + 7) / 8;\n-  for (col = 0; col < width; col++)\n-    {\n-    col_offset = col * (bps / 8); \n-    for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n+    if ((dumpfile != NULL) && (level == 3))\n       {\n-      src = srcbuffs[s] + col_offset; \n-      for (i = 0; i < bytes_per_sample; i++)\n-        *(dst + i) = *(src + i);\n-      src += bytes_per_sample;\n-      dst += bytes_per_sample;\n-      }   \n-    }\n+      dump_info (dumpfile, format, """",\n+\t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",\n+\t\t row + 1, col + 1, src_byte, src_bit, dst - out);\n+\n+      dump_long (dumpfile, format, ""Match bits "", matchbits);\n+      dump_data (dumpfile, format, ""Src   bits "", src, 4);\n+      dump_long (dumpfile, format, ""Buff1 bits "", buff1);\n+      dump_long (dumpfile, format, ""Buff2 bits "", buff2);\n+      dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);\n+      dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);\n+      dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits); \n+      }\n \n-  if ((dumpfile != NULL) && (level == 2))\n-    {\n-    dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Output data, combined samples"");\n-    dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n+    if ((dumpfile != NULL) && (level == 2))\n+      {\n+      dump_info (dumpfile, format, ""combineSeparateTileSamples32bits"",""Output data"");\n+      dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);\n+      }\n     }\n-\n+  \n   return (0);\n-  } /* end combineSeparateSamplesBytes */\n+  } /* end combineSeparateTileSamples32bits */\n+\n \n static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length, \n                                          uint32 width, uint16 spp,\n                                          struct dump_opts *dump)\n   {\n-  int i, bytes_per_sample, bytes_per_pixel, shift_width;\n-  uint16 bps;\n-  uint32 row, src_rowsize, dst_rowsize;\n+  int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;\n+  int32  bytes_read = 0;\n+  uint16 bps, nstrips, planar, strips_per_sample;\n+  uint32 src_rowsize, dst_rowsize, rows_processed, rps;\n+  uint32 rows_this_strip = 0;\n   tsample_t s;\n+  tstrip_t  strip;\n   tsize_t scanlinesize = TIFFScanlineSize(in);\n+  tsize_t stripsize    = TIFFStripSize(in);\n   unsigned char *srcbuffs[MAX_SAMPLES];\n   unsigned char *buff = NULL;\n   unsigned char *dst = NULL;\n \n-  (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n-\n   if (obuf == NULL)\n     {\n     TIFFError(""readSeparateStripsIntoBuffer"",""Invalid buffer argument"");\n     return (0);\n     }\n \n+  memset (srcbuffs, \'\\0\', sizeof(srcbuffs));\n+  TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n+  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n+  TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);\n+  if (rps > length)\n+    rps = length;\n+\n   bytes_per_sample = (bps + 7) / 8; \n   bytes_per_pixel  = ((bps * spp) + 7) / 8;\n   if (bytes_per_pixel < (bytes_per_sample + 1))\n@@ -3979,15 +4877,22 @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,\n \t\tbps, spp, shift_width);\n     }\n \n-  /* allocate scanline buffers for each sample */\n+  /* Libtiff seems to assume/require that data for separate planes are \n+   * written one complete plane after another and not interleaved in any way.\n+   * Multiple scanlines and possibly strips of the same plane must be \n+   * written before data for any other plane.\n+   */\n+  nstrips = TIFFNumberOfStrips(in);\n+  strips_per_sample = nstrips /spp;\n+\n   for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n     {\n     srcbuffs[s] = NULL;\n-    buff = _TIFFmalloc(src_rowsize);\n+    buff = _TIFFmalloc(stripsize);\n     if (!buff)\n       {\n       TIFFError (""readSeparateStripsIntoBuffer"", \n-                 ""Unable to allocate read buffer for sample %d"", s);\n+                 ""Unable to allocate strip read buffer for sample %d"", s);\n       for (i = 0; i < s; i++)\n         _TIFFfree (srcbuffs[i]);\n       return 0;\n@@ -3995,89 +4900,95 @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,\n     srcbuffs[s] = buff;\n     }\n \n-  /* read and process one scanline from each sample */\n-  for (row = 0; row < length; row++)\n+  rows_processed = 0;\n+  for (j = 0; (j < strips_per_sample) && (result == 1); j++)\n     {\n     for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)\n       {\n       buff = srcbuffs[s];\n-      /* read one scanline in the current sample color */\n-      if (TIFFReadScanline(in, buff, row, s) < 0\n-\t    && !ignore)\n+      strip = (s * strips_per_sample) + j; \n+      bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);\n+      rows_this_strip = bytes_read / src_rowsize;\n+      if (bytes_read < 0 && !ignore)\n         {\n         TIFFError(TIFFFileName(in),\n-\t         ""Error, can\'t read scanline %lu for sample %d"",\n-\t\t  (unsigned long) row, s + 1);\n-        for (i = 0; i < s; i++)\n-          _TIFFfree (srcbuffs[i]);\n-        return (0);\n+\t          ""Error, can\'t read strip %lu for sample %d"",\n+         \t   (unsigned long) strip, s + 1);\n+        result = 0;\n+        break;\n         }\n+#ifdef DEVELMODE\n+      TIFFError("""", ""Strip %2d, read %5d bytes for %4d scanlines, shift width %d"", \n+\t\tstrip, bytes_read, rows_this_strip, shift_width);\n+#endif\n       }\n \n-    /* combine the samples in each scanline */\n-    dst = obuf + (row * dst_rowsize);\n+    if (rps > rows_this_strip)\n+      rps = rows_this_strip;\n+    dst = obuf + (dst_rowsize * rows_processed);\n     if ((bps % 8) == 0)\n       {\n-      if (combineSeparateSamplesBytes (srcbuffs, dst, row, width,\n-                                      spp, bps, dump->infile,\n-                                      dump->format, dump->level))\n+      if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,\n+                                       spp, bps, dump->infile, \n+                                       dump->format, dump->level))\n         {\n-        for (i = 0; i < spp; i++)\n-         _TIFFfree (srcbuffs[i]);\n-\treturn (0);\n+        result = 0;\n+        break;\n \t}\n       }\n     else\n       {\n       switch (shift_width)\n         {\n-        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, row, width,\n-                                                spp, bps, dump->infile,\n-                                                dump->format, dump->level))\n-\t          {\n-                  for (i = 0; i < spp; i++)\n-                    _TIFFfree (srcbuffs[i]);\n-\t          return (0);\n-\t\t  }\n-\t\tbreak;\n-        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, row, width,\n+        case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,\n                                                  spp, bps, dump->infile,\n                                                  dump->format, dump->level))\n \t          {\n-                  for (i = 0; i < spp; i++)\n-                    _TIFFfree (srcbuffs[i]);\n-\t          return (0);\n-\t\t  }\n+                  result = 0;\n+                  break;\n+      \t          }\n \t        break;\n-        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, row, width,\n-                                                 spp, bps, dump->infile,\n-                                                 dump->format, dump->level))\n+        case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,\n+                                                  spp, bps, dump->infile,\n+                                                  dump->format, dump->level))\n \t          {\n-                  for (i = 0; i < spp; i++)\n-                    _TIFFfree (srcbuffs[i]);\n-\t          return (0);\n+                  result = 0;\n+                  break;\n \t\t  }\n-\n+\t        break;\n+        case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,\n+                                                  spp, bps, dump->infile,\n+                                                  dump->format, dump->level))\n+\t          {\n+                  result = 0;\n+                  break;\n+       \t          }\n                 break;\n         case 4: \n         case 5:\n         case 6:\n         case 7:\n-        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, row, width,\n-                                                 spp, bps, dump->infile,\n-                                                 dump->format, dump->level))\n+        case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,\n+                                                  spp, bps, dump->infile,\n+                                                  dump->format, dump->level))\n \t          {\n-                  for (i = 0; i < spp; i++)\n-                    _TIFFfree (srcbuffs[i]);\n-\t          return (0);\n+                  result = 0;\n+                  break;\n \t\t  }\n-\t\tbreak;\n+\t        break;\n         default: TIFFError (""readSeparateStripsIntoBuffer"", ""Unsupported bit depth: %d"", bps);\n-                  for (i = 0; i < spp; i++)\n-                    _TIFFfree (srcbuffs[i]);\n-\t          return (0);\n-\t}\n+                  result = 0;\n+                  break;\n+        }\n       }\n+ \n+    if ((rows_processed + rps) > length)\n+      {\n+      rows_processed = length;\n+      rps = length - rows_processed;\n+      }\n+    else\n+      rows_processed += rps;\n     }\n \n   /* free any buffers allocated for each plane or scanline and \n@@ -4090,7 +5001,7 @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,\n       _TIFFfree(buff);\n     }\n \n-  return (1);\n+  return (result);\n   } /* end readSeparateStripsIntoBuffer */\n \n static int\n@@ -4248,7 +5159,8 @@ computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,\n     }\n   else\n     {\n-    if (((image->xres == 0) || (image->yres == 0)) &&\n+    if (((image->xres == 0) || (image->yres == 0)) && \n+         (crop->res_unit != RESUNIT_NONE) &&\n \t((crop->crop_mode & CROP_REGIONS) || (crop->crop_mode & CROP_MARGINS) ||\n  \t (crop->crop_mode & CROP_LENGTH)  || (crop->crop_mode & CROP_WIDTH)))\n       {\n@@ -4326,10 +5238,6 @@ computeInputPixelOffsets(struct crop_mask *crop, struct image_data *image,\n       buffsize = (uint32)\n           (((zwidth * image->bps * image->spp + 7 ) / 8) * (zlength + 1));\n \n-      /*\n-      buffsize = (uint32)\n-          (((zwidth * image->bps + 7 ) / 8)  * image->spp * (zlength + 1));\n-      */\n       crop->regionlist[i].buffsize = buffsize;\n       crop->bufftotal += buffsize;\n       if (crop->img_mode == COMPOSITE_IMAGES)\n@@ -4945,13 +5853,17 @@ computeOutputPixelOffsets (struct crop_mask *crop, struct image_data *image,\n   } /* end computeOutputPixelOffsets */\n \n static int\n-loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned char **read_ptr)\n+loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)\n   {\n   uint32   i;\n-  float    xres=0.0, yres=0.0;\n-  uint16   nstrips, ntiles, planar, bps, spp, res_unit, photometric, orientation;\n-  uint32   width, length, rowsperstrip;\n-  uint32   stsize, tlsize, buffsize, scanlinesize;\n+  float    xres = 0.0, yres = 0.0;\n+  uint16   nstrips = 0, ntiles = 0, planar = 0;\n+  uint16   bps = 0, spp = 0, res_unit = 0;\n+  uint16   photometric = 0, orientation = 0, input_compression = 0;\n+  uint32   width = 0, length = 0;\n+  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;\n+  uint32   tw = 0, tl = 0;       /* Tile width and length */\n+  uint32   tile_rowsize = 0;\n   unsigned char *read_buff = NULL;\n   unsigned char *new_buff  = NULL;\n   int      readunit = 0;\n@@ -4961,12 +5873,18 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned\n   TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);\n   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);\n   TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n-  TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);\n-  TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width);\n-  TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length);\n-  TIFFGetField(in, TIFFTAG_XRESOLUTION, &xres);\n-  TIFFGetField(in, TIFFTAG_YRESOLUTION, &yres);\n-  TIFFGetField(in, TIFFTAG_RESOLUTIONUNIT, &res_unit);\n+  if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &photometric))\n+    TIFFError(""loadImage"",""Image lacks Photometric interpreation tag"");\n+  if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))\n+    TIFFError(""loadimage"",""Image lacks image width tag"");\n+  if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))\n+    TIFFError(""loadimage"",""Image lacks image length tag"");\n+  TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);\n+  TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);\n+  if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))\n+    res_unit = RESUNIT_INCH;\n+  if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))\n+    input_compression = COMPRESSION_NONE;\n   scanlinesize = TIFFScanlineSize(in);\n \n   image->bps = bps;\n@@ -5023,11 +5941,26 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned\n     readunit = TILE;\n     tlsize = TIFFTileSize(in);\n     ntiles = TIFFNumberOfTiles(in);\n+    TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n+    TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n+\n+    tile_rowsize  = TIFFTileRowSize(in);      \n     buffsize = tlsize * ntiles;\n+    \n+    if (buffsize < (uint32)(ntiles * tl * tile_rowsize))\n+      {\n+      buffsize = ntiles * tl * tile_rowsize;\n+#ifdef DEBUG2\n+      TIFFError(""loadImage"",\n+\t        ""Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu"",\n+                tlsize, (unsigned long)buffsize);\n+#endif\n+      }\n+    \n     if (dump->infile != NULL)\n       dump_info (dump->infile, dump->format, """", \n-                 ""Tilesize: %u, Number of Tiles: %u, Scanline size: %u"",\n-                 tlsize, ntiles, scanlinesize);\n+                 ""Tilesize: %u, Number of Tiles: %u, Tile row size: %u"",\n+                 tlsize, ntiles, tile_rowsize);\n     }\n   else\n     {\n@@ -5036,11 +5969,27 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned\n     stsize = TIFFStripSize(in);\n     nstrips = TIFFNumberOfStrips(in);\n     buffsize = stsize * nstrips;\n+    if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))\n+      {\n+      buffsize =  ((length * width * spp * bps) + 7) / 8;\n+#ifdef DEBUG2\n+      TIFFError(""loadImage"",\n+\t        ""Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu"",\n+                stsize, (unsigned long)buffsize);\n+#endif\n+      }\n+\n     if (dump->infile != NULL)\n       dump_info (dump->infile, dump->format, """",\n                  ""Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u"",\n \t\t stsize, nstrips, rowsperstrip, scanlinesize);\n     }\n+  \n+  if (input_compression == COMPRESSION_JPEG)\n+    {\n+    jpegcolormode = JPEGCOLORMODE_RGB;\n+    TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n+    }\n \n   read_buff = *read_ptr;\n   if (!read_buff)\n@@ -5065,7 +6014,7 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned\n     TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer"");\n     return (-1);\n     }\n-  _TIFFmemset(read_buff, \'\\0\', buffsize);\n+\n   prev_readsize = buffsize;\n   *read_ptr = read_buff;\n \n@@ -5077,7 +6026,7 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned\n     case STRIP:\n          if (planar == PLANARCONFIG_CONTIG)\n            {\n-\t   if (!(readContigStripsIntoBuffer(in, read_buff, length, width, spp)))\n+\t     if (!(readContigStripsIntoBuffer(in, read_buff, length, width, spp, dump)))\n \t     {\n \t     TIFFError(""loadImage"", ""Unable to read contiguous strips into buffer"");\n \t     return (-1);\n@@ -5096,7 +6045,7 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned\n     case TILE:\n          if (planar == PLANARCONFIG_CONTIG)\n            {\n-\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, spp)))\n+\t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n \t     {\n \t     TIFFError(""loadImage"", ""Unable to read contiguous tiles into buffer"");\n \t     return (-1);\n@@ -5104,7 +6053,7 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned\n            }\n          else\n            {\n-\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, spp)))\n+\t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))\n \t     {\n \t     TIFFError(""loadImage"", ""Unable to read separate tiles into buffer"");\n \t     return (-1);\n@@ -5275,27 +6224,31 @@ extractCompositeRegions(struct image_data *image,  struct crop_mask *crop,\n \t\t         return (1);\n \t\t         }\n \t\t       break;\n-               case 1:  if (extractContigSamplesShifted8bits (src, dst, img_width,\n-                                                              sample, spp, bps, count, \n-                                                              first_col, last_col + 1,\n-                                                              prev_trailing_bits))\n-                          {\n-\t\t          TIFFError(""extractCompositeRegions"",\n-                                    ""Unable to extract row %d"", row);\n-\t\t          return (1);\n-\t\t          }\n-\t\t        break;\n-               case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,\n+               case 1: if (bps == 1)\n+                         { \n+                         if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n-                          {\n-\t\t          TIFFError(""extractCompositeRegions"",\n-                                    ""Unable to extract row %d"", row);\n-\t\t          return (1);\n-\t\t          }\n+                           {\n+\t\t           TIFFError(""extractCompositeRegions"",\n+                                     ""Unable to extract row %d"", row);\n+\t\t           return (1);\n+\t\t           }\n+\t\t         break;\n+\t\t\t }\n+                       else\n+                         if (extractContigSamplesShifted16bits (src, dst, img_width,\n+                                                                sample, spp, bps, count, \n+                                                                first_col, last_col + 1,\n+                                                                prev_trailing_bits))\n+                           {\n+\t\t           TIFFError(""extractCompositeRegions"",\n+                                     ""Unable to extract row %d"", row);\n+\t\t           return (1);\n+\t\t           }\n \t\t        break;\n-               case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n+               case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n@@ -5305,6 +6258,7 @@ extractCompositeRegions(struct image_data *image,  struct crop_mask *crop,\n \t\t          return (1);\n \t\t          }\n \t\t        break;\n+               case 3:\n                case 4:\n                case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n@@ -5352,27 +6306,31 @@ extractCompositeRegions(struct image_data *image,  struct crop_mask *crop,\n \t\t         return (1);\n \t\t         }\n \t\t       break;\n-               case 1:  if (extractContigSamplesShifted8bits (src, dst, img_width,\n-                                                              sample, spp, bps, count, \n-                                                              first_col, last_col + 1,\n-                                                              prev_trailing_bits))\n-                          {\n-\t\t          TIFFError(""extractCompositeRegions"",\n-                                    ""Unable to extract row %d"", row);\n-\t\t          return (1);\n-\t\t          }\n-\t\t        break;\n-               case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,\n+               case 1: if (bps == 1)\n+                         { \n+                         if (extractContigSamplesShifted8bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n-                          {\n-\t\t          TIFFError(""extractCompositeRegions"",\n-                                    ""Unable to extract row %d"", row);\n-\t\t          return (1);\n-\t\t          }\n+                           {\n+\t\t           TIFFError(""extractCompositeRegions"",\n+                                     ""Unable to extract row %d"", row);\n+\t\t           return (1);\n+\t\t           }\n+\t\t         break;\n+\t\t\t }\n+                       else\n+                         if (extractContigSamplesShifted16bits (src, dst, img_width,\n+                                                                sample, spp, bps, count, \n+                                                                first_col, last_col + 1,\n+                                                                prev_trailing_bits))\n+                           {\n+\t\t           TIFFError(""extractCompositeRegions"",\n+                                     ""Unable to extract row %d"", row);\n+\t\t           return (1);\n+\t\t           }\n \t\t        break;\n-               case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n+              case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n                                                                first_col, last_col + 1,\n                                                                prev_trailing_bits))\n@@ -5382,6 +6340,7 @@ extractCompositeRegions(struct image_data *image,  struct crop_mask *crop,\n \t\t          return (1);\n \t\t          }\n \t\t        break;\n+               case 3:\n                case 4:\n                case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                                sample, spp, bps, count, \n@@ -5490,27 +6449,31 @@ extractSeparateRegion(struct image_data *image,  struct crop_mask *crop,\n \t        return (1);\n \t        }\n \t      break;\n-      case 1: if (extractContigSamplesShifted8bits (src, dst, img_width,\n-                                                    sample, spp, bps, count, \n-                                                    first_col, last_col + 1,\n-                                                    prev_trailing_bits))\n-                {\n-\t        TIFFError(""extractSeparateRegion"",\n-                         ""Unable to extract row %d"", row);\n-\t\treturn (1);\n-\t\t}\n-\t      break;\n-     case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,\n-                                                     sample, spp, bps, count, \n-                                                     first_col, last_col + 1,\n-                                                     prev_trailing_bits))\n-                {\n-\t\tTIFFError(""extractSeparateRegion"",\n-                          ""Unable to extract row %d"", row);\n-\t\treturn (1);\n+      case 1: if (bps == 1)\n+                { \n+                if (extractContigSamplesShifted8bits (src, dst, img_width,\n+                                                      sample, spp, bps, count, \n+                                                      first_col, last_col + 1,\n+                                                      prev_trailing_bits))\n+                  {\n+\t\t  TIFFError(""extractSeparateRegion"",\n+                            ""Unable to extract row %d"", row);\n+\t\t  return (1);\n+\t\t  }\n+\t\t  break;\n \t\t}\n+              else\n+                if (extractContigSamplesShifted16bits (src, dst, img_width,\n+                                                       sample, spp, bps, count, \n+                                                       first_col, last_col + 1,\n+                                                       prev_trailing_bits))\n+                  {\n+\t\t  TIFFError(""extractSeparateRegion"",\n+                            ""Unable to extract row %d"", row);\n+\t\t  return (1);\n+\t\t  }\n \t      break;\n-     case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n+      case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,\n                                                      sample, spp, bps, count, \n                                                      first_col, last_col + 1,\n                                                      prev_trailing_bits))\n@@ -5520,8 +6483,9 @@ extractSeparateRegion(struct image_data *image,  struct crop_mask *crop,\n \t\treturn (1);\n \t\t}\n \t      break;\n-     case 4:\n-     case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n+      case 3:\n+      case 4:\n+      case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,\n                                                      sample, spp, bps, count, \n                                                      first_col, last_col + 1,\n                                                      prev_trailing_bits))\n@@ -5554,7 +6518,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n   uint32    sect_width, sect_length;\n   uint16    bps, spp;\n \n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n   int      k;\n   unsigned char bitset;\n   static char *bitarray = NULL;\n@@ -5570,7 +6534,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n   src_offset = 0;\n   dst_offset = 0;\n \n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n   if (bitarray == NULL)\n     {\n     if ((bitarray = (char *)malloc(img_width)) == NULL)\n@@ -5593,7 +6557,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n   full_bytes = (sect_width * spp * bps) / 8;   /* number of COMPLETE bytes per row in section */\n   trailing_bits = (sect_width * bps) % 8;\n \n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n     TIFFError ("""", ""First row: %d, last row: %d, First col: %d, last col: %d\\n"",\n            first_row, last_row, first_col, last_col);\n     TIFFError ("""", ""Image width: %d, Image length: %d, bps: %d, spp: %d\\n"",\n@@ -5611,7 +6575,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n       row_offset = row * img_rowsize;\n       src_offset = row_offset + col_offset;\n \n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n         TIFFError ("""", ""Src offset: %8d, Dst offset: %8d\\n"", src_offset, dst_offset); \n #endif\n       _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);\n@@ -5629,7 +6593,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n       offset1 = row_offset + (first_col * bps / 8);\n       offset2 = row_offset + (last_col * bps / 8);\n \n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n       for (j = 0, k = 7; j < 8; j++, k--)\n         {\n         bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0;\n@@ -5652,7 +6616,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n         {\n \t_TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);\n \n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n \tTIFFError ("""", ""        Alligned data src offset1: %8d, Dst offset: %8d\\n"", offset1, dst_offset); \n \tsprintf(&bitarray[18], ""\\n"");\n \tsprintf(&bitarray[19], ""\\t"");\n@@ -5670,7 +6634,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n           {\n \t  bytebuff2 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2));\n           sect_buff[dst_offset] = bytebuff2;\n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n \t  TIFFError ("""", ""        Trailing bits src offset:  %8d, Dst offset: %8d\\n"", \n                               offset2, dst_offset); \n           for (j = 30, k = 7; j < 38; j++, k--)\n@@ -5686,7 +6650,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n         }\n       else   /* each destination byte will have to be built from two source bytes*/\n         {\n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n \t  TIFFError ("""", ""        Unalligned data src offset: %8d, Dst offset: %8d\\n"", offset1 , dst_offset); \n #endif\n         for (j = 0; j <= full_bytes; j++) \n@@ -5695,7 +6659,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n \t  bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1));\n           sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));\n           }\n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n \tsprintf(&bitarray[18], ""\\n"");\n \tsprintf(&bitarray[19], ""\\t"");\n         for (j = 20, k = 7; j < 28; j++, k--)\n@@ -5710,7 +6674,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n \n         if (trailing_bits != 0)\n           {\n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n \t    TIFFError ("""", ""        Trailing bits   src offset: %8d, Dst offset: %8d\\n"", offset1 + full_bytes, dst_offset); \n #endif\n \t  if (shift2 > shift1)\n@@ -5718,7 +6682,7 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n \t    bytebuff1 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2));\n             bytebuff2 = bytebuff1 & ((unsigned char)255 << shift1);\n             sect_buff[dst_offset] = bytebuff2;\n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n \t    TIFFError ("""", ""        Shift2 > Shift1\\n""); \n #endif\n             }\n@@ -5728,17 +6692,17 @@ extractImageSection(struct image_data *image, struct pageseg *section,\n               {\n               bytebuff2 = ((unsigned char)255 << (shift1 - shift2 - 1));\n \t      sect_buff[dst_offset] &= bytebuff2;\n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n \t      TIFFError ("""", ""        Shift2 < Shift1\\n""); \n #endif\n               }\n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n             else\n \t      TIFFError ("""", ""        Shift2 == Shift1\\n""); \n #endif\n             }\n \t  }\n-#ifdef DEBUG2\n+#ifdef DEVELMODE\n \t  sprintf(&bitarray[28], "" "");\n \t  sprintf(&bitarray[29], "" "");\n           for (j = 30, k = 7; j < 38; j++, k--)\n@@ -5877,11 +6841,6 @@ writeImageSections(TIFF *in, TIFF *out, struct image_data *image,\n   hres = page->hres;\n   vres = page->vres;\n \n-#ifdef DEBUG\n-  TIFFError("""",\n-    ""Writing %d sections for each original page. Hres: %3.2f Vres: %3.2f\\n"", \n-          page->rows * page->cols, hres, vres);\n-#endif\n   k = page->cols * page->rows;\n   if ((k < 1) || (k > MAX_SECTIONS))\n    {\n@@ -5904,11 +6863,6 @@ writeImageSections(TIFF *in, TIFF *out, struct image_data *image,\n       }\n     sect_buff = *sect_buff_ptr;\n \n-#ifdef DEBUG\n-    TIFFError ("""", ""\\nSection: %d, Width: %4d, Length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d\\n"",\n-             i + 1, width, length, sections[i].x1, sections[i].x2, sections[i].y1, sections[i].y2);\n-#endif\n-\n     if (extractImageSection (image, &sections[i], src_buff, sect_buff))\n       {\n       TIFFError(""writeImageSections"", ""Unable to extract image sections"");\n@@ -5928,6 +6882,9 @@ writeImageSections(TIFF *in, TIFF *out, struct image_data *image,\n \n /* Code in this function is heavily indebted to code in tiffcp\n  * with modifications by Richard Nolde to handle orientation correctly.\n+ * It will have to be updated significantly if support is added to\n+ * extract one or more samples from original image since the \n+ * original code assumes we are always copying all samples.\n  */\n static int  \n writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n@@ -5936,48 +6893,79 @@ writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n                    unsigned char *sect_buff)\n   {\n   uint16 bps, spp;\n+  uint16 input_compression, input_photometric;\n+  uint16 input_jpeg_colormode, input_planar;\n   struct cpTag* p;\n \n-#ifdef DEBUG\n-  TIFFError ("""",\n-""\\nWriting single section: Width %d Length: %d Hres: %4.1f, Vres: %4.1f\\n\\n"",\n-\t   width, length, hres, vres);\n-#endif\n   TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n   TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n \n   CopyField(TIFFTAG_BITSPERSAMPLE, bps);\n   CopyField(TIFFTAG_SAMPLESPERPIXEL, spp);\n+\n+  TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression);\n   if (compression != (uint16)-1)\n     TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n   else\n-    CopyField(TIFFTAG_COMPRESSION, compression);\n-\n-  if (compression == COMPRESSION_JPEG) {\n-    uint16 input_compression, input_photometric;\n+    {\n+    if (input_compression == COMPRESSION_OJPEG)\n+      {\n+      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n+      compression = COMPRESSION_JPEG;\n+      }\n+    else\n+      CopyField(TIFFTAG_COMPRESSION, compression);\n+    }\n \n-    if (TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)\n-        && input_compression == COMPRESSION_JPEG) {\n-          TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n-        }\n-    if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) {\n-\tif(input_photometric == PHOTOMETRIC_RGB) {\n-\t   if (jpegcolormode == JPEGCOLORMODE_RGB)\n-\t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n-\t   else\n-\t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n-\t   } else\n-\t      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n+  TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);\n+#ifdef DEBUG2\n+  TIFFError(""writeSingleSection"", ""Input compression: %s"",\n+\t    (input_compression == COMPRESSION_OJPEG) ? ""Old Jpeg"" :\n+\t    ((input_compression == COMPRESSION_JPEG) ?  ""New Jpeg"" : ""Non Jpeg""));\n+#endif\n+  if (compression == COMPRESSION_JPEG)\n+    {\n+    if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n+      {\n+      if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */\n+          (input_photometric == PHOTOMETRIC_MASK))       /* $holdout mask */\n+        {\n+\tTIFFError (""writeSingleSection"",\n+                   ""JPEG compression cannot be used with %s image data"",\n+\t\t   (input_photometric == PHOTOMETRIC_PALETTE) ?\n+                   ""palette"" : ""mask"");\n+        return (-1);\n \t}\n+      if (input_photometric == PHOTOMETRIC_RGB)\n+        {\n+\tif (jpegcolormode == JPEGCOLORMODE_RGB)\n+\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n+\telse\n+\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n+\t} \n+      else\n+\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n       }\n-  else \n+    }\n+  else\n     {\n     if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)\n-       TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n+      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?\n \t\t\tPHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);\n     else\n       TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);\n     }\n+\n+  if (((TIFFTAG_PHOTOMETRIC == PHOTOMETRIC_LOGL) ||\n+       (TIFFTAG_PHOTOMETRIC ==  PHOTOMETRIC_LOGLUV)) &&\n+      ((compression != COMPRESSION_SGILOG) && \n+       (compression != COMPRESSION_SGILOG24)))\n+    {\n+    TIFFError(""writeSingleSection"",\n+              ""LogL and LogLuv data require SGI_LOG or SGI_LOG24"");\n+    return (-1);\n+    }\n+\n   if (fillorder != 0)\n     TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n   else\n@@ -5988,7 +6976,7 @@ writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n    * applies the required rotation and mirror operations to \n    * present the data in TOPLEFT orientation and updates \n    * image->orientation if any transforms are performed, \n-   * as per EXIF standard. Original tiffcp code removed here.\n+   * as per EXIF standard.\n    */\n   TIFFSetField(out, TIFFTAG_ORIENTATION, image->orientation);\n \n@@ -6006,16 +6994,13 @@ writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n      * input image or, if nothing is defined, use the\n      * library default.\n      */\n-    if (tilewidth == (uint32) -1)\n+    if (tilewidth == (uint32) 0)\n       TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n-    if (tilelength == (uint32) -1)\n+    if (tilelength == (uint32) 0)\n       TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n \n-    if (tilewidth > width)\n-      tilewidth = width;\n-    if (tilelength > length)\n-      tilelength = length;\n-\n+    if (tilewidth == 0 || tilelength == 0)\n+      TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n     TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n     TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n     TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n@@ -6025,17 +7010,23 @@ writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n \t* value from the input image or, if nothing is defined,\n \t* use the library default.\n \t*/\n-\tif (rowsperstrip == (uint32) 0) {\n-\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip)) {\n-\t      rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n-\t     }\n-\t  if (rowsperstrip > length && rowsperstrip != (uint32)-1)\n-\t       rowsperstrip = length;\n+\tif (rowsperstrip == (uint32) 0)\n+          {\n+\t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n+\t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n+          if (compression != COMPRESSION_JPEG)\n+            {\n+  \t    if (rowsperstrip > length)\n+\t      rowsperstrip = length;\n+\t    }\n \t  }\n-\telse if (rowsperstrip == (uint32) -1)\n-\t\trowsperstrip = length;\n-\t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n+\telse \n+          if (rowsperstrip == (uint32) -1)\n+\t    rowsperstrip = length;\n+\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n \t}\n+\n+  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);\n   if (config != (uint16) -1)\n     TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n   else\n@@ -6046,9 +7037,21 @@ writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n \n /* SMinSampleValue & SMaxSampleValue */\n   switch (compression) {\n+    /* These are references to GLOBAL variables set by defaults\n+     * and /or the compression flag\n+     */\n     case COMPRESSION_JPEG:\n-         TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n-\t TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n+         if (((bps % 8) == 0) || ((bps % 12) == 0))\n+\t   {\n+           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n+\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n+           }\n+         else\n+           {\n+\t   TIFFError(""writeCroppedImage"",\n+                     ""JPEG compression requires 8 or 12 bits per sample"");\n+           return (-1);\n+           }\n \t break;\n    case COMPRESSION_LZW:\n    case COMPRESSION_ADOBE_DEFLATE:\n@@ -6120,22 +7123,16 @@ writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,\n   if (outtiled)\n     {\n     if (config == PLANARCONFIG_CONTIG)\n-      {\n-      writeBufferToContigTiles (out, sect_buff, length, width, spp);\n-      }\n+      writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);\n     else\n       writeBufferToSeparateTiles (out, sect_buff, length, width, spp, dump);\n     }\n   else\n     {\n     if (config == PLANARCONFIG_CONTIG)\n-      {\n-      writeBufferToContigStrips (out, sect_buff, length, width, spp);\n-      }\n+      writeBufferToContigStrips (out, sect_buff, length);\n     else\n-      {\n       writeBufferToSeparateStrips(out, sect_buff, length, width, spp, dump);\n-      }\n     }\n \n   if (!TIFFWriteDirectory(out))\n@@ -6545,13 +7542,25 @@ createCroppedImage(struct image_data *image, struct crop_mask *crop,\n   } /* end createCroppedImage */\n \n \n-/* The code in this function is heavily indebted to code from tiffcp. */\n+/* Code in this function is heavily indebted to code in tiffcp\n+ * with modifications by Richard Nolde to handle orientation correctly.\n+ * It will have to be updated significantly if support is added to\n+ * extract one or more samples from original image since the \n+ * original code assumes we are always copying all samples.\n+ * Use of global variables for config, compression and others\n+ * should be replaced by addition to the crop_mask struct (which\n+ * will be renamed to proc_opts indicating that is controlls\n+ * user supplied processing options, not just cropping) and \n+ * then passed in as an argument.\n+ */\n static int  \n writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image, \n                   struct dump_opts *dump, uint32 width, uint32 length, \n                   unsigned char *crop_buff, int pagenum, int total_pages)\n   {\n   uint16 bps, spp;\n+  uint16 input_compression, input_photometric;\n+  uint16 input_jpeg_colormode, input_planar;\n   struct cpTag* p;\n \n   TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n@@ -6559,28 +7568,51 @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n \n   CopyField(TIFFTAG_BITSPERSAMPLE, bps);\n   CopyField(TIFFTAG_SAMPLESPERPIXEL, spp);\n+\n+  TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression);\n   if (compression != (uint16)-1)\n     TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n   else\n-    CopyField(TIFFTAG_COMPRESSION, compression);\n-\n-  if (compression == COMPRESSION_JPEG) {\n-    uint16 input_compression, input_photometric;\n+    {\n+    if (input_compression == COMPRESSION_OJPEG)\n+      {\n+      TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);\n+      compression = COMPRESSION_JPEG;\n+      }\n+    else\n+      CopyField(TIFFTAG_COMPRESSION, compression);\n+    }\n \n-    if (TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)\n-        && input_compression == COMPRESSION_JPEG) {\n-          TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n-        }\n-    if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) {\n-\tif(input_photometric == PHOTOMETRIC_RGB) {\n-\t   if (jpegcolormode == JPEGCOLORMODE_RGB)\n-\t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n-\t   else\n-\t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n-\t   } else\n-\t      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n+  TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);\n+#ifdef DEBUG2\n+  TIFFError(""writeCroppedImage"", ""Input compression: %s"",\n+\t    (input_compression == COMPRESSION_OJPEG) ? ""Old Jpeg"" :\n+\t    ((input_compression == COMPRESSION_JPEG) ?  ""New Jpeg"" : ""Non Jpeg""));\n+#endif\n+  if (compression == COMPRESSION_JPEG)\n+    {\n+    if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric))\n+      {\n+      if ((input_photometric == PHOTOMETRIC_PALETTE) ||  /* color map indexed */\n+          (input_photometric == PHOTOMETRIC_MASK))       /* $holdout mask */\n+        {\n+\tTIFFError (""writeCroppedImage"",\n+                   ""JPEG compression cannot be used with %s image data"",\n+\t\t   (input_photometric == PHOTOMETRIC_PALETTE) ?\n+                   ""palette"" : ""mask"");\n+        return (-1);\n \t}\n-  }\n+      if (input_photometric == PHOTOMETRIC_RGB)\n+        {\n+\tif (jpegcolormode == JPEGCOLORMODE_RGB)\n+\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n+\telse\n+\t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n+\t} \n+      else\n+\tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n+      }\n+    }\n   else\n     {\n     if (compression == COMPRESSION_SGILOG || compression == COMPRESSION_SGILOG24)\n@@ -6589,6 +7621,17 @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n     else\n       TIFFSetField(out, TIFFTAG_PHOTOMETRIC, image->photometric);\n     }\n+\n+  if (((TIFFTAG_PHOTOMETRIC == PHOTOMETRIC_LOGL) ||\n+       (TIFFTAG_PHOTOMETRIC ==  PHOTOMETRIC_LOGLUV)) &&\n+      ((compression != COMPRESSION_SGILOG) && \n+       (compression != COMPRESSION_SGILOG24)))\n+    {\n+    TIFFError(""writeCroppedImage"",\n+              ""LogL and LogLuv data require SGI_LOG or SGI_LOG24"");\n+    return (-1);\n+    }\n+\n   if (fillorder != 0)\n     TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n   else\n@@ -6617,17 +7660,13 @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n      * input image or, if nothing is defined, use the\n      * library default.\n      */\n-    if (tilewidth == (uint32) -1)\n+    if (tilewidth == (uint32) 0)\n       TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n-    if (tilelength == (uint32) -1)\n+    if (tilelength == (uint32) 0)\n       TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n \n-    if (tilewidth > width)\n-      tilewidth = width;\n-    if (tilelength > length)\n-      tilelength = length;\n-\n-    TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n+    if (tilewidth == 0 || tilelength == 0)\n+      TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n     TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n     TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n     } else {\n@@ -6639,17 +7678,20 @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n \tif (rowsperstrip == (uint32) 0)\n           {\n \t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n-            {\n \t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n+          if (compression != COMPRESSION_JPEG)\n+            {\n+  \t    if (rowsperstrip > length)\n+\t      rowsperstrip = length;\n \t    }\n-\t  if (rowsperstrip > length)\n-\t    rowsperstrip = length;\n \t  }\n \telse \n           if (rowsperstrip == (uint32) -1)\n \t    rowsperstrip = length;\n \tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n \t}\n+\n+  TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);\n   if (config != (uint16) -1)\n     TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n   else\n@@ -6661,8 +7703,17 @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n /* SMinSampleValue & SMaxSampleValue */\n   switch (compression) {\n     case COMPRESSION_JPEG:\n-         TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n-\t TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n+         if (((bps % 8) == 0) || ((bps % 12) == 0))\n+\t   {\n+           TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n+\t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n+           }\n+         else\n+           {\n+\t   TIFFError(""writeCroppedImage"",\n+                     ""JPEG compression requires 8 or 12 bits per sample"");\n+           return (-1);\n+           }\n \t break;\n    case COMPRESSION_LZW:\n    case COMPRESSION_ADOBE_DEFLATE:\n@@ -6674,6 +7725,12 @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n \tbreak;\n    case COMPRESSION_CCITTFAX3:\n    case COMPRESSION_CCITTFAX4:\n+        if (bps != 1)\n+          {\n+\t  TIFFError(""writeCroppedImage"",\n+            ""Group 3/4 compression is not usable with bps > 1"");\n+          return (-1);\n+\t  }\n \tif (compression == COMPRESSION_CCITTFAX3) {\n           if (g3opts != (uint32) -1)\n \t    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n@@ -6687,7 +7744,10 @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n \t    CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n \t    CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n \t    CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n-\tbreak;\n+\t break;\n+    case COMPRESSION_NONE:\n+         break;\n+    default: break;\n    }\n    { uint32 len32;\n      void** data;\n@@ -6727,22 +7787,16 @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,\n   if (outtiled)\n     {\n     if (config == PLANARCONFIG_CONTIG)\n-      {\n-      writeBufferToContigTiles (out, crop_buff, length, width, spp);\n-      }\n+      writeBufferToContigTiles (out, crop_buff, length, width, spp, dump);\n     else\n       writeBufferToSeparateTiles (out, crop_buff, length, width, spp, dump);\n     }\n   else\n     {\n     if (config == PLANARCONFIG_CONTIG)\n-      {\n-      writeBufferToContigStrips (out, crop_buff, length, width, spp);\n-      }\n+      writeBufferToContigStrips (out, crop_buff, length);\n     else\n-      {\n       writeBufferToSeparateStrips(out, crop_buff, length, width, spp, dump);\n-      }\n     }\n \n   if (!TIFFWriteDirectory(out))\n@@ -7241,24 +8295,28 @@ rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width,\n                   dst = rbuff + dst_offset;\n                   switch (shift_width)\n                     {\n-                    case 1: if (reverseSamples8bits(spp, bps, width, src, dst))\n-                              {\n-\t\t              _TIFFfree(rbuff);\n-                              return (-1);\n+                    case 1: if (bps == 1)\n+\t\t\t      {\n+                              if (reverseSamples8bits(spp, bps, width, src, dst))\n+                                {\n+\t\t                _TIFFfree(rbuff);\n+                                return (-1);\n+                                }\n+                              break;\n                               }\n-                             break;\n-                    case 2: if (reverseSamples16bits(spp, bps, width, src, dst))\n+                            if (reverseSamples16bits(spp, bps, width, src, dst))\n                               {\n \t\t              _TIFFfree(rbuff);\n                               return (-1);\n                               }\n                              break;\n-                    case 3: if (reverseSamples24bits(spp, bps, width, src, dst))\n+                    case 2: if (reverseSamples24bits(spp, bps, width, src, dst))\n                               {\n \t\t              _TIFFfree(rbuff);\n                               return (-1);\n                               }\n                              break;\n+                    case 3: \n                     case 4: \n                     case 5: if (reverseSamples32bits(spp, bps, width, src, dst))\n                               {\n@@ -7302,27 +8360,31 @@ rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width,\n \t\t  dst = rbuff + dst_offset;\n                   switch (shift_width)\n                     {\n-                    case 1: if (rotateContigSamples8bits(rotation, spp, bps, width, \n+                    case 1: if (bps == 1)\n+\t\t\t      {\n+                              if (rotateContigSamples8bits(rotation, spp, bps, width, \n+\t\t\t\t   \t                 length, col, src, dst))\n+                                {\n+\t\t                _TIFFfree(rbuff);\n+                                return (-1);\n+                                }\n+                              break;\n+                              }\n+                            if (rotateContigSamples16bits(rotation, spp, bps, width, \n \t\t\t\t   \t                 length, col, src, dst))\n                               {\n \t                      _TIFFfree(rbuff);\n                               return (-1);\n \t\t              }\n \t\t            break;\n-                    case 2: if (rotateContigSamples16bits(rotation, spp, bps, width, \n+                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \n \t\t\t\t\t                  length, col, src, dst))\n                               {\n \t\t              _TIFFfree(rbuff);\n                               return (-1);\n                               }\n                              break;\n-                    case 3: if (rotateContigSamples24bits(rotation, spp, bps, width, \n-\t\t\t\t                          length, col, src, dst))\n-                              {\n-\t\t              _TIFFfree(rbuff);\n-                              return (-1);\n-                              }\n-                             break;\n+                    case 3: \n                     case 4: \n                     case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \n \t\t\t\t\t                  length, col, src, dst))\n@@ -7375,27 +8437,31 @@ rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width,\n \t\t  dst = rbuff + dst_offset;\n                   switch (shift_width)\n                     {\n-                    case 1: if (rotateContigSamples8bits(rotation, spp, bps, width, \n+                    case 1: if (bps == 1)\n+\t\t\t      {\n+                              if (rotateContigSamples8bits(rotation, spp, bps, width, \n+\t\t\t\t   \t                 length, col, src, dst))\n+                                {\n+\t\t                _TIFFfree(rbuff);\n+                                return (-1);\n+                                }\n+                              break;\n+                              }\n+                            if (rotateContigSamples16bits(rotation, spp, bps, width, \n \t\t\t\t   \t                 length, col, src, dst))\n                               {\n \t                      _TIFFfree(rbuff);\n                               return (-1);\n \t\t              }\n \t\t            break;\n-                    case 2: if (rotateContigSamples16bits(rotation, spp, bps, width, \n+                    case 2: if (rotateContigSamples24bits(rotation, spp, bps, width, \n \t\t\t\t\t                  length, col, src, dst))\n                               {\n \t\t              _TIFFfree(rbuff);\n                               return (-1);\n                               }\n                              break;\n-                    case 3: if (rotateContigSamples24bits(rotation, spp, bps, width, \n-\t\t\t\t                          length, col, src, dst))\n-                              {\n-\t\t              _TIFFfree(rbuff);\n-                              return (-1);\n-                              }\n-                             break;\n+                    case 3: \n                     case 4: \n                     case 5: if (rotateContigSamples32bits(rotation, spp, bps, width, \n \t\t\t\t\t                  length, col, src, dst))\n@@ -7436,7 +8502,7 @@ reverseSamples8bits (uint16 spp, uint16 bps, uint32 width,\n   uint32   col;\n   uint32   src_byte, src_bit;\n   uint32   bit_offset = 0;\n-  uint8    matchbits = 0, maskbits = 0;\n+  uint8    match_bits = 0, mask_bits = 0;\n   uint8    buff1 = 0, buff2 = 0;\n   unsigned char *src;\n   unsigned char *dst;\n@@ -7449,7 +8515,7 @@ reverseSamples8bits (uint16 spp, uint16 bps, uint32 width,\n     }\n \n   ready_bits = 0;\n-  maskbits =  (uint8)-1 >> ( 8 - bps);\n+  mask_bits =  (uint8)-1 >> ( 8 - bps);\n   dst = obuff;\n   for (col = width; col > 0; col--)\n     {\n@@ -7469,8 +8535,8 @@ reverseSamples8bits (uint16 spp, uint16 bps, uint32 width,\n         }\n \n       src = ibuff + src_byte;\n-      matchbits = maskbits << (8 - src_bit - bps); \n-      buff1 = ((*src) & matchbits) << (src_bit);\n+      match_bits = mask_bits << (8 - src_bit - bps); \n+      buff1 = ((*src) & match_bits) << (src_bit);\n \n       if (ready_bits < 8)\n         buff2 = (buff2 | (buff1 >> ready_bits));\n@@ -7492,15 +8558,16 @@ reverseSamples8bits (uint16 spp, uint16 bps, uint32 width,\n   return (0);\n   } /* end reverseSamples8bits */\n \n+\n static int\n reverseSamples16bits (uint16 spp, uint16 bps, uint32 width, \n                       uint8 *ibuff, uint8 *obuff)\n   {\n   int      ready_bits = 0;\n   uint32   col;\n-  uint32   src_byte = 0, src_bit = 0;\n+  uint32   src_byte = 0, high_bit = 0;\n   uint32   bit_offset = 0;\n-  uint16   matchbits = 0, maskbits = 0;\n+  uint16   match_bits = 0, mask_bits = 0;\n   uint16   buff1 = 0, buff2 = 0;\n   uint8    bytebuff = 0;\n   unsigned char *src;\n@@ -7515,7 +8582,7 @@ reverseSamples16bits (uint16 spp, uint16 bps, uint32 width,\n     }\n \n   ready_bits = 0;\n-  maskbits =  (uint16)-1 >> (16 - bps);\n+  mask_bits =  (uint16)-1 >> (16 - bps);\n   dst = obuff;\n   for (col = width; col > 0; col--)\n     {\n@@ -7526,16 +8593,16 @@ reverseSamples16bits (uint16 spp, uint16 bps, uint32 width,\n       if (sample == 0)\n         {\n         src_byte = bit_offset / 8;\n-        src_bit  = bit_offset % 8;\n+        high_bit  = bit_offset % 8;\n         }\n       else\n         {\n         src_byte = (bit_offset + (sample * bps)) / 8;\n-        src_bit  = (bit_offset + (sample * bps)) % 8;\n+        high_bit  = (bit_offset + (sample * bps)) % 8;\n         }\n \n       src = ibuff + src_byte;\n-      matchbits = maskbits << (16 - src_bit - bps); \n+      match_bits = mask_bits << (16 - high_bit - bps); \n       if (little_endian)\n         {\n         swapbuff[1] = *src;\n@@ -7548,7 +8615,7 @@ reverseSamples16bits (uint16 spp, uint16 bps, uint32 width,\n \t}\n \n       buff1 = *((uint16 *)swapbuff);\n-      buff1 = (buff1 & matchbits) << (src_bit);\n+      buff1 = (buff1 & match_bits) << (high_bit);\n       \n       if (ready_bits < 8)\n         { /* add another bps bits to the buffer */\n@@ -7582,9 +8649,9 @@ reverseSamples24bits (uint16 spp, uint16 bps, uint32 width,\n   {\n   int      ready_bits = 0;\n   uint32   col;\n-  uint32   src_byte = 0, src_bit = 0;\n+  uint32   src_byte = 0, high_bit = 0;\n   uint32   bit_offset = 0;\n-  uint32   matchbits = 0, maskbits = 0;\n+  uint32   match_bits = 0, mask_bits = 0;\n   uint32   buff1 = 0, buff2 = 0;\n   uint8    bytebuff1 = 0, bytebuff2 = 0;\n   unsigned char *src;\n@@ -7599,7 +8666,7 @@ reverseSamples24bits (uint16 spp, uint16 bps, uint32 width,\n     }\n \n   ready_bits = 0;\n-  maskbits =  (uint32)-1 >> (32 - bps);\n+  mask_bits =  (uint32)-1 >> (32 - bps);\n   dst = obuff;\n   for (col = width; col > 0; col--)\n     {\n@@ -7610,16 +8677,16 @@ reverseSamples24bits (uint16 spp, uint16 bps, uint32 width,\n       if (sample == 0)\n         {\n         src_byte = bit_offset / 8;\n-        src_bit  = bit_offset % 8;\n+        high_bit  = bit_offset % 8;\n         }\n       else\n         {\n         src_byte = (bit_offset + (sample * bps)) / 8;\n-        src_bit  = (bit_offset + (sample * bps)) % 8;\n+        high_bit  = (bit_offset + (sample * bps)) % 8;\n         }\n \n       src = ibuff + src_byte;\n-      matchbits = maskbits << (32 - src_bit - bps); \n+      match_bits = mask_bits << (32 - high_bit - bps); \n       if (little_endian)\n         {\n         swapbuff[3] = *src;\n@@ -7636,7 +8703,7 @@ reverseSamples24bits (uint16 spp, uint16 bps, uint32 width,\n \t}\n \n       buff1 = *((uint32 *)swapbuff);\n-      buff1 = (buff1 & matchbits) << (src_bit);\n+      buff1 = (buff1 & match_bits) << (high_bit);\n \n       if (ready_bits < 16)\n         { /* add another bps bits to the buffer */\n@@ -7680,10 +8747,10 @@ reverseSamples32bits (uint16 spp, uint16 bps, uint32 width,\n   int    ready_bits = 0, shift_width = 0;\n   int    bytes_per_sample, bytes_per_pixel;\n   uint32 bit_offset;\n-  uint32 src_byte = 0, src_bit = 0;\n+  uint32 src_byte = 0, high_bit = 0;\n   uint32 col;\n   uint32 longbuff1 = 0, longbuff2 = 0;\n-  uint64 maskbits = 0, matchbits = 0;\n+  uint64 mask_bits = 0, match_bits = 0;\n   uint64 buff1 = 0, buff2 = 0, buff3 = 0;\n   uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;\n   unsigned char *src;\n@@ -7699,7 +8766,7 @@ reverseSamples32bits (uint16 spp, uint16 bps, uint32 width,\n     }\n \n   ready_bits = 0;\n-  maskbits =  (uint64)-1 >> (64 - bps);\n+  mask_bits =  (uint64)-1 >> (64 - bps);\n   dst = obuff;\n \n   bytes_per_sample = (bps + 7) / 8;\n@@ -7718,16 +8785,16 @@ reverseSamples32bits (uint16 spp, uint16 bps, uint32 width,\n       if (sample == 0)\n         {\n         src_byte = bit_offset / 8;\n-        src_bit  = bit_offset % 8;\n+        high_bit  = bit_offset % 8;\n         }\n       else\n         {\n         src_byte = (bit_offset + (sample * bps)) / 8;\n-        src_bit  = (bit_offset + (sample * bps)) % 8;\n+        high_bit  = (bit_offset + (sample * bps)) % 8;\n         }\n \n       src = ibuff + src_byte;\n-      matchbits = maskbits << (64 - src_bit - bps); \n+      match_bits = mask_bits << (64 - high_bit - bps); \n       if (little_endian)\n         {\n         swapbuff1[3] = *src;\n@@ -7762,7 +8829,7 @@ reverseSamples32bits (uint16 spp, uint16 bps, uint32 width,\n \n       longbuff2 = *((uint32 *)swapbuff2);\n       buff3 = ((uint64)longbuff1 << 32) | longbuff2;\n-      buff1 = (buff3 & matchbits) << (src_bit);\n+      buff1 = (buff3 & match_bits) << (high_bit);\n \n       if (ready_bits < 32)\n         { /* add another bps bits to the buffer */\n@@ -7918,27 +8985,21 @@ mirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length,\n                   _TIFFmemset (line_buff, \'\\0\', rowsize);\n                   switch (shift_width)\n                     {\n-                    case 1: if (reverseSamples8bits(spp, bps, width, src, line_buff))\n-                              {\n-\t\t              _TIFFfree(line_buff);\n-                              return (-1);\n-                              }\n-                             _TIFFmemcpy (src, line_buff, rowsize);\n-                             break;\n-                    case 2: if (reverseSamples16bits(spp, bps, width, src, line_buff))\n+                    case 1: if (reverseSamples16bits(spp, bps, width, src, line_buff))\n                               {\n \t\t              _TIFFfree(line_buff);\n                               return (-1);\n                               }\n                              _TIFFmemcpy (src, line_buff, rowsize);\n                              break;\n-                    case 3: if (reverseSamples24bits(spp, bps, width, src, line_buff))\n+                    case 2: if (reverseSamples24bits(spp, bps, width, src, line_buff))\n                               {\n \t\t              _TIFFfree(line_buff);\n                               return (-1);\n                               }\n                              _TIFFmemcpy (src, line_buff, rowsize);\n                              break;\n+                    case 3: \n                     case 4: \n                     case 5: if (reverseSamples32bits(spp, bps, width, src, line_buff))\n                               {\n']",2009-09-24 21:57:11+00:00,"* tools/tiffcrop.c, man/tiffcrop.1: New tiffcrop from Richard
Nolde.  Major updates to add significant functionality for reading
and writing tile based images with bit depths not a multiple of 8
which cannot be handled by tiffcp.","[['+ static   char tiffcrop_version_id[] = ""2.1"";', '+ static   char tiffcrop_rev_date[] = ""09-18-2009"";', '+ ', '+ static uint32 tilewidth = 0;', '+ static uint32 tilelength = 0;', '+ ', '+ static uint16 config = 0;', '+ static uint16 compression = 0;', '+ static uint16 predictor = 0;', '+ static uint16 fillorder = 0;', '+ static uint32 rowsperstrip = 0;', '+ static uint32 g3opts = 0;', '+ static int  readContigStripsIntoBuffer   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);', '+ static int  readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);', '+ static int  writeBufferToContigStrips    (TIFF*, uint8*, uint32);', '+ static int  writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, tsample_t,', '+                                          uint16, uint16, struct dump_opts *);', '+ static int extractContigSamplesToTileBuffer(uint8 *, uint8 *, uint32, uint32,', '+   \t                                    uint32, uint32, tsample_t, uint16,', '+ \t\t\t\t\t    uint16, uint16, struct dump_opts *);', '+ ', '+ \t\t\t\t\tuint32, uint32, tsample_t, uint16,', '+                                         FILE *, int, int);', '+ ', '+ static int combineSeparateTileSamples8bits (uint8 *[], uint8 *, uint32, uint32,', '+                                             uint32, uint32, uint16, uint16,', '+                                             FILE *, int, int);', '+ static int combineSeparateTileSamples16bits (uint8 *[], uint8 *, uint32, uint32,', '+                                              uint32, uint32, uint16, uint16,', '+                                              FILE *, int, int);', '+ static int combineSeparateTileSamples24bits (uint8 *[], uint8 *, uint32, uint32,', '+                                              uint32, uint32, uint16, uint16,', '+                                              FILE *, int, int);', '+ static int combineSeparateTileSamples32bits (uint8 *[], uint8 *, uint32, uint32,', '+                                              uint32, uint32, uint16, uint16,', '+                                              FILE *, int, int);', '+ static int combineSeparateTileSamplesBytes (unsigned char *[], unsigned char *,', '+ \t\t\t  \t\t    uint32, uint32, uint32, uint32,', '+                                             tsample_t, uint16, FILE *, int, int);', '+ "" #\t\tSet compression quality level (0-100, default 100)"",', '+ "" r\t\tOutput color image as raw RGB rather than YCbCr"",', '+ "" a\t\tOutput color image as RGB or YCbCr with auto detection"",', '+ ""             when sectioning image into columns x rows using the -S cols:rows option"",', '+ ""             when sectioning image into columns x rows using the -S cols:rows option"",', '+ ""             increase the level of detail. Note: Tiffcrop may be compiled with"",', '+ ""             -DDEVELMODE to enable additional very low level debug reporting."",', '+ ""   Format:txt|raw  Format any logged data as ASCII text or raw binary "",', '+                                       uint32 tw, uint32 tl,', '+                                       tsample_t spp, uint16 bps)', '+   {', '+   int status = 1;', '+   tsample_t sample = 0;', '+   tsample_t count = spp;', '+   uint32 row, col, trow;', '+   uint32 nrow, ncol;', '+   uint32 dst_rowsize, shift_width;', '+   uint32 bytes_per_sample, bytes_per_pixel;', '+   uint32 trailing_bits, prev_trailing_bits;', '+   uint32 tile_rowsize  = TIFFTileRowSize(in);', '+   uint32 src_offset, dst_offset;', '+   uint32 row_offset, col_offset;', '+   uint8 *bufp = (uint8*) buf;', '+   unsigned char *src = NULL;', '+   unsigned char *dst = NULL;', '+   tsize_t tbytes = 0, tile_buffsize = 0;', '+   tsize_t tilesize = TIFFTileSize(in);', '+   unsigned char *tilebuf = NULL;', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   bytes_per_pixel  = ((bps * spp) + 7) / 8;', '+ ', '+   if ((bps % 8) == 0)', '+     shift_width = 0;', '+   else', '+     {', '+     if (bytes_per_pixel < (bytes_per_sample + 1))', '+       shift_width = bytes_per_pixel;', '+     else', '+       shift_width = bytes_per_sample + 1;', '+     }', '+ ', '+   tile_buffsize = tilesize;', '+ ', '+   if (tilesize < (tsize_t)(tl * tile_rowsize))', '+     {', '+ #ifdef DEBUG2', '+     TIFFError(""readContigTilesIntoBuffer"",', '+ \t      ""Tilesize %lu is too small, using alternate calculation %u"",', '+               tilesize, tl * tile_rowsize);', '+ #endif', '+     tile_buffsize = tl * tile_rowsize;', '+     }', '+ ', '+   tilebuf = _TIFFmalloc(tile_buffsize);', '+   if (tilebuf == 0)', '+     return 0;', '+ ', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   for (row = 0; row < imagelength; row += tl)', '+     {', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       {', '+       tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);', '+       if (tbytes < tilesize  && !ignore)', '+         {', '+ \tTIFFError(TIFFFileName(in),', '+ \t\t  ""Error, can\'t read tile at row %lu col %lu, Read %lu bytes of %lu"",', '+ \t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,', '+                   (unsigned long)tilesize);', '+ \t\t  status = 0;', '+                   _TIFFfree(tilebuf);', '+ \t\t  return status;', '+ ', '+       row_offset = row * dst_rowsize;', '+       col_offset = ((col * bps * spp) + 7)/ 8;', '+       bufp = buf + row_offset + col_offset;', '+       if (col + tw > imagewidth)', '+ \tncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       if (((bps % 8) == 0) && (count == spp))', '+         {', '+ \tfor (trow = 0; trow < nrow; trow++)', '+           {', '+ \t  src_offset = trow * tile_rowsize;', '+ \t  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);', '+           bufp += (imagewidth * bps * spp) / 8;', '+ \t  }', '+         }', '+       else', '+         {', '+         prev_trailing_bits = trailing_bits = 0;', '+         trailing_bits = (ncol * bps * spp) % 8;', '+ ', '+ \tfor (trow = 0; trow < nrow; trow++)', '+           {', '+ \t  src_offset = trow * tile_rowsize;', '+           src = tilebuf + src_offset;', '+ \t  dst_offset = (row + trow) * dst_rowsize;', '+           dst = buf + dst_offset + col_offset;', '+           switch (shift_width)', '+             {', '+             case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,', '+                                                    spp, bps, count, 0, ncol))', '+                       {', '+ \t\t      TIFFError(""readContigTilesIntoBuffer"",', '+                                 ""Unable to extract row %d from tile %lu"",', '+ \t\t\t\trow, (unsigned long)TIFFCurrentTile(in));', '+ \t\t      return (1);', '+ \t\t      }', '+ \t\t    break;', '+             case 1: if (bps == 1)', '+                       {', '+                       if (extractContigSamplesShifted8bits (src, dst, ncol,', '+                                                             sample, spp,', '+                                                             bps, count,', '+                                                             0, ncol,', '+                                                             prev_trailing_bits))', '+                         {', '+ \t\t        TIFFError(""readContigTilesIntoBuffer"",', '+                                   ""Unable to extract row %d from tile %lu"",', '+ \t\t\t\t  row, (unsigned long)TIFFCurrentTile(in));', '+ \t\t        return (1);', '+ \t\t        }', '+ \t\t      break;', '+ \t\t      }', '+                     else', '+                       if (extractContigSamplesShifted16bits (src, dst, ncol,', '+                                                              sample, spp,', '+                                                              bps, count,', '+                                                              0, ncol,', '+                                                              prev_trailing_bits))', '+                         {', '+ \t\t        TIFFError(""readContigTilesIntoBuffer"",', '+                                   ""Unable to extract row %d from tile %lu"",', '+ \t\t\t  \t  row, (unsigned long)TIFFCurrentTile(in));', '+ \t\t        return (1);', '+ \t\t        }', '+ \t            break;', '+             case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,', '+                                                            sample, spp,', '+                                                            bps, count,', '+                                                            0, ncol,', '+                                                            prev_trailing_bits))', '+                       {', '+ \t\t      TIFFError(""readContigTilesIntoBuffer"",', '+                                 ""Unable to extract row %d from tile %lu"",', '+ \t\t  \t        row, (unsigned long)TIFFCurrentTile(in));', '+ \t\t      return (1);', '+ \t\t      }', '+ \t\t    break;', '+             case 3:', '+             case 4:', '+             case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,', '+                                                            sample, spp,', '+                                                            bps, count,', '+                                                            0, ncol,', '+                                                            prev_trailing_bits))', '+                       {', '+ \t\t      TIFFError(""readContigTilesIntoBuffer"",', '+                                 ""Unable to extract row %d from tile %lu"",', '+ \t\t\t        row, (unsigned long)TIFFCurrentTile(in));', '+ \t\t      return (1);', '+ \t\t      }', '+ \t\t    break;', '+             default: TIFFError(""readContigTilesIntoBuffer"", ""Unsupported bit depth %d"", bps);', '+ \t\t     return (1);', '+ \t    }', '+           }', '+         prev_trailing_bits += trailing_bits;', '+         if (prev_trailing_bits > 7)', '+ \t  prev_trailing_bits-= 8;', '+       }', '+     }', '+   _TIFFfree(tilebuf);', '+   return status;', '+   }', '+ ', '+ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,', '+ \t\t\t\t\t uint32 imagelength, uint32 imagewidth,', '+                                          uint32 tw, uint32 tl,', '+                                          uint16 spp, uint16 bps)', '+   {', '+   int     i, status = 1, sample;', '+   int     shift_width, bytes_per_pixel;', '+   uint16  bytes_per_sample;', '+   tsize_t tbytes = 0, tilesize = TIFFTileSize(in);', '+   tsample_t s;', '+   uint8*  bufp = (uint8*)obuf;', '+   unsigned char *srcbuffs[MAX_SAMPLES];', '+   unsigned char *tbuff = NULL;', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+ ', '+   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)', '+     {', '+     srcbuffs[sample] = NULL;', '+     tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);', '+     if (!tbuff)', '+       {', '+       TIFFError (""readSeparateStripsIntoBuffer"",', '+                  ""Unable to allocate tile read buffer for sample %d"", sample);', '+       for (i = 0; i < sample; i++)', '+         _TIFFfree (srcbuffs[i]);', '+       return 0;', '+       }', '+     srcbuffs[sample] = tbuff;', '+     }', '+   for (row = 0; row < imagelength; row += tl)', '+     {', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       {', '+       for (s = 0; s < spp; s++)', '+       if (col + tw > imagewidth)', '+         ncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       row_offset = row * (((imagewidth * spp * bps) + 7) / 8);', '+       col_offset = ((col * spp * bps) + 7) / 8;', '+       bufp = obuf + row_offset + col_offset;', '+ ', '+       if ((bps % 8) == 0)', '+         {', '+         if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,', '+ \t\t\t\t\t    tw, spp, bps, NULL, 0, 0))', '+ \t  {', '+           status = 0;', '+           break;', '+       \t  }', '+ \t}', '+       else', '+         {', '+         bytes_per_pixel  = ((bps * spp) + 7) / 8;', '+         if (bytes_per_pixel < (bytes_per_sample + 1))', '+           shift_width = bytes_per_pixel;', '+         else', '+           shift_width = bytes_per_sample + 1;', '+ ', '+         switch (shift_width)', '+           {', '+           case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       NULL, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+       \t            }', '+ \t          break;', '+           case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       NULL, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+ \t\t    }', '+ \t          break;', '+           case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       NULL, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+        \t            }', '+                   break;', '+           case 4:', '+           case 5:', '+           case 6:', '+           case 7:', '+           case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       NULL, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+ \t\t    }', '+ \t          break;', '+           default: TIFFError (""readSeparateTilesIntoBuffer"", ""Unsupported bit depth: %d"", bps);', '+                   status = 0;', '+                   break;', '+           }', '+         }', '+       }', '+     }', '+ ', '+   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)', '+     {', '+     tbuff = srcbuffs[sample];', '+     if (tbuff != NULL)', '+       _TIFFfree(tbuff);', '+     }', '+ ', '+   return status;', '+   }', '+ ', '+ static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)', '+   {', '+   uint32 row, nrows, rowsperstrip;', '+   tstrip_t strip = 0;', '+   tsize_t stripsize;', '+ ', '+   TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);', '+   for (row = 0; row < imagelength; row += rowsperstrip)', '+     {', '+     nrows = (row + rowsperstrip > imagelength) ?', '+ \t     imagelength - row : rowsperstrip;', '+     stripsize = TIFFVStripSize(out, nrows);', '+     if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0)', '+       {', '+       TIFFError(TIFFFileName(out), ""Error, can\'t write strip %u"", strip - 1);', '+       return 0;', '+       }', '+     buf += stripsize;', '+     }', '+   return 1;', '+   }', '+ ', '+       if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))', '+   _TIFFfree(obuf);', '+   return 1;', '+ }', '+ static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,', '+ \t\t\t\t       uint32 imagewidth, tsample_t spp,', '+                                        struct dump_opts* dump)', '+   {', '+   uint16 bps;', '+   uint32 tl, tw;', '+   uint32 row, col, nrow, ncol;', '+   uint32 src_rowsize, col_offset;', '+   uint32 tile_rowsize  = TIFFTileRowSize(out);', '+   uint8* bufp = (uint8*) buf;', '+   tsize_t tile_buffsize = 0;', '+   tsize_t tilesize = TIFFTileSize(out);', '+   unsigned char *tilebuf = NULL;', '+ ', '+   TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);', '+   TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);', '+   TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);', '+ ', '+   tile_buffsize = tilesize;', '+   if (tilesize < (tsize_t)(tl * tile_rowsize))', '+     {', '+ #ifdef DEBUG2', '+     TIFFError(""writeBufferToContigTiles"",', '+ \t      ""Tilesize %lu is too small, using alternate calculation %u"",', '+               tilesize, tl * tile_rowsize);', '+ #endif', '+     tile_buffsize = tl * tile_rowsize;', '+     }', '+   tilebuf = _TIFFmalloc(tile_buffsize);', '+   if (tilebuf == 0)', '+     return 0;', '+   src_rowsize = ((imagewidth * spp * bps) + 7) / 8;', '+   for (row = 0; row < imagelength; row += tl)', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       if (col + tw > imagewidth)', '+ \tncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       col_offset = (((col * bps * spp) + 7) / 8);', '+       bufp = buf + (row * src_rowsize) + col_offset;', '+       if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,', '+ \t\t\t\t\t   tw, 0, spp, spp, bps, dump) > 0)', '+ \tTIFFError(""writeBufferToContigTiles"",', '+                   ""Unable to extract data to tile for row %lu, col %lu"",', '+                   (unsigned long) row, (unsigned long)col);', '+ \t_TIFFfree(tilebuf);', '+ \treturn (0);', '+         }', '+       if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0)', '+ \tTIFFError(""writeBufferToContigTiles"",', '+ \t          ""Cannot write tile at %lu %lu"",', '+ \t          (unsigned long) col, (unsigned long) row);', '+ \t _TIFFfree(tilebuf);', '+     }', '+   _TIFFfree(tilebuf);', '+   tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));', '+   uint32 tl, tw;', '+   uint32 row, col, nrow, ncol;', '+   uint32 src_rowsize, col_offset;', '+   uint16 bps;', '+   tsample_t s;', '+   uint8* bufp = (uint8*) buf;', '+ ', '+   if (obuf == NULL)', '+     return 0;', '+ ', '+   TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);', '+   TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);', '+   TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);', '+   src_rowsize = ((imagewidth * spp * bps) + 7) / 8;', '+ ', '+   for (row = 0; row < imagelength; row += tl)', '+     {', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       {', '+       if (col + tw > imagewidth)', '+ \tncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       col_offset = (((col * bps * spp) + 7) / 8);', '+       bufp = buf + (row * src_rowsize) + col_offset;', '+ ', '+       for (s = 0; s < spp; s++)', '+         {', '+ \tif (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,', '+ \t\t\t\t\t     tw, s, 1, spp, bps, dump) > 0)', '+           {', '+ \t  TIFFError(""writeBufferToSeparateTiles"",', '+                     ""Unable to extract data to tile for row %lu, col %lu sample %d"",', '+                     (unsigned long) row, (unsigned long)col, (int)s);', '+ \t  _TIFFfree(obuf);', '+ \t  return (0);', '+           }', '+ ', '+ \tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0)', '+           {', '+ \t   TIFFError(""writeBufferToseparateTiles"",', '+ \t             ""Cannot write tile at %lu %lu sample %lu"",', '+ \t             (unsigned long) col, (unsigned long) row,', '+ \t             (unsigned long) s);', '+ \t   _TIFFfree(obuf);', '+ \t  return 0;', '+ \t  }', '+       }', '+     }', '+   _TIFFfree(obuf);', '+   return 1;', '+   {', '+   char* cp = NULL;', '+   if (strneq(opt, ""none"",4))', '+     {', '+     defcompression = COMPRESSION_NONE;', ""+     cp = strchr(opt, ':');"", '+     if (cp)', '+       {', ""+       if (cp[1] == 'r' )"", '+ \tjpegcolormode = JPEGCOLORMODE_RAW;', ""+       else if (cp[1] == 'a' )"", '+ \tjpegcolormode = JPEGCOLORMODE_RGB;', '+       }', '+     }', '+   else if (streq(opt, ""packbits""))', '+     {', '+     defcompression = COMPRESSION_PACKBITS;', '+     }', '+   else if (strneq(opt, ""jpeg"", 4))', '+     {', ""+     cp = strchr(opt, ':');"", '+     defcompression = COMPRESSION_JPEG;', '+     while ( cp )', '+       {', '+       if (isdigit((int)cp[1]))', '+ \tquality = atoi(cp+1);', ""+       else if (cp[1] == 'r' )"", '+ \tjpegcolormode = JPEGCOLORMODE_RAW;', ""+       else if (cp[1] == 'a' )"", '+ \tjpegcolormode = JPEGCOLORMODE_RGB;', '+       else', '+         usage();', ""+       cp = strchr(cp+1,':');"", '+       }', '+     }', '+   else if (strneq(opt, ""g3"", 2))', '+     {', '+     processG3Options(opt);', '+     defcompression = COMPRESSION_CCITTFAX3;', '+     }', '+   else if (streq(opt, ""g4""))', '+     {', '+     defcompression = COMPRESSION_CCITTFAX4;', '+     }', '+   else if (strneq(opt, ""lzw"", 3))', '+     {', ""+     cp = strchr(opt, ':');"", '+     if (cp)', '+       defpredictor = atoi(cp+1);', '+     defcompression = COMPRESSION_LZW;', '+     }', '+   else if (strneq(opt, ""zip"", 3))', '+     {', ""+     cp = strchr(opt, ':');"", '+     if (cp)', '+       defpredictor = atoi(cp+1);', '+     defcompression = COMPRESSION_ADOBE_DEFLATE;', '+    }', '+   else', '+     return (0);', '+   return (1);', '+   }', '+   {', '+   char buf[BUFSIZ];', '+   int i;', '+ ', '+   setbuf(stderr, buf);', '+   fprintf(stderr, ""\\n%s\\n"", TIFFGetVersion());', '+   for (i = 0; stuff[i] != NULL; i++)', '+     fprintf(stderr, ""%s\\n"", stuff[i]);', '+   exit(-1);', '+   }', '+       case \'v\': TIFFError(""Library Release"", ""%s"", TIFFGetVersion());', '+                 TIFFError (""Tiffcrop version"", ""%s, last updated: %s"",', '+   uint32 deftilewidth = (uint32) 0;', '+   uint32 deftilelength = (uint32) 0;', '+ \t    TIFFError (""Unable to open dump file for writing"", ""%s"", temp_filename);', '+ \t      TIFFError (""Unable to open dump file for writing"", ""%s"", temp_filename);', '+   \t                     tsample_t sample, uint16 spp, uint16 bps,', '+                              struct dump_opts *dump)', '+       case 1: if (bps == 1)', '+                 {', '+                 if (extractContigSamples8bits (src, dst, cols, sample,', '+                                                spp, bps, count, first_col, cols))', '+ \t          return (1);', '+ \t        break;', '+ \t\t}', '+ \t      else', '+                  if (extractContigSamples16bits (src, dst, cols, sample,', '+                                                  spp, bps, count, first_col, cols))', '+       case 2: if (extractContigSamples24bits (src, dst, cols, sample,', '+       case 3:', '+ static int', '+ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,', '+   \t                         uint32 imagewidth, uint32 tilewidth, tsample_t sample,', '+ \t\t\t\t uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump)', '+   int    shift_width, bytes_per_sample, bytes_per_pixel;', '+   uint32 src_rowsize, src_offset, row;', '+   uint32 dst_rowsize, dst_offset;', '+   uint8 *src, *dst;', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   bytes_per_pixel  = ((bps * spp) + 7) / 8;', '+   if ((bps % 8) == 0)', '+     shift_width = 0;', '+   else', '+     if (bytes_per_pixel < (bytes_per_sample + 1))', '+       shift_width = bytes_per_pixel;', '+     else', '+       shift_width = bytes_per_sample + 1;', '+     }', '+ ', '+   if ((dump->outfile != NULL) && (dump->level == 4))', '+     {', '+     dump_info  (dump->outfile, dump->format, ""extractContigSamplesToTileBuffer"",', '+                 ""Sample %d, %d rows"", sample + 1, rows + 1);', '+     }', '+ ', '+   src_rowsize = ((bps * spp * imagewidth) + 7) / 8;', '+   dst_rowsize = ((bps * tilewidth * count) + 7) / 8;', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     src_offset = row * src_rowsize;', '+     dst_offset = row * dst_rowsize;', '+     src = in + src_offset;', '+     dst = out + dst_offset;', '+ ', '+     switch (shift_width)', '+       {', '+       case 0: if (extractContigSamplesBytes (src, dst, cols, sample,', '+                                              spp, bps,  count, 0, cols))', '+                 return (1);', '+  \t      break;', '+       case 1: if (bps == 1)', '+                 {', '+                 if (extractContigSamples8bits (src, dst, cols, sample,', '+                                                spp, bps, count, 0, cols))', '+ \t          return (1);', '+ \t        break;', '+ \t\t}', '+ \t      else', '+                  if (extractContigSamples16bits (src, dst, cols, sample,', '+                                                  spp, bps, count, 0, cols))', '+ \t         return (1);', '+ \t      break;', '+       case 2: if (extractContigSamples24bits (src, dst, cols, sample,', '+                                               spp, bps,  count, 0, cols))', '+ \t         return (1);', '+ \t      break;', '+       case 3:', '+       case 4:', '+       case 5: if (extractContigSamples32bits (src, dst, cols, sample,', '+                                               spp, bps,  count, 0, cols))', '+ \t         return (1);', '+ \t      break;', '+       default: TIFFError (""extractContigSamplesToTileBuffer"", ""Unsupported bit depth: %d"", bps);', '+ \t       return (1);', '+     if ((dump->outfile != NULL) && (dump->level == 4))', '+       dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);', '+   return (0);', '+ ', '+ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf, uint32 length, uint32 width,', '+                                        tsample_t spp, struct dump_opts * dump)', '+   int32  bytes_read = 0;', '+   uint16 nstrips   = TIFFNumberOfStrips(in);', '+   uint32 stripsize = TIFFStripSize(in);', '+   uint32 rows = 0, strip;', '+   uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);', '+   tsize_t scanline_size = TIFFScanlineSize(in);', '+ ', '+   for (strip = 0; strip < nstrips; strip++)', '+     {', '+     bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);', '+     rows = bytes_read / scanline_size;', '+     if (bytes_read != (int32)stripsize)', '+       TIFFError("""", ""Bytes read %lu does not match reported strip size %lu"",', '+ \t\t(unsigned long) bytes_read, (unsigned long)stripsize);', '+ ', '+     if (bytes_read < 0 && !ignore)', '+       {', '+       TIFFError("""", ""Error reading strip %lu after %lu rows"",', '+ \t\t(unsigned long) strip, (unsigned long)rows);', '+       return 0;', '+       }', '+     bufp += bytes_read;', '+     }', '+ static int', '+ combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,', '+                              uint32 cols, uint32 rows, uint16 spp, uint16 bps,', '+                              FILE *dumpfile, int format, int level)', '+   {', '+   int i, bytes_per_sample;', '+   uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;', '+   unsigned char *src;', '+   unsigned char *dst;', '+   tsample_t s;', '+ ', '+   src = srcbuffs[0];', '+   dst = out;', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateSamplesBytes"",""Invalid buffer address"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+ ', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   dst_rowsize = ((bps * spp * cols) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     {', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       for (s = 0; s < spp; s++)', '+         {', '+         dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Input data, Sample %d"", s);', '+         dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));', '+         }', '+       }', '+     dst = out + (row * dst_rowsize);', '+     row_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       col_offset = row_offset + (col * (bps / 8));', '+       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)', '+         {', '+         src = srcbuffs[s] + col_offset;', '+         for (i = 0; i < bytes_per_sample; i++)', '+           *(dst + i) = *(src + i);', '+         src += bytes_per_sample;', '+         dst += bytes_per_sample;', '+         }', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Output data, combined samples"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols,', '+                             uint32 rows, uint16 spp, uint16 bps,', '+   uint32 src_rowsize, dst_rowsize, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+       matchbits = maskbits << (8 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         buff1 = ((*src) & matchbits) << (src_bit);', '+ ', '+         if (ready_bits >= 8)', '+           {', '+           *dst++ = buff2;', '+           buff2 = buff1;', '+           ready_bits -= 8;', '+           strcpy (action, ""Flush"");', '+           }', '+         else', '+           {', '+           buff2 = (buff2 | (buff1 >> ready_bits));', '+           strcpy (action, ""Update"");', '+           }', '+         ready_bits += bps;', '+         if ((dumpfile != NULL) && (level == 3))', '+           {', '+           dump_info (dumpfile, format, """",', '+           dump_byte (dumpfile, format, ""Match bits"", matchbits);', '+           dump_byte (dumpfile, format, ""Src   bits"", *src);', '+           dump_byte (dumpfile, format, ""Buff1 bits"", buff1);', '+           dump_byte (dumpfile, format, ""Buff2 bits"", buff2);', '+           dump_info (dumpfile, format, """",""%s"", action);', '+ \t  }', '+         }', '+     if (ready_bits > 0)', '+       buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));', '+       *dst++ = buff1;', '+       if ((dumpfile != NULL) && (level == 3))', '+         {', '+         dump_info (dumpfile, format, """",', '+         }', '+     if ((dumpfile != NULL) && (level >= 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamples8bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+ ', '+ combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols,', '+                               uint32 rows, uint16 spp, uint16 bps,', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (16 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[1] = *src;', '+           swapbuff[0] = *(src + 1);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+ \t  }', '+ ', '+ \tbuff1 = *((uint16 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 8)', '+ \t  {', '+ \t    bytebuff = (buff2 >> 8);', '+ \t    *dst++ = bytebuff;', '+ \t    ready_bits -= 8;', '+ \t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ ', '+ \t  dump_short (dumpfile, format, ""Match bits"", matchbits);', '+ \t  dump_data  (dumpfile, format, ""Src   bits"", src, 2);', '+ \t  dump_short (dumpfile, format, ""Buff1 bits"", buff1);', '+ \t  dump_short (dumpfile, format, ""Buff2 bits"", buff2);', '+ \t  dump_byte  (dumpfile, format, ""Write byte"", bytebuff);', '+ \t  dump_info  (dumpfile, format, """",""Ready bits:  %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+       }', '+ ', '+     if (ready_bits > 0)', '+       {', '+       bytebuff = (buff2 >> 8);', '+       *dst++ = bytebuff;', '+       if ((dumpfile != NULL) && (level == 3))', '+ \t{', '+ \tdump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, src_byte, src_bit, dst - out);', '+ \tdump_byte (dumpfile, format, ""Final bits"", bytebuff);', '+ \t}', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamples16bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols,', '+                               uint32 rows, uint16 spp, uint16 bps,', '+ \t                      FILE *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0, bytes_per_sample = 0;', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   uint32 maskbits = 0, matchbits = 0;', '+   uint32 buff1 = 0, buff2 = 0;', '+   uint8  bytebuff1 = 0, bytebuff2 = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   unsigned char  swapbuff[4];', '+   char           action[8];', '+ ', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateSamples24bits"",""Invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   dst_rowsize = ((bps * cols * spp) + 7) / 8;', '+   maskbits =  (uint32)-1 >> ( 32 - bps);', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (32 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[3] = *src;', '+           swapbuff[2] = *(src + 1);', '+           swapbuff[1] = *(src + 2);', '+           swapbuff[0] = *(src + 3);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+           swapbuff[2] = *(src + 2);', '+           swapbuff[3] = *(src + 3);', '+ \t  }', '+ ', '+ \tbuff1 = *((uint32 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 16)', '+ \t  {', '+ \t    bytebuff1 = (buff2 >> 24);', '+ \t    *dst++ = bytebuff1;', '+ \t    bytebuff2 = (buff2 >> 16);', '+ \t    *dst++ = bytebuff2;', '+ \t    ready_bits -= 16;', '+ ', '+ \t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_long (dumpfile, format, ""Match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+ \t  dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+ \t  dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+ \t  dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+ \t  dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+ \t  dump_info (dumpfile, format, """",""Ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+       }', '+     while (ready_bits > 0)', '+       {', '+ \tbytebuff1 = (buff2 >> 24);', '+ \t*dst++ = bytebuff1;', '+ \tbuff2 = (buff2 << 8);', '+ \tbytebuff2 = bytebuff1;', '+ \tready_bits -= 8;', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 3))', '+       {', '+       dump_info (dumpfile, format, """",', '+ \t\t   ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t   row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""Match bits "", matchbits);', '+       dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamples24bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,', '+                               uint32 rows, uint16 spp, uint16 bps,', '+ \t                      FILE *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;', '+   uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;', '+   uint32 src_byte = 0, src_bit = 0;', '+   uint32 row, col;', '+   uint32 longbuff1 = 0, longbuff2 = 0;', '+   uint64 maskbits = 0, matchbits = 0;', '+   uint64 buff1 = 0, buff2 = 0, buff3 = 0;', '+   uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   unsigned char  swapbuff1[4];', '+   unsigned char  swapbuff2[4];', '+   char           action[8];', '+ ', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateSamples32bits"",""Invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   dst_rowsize = ((bps * cols * spp) + 7) / 8;', '+   maskbits =  (uint64)-1 >> ( 64 - bps);', '+   shift_width = ((bps + 7) / 8) + 1;', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (64 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \t{', '+ \tsrc = in[s] + src_offset + src_byte;', '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff1[3] = *src;', '+ \t  swapbuff1[2] = *(src + 1);', '+ \t  swapbuff1[1] = *(src + 2);', '+ \t  swapbuff1[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff1[0] = *src;', '+ \t  swapbuff1[1] = *(src + 1);', '+ \t  swapbuff1[2] = *(src + 2);', '+ \t  swapbuff1[3] = *(src + 3);', '+ \t  }', '+         longbuff1 = *((uint32 *)swapbuff1);', '+ ', ""+ \tmemset (swapbuff2, '\\0', sizeof(swapbuff2));"", '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff2[3] = *src;', '+ \t  swapbuff2[2] = *(src + 1);', '+ \t  swapbuff2[1] = *(src + 2);', '+ \t  swapbuff2[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff2[0] = *src;', '+ \t  swapbuff2[1] = *(src + 1);', '+ \t  swapbuff2[2] = *(src + 2);', '+ \t  swapbuff2[3] = *(src + 3);', '+ \t  }', '+ ', '+ \tlongbuff2 = *((uint32 *)swapbuff2);', '+ \tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;', '+ \tbuff1 = (buff3 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 32)', '+ \t  {', '+ \t  bytebuff1 = (buff2 >> 56);', '+ \t  *dst++ = bytebuff1;', '+ \t  bytebuff2 = (buff2 >> 48);', '+ \t  *dst++ = bytebuff2;', '+ \t  bytebuff3 = (buff2 >> 40);', '+ \t  *dst++ = bytebuff3;', '+ \t  bytebuff4 = (buff2 >> 32);', '+ \t  *dst++ = bytebuff4;', '+ \t  ready_bits -= 32;', '+ ', '+ \t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));', '+ \t  strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t     ""Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_wide (dumpfile, format, ""Match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""Src   bits "", src, 8);', '+ \t  dump_wide (dumpfile, format, ""Buff1 bits "", buff1);', '+ \t  dump_wide (dumpfile, format, ""Buff2 bits "", buff2);', '+ \t  dump_info (dumpfile, format, """", ""Ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+       }', '+     while (ready_bits > 0)', '+       {', '+       bytebuff1 = (buff2 >> 56);', '+       *dst++ = bytebuff1;', '+       buff2 = (buff2 << 8);', '+       ready_bits -= 8;', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 3))', '+       {', '+       dump_info (dumpfile, format, """",', '+ \t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""Match bits "", matchbits);', '+       dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamples32bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,', '+                                  uint32 cols, uint32 rows, uint32 imagewidth,', '+                                  uint32 tw, uint16 spp, uint16 bps,', '+                                  FILE *dumpfile, int format, int level)', '+   {', '+   int i, bytes_per_sample;', '+   uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;', '+   unsigned char *src;', '+   unsigned char *dst;', '+   tsample_t s;', '+ ', '+   src = srcbuffs[0];', '+   dst = out;', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateTileSamplesBytes"",""Invalid buffer address"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = imagewidth * bytes_per_sample * spp;', '+   for (row = 0; row < rows; row++)', '+     {', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       for (s = 0; s < spp; s++)', '+         dump_info (dumpfile, format, ""combineSeparateTileSamplesBytes"",""Input data, Sample %d"", s);', '+         dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));', '+       }', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+ #ifdef DEVELMODE', '+     TIFFError("""",""Tile row %4d, Src offset %6d   Dst offset %6d"",', '+               row, src_offset, dst - out);', '+ #endif', '+     for (col = 0; col < cols; col++)', '+       {', '+       col_offset = src_offset + (col * (bps / 8));', '+       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)', '+         {', '+         src = srcbuffs[s] + col_offset;', '+         for (i = 0; i < bytes_per_sample; i++)', '+           *(dst + i) = *(src + i);', '+         dst += bytes_per_sample;', '+         }', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateTileSamplesBytes"",""Output data, combined samples"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                  uint32 rows, uint32 imagewidth,', '+                                  uint32 tw, uint16 spp, uint16 bps,', '+  \t                         FILE *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0;', '+   uint32 src_rowsize, dst_rowsize, src_offset;', '+   uint32 bit_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   uint8  maskbits = 0, matchbits = 0;', '+   uint8  buff1 = 0, buff2 = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   char           action[32];', '+ ', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateTileSamples8bits"",""Invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   maskbits =  (uint8)-1 >> ( 8 - bps);', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (8 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+         {', '+ \tsrc = in[s] + src_offset + src_byte;', '+         buff1 = ((*src) & matchbits) << (src_bit);', '+ ', '+         if (ready_bits >= 8)', '+           {', '+           *dst++ = buff2;', '+           buff2 = buff1;', '+           ready_bits -= 8;', '+           strcpy (action, ""Flush"");', '+           }', '+         else', '+           {', '+           buff2 = (buff2 | (buff1 >> ready_bits));', '+           strcpy (action, ""Update"");', '+           }', '+         ready_bits += bps;', '+ ', '+         if ((dumpfile != NULL) && (level == 3))', '+           {', '+           dump_info (dumpfile, format, """",', '+                    ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+           dump_byte (dumpfile, format, ""Match bits"", matchbits);', '+           dump_byte (dumpfile, format, ""Src   bits"", *src);', '+           dump_byte (dumpfile, format, ""Buff1 bits"", buff1);', '+           dump_byte (dumpfile, format, ""Buff2 bits"", buff2);', '+           dump_info (dumpfile, format, """",""%s"", action);', '+ \t  }', '+       }', '+     if (ready_bits > 0)', '+       {', '+       buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));', '+       *dst++ = buff1;', '+ \t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t         row + 1, col + 1, src_byte, src_bit, dst - out);', '+                  dump_byte (dumpfile, format, ""Final bits"", buff1);', '+ ', '+     if ((dumpfile != NULL) && (level >= 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateTileSamples8bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                   uint32 rows, uint32 imagewidth,', '+                                   uint32 tw, uint16 spp, uint16 bps,', '+  \t                          FILE *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0;', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   uint16 maskbits = 0, matchbits = 0;', '+   uint16 buff1 = 0, buff2 = 0;', '+   uint8  bytebuff = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   unsigned char  swapbuff[2];', '+   char           action[8];', '+ ', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateTileSamples16bits"",""Invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   maskbits = (uint16)-1 >> (16 - bps);', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (16 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+         {', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[1] = *src;', '+           swapbuff[0] = *(src + 1);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+ \t  }', '+ ', '+ \tbuff1 = *((uint16 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 8)', '+ \t  {', '+ \t    bytebuff = (buff2 >> 8);', '+ \t    *dst++ = bytebuff;', '+ \t    ready_bits -= 8;', '+ \t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ ', '+ \t  dump_short (dumpfile, format, ""Match bits"", matchbits);', '+ \t  dump_data  (dumpfile, format, ""Src   bits"", src, 2);', '+ \t  dump_short (dumpfile, format, ""Buff1 bits"", buff1);', '+ \t  dump_short (dumpfile, format, ""Buff2 bits"", buff2);', '+ \t  dump_byte  (dumpfile, format, ""Write byte"", bytebuff);', '+ \t  dump_info  (dumpfile, format, """",""Ready bits:  %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+       }', '+ ', '+     if (ready_bits > 0)', '+       {', '+       bytebuff = (buff2 >> 8);', '+       *dst++ = bytebuff;', '+       if ((dumpfile != NULL) && (level == 3))', '+ \t{', '+ \tdump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, src_byte, src_bit, dst - out);', '+ \tdump_byte (dumpfile, format, ""Final bits"", bytebuff);', '+ \t}', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       dump_info (dumpfile, format, ""combineSeparateTileSamples16bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+ combineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                   uint32 rows, uint32 imagewidth,', '+                                   uint32 tw, uint16 spp, uint16 bps,', '+  \t                          FILE *dumpfile, int format, int level)', '+   int    ready_bits = 0;', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+     TIFFError(""combineSeparateTileSamples24bits"",""Invalid input or output buffer"");', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+       matchbits = maskbits << (32 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[3] = *src;', '+           swapbuff[2] = *(src + 1);', '+           swapbuff[1] = *(src + 2);', '+           swapbuff[0] = *(src + 3);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+           swapbuff[2] = *(src + 2);', '+           swapbuff[3] = *(src + 3);', '+ \t  }', '+ \tbuff1 = *((uint32 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 16)', '+ \t  {', '+ \t    bytebuff1 = (buff2 >> 24);', '+ \t    *dst++ = bytebuff1;', '+ \t    bytebuff2 = (buff2 >> 16);', '+ \t    *dst++ = bytebuff2;', '+ \t    ready_bits -= 16;', '+ ', '+ \t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_long (dumpfile, format, ""Match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+ \t  dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+ \t  dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+ \t  dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+ \t  dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+ \t  dump_info (dumpfile, format, """",""Ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+     while (ready_bits > 0)', '+       {', '+ \tbytebuff1 = (buff2 >> 24);', '+ \t*dst++ = bytebuff1;', '+ \tbuff2 = (buff2 << 8);', '+ \tbytebuff2 = bytebuff1;', '+ \tready_bits -= 8;', '+       }', '+     if ((dumpfile != NULL) && (level == 3))', '+       {', '+       dump_info (dumpfile, format, """",', '+ \t\t   ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t   row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""Match bits "", matchbits);', '+       dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '+       }', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateTileSamples24bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+ combineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                   uint32 rows, uint32 imagewidth,', '+                                   uint32 tw, uint16 spp, uint16 bps,', '+  \t                          FILE *dumpfile, int format, int level)', '+   int    ready_bits = 0, shift_width = 0;', '+   uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;', '+   uint32 row, col;', '+     TIFFError(""combineSeparateTileSamples32bits"",""Invalid input or output buffer"");', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+       matchbits = maskbits << (64 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \t{', '+ \tsrc = in[s] + src_offset + src_byte;', '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff1[3] = *src;', '+ \t  swapbuff1[2] = *(src + 1);', '+ \t  swapbuff1[1] = *(src + 2);', '+ \t  swapbuff1[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff1[0] = *src;', '+ \t  swapbuff1[1] = *(src + 1);', '+ \t  swapbuff1[2] = *(src + 2);', '+ \t  swapbuff1[3] = *(src + 3);', '+ \t  }', '+         longbuff1 = *((uint32 *)swapbuff1);', '+ ', ""+ \tmemset (swapbuff2, '\\0', sizeof(swapbuff2));"", '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff2[3] = *src;', '+ \t  swapbuff2[2] = *(src + 1);', '+ \t  swapbuff2[1] = *(src + 2);', '+ \t  swapbuff2[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff2[0] = *src;', '+ \t  swapbuff2[1] = *(src + 1);', '+ \t  swapbuff2[2] = *(src + 2);', '+ \t  swapbuff2[3] = *(src + 3);', '+ \t  }', '+ \tlongbuff2 = *((uint32 *)swapbuff2);', '+ \tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;', '+ \tbuff1 = (buff3 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 32)', '+ \t  {', '+ \t  bytebuff1 = (buff2 >> 56);', '+ \t  *dst++ = bytebuff1;', '+ \t  bytebuff2 = (buff2 >> 48);', '+ \t  *dst++ = bytebuff2;', '+ \t  bytebuff3 = (buff2 >> 40);', '+ \t  *dst++ = bytebuff3;', '+ \t  bytebuff4 = (buff2 >> 32);', '+ \t  *dst++ = bytebuff4;', '+ \t  ready_bits -= 32;', '+ \t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));', '+ \t  strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t     ""Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_wide (dumpfile, format, ""Match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""Src   bits "", src, 8);', '+ \t  dump_wide (dumpfile, format, ""Buff1 bits "", buff1);', '+ \t  dump_wide (dumpfile, format, ""Buff2 bits "", buff2);', '+ \t  dump_info (dumpfile, format, """", ""Ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+     while (ready_bits > 0)', '+       bytebuff1 = (buff2 >> 56);', '+       *dst++ = bytebuff1;', '+       buff2 = (buff2 << 8);', '+       ready_bits -= 8;', '+     if ((dumpfile != NULL) && (level == 3))', '+       dump_info (dumpfile, format, """",', '+ \t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""Match bits "", matchbits);', '+       dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '+       }', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateTileSamples32bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '+       }', '+ ', '+ ', '+   int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;', '+   int32  bytes_read = 0;', '+   uint16 bps, nstrips, planar, strips_per_sample;', '+   uint32 src_rowsize, dst_rowsize, rows_processed, rps;', '+   uint32 rows_this_strip = 0;', '+   tstrip_t  strip;', '+   tsize_t stripsize    = TIFFStripSize(in);', ""+   memset (srcbuffs, '\\0', sizeof(srcbuffs));"", '+   TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '+   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);', '+   TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);', '+   if (rps > length)', '+     rps = length;', '+ ', '+   nstrips = TIFFNumberOfStrips(in);', '+   strips_per_sample = nstrips /spp;', '+ ', '+     buff = _TIFFmalloc(stripsize);', '+                  ""Unable to allocate strip read buffer for sample %d"", s);', '+   rows_processed = 0;', '+   for (j = 0; (j < strips_per_sample) && (result == 1); j++)', '+       strip = (s * strips_per_sample) + j;', '+       bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);', '+       rows_this_strip = bytes_read / src_rowsize;', '+       if (bytes_read < 0 && !ignore)', '+ \t          ""Error, can\'t read strip %lu for sample %d"",', '+          \t   (unsigned long) strip, s + 1);', '+         result = 0;', '+         break;', '+ #ifdef DEVELMODE', '+       TIFFError("""", ""Strip %2d, read %5d bytes for %4d scanlines, shift width %d"",', '+ \t\tstrip, bytes_read, rows_this_strip, shift_width);', '+ #endif', '+     if (rps > rows_this_strip)', '+       rps = rows_this_strip;', '+     dst = obuf + (dst_rowsize * rows_processed);', '+       if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,', '+                                        spp, bps, dump->infile,', '+                                        dump->format, dump->level))', '+         result = 0;', '+         break;', '+         case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,', '+                   result = 0;', '+                   break;', '+       \t          }', '+         case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,', '+                                                   spp, bps, dump->infile,', '+                                                   dump->format, dump->level))', '+                   result = 0;', '+                   break;', '+ \t        break;', '+         case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,', '+                                                   spp, bps, dump->infile,', '+                                                   dump->format, dump->level))', '+ \t          {', '+                   result = 0;', '+                   break;', '+        \t          }', '+         case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,', '+                                                   spp, bps, dump->infile,', '+                                                   dump->format, dump->level))', '+                   result = 0;', '+                   break;', '+ \t        break;', '+                   result = 0;', '+                   break;', '+         }', '+ ', '+     if ((rows_processed + rps) > length)', '+       {', '+       rows_processed = length;', '+       rps = length - rows_processed;', '+       }', '+     else', '+       rows_processed += rps;', '+   return (result);', '+     if (((image->xres == 0) || (image->yres == 0)) &&', '+          (crop->res_unit != RESUNIT_NONE) &&', '+ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)', '+   float    xres = 0.0, yres = 0.0;', '+   uint16   nstrips = 0, ntiles = 0, planar = 0;', '+   uint16   bps = 0, spp = 0, res_unit = 0;', '+   uint16   photometric = 0, orientation = 0, input_compression = 0;', '+   uint32   width = 0, length = 0;', '+   uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;', '+   uint32   tile_rowsize = 0;', '+   if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &photometric))', '+     TIFFError(""loadImage"",""Image lacks Photometric interpreation tag"");', '+   if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))', '+     TIFFError(""loadimage"",""Image lacks image width tag"");', '+   if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))', '+     TIFFError(""loadimage"",""Image lacks image length tag"");', '+   TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);', '+   TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);', '+   if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))', '+     res_unit = RESUNIT_INCH;', '+   if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))', '+     input_compression = COMPRESSION_NONE;', '+     TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);', '+     TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);', '+ ', '+     tile_rowsize  = TIFFTileRowSize(in);', '+ ', '+     if (buffsize < (uint32)(ntiles * tl * tile_rowsize))', '+       {', '+       buffsize = ntiles * tl * tile_rowsize;', '+ #ifdef DEBUG2', '+       TIFFError(""loadImage"",', '+ \t        ""Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu"",', '+                 tlsize, (unsigned long)buffsize);', '+ #endif', '+       }', '+ ', '+                  ""Tilesize: %u, Number of Tiles: %u, Tile row size: %u"",', '+                  tlsize, ntiles, tile_rowsize);', '+     if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))', '+       {', '+       buffsize =  ((length * width * spp * bps) + 7) / 8;', '+ #ifdef DEBUG2', '+       TIFFError(""loadImage"",', '+ \t        ""Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu"",', '+                 stsize, (unsigned long)buffsize);', '+ #endif', '+       }', '+ ', '+ ', '+   if (input_compression == COMPRESSION_JPEG)', '+     {', '+     jpegcolormode = JPEGCOLORMODE_RGB;', '+     TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '+     }', '+ ', '+ \t     if (!(readContigStripsIntoBuffer(in, read_buff, length, width, spp, dump)))', '+ \t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))', '+ \t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))', '+                case 1: if (bps == 1)', '+                          {', '+                          if (extractContigSamplesShifted8bits (src, dst, img_width,', '+                            {', '+ \t\t           TIFFError(""extractCompositeRegions"",', '+                                      ""Unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+ \t\t         break;', '+ \t\t\t }', '+                        else', '+                          if (extractContigSamplesShifted16bits (src, dst, img_width,', '+                                                                 sample, spp, bps, count,', '+                                                                 first_col, last_col + 1,', '+                                                                 prev_trailing_bits))', '+                            {', '+ \t\t           TIFFError(""extractCompositeRegions"",', '+                                      ""Unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+                case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '+                case 3:', '+                case 1: if (bps == 1)', '+                          {', '+                          if (extractContigSamplesShifted8bits (src, dst, img_width,', '+                            {', '+ \t\t           TIFFError(""extractCompositeRegions"",', '+                                      ""Unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+ \t\t         break;', '+ \t\t\t }', '+                        else', '+                          if (extractContigSamplesShifted16bits (src, dst, img_width,', '+                                                                 sample, spp, bps, count,', '+                                                                 first_col, last_col + 1,', '+                                                                 prev_trailing_bits))', '+                            {', '+ \t\t           TIFFError(""extractCompositeRegions"",', '+                                      ""Unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+               case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '+                case 3:', '+       case 1: if (bps == 1)', '+                 {', '+                 if (extractContigSamplesShifted8bits (src, dst, img_width,', '+                                                       sample, spp, bps, count,', '+                                                       first_col, last_col + 1,', '+                                                       prev_trailing_bits))', '+                   {', '+ \t\t  TIFFError(""extractSeparateRegion"",', '+                             ""Unable to extract row %d"", row);', '+ \t\t  return (1);', '+ \t\t  }', '+ \t\t  break;', '+               else', '+                 if (extractContigSamplesShifted16bits (src, dst, img_width,', '+                                                        sample, spp, bps, count,', '+                                                        first_col, last_col + 1,', '+                                                        prev_trailing_bits))', '+                   {', '+ \t\t  TIFFError(""extractSeparateRegion"",', '+                             ""Unable to extract row %d"", row);', '+ \t\t  return (1);', '+ \t\t  }', '+       case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '+       case 3:', '+       case 4:', '+       case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,', '+ #ifdef DEVELMODE', '+ #ifdef DEVELMODE', '+ #ifdef DEVELMODE', '+ #ifdef DEVELMODE', '+   uint16 input_compression, input_photometric;', '+   uint16 input_jpeg_colormode, input_planar;', '+ ', '+   TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression);', '+     {', '+     if (input_compression == COMPRESSION_OJPEG)', '+       {', '+       TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);', '+       compression = COMPRESSION_JPEG;', '+       }', '+     else', '+       CopyField(TIFFTAG_COMPRESSION, compression);', '+     }', '+   TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);', '+ #ifdef DEBUG2', '+   TIFFError(""writeSingleSection"", ""Input compression: %s"",', '+ \t    (input_compression == COMPRESSION_OJPEG) ? ""Old Jpeg"" :', '+ \t    ((input_compression == COMPRESSION_JPEG) ?  ""New Jpeg"" : ""Non Jpeg""));', '+ #endif', '+   if (compression == COMPRESSION_JPEG)', '+     {', '+     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric))', '+       {', '+       if (input_photometric == PHOTOMETRIC_RGB)', '+         {', '+ \tif (jpegcolormode == JPEGCOLORMODE_RGB)', '+ \t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);', '+ \telse', '+ \t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);', '+ \t}', '+       else', '+ \tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);', '+     }', '+   else', '+       TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?', '+ ', '+   if (((TIFFTAG_PHOTOMETRIC == PHOTOMETRIC_LOGL) ||', '+        (TIFFTAG_PHOTOMETRIC ==  PHOTOMETRIC_LOGLUV)) &&', '+       ((compression != COMPRESSION_SGILOG) &&', '+        (compression != COMPRESSION_SGILOG24)))', '+     {', '+     TIFFError(""writeSingleSection"",', '+               ""LogL and LogLuv data require SGI_LOG or SGI_LOG24"");', '+     return (-1);', '+     }', '+ ', '+     if (tilewidth == (uint32) 0)', '+     if (tilelength == (uint32) 0)', '+     if (tilewidth == 0 || tilelength == 0)', '+       TIFFDefaultTileSize(out, &tilewidth, &tilelength);', '+ \tif (rowsperstrip == (uint32) 0)', '+           {', '+ \t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))', '+ \t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);', '+           if (compression != COMPRESSION_JPEG)', '+             {', '+   \t    if (rowsperstrip > length)', '+ \t      rowsperstrip = length;', '+ \t    }', '+ \telse', '+           if (rowsperstrip == (uint32) -1)', '+ \t    rowsperstrip = length;', '+ \tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);', '+ ', '+   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);', '+          if (((bps % 8) == 0) || ((bps % 12) == 0))', '+ \t   {', '+            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);', '+ \t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '+            }', '+          else', '+            {', '+ \t   TIFFError(""writeCroppedImage"",', '+                      ""JPEG compression requires 8 or 12 bits per sample"");', '+            return (-1);', '+            }', '+       writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);', '+       writeBufferToContigStrips (out, sect_buff, length);', '+   uint16 input_compression, input_photometric;', '+   uint16 input_jpeg_colormode, input_planar;', '+ ', '+   TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression);', '+     {', '+     if (input_compression == COMPRESSION_OJPEG)', '+       {', '+       TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);', '+       compression = COMPRESSION_JPEG;', '+       }', '+     else', '+       CopyField(TIFFTAG_COMPRESSION, compression);', '+     }', '+   TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);', '+ #ifdef DEBUG2', '+   TIFFError(""writeCroppedImage"", ""Input compression: %s"",', '+ \t    (input_compression == COMPRESSION_OJPEG) ? ""Old Jpeg"" :', '+ \t    ((input_compression == COMPRESSION_JPEG) ?  ""New Jpeg"" : ""Non Jpeg""));', '+ #endif', '+   if (compression == COMPRESSION_JPEG)', '+     {', '+     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric))', '+       {', '+       if (input_photometric == PHOTOMETRIC_RGB)', '+         {', '+ \tif (jpegcolormode == JPEGCOLORMODE_RGB)', '+ \t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);', '+ \telse', '+ \t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);', '+ \t}', '+       else', '+ \tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);', '+       }', '+     }', '+ ', '+   if (((TIFFTAG_PHOTOMETRIC == PHOTOMETRIC_LOGL) ||', '+        (TIFFTAG_PHOTOMETRIC ==  PHOTOMETRIC_LOGLUV)) &&', '+       ((compression != COMPRESSION_SGILOG) &&', '+        (compression != COMPRESSION_SGILOG24)))', '+     {', '+     TIFFError(""writeCroppedImage"",', '+               ""LogL and LogLuv data require SGI_LOG or SGI_LOG24"");', '+     return (-1);', '+     }', '+ ', '+     if (tilewidth == (uint32) 0)', '+     if (tilelength == (uint32) 0)', '+     if (tilewidth == 0 || tilelength == 0)', '+       TIFFDefaultTileSize(out, &tilewidth, &tilelength);', '+           if (compression != COMPRESSION_JPEG)', '+             {', '+   \t    if (rowsperstrip > length)', '+ \t      rowsperstrip = length;', '+ ', '+   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);', '+          if (((bps % 8) == 0) || ((bps % 12) == 0))', '+ \t   {', '+            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);', '+ \t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '+            }', '+          else', '+            {', '+ \t   TIFFError(""writeCroppedImage"",', '+                      ""JPEG compression requires 8 or 12 bits per sample"");', '+            return (-1);', '+            }', '+         if (bps != 1)', '+           {', '+ \t  TIFFError(""writeCroppedImage"",', '+             ""Group 3/4 compression is not usable with bps > 1"");', '+           return (-1);', '+ \t  }', '+ \t break;', '+     case COMPRESSION_NONE:', '+          break;', '+     default: break;', '+       writeBufferToContigTiles (out, crop_buff, length, width, spp, dump);', '+       writeBufferToContigStrips (out, crop_buff, length);', '+   uint8    match_bits = 0, mask_bits = 0;', '+   mask_bits =  (uint8)-1 >> ( 8 - bps);', '+       match_bits = mask_bits << (8 - src_bit - bps);', '+       buff1 = ((*src) & match_bits) << (src_bit);', '+ ', '+   uint32   src_byte = 0, high_bit = 0;', '+   uint16   match_bits = 0, mask_bits = 0;', '+   mask_bits =  (uint16)-1 >> (16 - bps);', '+         high_bit  = bit_offset % 8;', '+         high_bit  = (bit_offset + (sample * bps)) % 8;', '+       match_bits = mask_bits << (16 - high_bit - bps);', '+       buff1 = (buff1 & match_bits) << (high_bit);', '+   uint32   src_byte = 0, high_bit = 0;', '+   uint32   match_bits = 0, mask_bits = 0;', '+   mask_bits =  (uint32)-1 >> (32 - bps);', '+         high_bit  = bit_offset % 8;', '+         high_bit  = (bit_offset + (sample * bps)) % 8;', '+       match_bits = mask_bits << (32 - high_bit - bps);', '+       buff1 = (buff1 & match_bits) << (high_bit);', '+   uint32 src_byte = 0, high_bit = 0;', '+   uint64 mask_bits = 0, match_bits = 0;', '+   mask_bits =  (uint64)-1 >> (64 - bps);', '+         high_bit  = bit_offset % 8;', '+         high_bit  = (bit_offset + (sample * bps)) % 8;', '+       match_bits = mask_bits << (64 - high_bit - bps);', '+       buff1 = (buff3 & match_bits) << (high_bit);', '- static uint32 tilewidth;', '- static uint32 tilelength;', '- ', '- static uint16 config;', '- static uint16 compression;', '- static uint16 predictor;', '- static uint16 fillorder;', '- static uint32 rowsperstrip;', '- static uint32 g3opts;', '- static int    jpegcolormode = JPEGCOLORMODE_RGB;', '- static int readContigStripsIntoBuffer   (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '- static int readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int writeBufferToContigStrips    (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '- static int writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '- static int extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, int, int,', '-                                          tsample_t, uint16, uint16, struct dump_opts *);', '- static void cpStripToTile (uint8*, uint8*, uint32, uint32, int, int);', '- static void cpSeparateBufToContigBuf(uint8 *, uint8 *, uint32, uint32 ,', '- \t\t\t\t     int, int, tsample_t, int);', '- ', '-                                        uint32, uint32, tsample_t, uint16,', '-                                        FILE *, int, int);', '- ', '- static   char tiffcrop_version_id[] = ""2.0"";', '- static   char tiffcrop_rev_date[] = ""01-06-2009"";', '- "" #\t\tSet compression quality level (0-100, default 75)"",', '- "" r\t\tOutput color image as RGB rather than YCbCr"",', '- ""             increase the level of detail. The program must be compiled with"",', '- ""             -DDEBUG -DDEBUG2 to enable full debug reporting"",', '- ""   format:txt|raw  Format any logged data as ASCII text or raw binary "",', '-                                       tsample_t spp)', '- {', '- \tint status = 1;', '- \ttdata_t tilebuf = _TIFFmalloc(TIFFTileSize(in));', '- \tuint32 imagew = TIFFScanlineSize(in);', '- \tuint32 tilew  = TIFFTileRowSize(in);', '- \tint iskew = imagew - tilew;', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tw, tl;', '- \tuint32 row;', '- ', '- \t(void) spp;', '- \tif (tilebuf == 0)', '- \t\treturn 0;', '- \t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);', '- \t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);', '- ', '- \tfor (row = 0; row < imagelength; row += tl) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0', '- \t\t\t    && !ignore) {', '- \t\t\t\tTIFFError(TIFFFileName(in),', '- \t\t\t\t\t  ""Error, can\'t read tile at %lu %lu"",', '- \t\t\t\t\t  (unsigned long) col,', '- \t\t\t\t\t  (unsigned long) row);', '- \t\t\t\tstatus = 0;', '- \t\t\t\tgoto done;', '- \t\t\t}', '- \t\t\tif (colb + tilew > imagew) {', '- \t\t\t\tuint32 width = imagew - colb;', '- \t\t\t\tuint32 oskew = tilew - width;', '- \t\t\t\tcpStripToTile(bufp + colb,', '-                                               tilebuf, nrow, width,', '-                                               oskew + iskew, oskew );', '- \t\t\t} else', '- \t\t\t\tcpStripToTile(bufp + colb,', '-                                               tilebuf, nrow, tilew,', '-                                               iskew, 0);', '- \t\t\tcolb += tilew;', '- \t\t}', '- \t\tbufp += imagew * nrow;', '- done:', '- \t_TIFFfree(tilebuf);', '- \treturn status;', '- }', '- static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *buf,', '-             uint32 imagelength, uint32 imagewidth, uint16 spp)', '- {', '- \tint status = 1;', '- \tuint32 imagew = TIFFRasterScanlineSize(in);', '- \tuint32 tilew = TIFFTileRowSize(in);', '- \tint iskew  = imagew - tilew*spp;', '- \ttdata_t tilebuf = _TIFFmalloc(TIFFTileSize(in));', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tw, tl;', '- \tuint32 row;', '-         uint16 bps, bytes_per_sample;', '- ', '- \tif (tilebuf == 0)', '- \t\treturn 0;', '- \t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);', '- \t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);', '- \t(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '-         assert( bps % 8 == 0 );', '-         bytes_per_sample = bps/8;', '- ', '- \tfor (row = 0; row < imagelength; row += tl) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\ttsample_t s;', '- ', '- \t\t\tfor (s = 0; s < spp; s++) {', '- \t\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0', '- \t\t\t\t    && !ignore) {', '- \t\t\t\t\tTIFFError(TIFFFileName(in),', '- \t\t\t\t\t  ""Error, can\'t read tile at %lu %lu, ""', '- \t\t\t\t\t  ""sample %lu"",', '- \t\t\t\t\t  (unsigned long) col,', '- \t\t\t\t\t  (unsigned long) row,', '- \t\t\t\t\t  (unsigned long) s);', '- \t\t\t\t\tstatus = 0;', '- \t\t\t\t\tgoto done;', '- \t\t\t\t}', '- \t\t\t\tif (colb + tilew*spp > imagew) {', '- \t\t\t\t\tuint32 width = imagew - colb;', '- \t\t\t\t\tint oskew = tilew*spp - width;', '- \t\t\t\t\tcpSeparateBufToContigBuf(', '-                                             bufp+colb+s*bytes_per_sample,', '- \t\t\t\t\t    tilebuf, nrow,', '-                                             width/(spp*bytes_per_sample),', '- \t\t\t\t\t    oskew + iskew,', '-                                             oskew/spp, spp,', '-                                             bytes_per_sample);', '- \t\t\t\t} else', '- \t\t\t\t\tcpSeparateBufToContigBuf(', '-                                             bufp+colb+s*bytes_per_sample,', '- \t\t\t\t\t    tilebuf, nrow, tw,', '- \t\t\t\t\t    iskew, 0, spp,', '-                                             bytes_per_sample);', '- \t\t\t}', '- \t\t\tcolb += tilew*spp;', '- \t\t}', '- \t\tbufp += imagew * nrow;', '- done:', '- \t_TIFFfree(tilebuf);', '- \treturn status;', '- }', '- static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength,', '-                                      uint32 imagewidth, tsample_t spp)', '- {', '- \tuint32 row, rowsperstrip;', '- \ttstrip_t strip = 0;', '- ', '- \t(void) imagewidth; (void) spp;', '- \t(void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);', '- \tfor (row = 0; row < imagelength; row += rowsperstrip) {', '- \t\tuint32 nrows = (row+rowsperstrip > imagelength) ?', '- \t\t    imagelength-row : rowsperstrip;', '- \t\ttsize_t stripsize = TIFFVStripSize(out, nrows);', '- \t\tif (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0) {', '- \t\t\tTIFFError(TIFFFileName(out),', '- \t\t\t\t  ""Error, can\'t write strip %u"", strip - 1);', '- \t\t\treturn 0;', '- \t\t}', '- \t\tbuf += stripsize;', '- \treturn 1;', '- }', '-       if (extractContigSamplesToBuffer(obuf, src, nrows, width, 0, 0, s, spp, bps, dump))', '-   _TIFFfree(obuf);', '- }', '- ', '- static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,', '-                                      uint32 imagewidth, tsample_t spp)', '- {', '- \tuint32 imagew = TIFFScanlineSize(out);', '- \tuint32 tilew  = TIFFTileRowSize(out);', '- \tint iskew = imagew - tilew;', '- \ttdata_t obuf = _TIFFmalloc(TIFFTileSize(out));', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tl, tw;', '- \tuint32 row;', '- ', '- \t(void) spp;', '- \tif (obuf == NULL)', '- \t\treturn 0;', '- \t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);', '- \t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);', '- \tfor (row = 0; row < imagelength; row += tilelength) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\tif (colb + tilew > imagew) {', '- \t\t\t\tuint32 width = imagew - colb;', '- \t\t\t\tint oskew = tilew - width;', '- \t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,', '- \t\t\t\t    oskew, oskew + iskew);', '- \t\t\t} else', '- \t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,', '- \t\t\t\t    0, iskew);', '- \t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {', '- \t\t\t\tTIFFError(TIFFFileName(out),', '- \t\t\t\t\t  ""Error, can\'t write tile at %lu %lu"",', '- \t\t\t\t\t  (unsigned long) col,', '- \t\t\t\t\t  (unsigned long) row);', '- \t\t\t\t_TIFFfree(obuf);', '- \t\t\t\treturn 0;', '- \t\t\t}', '- \t\t\tcolb += tilew;', '- \t\t}', '- \t\tbufp += nrow * imagew;', '- \t}', '- \t_TIFFfree(obuf);', '- \treturn 1;', '- }', '- \tuint32 imagew = TIFFScanlineSize(out);', '- \ttsize_t tilew  = TIFFTileRowSize(out);', '- \tuint32 iimagew = TIFFRasterScanlineSize(out);', '- \tint iskew = iimagew - tilew*spp;', '- \ttdata_t obuf = _TIFFmalloc(TIFFTileSize(out));', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tl, tw;', '- \tuint32 row;', '-         uint16 bps, bytes_per_sample;', '- ', '- \tif (obuf == NULL)', '- \t\treturn 0;', '- \t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);', '- \t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);', '- \t(void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);', '-         assert( bps % 8 == 0 );', '-         bytes_per_sample = (bps + 7)/8;', '- ', '- \tfor (row = 0; row < imagelength; row += tl) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\ttsample_t s;', '- \t\t\tfor (s = 0; s < spp; s++) {', '- \t\t\t\tif (colb + tilew > imagew) {', '- \t\t\t\t\tuint32 width = (imagew - colb);', '- \t\t\t\t\tint oskew = tilew - width;', '- ', '- \t\t\t\t  extractContigSamplesToBuffer(obuf,', '- \t\t\t\t\t    bufp + (colb*spp) + s,', '- \t\t\t\t\t    nrow, width/bytes_per_sample,', '- \t\t\t\t\t    oskew, (oskew*spp)+iskew, s,', '- \t\t\t\t\t    spp, bps, dump);', '- \t\t\t\t} else', '- \t\t\t\t    extractContigSamplesToBuffer(obuf,', '- \t\t\t\t\t    bufp + (colb*spp) + s,', '- \t\t\t\t\t    nrow, tilewidth,', '- \t\t\t\t\t    0, iskew, s, spp,', '- \t\t\t\t\t    bps, dump);', '- \t\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {', '- \t\t\t\t\tTIFFError(TIFFFileName(out),', '- \t\t\t\t\t""Error, can\'t write tile at %lu %lu ""', '- \t\t\t\t\t""sample %lu"",', '- \t\t\t\t\t(unsigned long) col,', '- \t\t\t\t\t(unsigned long) row,', '- \t\t\t\t\t(unsigned long) s);', '- \t\t\t\t\t_TIFFfree(obuf);', '- \t\t\t\t\treturn 0;', '- \t\t\t\t}', '- \t\t\t}', '- \t\t\tcolb += tilew;', '- \t\t}', '- \t\tbufp += nrow * iimagew;', '- \t_TIFFfree(obuf);', '- \treturn 1;', '- }', '- {', '- \tif (streq(opt, ""none"")) {', '- \t\tdefcompression = COMPRESSION_NONE;', '- \t} else if (streq(opt, ""packbits"")) {', '- \t\tdefcompression = COMPRESSION_PACKBITS;', '- \t} else if (strneq(opt, ""jpeg"", 4)) {', ""- \t\tchar* cp = strchr(opt, ':');"", '- ', '-                 defcompression = COMPRESSION_JPEG;', '-                 while( cp )', '-                 {', '-                     if (isdigit((int)cp[1]))', '- \t\t\tquality = atoi(cp+1);', ""-                     else if (cp[1] == 'r' )"", '- \t\t\tjpegcolormode = JPEGCOLORMODE_RAW;', '-                     else', '-                         usage();', ""-                     cp = strchr(cp+1,':');"", '-                 }', '- \t} else if (strneq(opt, ""g3"", 2)) {', '- \t\tprocessG3Options(opt);', '- \t\tdefcompression = COMPRESSION_CCITTFAX3;', '- \t} else if (streq(opt, ""g4"")) {', '- \t\tdefcompression = COMPRESSION_CCITTFAX4;', '- \t} else if (strneq(opt, ""lzw"", 3)) {', ""- \t\tchar* cp = strchr(opt, ':');"", '- \t\tif (cp)', '- \t\t\tdefpredictor = atoi(cp+1);', '- \t\tdefcompression = COMPRESSION_LZW;', '- \t} else if (strneq(opt, ""zip"", 3)) {', ""- \t\tchar* cp = strchr(opt, ':');"", '- \t\tif (cp)', '- \t\t\tdefpredictor = atoi(cp+1);', '- \t\tdefcompression = COMPRESSION_ADOBE_DEFLATE;', '- \t} else', '- \t\treturn (0);', '- \treturn (1);', '- }', '- {', '- \tchar buf[BUFSIZ];', '- \tint i;', '- ', '- \tsetbuf(stderr, buf);', '-         fprintf(stderr, ""\\n%s\\n"", TIFFGetVersion());', '- \tfor (i = 0; stuff[i] != NULL; i++)', '- \t\tfprintf(stderr, ""%s\\n"", stuff[i]);', '- \texit(-1);', '- }', '- static void', '- cpStripToTile(uint8* out, uint8* in,', '- \tuint32 rows, uint32 cols, int outskew, int inskew)', '- {', '- \twhile (rows-- > 0) {', '- \t\tuint32 j = cols;', '- \t\twhile (j-- > 0)', '- \t\t\t*out++ = *in++;', '- \t\tout += outskew;', '- \t\tin += inskew;', '- \t}', '- }', '- ', '- ', '-       case \'v\': TIFFError (""Tiffcrop version"", ""%s, last updated: %s"",', '-   uint32 deftilewidth = (uint32) -1;', '-   uint32 deftilelength = (uint32) -1;', '-   extern int   optind;', '- \t    TIFFError (""Unable to open dump file %s for writing"", ""%s"", temp_filename);', '- \t    TIFFError (""Unable to open dump file %s for writing"", ""%s"", temp_filename);', '- ', '-   \t                     int outskew, int inskew, tsample_t sample,', '-                              uint16 spp, uint16 bps, struct dump_opts *dump)', '-       case 1: if (extractContigSamples8bits (src, dst, cols, sample,', '-                                              spp, bps, count, first_col, cols))', '-       case 2: if (extractContigSamples16bits (src, dst, cols, sample,', '-       case 3: if (extractContigSamples24bits (src, dst, cols, sample,', '-                                               spp, bps,  count, first_col, cols))', '- \t         return (1);', '-               break;', '- ', '-     out += outskew;', '-     in += inskew;', '- static void', '- cpSeparateBufToContigBuf(uint8  *out, uint8 *in, uint32 rows, uint32 cols,', '-                          int outskew, int inskew, tsample_t spp,', '-                          int bytes_per_sample)', '-   while (rows-- > 0)', '-     uint32 j = cols;', '-     while (j-- > 0)', '-       {', '-       int n = bytes_per_sample;', '-       while( n-- )', '-         {', '-         *out++ = *in++;', '-         }', '-       out += (spp-1)*bytes_per_sample;', '-     out += outskew;', '-     in += inskew;', '- static int readContigStripsIntoBuffer (TIFF* in, uint8* buf, uint32 imagelength,', '-                                          uint32 imagewidth, tsample_t spp)', '-   tsize_t scanlinesize = TIFFScanlineSize(in);', '-   uint32 row;', '- ', '-  (void) imagewidth; (void) spp;', '-  for (row = 0; row < imagelength; row++)', '-    {', '-    if (TIFFReadScanline(in, (tdata_t) bufp, row, 0) < 0', '- \t && !ignore)', '-      {', '-      TIFFError(TIFFFileName(in),""Error, can\'t read scanline %lu"",', '- \t       (unsigned long) row);', '-      return 0;', '-      }', '-    bufp += scanlinesize;', '-    }', '- combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 row,', '-                             uint32 cols, uint16 spp, uint16 bps,', '-   uint32 dst_rowsize;', '-   uint32 col, src_byte = 0, src_bit = 0;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '- ', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (8 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       buff1 = ((*src) & matchbits) << (src_bit);', '-       if (ready_bits >= 8)', '-         {', '-         *dst++ = buff2;', '-         buff2 = buff1;', '-         ready_bits -= 8;', '-         strcpy (action, ""Flush"");', '-         }', '-       else', '-         buff2 = (buff2 | (buff1 >> ready_bits));', '-         strcpy (action, ""Update"");', '-         }', '-       ready_bits += bps;', '-       if ((dumpfile != NULL) && (level == 3))', '-         {', '-         dump_info (dumpfile, format, """",', '-         dump_byte (dumpfile, format, ""Match bits"", matchbits);', '-         dump_byte (dumpfile, format, ""Src   bits"", *src);', '-         dump_byte (dumpfile, format, ""Buff1 bits"", buff1);', '-         dump_byte (dumpfile, format, ""Buff2 bits"", buff2);', '-         dump_info (dumpfile, format, """",""%s"", action);', '- \t}', '-     }', '-   if (ready_bits > 0)', '-     {', '-     buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));', '-     *dst++ = buff1;', '-     if ((dumpfile != NULL) && (level == 3))', '-       dump_info (dumpfile, format, """",', '-     }', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamples8bits"",""Output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '- ', '- combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 row,', '-                               uint32 cols, uint16 spp, uint16 bps,', '-   uint32 dst_rowsize;', '-   uint32 bit_offset;', '-   uint32 col, src_byte = 0, src_bit = 0;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (16 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       if (little_endian)', '-         swapbuff[1] = *src;', '-         swapbuff[0] = *(src + 1);', '-         }', '-       else', '-         swapbuff[0] = *src;', '-         swapbuff[1] = *(src + 1);', '-       buff1 = *((uint16 *)swapbuff);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-       if (ready_bits >= 8)', '-         bytebuff = (buff2 >> 8);', '-         *dst++ = bytebuff;', '-         ready_bits -= 8;', '-         buff2 = ((buff2 << 8) | (buff1 >> ready_bits));', '-         strcpy (action, ""Flush"");', '-       else', '-       ready_bits += bps;', '- \t    ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '- \t    row + 1, col + 1, s, src_byte, src_bit, dst - out);', '- ', '-         dump_short (dumpfile, format, ""Match bits"", matchbits);', '-         dump_data  (dumpfile, format, ""Src   bits"", src, 2);', '-         dump_short (dumpfile, format, ""Buff1 bits"", buff1);', '-         dump_short (dumpfile, format, ""Buff2 bits"", buff2);', '-         dump_byte  (dumpfile, format, ""Write byte"", bytebuff);', '-         dump_info  (dumpfile, format, """",""Ready bits:  %d, %s"", ready_bits, action);', '-     }', '-   if (ready_bits > 0)', '-     {', '-     bytebuff = (buff2 >> 8);', '-     *dst++ = bytebuff;', '-     if ((dumpfile != NULL) && (level == 3))', '-       dump_info (dumpfile, format, """",', '- \t  ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '- \t  row + 1, col + 1, src_byte, src_bit, dst - out);', '-       dump_byte (dumpfile, format, ""Final bits"", bytebuff);', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamples16bits"",""Output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '-     }', '- ', '- combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 row,', '-                               uint32 cols, uint16 spp, uint16 bps,', '- \t                      FILE *dumpfile, int format, int level)', '-   int    ready_bits = 0, bytes_per_sample = 0;', '-   uint32 dst_rowsize;', '-   uint32 bit_offset;', '-   uint32 col, src_byte = 0, src_bit = 0;', '-     TIFFError(""combineSeparateSamples24bits"",""Invalid input or output buffer"");', '-   bytes_per_sample = (bps + 7) / 8;', '-   dst_rowsize = ((bps * cols) + 7) / 8;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (32 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       if (little_endian)', '-         {', '-         swapbuff[3] = *src;', '-         swapbuff[2] = *(src + 1);', '-         swapbuff[1] = *(src + 2);', '-         swapbuff[0] = *(src + 3);', '-         }', '-       else', '-         {', '-         swapbuff[0] = *src;', '-         swapbuff[1] = *(src + 1);', '-         swapbuff[2] = *(src + 2);', '-         swapbuff[3] = *(src + 3);', '- \t}', '- ', '-       buff1 = *((uint32 *)swapbuff);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-       if (ready_bits >= 16)', '-         bytebuff1 = (buff2 >> 24);', '-         *dst++ = bytebuff1;', '-         bytebuff2 = (buff2 >> 16);', '-         *dst++ = bytebuff2;', '-         ready_bits -= 16;', '- ', '-         buff2 = ((buff2 << 16) | (buff1 >> ready_bits));', '-         strcpy (action, ""Flush"");', '-         }', '-       else', '-       ready_bits += bps;', '-       if ((dumpfile != NULL) && (level == 3))', '-         {', '-         dump_info (dumpfile, format, """",', '- \t        ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '- \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);', '-         dump_long (dumpfile, format, ""Match bits "", matchbits);', '-         dump_data (dumpfile, format, ""Src   bits "", src, 4);', '-         dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '-         dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '-         dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '-         dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '-         dump_info (dumpfile, format, """",""Ready bits:   %d, %s"", ready_bits, action);', '-         }', '-     }', '-   while (ready_bits > 0)', '-     {', '-     bytebuff1 = (buff2 >> 24);', '-     *dst++ = bytebuff1;', '-     buff2 = (buff2 << 8);', '-     bytebuff2 = bytebuff1;', '-     ready_bits -= 8;', '-     }', '-   if ((dumpfile != NULL) && (level == 3))', '-     {', '-     dump_info (dumpfile, format, """",', '-       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '-       row + 1, col + 1, src_byte, src_bit, dst - out);', '- ', '-     dump_long (dumpfile, format, ""Match bits "", matchbits);', '-     dump_data (dumpfile, format, ""Src   bits "", src, 4);', '-     dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '-     dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '-     dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '-     dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '-     dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '-     }', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamples24bits"",""Output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '- combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 row,', '-                               uint32 cols, uint16 spp, uint16 bps,', '- \t                      FILE *dumpfile, int format, int level)', '-   int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;', '-   uint32 dst_rowsize;', '-   uint32 bit_offset;', '-   uint32 col;', '-     TIFFError(""combineSeparateSamples32bits"",""Invalid input or output buffer"");', '-   bytes_per_sample = (bps + 7) / 8;', '-   dst_rowsize = ((bps * cols) + 7) / 8;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (64 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       if (little_endian)', '-         {', '-         swapbuff1[3] = *src;', '-         swapbuff1[2] = *(src + 1);', '-         swapbuff1[1] = *(src + 2);', '-         swapbuff1[0] = *(src + 3);', '-         }', '-       else', '-         {', '-         swapbuff1[0] = *src;', '-         swapbuff1[1] = *(src + 1);', '-         swapbuff1[2] = *(src + 2);', '-         swapbuff1[3] = *(src + 3);', '- \t}', '-       longbuff1 = *((uint32 *)swapbuff1);', '- ', ""-       memset (swapbuff2, '\\0', sizeof(swapbuff2));"", '-       if (little_endian)', '-         {', '-         swapbuff2[3] = *src;', '-         swapbuff2[2] = *(src + 1);', '-         swapbuff2[1] = *(src + 2);', '-         swapbuff2[0] = *(src + 3);', '-         }', '-       else', '-         {', '-         swapbuff2[0] = *src;', '-         swapbuff2[1] = *(src + 1);', '-         swapbuff2[2] = *(src + 2);', '-         swapbuff2[3] = *(src + 3);', '- \t}', '-       longbuff2 = *((uint32 *)swapbuff2);', '-       buff3 = ((uint64)longbuff1 << 32) | longbuff2;', '-       buff1 = (buff3 & matchbits) << (src_bit);', '-       if (ready_bits >= 32)', '-         {', '-         bytebuff1 = (buff2 >> 56);', '-         *dst++ = bytebuff1;', '-         bytebuff2 = (buff2 >> 48);', '-         *dst++ = bytebuff2;', '-         bytebuff3 = (buff2 >> 40);', '-         *dst++ = bytebuff3;', '-         bytebuff4 = (buff2 >> 32);', '-         *dst++ = bytebuff4;', '-         ready_bits -= 32;', '-         buff2 = ((buff2 << 32) | (buff1 >> ready_bits));', '-         strcpy (action, ""Flush"");', '-         }', '-       else', '-       ready_bits += bps;', '- ', '-       if ((dumpfile != NULL) && (level == 3))', '-         {', '-         dump_info (dumpfile, format, """",', '- \t    ""Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '- \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);', '-         dump_wide (dumpfile, format, ""Match bits "", matchbits);', '-         dump_data (dumpfile, format, ""Src   bits "", src, 8);', '-         dump_wide (dumpfile, format, ""Buff1 bits "", buff1);', '-         dump_wide (dumpfile, format, ""Buff2 bits "", buff2);', '-         dump_info (dumpfile, format, """", ""Ready bits:   %d, %s"", ready_bits, action);', '-         }', '-     }', '-   while (ready_bits > 0)', '-     {', '-     bytebuff1 = (buff2 >> 56);', '-     *dst++ = bytebuff1;', '-     buff2 = (buff2 << 8);', '-     ready_bits -= 8;', '-     }', '- ', '-   if ((dumpfile != NULL) && (level == 3))', '-     {', '-     dump_info (dumpfile, format, """",', '-       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '-       row + 1, col + 1, src_byte, src_bit, dst - out);', '- ', '-     dump_long (dumpfile, format, ""Match bits "", matchbits);', '-     dump_data (dumpfile, format, ""Src   bits "", src, 4);', '-     dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '-     dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '-     dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '-     dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '-     dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '-     }', '- ', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamples32bits"",""Output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '-     }', '- ', '-   return (0);', '- ', '- static int', '- combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,', '-                              uint32 row, uint32 width, uint16 spp, uint16 bps,', '-                              FILE *dumpfile, int format, int level)', '-   {', '-   int i, bytes_per_sample, bytes_per_pixel, dst_rowsize, shift_width;', '-   uint32 col, col_offset;', '-   unsigned char *src;', '-   unsigned char *dst;', '-   tsample_t s;', '- ', '-   src = srcbuffs[0];', '-   dst = out;', '-   if ((src == NULL) || (dst == NULL))', '-     {', '-     TIFFError(""combineSeparateSamplesBytes"",""Invalid buffer address"");', '-     return (1);', '-     }', '- ', '-   bytes_per_sample = (bps + 7) / 8;', '-   bytes_per_pixel  = ((bps * spp) + 7) / 8;', '-   if (bytes_per_pixel < (bytes_per_sample + 1))', '-     shift_width = bytes_per_sample;', '-   else', '-     shift_width = bytes_per_pixel;', '- ', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     for (s = 0; s < spp; s++)', '-       dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Input data, Sample %d"", s);', '-       dump_buffer(dumpfile, format, 1, width, row, srcbuffs[s]);', '-     }', '-   dst_rowsize = ((bps * spp * width) + 7) / 8;', '-   for (col = 0; col < width; col++)', '-     {', '-     col_offset = col * (bps / 8);', '-     for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)', '-       src = srcbuffs[s] + col_offset;', '-       for (i = 0; i < bytes_per_sample; i++)', '-         *(dst + i) = *(src + i);', '-       src += bytes_per_sample;', '-       dst += bytes_per_sample;', '-       }', '-     }', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Output data, combined samples"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '- ', '-   int i, bytes_per_sample, bytes_per_pixel, shift_width;', '-   uint16 bps;', '-   uint32 row, src_rowsize, dst_rowsize;', '-   (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '- ', '-     buff = _TIFFmalloc(src_rowsize);', '-                  ""Unable to allocate read buffer for sample %d"", s);', '-   for (row = 0; row < length; row++)', '-       if (TIFFReadScanline(in, buff, row, s) < 0', '- \t    && !ignore)', '- \t         ""Error, can\'t read scanline %lu for sample %d"",', '- \t\t  (unsigned long) row, s + 1);', '-         for (i = 0; i < s; i++)', '-           _TIFFfree (srcbuffs[i]);', '-         return (0);', '-     dst = obuf + (row * dst_rowsize);', '-       if (combineSeparateSamplesBytes (srcbuffs, dst, row, width,', '-                                       spp, bps, dump->infile,', '-                                       dump->format, dump->level))', '-         for (i = 0; i < spp; i++)', '-          _TIFFfree (srcbuffs[i]);', '- \treturn (0);', '-         case 1: if (combineSeparateSamples8bits (srcbuffs, dst, row, width,', '-                                                 spp, bps, dump->infile,', '-                                                 dump->format, dump->level))', '- \t          {', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- \t\t  }', '- \t\tbreak;', '-         case 2: if (combineSeparateSamples16bits (srcbuffs, dst, row, width,', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- \t\t  }', '-         case 3: if (combineSeparateSamples24bits (srcbuffs, dst, row, width,', '-                                                  spp, bps, dump->infile,', '-                                                  dump->format, dump->level))', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- ', '-         case 8: if (combineSeparateSamples32bits (srcbuffs, dst, row, width,', '-                                                  spp, bps, dump->infile,', '-                                                  dump->format, dump->level))', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- \t\tbreak;', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- \t}', '-   return (1);', '-     if (((image->xres == 0) || (image->yres == 0)) &&', '- loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned char **read_ptr)', '-   float    xres=0.0, yres=0.0;', '-   uint16   nstrips, ntiles, planar, bps, spp, res_unit, photometric, orientation;', '-   uint32   width, length, rowsperstrip;', '-   uint32   stsize, tlsize, buffsize, scanlinesize;', '-   TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);', '-   TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width);', '-   TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length);', '-   TIFFGetField(in, TIFFTAG_XRESOLUTION, &xres);', '-   TIFFGetField(in, TIFFTAG_YRESOLUTION, &yres);', '-   TIFFGetField(in, TIFFTAG_RESOLUTIONUNIT, &res_unit);', '-                  ""Tilesize: %u, Number of Tiles: %u, Scanline size: %u"",', '-                  tlsize, ntiles, scanlinesize);', ""-   _TIFFmemset(read_buff, '\\0', buffsize);"", '- \t   if (!(readContigStripsIntoBuffer(in, read_buff, length, width, spp)))', '- \t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, spp)))', '- \t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, spp)))', '-                case 1:  if (extractContigSamplesShifted8bits (src, dst, img_width,', '-                                                               sample, spp, bps, count,', '-                                                               first_col, last_col + 1,', '-                                                               prev_trailing_bits))', '-                           {', '- \t\t          TIFFError(""extractCompositeRegions"",', '-                                     ""Unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '- \t\t        break;', '-                case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,', '-                           {', '- \t\t          TIFFError(""extractCompositeRegions"",', '-                                     ""Unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '-                case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '-                case 1:  if (extractContigSamplesShifted8bits (src, dst, img_width,', '-                                                               sample, spp, bps, count,', '-                                                               first_col, last_col + 1,', '-                                                               prev_trailing_bits))', '-                           {', '- \t\t          TIFFError(""extractCompositeRegions"",', '-                                     ""Unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '- \t\t        break;', '-                case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,', '-                           {', '- \t\t          TIFFError(""extractCompositeRegions"",', '-                                     ""Unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '-                case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '-       case 1: if (extractContigSamplesShifted8bits (src, dst, img_width,', '-                                                     sample, spp, bps, count,', '-                                                     first_col, last_col + 1,', '-                                                     prev_trailing_bits))', '-                 {', '- \t        TIFFError(""extractSeparateRegion"",', '-                          ""Unable to extract row %d"", row);', '- \t\treturn (1);', '- \t\t}', '- \t      break;', '-      case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,', '-                                                      sample, spp, bps, count,', '-                                                      first_col, last_col + 1,', '-                                                      prev_trailing_bits))', '-                 {', '- \t\tTIFFError(""extractSeparateRegion"",', '-                           ""Unable to extract row %d"", row);', '- \t\treturn (1);', '-      case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '-      case 4:', '-      case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,', '- #ifdef DEBUG2', '- #ifdef DEBUG2', '- #ifdef DEBUG2', '- #ifdef DEBUG2', '- #ifdef DEBUG', '-   TIFFError("""",', '-     ""Writing %d sections for each original page. Hres: %3.2f Vres: %3.2f\\n"",', '-           page->rows * page->cols, hres, vres);', '- #endif', '- #ifdef DEBUG', '-     TIFFError ("""", ""\\nSection: %d, Width: %4d, Length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d\\n"",', '-              i + 1, width, length, sections[i].x1, sections[i].x2, sections[i].y1, sections[i].y2);', '- #endif', '- ', '- #ifdef DEBUG', '-   TIFFError ("""",', '- ""\\nWriting single section: Width %d Length: %d Hres: %4.1f, Vres: %4.1f\\n\\n"",', '- \t   width, length, hres, vres);', '- #endif', '-     CopyField(TIFFTAG_COMPRESSION, compression);', '- ', '-   if (compression == COMPRESSION_JPEG) {', '-     uint16 input_compression, input_photometric;', '-     if (TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)', '-         && input_compression == COMPRESSION_JPEG) {', '-           TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '-         }', '-     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) {', '- \tif(input_photometric == PHOTOMETRIC_RGB) {', '- \t   if (jpegcolormode == JPEGCOLORMODE_RGB)', '- \t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);', '- \t   else', '- \t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);', '- \t   } else', '- \t      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);', '-   else', '-        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?', '-     if (tilewidth == (uint32) -1)', '-     if (tilelength == (uint32) -1)', '-     if (tilewidth > width)', '-       tilewidth = width;', '-     if (tilelength > length)', '-       tilelength = length;', '- ', '- \tif (rowsperstrip == (uint32) 0) {', '- \t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip)) {', '- \t      rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);', '- \t     }', '- \t  if (rowsperstrip > length && rowsperstrip != (uint32)-1)', '- \t       rowsperstrip = length;', '- \telse if (rowsperstrip == (uint32) -1)', '- \t\trowsperstrip = length;', '- \t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);', '-          TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);', '- \t TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);', '-       {', '-       writeBufferToContigTiles (out, sect_buff, length, width, spp);', '-       }', '-       {', '-       writeBufferToContigStrips (out, sect_buff, length, width, spp);', '-       }', '-       {', '-       }', '-     CopyField(TIFFTAG_COMPRESSION, compression);', '- ', '-   if (compression == COMPRESSION_JPEG) {', '-     uint16 input_compression, input_photometric;', '-     if (TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)', '-         && input_compression == COMPRESSION_JPEG) {', '-           TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '-         }', '-     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) {', '- \tif(input_photometric == PHOTOMETRIC_RGB) {', '- \t   if (jpegcolormode == JPEGCOLORMODE_RGB)', '- \t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);', '- \t   else', '- \t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);', '- \t   } else', '- \t      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);', '-   }', '-     if (tilewidth == (uint32) -1)', '-     if (tilelength == (uint32) -1)', '-     if (tilewidth > width)', '-       tilewidth = width;', '-     if (tilelength > length)', '-       tilelength = length;', '- ', '-     TIFFDefaultTileSize(out, &tilewidth, &tilelength);', '-             {', '- \t  if (rowsperstrip > length)', '- \t    rowsperstrip = length;', '-          TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);', '- \t TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);', '- \tbreak;', '-       {', '-       writeBufferToContigTiles (out, crop_buff, length, width, spp);', '-       }', '-       {', '-       writeBufferToContigStrips (out, crop_buff, length, width, spp);', '-       }', '-       {', '-       }', '-   uint8    matchbits = 0, maskbits = 0;', '-   maskbits =  (uint8)-1 >> ( 8 - bps);', '-       matchbits = maskbits << (8 - src_bit - bps);', '-       buff1 = ((*src) & matchbits) << (src_bit);', '-   uint32   src_byte = 0, src_bit = 0;', '-   uint16   matchbits = 0, maskbits = 0;', '-   maskbits =  (uint16)-1 >> (16 - bps);', '-         src_bit  = bit_offset % 8;', '-         src_bit  = (bit_offset + (sample * bps)) % 8;', '-       matchbits = maskbits << (16 - src_bit - bps);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-   uint32   src_byte = 0, src_bit = 0;', '-   uint32   matchbits = 0, maskbits = 0;', '-   maskbits =  (uint32)-1 >> (32 - bps);', '-         src_bit  = bit_offset % 8;', '-         src_bit  = (bit_offset + (sample * bps)) % 8;', '-       matchbits = maskbits << (32 - src_bit - bps);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-   uint32 src_byte = 0, src_bit = 0;', '-   uint64 maskbits = 0, matchbits = 0;', '-   maskbits =  (uint64)-1 >> (64 - bps);', '-         src_bit  = bit_offset % 8;', '-         src_bit  = (bit_offset + (sample * bps)) % 8;', '-       matchbits = maskbits << (64 - src_bit - bps);', '-       buff1 = (buff3 & matchbits) << (src_bit);']]","[['+ static   char tiffcrop_version_id[] = ""2.1"";', '+ static   char tiffcrop_rev_date[] = ""09-18-2009"";', '+ ', '+ static uint32 tilewidth = 0;', '+ static uint32 tilelength = 0;', '+ ', '+ static uint16 config = 0;', '+ static uint16 compression = 0;', '+ static uint16 predictor = 0;', '+ static uint16 fillorder = 0;', '+ static uint32 rowsperstrip = 0;', '+ static uint32 g3opts = 0;', '+ static int  readcontigstripsintobuffer   (tiff*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  readseparatestripsintobuffer (tiff*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  readcontigtilesintobuffer    (tiff*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);', '+ static int  readseparatetilesintobuffer  (tiff*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);', '+ static int  writebuffertocontigstrips    (tiff*, uint8*, uint32);', '+ static int  writebuffertocontigtiles     (tiff*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  writebuffertoseparatestrips  (tiff*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  writebuffertoseparatetiles   (tiff*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  extractcontigsamplestobuffer (uint8 *, uint8 *, uint32, uint32, tsample_t,', '+                                          uint16, uint16, struct dump_opts *);', '+ static int extractcontigsamplestotilebuffer(uint8 *, uint8 *, uint32, uint32,', '+   \t                                    uint32, uint32, tsample_t, uint16,', '+ \t\t\t\t\t    uint16, uint16, struct dump_opts *);', '+ ', '+ \t\t\t\t\tuint32, uint32, tsample_t, uint16,', '+                                         file *, int, int);', '+ ', '+ static int combineseparatetilesamples8bits (uint8 *[], uint8 *, uint32, uint32,', '+                                             uint32, uint32, uint16, uint16,', '+                                             file *, int, int);', '+ static int combineseparatetilesamples16bits (uint8 *[], uint8 *, uint32, uint32,', '+                                              uint32, uint32, uint16, uint16,', '+                                              file *, int, int);', '+ static int combineseparatetilesamples24bits (uint8 *[], uint8 *, uint32, uint32,', '+                                              uint32, uint32, uint16, uint16,', '+                                              file *, int, int);', '+ static int combineseparatetilesamples32bits (uint8 *[], uint8 *, uint32, uint32,', '+                                              uint32, uint32, uint16, uint16,', '+                                              file *, int, int);', '+ static int combineseparatetilesamplesbytes (unsigned char *[], unsigned char *,', '+ \t\t\t  \t\t    uint32, uint32, uint32, uint32,', '+                                             tsample_t, uint16, file *, int, int);', '+ "" #\t\tset compression quality level (0-100, default 100)"",', '+ "" r\t\toutput color image as raw rgb rather than ycbcr"",', '+ "" a\t\toutput color image as rgb or ycbcr with auto detection"",', '+ ""             when sectioning image into columns x rows using the -s cols:rows option"",', '+ ""             when sectioning image into columns x rows using the -s cols:rows option"",', '+ ""             increase the level of detail. note: tiffcrop may be compiled with"",', '+ ""             -ddevelmode to enable additional very low level debug reporting."",', '+ ""   format:txt|raw  format any logged data as ascii text or raw binary "",', '+                                       uint32 tw, uint32 tl,', '+                                       tsample_t spp, uint16 bps)', '+   {', '+   int status = 1;', '+   tsample_t sample = 0;', '+   tsample_t count = spp;', '+   uint32 row, col, trow;', '+   uint32 nrow, ncol;', '+   uint32 dst_rowsize, shift_width;', '+   uint32 bytes_per_sample, bytes_per_pixel;', '+   uint32 trailing_bits, prev_trailing_bits;', '+   uint32 tile_rowsize  = tifftilerowsize(in);', '+   uint32 src_offset, dst_offset;', '+   uint32 row_offset, col_offset;', '+   uint8 *bufp = (uint8*) buf;', '+   unsigned char *src = null;', '+   unsigned char *dst = null;', '+   tsize_t tbytes = 0, tile_buffsize = 0;', '+   tsize_t tilesize = tifftilesize(in);', '+   unsigned char *tilebuf = null;', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   bytes_per_pixel  = ((bps * spp) + 7) / 8;', '+ ', '+   if ((bps % 8) == 0)', '+     shift_width = 0;', '+   else', '+     {', '+     if (bytes_per_pixel < (bytes_per_sample + 1))', '+       shift_width = bytes_per_pixel;', '+     else', '+       shift_width = bytes_per_sample + 1;', '+     }', '+ ', '+   tile_buffsize = tilesize;', '+ ', '+   if (tilesize < (tsize_t)(tl * tile_rowsize))', '+     {', '+ #ifdef debug2', '+     tifferror(""readcontigtilesintobuffer"",', '+ \t      ""tilesize %lu is too small, using alternate calculation %u"",', '+               tilesize, tl * tile_rowsize);', '+ #endif', '+     tile_buffsize = tl * tile_rowsize;', '+     }', '+ ', '+   tilebuf = _tiffmalloc(tile_buffsize);', '+   if (tilebuf == 0)', '+     return 0;', '+ ', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   for (row = 0; row < imagelength; row += tl)', '+     {', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       {', '+       tbytes = tiffreadtile(in, tilebuf, col, row, 0, 0);', '+       if (tbytes < tilesize  && !ignore)', '+         {', '+ \ttifferror(tifffilename(in),', '+ \t\t  ""error, can\'t read tile at row %lu col %lu, read %lu bytes of %lu"",', '+ \t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,', '+                   (unsigned long)tilesize);', '+ \t\t  status = 0;', '+                   _tifffree(tilebuf);', '+ \t\t  return status;', '+ ', '+       row_offset = row * dst_rowsize;', '+       col_offset = ((col * bps * spp) + 7)/ 8;', '+       bufp = buf + row_offset + col_offset;', '+       if (col + tw > imagewidth)', '+ \tncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       if (((bps % 8) == 0) && (count == spp))', '+         {', '+ \tfor (trow = 0; trow < nrow; trow++)', '+           {', '+ \t  src_offset = trow * tile_rowsize;', '+ \t  _tiffmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);', '+           bufp += (imagewidth * bps * spp) / 8;', '+ \t  }', '+         }', '+       else', '+         {', '+         prev_trailing_bits = trailing_bits = 0;', '+         trailing_bits = (ncol * bps * spp) % 8;', '+ ', '+ \tfor (trow = 0; trow < nrow; trow++)', '+           {', '+ \t  src_offset = trow * tile_rowsize;', '+           src = tilebuf + src_offset;', '+ \t  dst_offset = (row + trow) * dst_rowsize;', '+           dst = buf + dst_offset + col_offset;', '+           switch (shift_width)', '+             {', '+             case 0: if (extractcontigsamplesbytes (src, dst, ncol, sample,', '+                                                    spp, bps, count, 0, ncol))', '+                       {', '+ \t\t      tifferror(""readcontigtilesintobuffer"",', '+                                 ""unable to extract row %d from tile %lu"",', '+ \t\t\t\trow, (unsigned long)tiffcurrenttile(in));', '+ \t\t      return (1);', '+ \t\t      }', '+ \t\t    break;', '+             case 1: if (bps == 1)', '+                       {', '+                       if (extractcontigsamplesshifted8bits (src, dst, ncol,', '+                                                             sample, spp,', '+                                                             bps, count,', '+                                                             0, ncol,', '+                                                             prev_trailing_bits))', '+                         {', '+ \t\t        tifferror(""readcontigtilesintobuffer"",', '+                                   ""unable to extract row %d from tile %lu"",', '+ \t\t\t\t  row, (unsigned long)tiffcurrenttile(in));', '+ \t\t        return (1);', '+ \t\t        }', '+ \t\t      break;', '+ \t\t      }', '+                     else', '+                       if (extractcontigsamplesshifted16bits (src, dst, ncol,', '+                                                              sample, spp,', '+                                                              bps, count,', '+                                                              0, ncol,', '+                                                              prev_trailing_bits))', '+                         {', '+ \t\t        tifferror(""readcontigtilesintobuffer"",', '+                                   ""unable to extract row %d from tile %lu"",', '+ \t\t\t  \t  row, (unsigned long)tiffcurrenttile(in));', '+ \t\t        return (1);', '+ \t\t        }', '+ \t            break;', '+             case 2: if (extractcontigsamplesshifted24bits (src, dst, ncol,', '+                                                            sample, spp,', '+                                                            bps, count,', '+                                                            0, ncol,', '+                                                            prev_trailing_bits))', '+                       {', '+ \t\t      tifferror(""readcontigtilesintobuffer"",', '+                                 ""unable to extract row %d from tile %lu"",', '+ \t\t  \t        row, (unsigned long)tiffcurrenttile(in));', '+ \t\t      return (1);', '+ \t\t      }', '+ \t\t    break;', '+             case 3:', '+             case 4:', '+             case 5: if (extractcontigsamplesshifted32bits (src, dst, ncol,', '+                                                            sample, spp,', '+                                                            bps, count,', '+                                                            0, ncol,', '+                                                            prev_trailing_bits))', '+                       {', '+ \t\t      tifferror(""readcontigtilesintobuffer"",', '+                                 ""unable to extract row %d from tile %lu"",', '+ \t\t\t        row, (unsigned long)tiffcurrenttile(in));', '+ \t\t      return (1);', '+ \t\t      }', '+ \t\t    break;', '+             default: tifferror(""readcontigtilesintobuffer"", ""unsupported bit depth %d"", bps);', '+ \t\t     return (1);', '+ \t    }', '+           }', '+         prev_trailing_bits += trailing_bits;', '+         if (prev_trailing_bits > 7)', '+ \t  prev_trailing_bits-= 8;', '+       }', '+     }', '+   _tifffree(tilebuf);', '+   return status;', '+   }', '+ ', '+ static int  readseparatetilesintobuffer (tiff* in, uint8 *obuf,', '+ \t\t\t\t\t uint32 imagelength, uint32 imagewidth,', '+                                          uint32 tw, uint32 tl,', '+                                          uint16 spp, uint16 bps)', '+   {', '+   int     i, status = 1, sample;', '+   int     shift_width, bytes_per_pixel;', '+   uint16  bytes_per_sample;', '+   tsize_t tbytes = 0, tilesize = tifftilesize(in);', '+   tsample_t s;', '+   uint8*  bufp = (uint8*)obuf;', '+   unsigned char *srcbuffs[max_samples];', '+   unsigned char *tbuff = null;', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+ ', '+   for (sample = 0; (sample < spp) && (sample < max_samples); sample++)', '+     {', '+     srcbuffs[sample] = null;', '+     tbuff = (unsigned char *)_tiffmalloc(tilesize + 8);', '+     if (!tbuff)', '+       {', '+       tifferror (""readseparatestripsintobuffer"",', '+                  ""unable to allocate tile read buffer for sample %d"", sample);', '+       for (i = 0; i < sample; i++)', '+         _tifffree (srcbuffs[i]);', '+       return 0;', '+       }', '+     srcbuffs[sample] = tbuff;', '+     }', '+   for (row = 0; row < imagelength; row += tl)', '+     {', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       {', '+       for (s = 0; s < spp; s++)', '+       if (col + tw > imagewidth)', '+         ncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       row_offset = row * (((imagewidth * spp * bps) + 7) / 8);', '+       col_offset = ((col * spp * bps) + 7) / 8;', '+       bufp = obuf + row_offset + col_offset;', '+ ', '+       if ((bps % 8) == 0)', '+         {', '+         if (combineseparatetilesamplesbytes(srcbuffs, bufp, ncol, nrow, imagewidth,', '+ \t\t\t\t\t    tw, spp, bps, null, 0, 0))', '+ \t  {', '+           status = 0;', '+           break;', '+       \t  }', '+ \t}', '+       else', '+         {', '+         bytes_per_pixel  = ((bps * spp) + 7) / 8;', '+         if (bytes_per_pixel < (bytes_per_sample + 1))', '+           shift_width = bytes_per_pixel;', '+         else', '+           shift_width = bytes_per_sample + 1;', '+ ', '+         switch (shift_width)', '+           {', '+           case 1: if (combineseparatetilesamples8bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       null, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+       \t            }', '+ \t          break;', '+           case 2: if (combineseparatetilesamples16bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       null, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+ \t\t    }', '+ \t          break;', '+           case 3: if (combineseparatetilesamples24bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       null, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+        \t            }', '+                   break;', '+           case 4:', '+           case 5:', '+           case 6:', '+           case 7:', '+           case 8: if (combineseparatetilesamples32bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       null, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+ \t\t    }', '+ \t          break;', '+           default: tifferror (""readseparatetilesintobuffer"", ""unsupported bit depth: %d"", bps);', '+                   status = 0;', '+                   break;', '+           }', '+         }', '+       }', '+     }', '+ ', '+   for (sample = 0; (sample < spp) && (sample < max_samples); sample++)', '+     {', '+     tbuff = srcbuffs[sample];', '+     if (tbuff != null)', '+       _tifffree(tbuff);', '+     }', '+ ', '+   return status;', '+   }', '+ ', '+ static int writebuffertocontigstrips(tiff* out, uint8* buf, uint32 imagelength)', '+   {', '+   uint32 row, nrows, rowsperstrip;', '+   tstrip_t strip = 0;', '+   tsize_t stripsize;', '+ ', '+   tiffgetfielddefaulted(out, tifftag_rowsperstrip, &rowsperstrip);', '+   for (row = 0; row < imagelength; row += rowsperstrip)', '+     {', '+     nrows = (row + rowsperstrip > imagelength) ?', '+ \t     imagelength - row : rowsperstrip;', '+     stripsize = tiffvstripsize(out, nrows);', '+     if (tiffwriteencodedstrip(out, strip++, buf, stripsize) < 0)', '+       {', '+       tifferror(tifffilename(out), ""error, can\'t write strip %u"", strip - 1);', '+       return 0;', '+       }', '+     buf += stripsize;', '+     }', '+   return 1;', '+   }', '+ ', '+       if (extractcontigsamplestobuffer(obuf, src, nrows, width, s, spp, bps, dump))', '+   _tifffree(obuf);', '+   return 1;', '+ }', '+ static int writebuffertocontigtiles (tiff* out, uint8* buf, uint32 imagelength,', '+ \t\t\t\t       uint32 imagewidth, tsample_t spp,', '+                                        struct dump_opts* dump)', '+   {', '+   uint16 bps;', '+   uint32 tl, tw;', '+   uint32 row, col, nrow, ncol;', '+   uint32 src_rowsize, col_offset;', '+   uint32 tile_rowsize  = tifftilerowsize(out);', '+   uint8* bufp = (uint8*) buf;', '+   tsize_t tile_buffsize = 0;', '+   tsize_t tilesize = tifftilesize(out);', '+   unsigned char *tilebuf = null;', '+ ', '+   tiffgetfield(out, tifftag_tilelength, &tl);', '+   tiffgetfield(out, tifftag_tilewidth, &tw);', '+   tiffgetfield(out, tifftag_bitspersample, &bps);', '+ ', '+   tile_buffsize = tilesize;', '+   if (tilesize < (tsize_t)(tl * tile_rowsize))', '+     {', '+ #ifdef debug2', '+     tifferror(""writebuffertocontigtiles"",', '+ \t      ""tilesize %lu is too small, using alternate calculation %u"",', '+               tilesize, tl * tile_rowsize);', '+ #endif', '+     tile_buffsize = tl * tile_rowsize;', '+     }', '+   tilebuf = _tiffmalloc(tile_buffsize);', '+   if (tilebuf == 0)', '+     return 0;', '+   src_rowsize = ((imagewidth * spp * bps) + 7) / 8;', '+   for (row = 0; row < imagelength; row += tl)', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       if (col + tw > imagewidth)', '+ \tncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       col_offset = (((col * bps * spp) + 7) / 8);', '+       bufp = buf + (row * src_rowsize) + col_offset;', '+       if (extractcontigsamplestotilebuffer(tilebuf, bufp, nrow, ncol, imagewidth,', '+ \t\t\t\t\t   tw, 0, spp, spp, bps, dump) > 0)', '+ \ttifferror(""writebuffertocontigtiles"",', '+                   ""unable to extract data to tile for row %lu, col %lu"",', '+                   (unsigned long) row, (unsigned long)col);', '+ \t_tifffree(tilebuf);', '+ \treturn (0);', '+         }', '+       if (tiffwritetile(out, tilebuf, col, row, 0, 0) < 0)', '+ \ttifferror(""writebuffertocontigtiles"",', '+ \t          ""cannot write tile at %lu %lu"",', '+ \t          (unsigned long) col, (unsigned long) row);', '+ \t _tifffree(tilebuf);', '+     }', '+   _tifffree(tilebuf);', '+   tdata_t obuf = _tiffmalloc(tifftilesize(out));', '+   uint32 tl, tw;', '+   uint32 row, col, nrow, ncol;', '+   uint32 src_rowsize, col_offset;', '+   uint16 bps;', '+   tsample_t s;', '+   uint8* bufp = (uint8*) buf;', '+ ', '+   if (obuf == null)', '+     return 0;', '+ ', '+   tiffgetfield(out, tifftag_tilelength, &tl);', '+   tiffgetfield(out, tifftag_tilewidth, &tw);', '+   tiffgetfield(out, tifftag_bitspersample, &bps);', '+   src_rowsize = ((imagewidth * spp * bps) + 7) / 8;', '+ ', '+   for (row = 0; row < imagelength; row += tl)', '+     {', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       {', '+       if (col + tw > imagewidth)', '+ \tncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       col_offset = (((col * bps * spp) + 7) / 8);', '+       bufp = buf + (row * src_rowsize) + col_offset;', '+ ', '+       for (s = 0; s < spp; s++)', '+         {', '+ \tif (extractcontigsamplestotilebuffer(obuf, bufp, nrow, ncol, imagewidth,', '+ \t\t\t\t\t     tw, s, 1, spp, bps, dump) > 0)', '+           {', '+ \t  tifferror(""writebuffertoseparatetiles"",', '+                     ""unable to extract data to tile for row %lu, col %lu sample %d"",', '+                     (unsigned long) row, (unsigned long)col, (int)s);', '+ \t  _tifffree(obuf);', '+ \t  return (0);', '+           }', '+ ', '+ \tif (tiffwritetile(out, obuf, col, row, 0, s) < 0)', '+           {', '+ \t   tifferror(""writebuffertoseparatetiles"",', '+ \t             ""cannot write tile at %lu %lu sample %lu"",', '+ \t             (unsigned long) col, (unsigned long) row,', '+ \t             (unsigned long) s);', '+ \t   _tifffree(obuf);', '+ \t  return 0;', '+ \t  }', '+       }', '+     }', '+   _tifffree(obuf);', '+   return 1;', '+   {', '+   char* cp = null;', '+   if (strneq(opt, ""none"",4))', '+     {', '+     defcompression = compression_none;', ""+     cp = strchr(opt, ':');"", '+     if (cp)', '+       {', ""+       if (cp[1] == 'r' )"", '+ \tjpegcolormode = jpegcolormode_raw;', ""+       else if (cp[1] == 'a' )"", '+ \tjpegcolormode = jpegcolormode_rgb;', '+       }', '+     }', '+   else if (streq(opt, ""packbits""))', '+     {', '+     defcompression = compression_packbits;', '+     }', '+   else if (strneq(opt, ""jpeg"", 4))', '+     {', ""+     cp = strchr(opt, ':');"", '+     defcompression = compression_jpeg;', '+     while ( cp )', '+       {', '+       if (isdigit((int)cp[1]))', '+ \tquality = atoi(cp+1);', ""+       else if (cp[1] == 'r' )"", '+ \tjpegcolormode = jpegcolormode_raw;', ""+       else if (cp[1] == 'a' )"", '+ \tjpegcolormode = jpegcolormode_rgb;', '+       else', '+         usage();', ""+       cp = strchr(cp+1,':');"", '+       }', '+     }', '+   else if (strneq(opt, ""g3"", 2))', '+     {', '+     processg3options(opt);', '+     defcompression = compression_ccittfax3;', '+     }', '+   else if (streq(opt, ""g4""))', '+     {', '+     defcompression = compression_ccittfax4;', '+     }', '+   else if (strneq(opt, ""lzw"", 3))', '+     {', ""+     cp = strchr(opt, ':');"", '+     if (cp)', '+       defpredictor = atoi(cp+1);', '+     defcompression = compression_lzw;', '+     }', '+   else if (strneq(opt, ""zip"", 3))', '+     {', ""+     cp = strchr(opt, ':');"", '+     if (cp)', '+       defpredictor = atoi(cp+1);', '+     defcompression = compression_adobe_deflate;', '+    }', '+   else', '+     return (0);', '+   return (1);', '+   }', '+   {', '+   char buf[bufsiz];', '+   int i;', '+ ', '+   setbuf(stderr, buf);', '+   fprintf(stderr, ""\\n%s\\n"", tiffgetversion());', '+   for (i = 0; stuff[i] != null; i++)', '+     fprintf(stderr, ""%s\\n"", stuff[i]);', '+   exit(-1);', '+   }', '+       case \'v\': tifferror(""library release"", ""%s"", tiffgetversion());', '+                 tifferror (""tiffcrop version"", ""%s, last updated: %s"",', '+   uint32 deftilewidth = (uint32) 0;', '+   uint32 deftilelength = (uint32) 0;', '+ \t    tifferror (""unable to open dump file for writing"", ""%s"", temp_filename);', '+ \t      tifferror (""unable to open dump file for writing"", ""%s"", temp_filename);', '+   \t                     tsample_t sample, uint16 spp, uint16 bps,', '+                              struct dump_opts *dump)', '+       case 1: if (bps == 1)', '+                 {', '+                 if (extractcontigsamples8bits (src, dst, cols, sample,', '+                                                spp, bps, count, first_col, cols))', '+ \t          return (1);', '+ \t        break;', '+ \t\t}', '+ \t      else', '+                  if (extractcontigsamples16bits (src, dst, cols, sample,', '+                                                  spp, bps, count, first_col, cols))', '+       case 2: if (extractcontigsamples24bits (src, dst, cols, sample,', '+       case 3:', '+ static int', '+ extractcontigsamplestotilebuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,', '+   \t                         uint32 imagewidth, uint32 tilewidth, tsample_t sample,', '+ \t\t\t\t uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump)', '+   int    shift_width, bytes_per_sample, bytes_per_pixel;', '+   uint32 src_rowsize, src_offset, row;', '+   uint32 dst_rowsize, dst_offset;', '+   uint8 *src, *dst;', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   bytes_per_pixel  = ((bps * spp) + 7) / 8;', '+   if ((bps % 8) == 0)', '+     shift_width = 0;', '+   else', '+     if (bytes_per_pixel < (bytes_per_sample + 1))', '+       shift_width = bytes_per_pixel;', '+     else', '+       shift_width = bytes_per_sample + 1;', '+     }', '+ ', '+   if ((dump->outfile != null) && (dump->level == 4))', '+     {', '+     dump_info  (dump->outfile, dump->format, ""extractcontigsamplestotilebuffer"",', '+                 ""sample %d, %d rows"", sample + 1, rows + 1);', '+     }', '+ ', '+   src_rowsize = ((bps * spp * imagewidth) + 7) / 8;', '+   dst_rowsize = ((bps * tilewidth * count) + 7) / 8;', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     src_offset = row * src_rowsize;', '+     dst_offset = row * dst_rowsize;', '+     src = in + src_offset;', '+     dst = out + dst_offset;', '+ ', '+     switch (shift_width)', '+       {', '+       case 0: if (extractcontigsamplesbytes (src, dst, cols, sample,', '+                                              spp, bps,  count, 0, cols))', '+                 return (1);', '+  \t      break;', '+       case 1: if (bps == 1)', '+                 {', '+                 if (extractcontigsamples8bits (src, dst, cols, sample,', '+                                                spp, bps, count, 0, cols))', '+ \t          return (1);', '+ \t        break;', '+ \t\t}', '+ \t      else', '+                  if (extractcontigsamples16bits (src, dst, cols, sample,', '+                                                  spp, bps, count, 0, cols))', '+ \t         return (1);', '+ \t      break;', '+       case 2: if (extractcontigsamples24bits (src, dst, cols, sample,', '+                                               spp, bps,  count, 0, cols))', '+ \t         return (1);', '+ \t      break;', '+       case 3:', '+       case 4:', '+       case 5: if (extractcontigsamples32bits (src, dst, cols, sample,', '+                                               spp, bps,  count, 0, cols))', '+ \t         return (1);', '+ \t      break;', '+       default: tifferror (""extractcontigsamplestotilebuffer"", ""unsupported bit depth: %d"", bps);', '+ \t       return (1);', '+     if ((dump->outfile != null) && (dump->level == 4))', '+       dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);', '+   return (0);', '+ ', '+ static int readcontigstripsintobuffer (tiff* in, uint8* buf, uint32 length, uint32 width,', '+                                        tsample_t spp, struct dump_opts * dump)', '+   int32  bytes_read = 0;', '+   uint16 nstrips   = tiffnumberofstrips(in);', '+   uint32 stripsize = tiffstripsize(in);', '+   uint32 rows = 0, strip;', '+   uint32 rps = tiffgetfielddefaulted(in, tifftag_rowsperstrip, &rps);', '+   tsize_t scanline_size = tiffscanlinesize(in);', '+ ', '+   for (strip = 0; strip < nstrips; strip++)', '+     {', '+     bytes_read = tiffreadencodedstrip (in, strip, bufp, -1);', '+     rows = bytes_read / scanline_size;', '+     if (bytes_read != (int32)stripsize)', '+       tifferror("""", ""bytes read %lu does not match reported strip size %lu"",', '+ \t\t(unsigned long) bytes_read, (unsigned long)stripsize);', '+ ', '+     if (bytes_read < 0 && !ignore)', '+       {', '+       tifferror("""", ""error reading strip %lu after %lu rows"",', '+ \t\t(unsigned long) strip, (unsigned long)rows);', '+       return 0;', '+       }', '+     bufp += bytes_read;', '+     }', '+ static int', '+ combineseparatesamplesbytes (unsigned char *srcbuffs[], unsigned char *out,', '+                              uint32 cols, uint32 rows, uint16 spp, uint16 bps,', '+                              file *dumpfile, int format, int level)', '+   {', '+   int i, bytes_per_sample;', '+   uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;', '+   unsigned char *src;', '+   unsigned char *dst;', '+   tsample_t s;', '+ ', '+   src = srcbuffs[0];', '+   dst = out;', '+   if ((src == null) || (dst == null))', '+     {', '+     tifferror(""combineseparatesamplesbytes"",""invalid buffer address"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+ ', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   dst_rowsize = ((bps * spp * cols) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     {', '+     if ((dumpfile != null) && (level == 2))', '+       {', '+       for (s = 0; s < spp; s++)', '+         {', '+         dump_info (dumpfile, format, ""combineseparatesamplesbytes"",""input data, sample %d"", s);', '+         dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));', '+         }', '+       }', '+     dst = out + (row * dst_rowsize);', '+     row_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       col_offset = row_offset + (col * (bps / 8));', '+       for (s = 0; (s < spp) && (s < max_samples); s++)', '+         {', '+         src = srcbuffs[s] + col_offset;', '+         for (i = 0; i < bytes_per_sample; i++)', '+           *(dst + i) = *(src + i);', '+         src += bytes_per_sample;', '+         dst += bytes_per_sample;', '+         }', '+       }', '+ ', '+     if ((dumpfile != null) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineseparatesamplesbytes"",""output data, combined samples"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ combineseparatesamples8bits (uint8 *in[], uint8 *out, uint32 cols,', '+                             uint32 rows, uint16 spp, uint16 bps,', '+   uint32 src_rowsize, dst_rowsize, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+       matchbits = maskbits << (8 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         buff1 = ((*src) & matchbits) << (src_bit);', '+ ', '+         if (ready_bits >= 8)', '+           {', '+           *dst++ = buff2;', '+           buff2 = buff1;', '+           ready_bits -= 8;', '+           strcpy (action, ""flush"");', '+           }', '+         else', '+           {', '+           buff2 = (buff2 | (buff1 >> ready_bits));', '+           strcpy (action, ""update"");', '+           }', '+         ready_bits += bps;', '+         if ((dumpfile != null) && (level == 3))', '+           {', '+           dump_info (dumpfile, format, """",', '+           dump_byte (dumpfile, format, ""match bits"", matchbits);', '+           dump_byte (dumpfile, format, ""src   bits"", *src);', '+           dump_byte (dumpfile, format, ""buff1 bits"", buff1);', '+           dump_byte (dumpfile, format, ""buff2 bits"", buff2);', '+           dump_info (dumpfile, format, """",""%s"", action);', '+ \t  }', '+         }', '+     if (ready_bits > 0)', '+       buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));', '+       *dst++ = buff1;', '+       if ((dumpfile != null) && (level == 3))', '+         {', '+         dump_info (dumpfile, format, """",', '+         }', '+     if ((dumpfile != null) && (level >= 2))', '+       {', '+       dump_info (dumpfile, format, ""combineseparatesamples8bits"",""output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+ ', '+ combineseparatesamples16bits (uint8 *in[], uint8 *out, uint32 cols,', '+                               uint32 rows, uint16 spp, uint16 bps,', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (16 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[1] = *src;', '+           swapbuff[0] = *(src + 1);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+ \t  }', '+ ', '+ \tbuff1 = *((uint16 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 8)', '+ \t  {', '+ \t    bytebuff = (buff2 >> 8);', '+ \t    *dst++ = bytebuff;', '+ \t    ready_bits -= 8;', '+ \t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != null) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""row %3d, col %3d, samples %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ ', '+ \t  dump_short (dumpfile, format, ""match bits"", matchbits);', '+ \t  dump_data  (dumpfile, format, ""src   bits"", src, 2);', '+ \t  dump_short (dumpfile, format, ""buff1 bits"", buff1);', '+ \t  dump_short (dumpfile, format, ""buff2 bits"", buff2);', '+ \t  dump_byte  (dumpfile, format, ""write byte"", bytebuff);', '+ \t  dump_info  (dumpfile, format, """",""ready bits:  %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+       }', '+ ', '+     if (ready_bits > 0)', '+       {', '+       bytebuff = (buff2 >> 8);', '+       *dst++ = bytebuff;', '+       if ((dumpfile != null) && (level == 3))', '+ \t{', '+ \tdump_info (dumpfile, format, """",', '+ \t\t       ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t       row + 1, col + 1, src_byte, src_bit, dst - out);', '+ \tdump_byte (dumpfile, format, ""final bits"", bytebuff);', '+ \t}', '+       }', '+ ', '+     if ((dumpfile != null) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineseparatesamples16bits"",""output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineseparatesamples24bits (uint8 *in[], uint8 *out, uint32 cols,', '+                               uint32 rows, uint16 spp, uint16 bps,', '+ \t                      file *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0, bytes_per_sample = 0;', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   uint32 maskbits = 0, matchbits = 0;', '+   uint32 buff1 = 0, buff2 = 0;', '+   uint8  bytebuff1 = 0, bytebuff2 = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   unsigned char  swapbuff[4];', '+   char           action[8];', '+ ', '+   if ((src == null) || (dst == null))', '+     {', '+     tifferror(""combineseparatesamples24bits"",""invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   dst_rowsize = ((bps * cols * spp) + 7) / 8;', '+   maskbits =  (uint32)-1 >> ( 32 - bps);', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (32 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[3] = *src;', '+           swapbuff[2] = *(src + 1);', '+           swapbuff[1] = *(src + 2);', '+           swapbuff[0] = *(src + 3);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+           swapbuff[2] = *(src + 2);', '+           swapbuff[3] = *(src + 3);', '+ \t  }', '+ ', '+ \tbuff1 = *((uint32 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 16)', '+ \t  {', '+ \t    bytebuff1 = (buff2 >> 24);', '+ \t    *dst++ = bytebuff1;', '+ \t    bytebuff2 = (buff2 >> 16);', '+ \t    *dst++ = bytebuff2;', '+ \t    ready_bits -= 16;', '+ ', '+ \t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != null) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""row %3d, col %3d, samples %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_long (dumpfile, format, ""match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""src   bits "", src, 4);', '+ \t  dump_long (dumpfile, format, ""buff1 bits "", buff1);', '+ \t  dump_long (dumpfile, format, ""buff2 bits "", buff2);', '+ \t  dump_byte (dumpfile, format, ""write bits1"", bytebuff1);', '+ \t  dump_byte (dumpfile, format, ""write bits2"", bytebuff2);', '+ \t  dump_info (dumpfile, format, """",""ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+       }', '+     while (ready_bits > 0)', '+       {', '+ \tbytebuff1 = (buff2 >> 24);', '+ \t*dst++ = bytebuff1;', '+ \tbuff2 = (buff2 << 8);', '+ \tbytebuff2 = bytebuff1;', '+ \tready_bits -= 8;', '+       }', '+ ', '+     if ((dumpfile != null) && (level == 3))', '+       {', '+       dump_info (dumpfile, format, """",', '+ \t\t   ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t   row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""match bits "", matchbits);', '+       dump_data (dumpfile, format, ""src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""ready bits:  %2d"", ready_bits);', '+       }', '+ ', '+     if ((dumpfile != null) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineseparatesamples24bits"",""output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineseparatesamples32bits (uint8 *in[], uint8 *out, uint32 cols,', '+                               uint32 rows, uint16 spp, uint16 bps,', '+ \t                      file *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;', '+   uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;', '+   uint32 src_byte = 0, src_bit = 0;', '+   uint32 row, col;', '+   uint32 longbuff1 = 0, longbuff2 = 0;', '+   uint64 maskbits = 0, matchbits = 0;', '+   uint64 buff1 = 0, buff2 = 0, buff3 = 0;', '+   uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   unsigned char  swapbuff1[4];', '+   unsigned char  swapbuff2[4];', '+   char           action[8];', '+ ', '+   if ((src == null) || (dst == null))', '+     {', '+     tifferror(""combineseparatesamples32bits"",""invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   dst_rowsize = ((bps * cols * spp) + 7) / 8;', '+   maskbits =  (uint64)-1 >> ( 64 - bps);', '+   shift_width = ((bps + 7) / 8) + 1;', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (64 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \t{', '+ \tsrc = in[s] + src_offset + src_byte;', '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff1[3] = *src;', '+ \t  swapbuff1[2] = *(src + 1);', '+ \t  swapbuff1[1] = *(src + 2);', '+ \t  swapbuff1[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff1[0] = *src;', '+ \t  swapbuff1[1] = *(src + 1);', '+ \t  swapbuff1[2] = *(src + 2);', '+ \t  swapbuff1[3] = *(src + 3);', '+ \t  }', '+         longbuff1 = *((uint32 *)swapbuff1);', '+ ', ""+ \tmemset (swapbuff2, '\\0', sizeof(swapbuff2));"", '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff2[3] = *src;', '+ \t  swapbuff2[2] = *(src + 1);', '+ \t  swapbuff2[1] = *(src + 2);', '+ \t  swapbuff2[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff2[0] = *src;', '+ \t  swapbuff2[1] = *(src + 1);', '+ \t  swapbuff2[2] = *(src + 2);', '+ \t  swapbuff2[3] = *(src + 3);', '+ \t  }', '+ ', '+ \tlongbuff2 = *((uint32 *)swapbuff2);', '+ \tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;', '+ \tbuff1 = (buff3 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 32)', '+ \t  {', '+ \t  bytebuff1 = (buff2 >> 56);', '+ \t  *dst++ = bytebuff1;', '+ \t  bytebuff2 = (buff2 >> 48);', '+ \t  *dst++ = bytebuff2;', '+ \t  bytebuff3 = (buff2 >> 40);', '+ \t  *dst++ = bytebuff3;', '+ \t  bytebuff4 = (buff2 >> 32);', '+ \t  *dst++ = bytebuff4;', '+ \t  ready_bits -= 32;', '+ ', '+ \t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));', '+ \t  strcpy (action, ""flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != null) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t     ""row %3d, col %3d, sample %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_wide (dumpfile, format, ""match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""src   bits "", src, 8);', '+ \t  dump_wide (dumpfile, format, ""buff1 bits "", buff1);', '+ \t  dump_wide (dumpfile, format, ""buff2 bits "", buff2);', '+ \t  dump_info (dumpfile, format, """", ""ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+       }', '+     while (ready_bits > 0)', '+       {', '+       bytebuff1 = (buff2 >> 56);', '+       *dst++ = bytebuff1;', '+       buff2 = (buff2 << 8);', '+       ready_bits -= 8;', '+       }', '+ ', '+     if ((dumpfile != null) && (level == 3))', '+       {', '+       dump_info (dumpfile, format, """",', '+ \t         ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""match bits "", matchbits);', '+       dump_data (dumpfile, format, ""src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""ready bits:  %2d"", ready_bits);', '+       }', '+ ', '+     if ((dumpfile != null) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineseparatesamples32bits"",""output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineseparatetilesamplesbytes (unsigned char *srcbuffs[], unsigned char *out,', '+                                  uint32 cols, uint32 rows, uint32 imagewidth,', '+                                  uint32 tw, uint16 spp, uint16 bps,', '+                                  file *dumpfile, int format, int level)', '+   {', '+   int i, bytes_per_sample;', '+   uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;', '+   unsigned char *src;', '+   unsigned char *dst;', '+   tsample_t s;', '+ ', '+   src = srcbuffs[0];', '+   dst = out;', '+   if ((src == null) || (dst == null))', '+     {', '+     tifferror(""combineseparatetilesamplesbytes"",""invalid buffer address"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = imagewidth * bytes_per_sample * spp;', '+   for (row = 0; row < rows; row++)', '+     {', '+     if ((dumpfile != null) && (level == 2))', '+       {', '+       for (s = 0; s < spp; s++)', '+         dump_info (dumpfile, format, ""combineseparatetilesamplesbytes"",""input data, sample %d"", s);', '+         dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));', '+       }', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+ #ifdef develmode', '+     tifferror("""",""tile row %4d, src offset %6d   dst offset %6d"",', '+               row, src_offset, dst - out);', '+ #endif', '+     for (col = 0; col < cols; col++)', '+       {', '+       col_offset = src_offset + (col * (bps / 8));', '+       for (s = 0; (s < spp) && (s < max_samples); s++)', '+         {', '+         src = srcbuffs[s] + col_offset;', '+         for (i = 0; i < bytes_per_sample; i++)', '+           *(dst + i) = *(src + i);', '+         dst += bytes_per_sample;', '+         }', '+       }', '+ ', '+     if ((dumpfile != null) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineseparatetilesamplesbytes"",""output data, combined samples"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineseparatetilesamples8bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                  uint32 rows, uint32 imagewidth,', '+                                  uint32 tw, uint16 spp, uint16 bps,', '+  \t                         file *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0;', '+   uint32 src_rowsize, dst_rowsize, src_offset;', '+   uint32 bit_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   uint8  maskbits = 0, matchbits = 0;', '+   uint8  buff1 = 0, buff2 = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   char           action[32];', '+ ', '+   if ((src == null) || (dst == null))', '+     {', '+     tifferror(""combineseparatetilesamples8bits"",""invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   maskbits =  (uint8)-1 >> ( 8 - bps);', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (8 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+         {', '+ \tsrc = in[s] + src_offset + src_byte;', '+         buff1 = ((*src) & matchbits) << (src_bit);', '+ ', '+         if (ready_bits >= 8)', '+           {', '+           *dst++ = buff2;', '+           buff2 = buff1;', '+           ready_bits -= 8;', '+           strcpy (action, ""flush"");', '+           }', '+         else', '+           {', '+           buff2 = (buff2 | (buff1 >> ready_bits));', '+           strcpy (action, ""update"");', '+           }', '+         ready_bits += bps;', '+ ', '+         if ((dumpfile != null) && (level == 3))', '+           {', '+           dump_info (dumpfile, format, """",', '+                    ""row %3d, col %3d, samples %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+           dump_byte (dumpfile, format, ""match bits"", matchbits);', '+           dump_byte (dumpfile, format, ""src   bits"", *src);', '+           dump_byte (dumpfile, format, ""buff1 bits"", buff1);', '+           dump_byte (dumpfile, format, ""buff2 bits"", buff2);', '+           dump_info (dumpfile, format, """",""%s"", action);', '+ \t  }', '+       }', '+     if (ready_bits > 0)', '+       {', '+       buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));', '+       *dst++ = buff1;', '+ \t         ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t         row + 1, col + 1, src_byte, src_bit, dst - out);', '+                  dump_byte (dumpfile, format, ""final bits"", buff1);', '+ ', '+     if ((dumpfile != null) && (level >= 2))', '+       {', '+       dump_info (dumpfile, format, ""combineseparatetilesamples8bits"",""output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineseparatetilesamples16bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                   uint32 rows, uint32 imagewidth,', '+                                   uint32 tw, uint16 spp, uint16 bps,', '+  \t                          file *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0;', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   uint16 maskbits = 0, matchbits = 0;', '+   uint16 buff1 = 0, buff2 = 0;', '+   uint8  bytebuff = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   unsigned char  swapbuff[2];', '+   char           action[8];', '+ ', '+   if ((src == null) || (dst == null))', '+     {', '+     tifferror(""combineseparatetilesamples16bits"",""invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   maskbits = (uint16)-1 >> (16 - bps);', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (16 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+         {', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[1] = *src;', '+           swapbuff[0] = *(src + 1);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+ \t  }', '+ ', '+ \tbuff1 = *((uint16 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 8)', '+ \t  {', '+ \t    bytebuff = (buff2 >> 8);', '+ \t    *dst++ = bytebuff;', '+ \t    ready_bits -= 8;', '+ \t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != null) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""row %3d, col %3d, samples %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ ', '+ \t  dump_short (dumpfile, format, ""match bits"", matchbits);', '+ \t  dump_data  (dumpfile, format, ""src   bits"", src, 2);', '+ \t  dump_short (dumpfile, format, ""buff1 bits"", buff1);', '+ \t  dump_short (dumpfile, format, ""buff2 bits"", buff2);', '+ \t  dump_byte  (dumpfile, format, ""write byte"", bytebuff);', '+ \t  dump_info  (dumpfile, format, """",""ready bits:  %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+       }', '+ ', '+     if (ready_bits > 0)', '+       {', '+       bytebuff = (buff2 >> 8);', '+       *dst++ = bytebuff;', '+       if ((dumpfile != null) && (level == 3))', '+ \t{', '+ \tdump_info (dumpfile, format, """",', '+ \t\t       ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t       row + 1, col + 1, src_byte, src_bit, dst - out);', '+ \tdump_byte (dumpfile, format, ""final bits"", bytebuff);', '+ \t}', '+       }', '+ ', '+     if ((dumpfile != null) && (level == 2))', '+       dump_info (dumpfile, format, ""combineseparatetilesamples16bits"",""output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+ combineseparatetilesamples24bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                   uint32 rows, uint32 imagewidth,', '+                                   uint32 tw, uint16 spp, uint16 bps,', '+  \t                          file *dumpfile, int format, int level)', '+   int    ready_bits = 0;', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+     tifferror(""combineseparatetilesamples24bits"",""invalid input or output buffer"");', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+       matchbits = maskbits << (32 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[3] = *src;', '+           swapbuff[2] = *(src + 1);', '+           swapbuff[1] = *(src + 2);', '+           swapbuff[0] = *(src + 3);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+           swapbuff[2] = *(src + 2);', '+           swapbuff[3] = *(src + 3);', '+ \t  }', '+ \tbuff1 = *((uint32 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 16)', '+ \t  {', '+ \t    bytebuff1 = (buff2 >> 24);', '+ \t    *dst++ = bytebuff1;', '+ \t    bytebuff2 = (buff2 >> 16);', '+ \t    *dst++ = bytebuff2;', '+ \t    ready_bits -= 16;', '+ ', '+ \t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != null) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""row %3d, col %3d, samples %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_long (dumpfile, format, ""match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""src   bits "", src, 4);', '+ \t  dump_long (dumpfile, format, ""buff1 bits "", buff1);', '+ \t  dump_long (dumpfile, format, ""buff2 bits "", buff2);', '+ \t  dump_byte (dumpfile, format, ""write bits1"", bytebuff1);', '+ \t  dump_byte (dumpfile, format, ""write bits2"", bytebuff2);', '+ \t  dump_info (dumpfile, format, """",""ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+     while (ready_bits > 0)', '+       {', '+ \tbytebuff1 = (buff2 >> 24);', '+ \t*dst++ = bytebuff1;', '+ \tbuff2 = (buff2 << 8);', '+ \tbytebuff2 = bytebuff1;', '+ \tready_bits -= 8;', '+       }', '+     if ((dumpfile != null) && (level == 3))', '+       {', '+       dump_info (dumpfile, format, """",', '+ \t\t   ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t   row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""match bits "", matchbits);', '+       dump_data (dumpfile, format, ""src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""ready bits:  %2d"", ready_bits);', '+       }', '+     if ((dumpfile != null) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineseparatetilesamples24bits"",""output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+ combineseparatetilesamples32bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                   uint32 rows, uint32 imagewidth,', '+                                   uint32 tw, uint16 spp, uint16 bps,', '+  \t                          file *dumpfile, int format, int level)', '+   int    ready_bits = 0, shift_width = 0;', '+   uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;', '+   uint32 row, col;', '+     tifferror(""combineseparatetilesamples32bits"",""invalid input or output buffer"");', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+       matchbits = maskbits << (64 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \t{', '+ \tsrc = in[s] + src_offset + src_byte;', '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff1[3] = *src;', '+ \t  swapbuff1[2] = *(src + 1);', '+ \t  swapbuff1[1] = *(src + 2);', '+ \t  swapbuff1[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff1[0] = *src;', '+ \t  swapbuff1[1] = *(src + 1);', '+ \t  swapbuff1[2] = *(src + 2);', '+ \t  swapbuff1[3] = *(src + 3);', '+ \t  }', '+         longbuff1 = *((uint32 *)swapbuff1);', '+ ', ""+ \tmemset (swapbuff2, '\\0', sizeof(swapbuff2));"", '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff2[3] = *src;', '+ \t  swapbuff2[2] = *(src + 1);', '+ \t  swapbuff2[1] = *(src + 2);', '+ \t  swapbuff2[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff2[0] = *src;', '+ \t  swapbuff2[1] = *(src + 1);', '+ \t  swapbuff2[2] = *(src + 2);', '+ \t  swapbuff2[3] = *(src + 3);', '+ \t  }', '+ \tlongbuff2 = *((uint32 *)swapbuff2);', '+ \tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;', '+ \tbuff1 = (buff3 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 32)', '+ \t  {', '+ \t  bytebuff1 = (buff2 >> 56);', '+ \t  *dst++ = bytebuff1;', '+ \t  bytebuff2 = (buff2 >> 48);', '+ \t  *dst++ = bytebuff2;', '+ \t  bytebuff3 = (buff2 >> 40);', '+ \t  *dst++ = bytebuff3;', '+ \t  bytebuff4 = (buff2 >> 32);', '+ \t  *dst++ = bytebuff4;', '+ \t  ready_bits -= 32;', '+ \t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));', '+ \t  strcpy (action, ""flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != null) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t     ""row %3d, col %3d, sample %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_wide (dumpfile, format, ""match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""src   bits "", src, 8);', '+ \t  dump_wide (dumpfile, format, ""buff1 bits "", buff1);', '+ \t  dump_wide (dumpfile, format, ""buff2 bits "", buff2);', '+ \t  dump_info (dumpfile, format, """", ""ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+     while (ready_bits > 0)', '+       bytebuff1 = (buff2 >> 56);', '+       *dst++ = bytebuff1;', '+       buff2 = (buff2 << 8);', '+       ready_bits -= 8;', '+     if ((dumpfile != null) && (level == 3))', '+       dump_info (dumpfile, format, """",', '+ \t         ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '+ \t\t row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""match bits "", matchbits);', '+       dump_data (dumpfile, format, ""src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""ready bits:  %2d"", ready_bits);', '+       }', '+     if ((dumpfile != null) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineseparatetilesamples32bits"",""output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '+       }', '+ ', '+ ', '+   int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;', '+   int32  bytes_read = 0;', '+   uint16 bps, nstrips, planar, strips_per_sample;', '+   uint32 src_rowsize, dst_rowsize, rows_processed, rps;', '+   uint32 rows_this_strip = 0;', '+   tstrip_t  strip;', '+   tsize_t stripsize    = tiffstripsize(in);', ""+   memset (srcbuffs, '\\0', sizeof(srcbuffs));"", '+   tiffgetfield(in, tifftag_bitspersample, &bps);', '+   tiffgetfielddefaulted(in, tifftag_planarconfig, &planar);', '+   tiffgetfielddefaulted(in, tifftag_rowsperstrip, &rps);', '+   if (rps > length)', '+     rps = length;', '+ ', '+   nstrips = tiffnumberofstrips(in);', '+   strips_per_sample = nstrips /spp;', '+ ', '+     buff = _tiffmalloc(stripsize);', '+                  ""unable to allocate strip read buffer for sample %d"", s);', '+   rows_processed = 0;', '+   for (j = 0; (j < strips_per_sample) && (result == 1); j++)', '+       strip = (s * strips_per_sample) + j;', '+       bytes_read = tiffreadencodedstrip (in, strip, buff, stripsize);', '+       rows_this_strip = bytes_read / src_rowsize;', '+       if (bytes_read < 0 && !ignore)', '+ \t          ""error, can\'t read strip %lu for sample %d"",', '+          \t   (unsigned long) strip, s + 1);', '+         result = 0;', '+         break;', '+ #ifdef develmode', '+       tifferror("""", ""strip %2d, read %5d bytes for %4d scanlines, shift width %d"",', '+ \t\tstrip, bytes_read, rows_this_strip, shift_width);', '+ #endif', '+     if (rps > rows_this_strip)', '+       rps = rows_this_strip;', '+     dst = obuf + (dst_rowsize * rows_processed);', '+       if (combineseparatesamplesbytes (srcbuffs, dst, width, rps,', '+                                        spp, bps, dump->infile,', '+                                        dump->format, dump->level))', '+         result = 0;', '+         break;', '+         case 1: if (combineseparatesamples8bits (srcbuffs, dst, width, rps,', '+                   result = 0;', '+                   break;', '+       \t          }', '+         case 2: if (combineseparatesamples16bits (srcbuffs, dst, width, rps,', '+                                                   spp, bps, dump->infile,', '+                                                   dump->format, dump->level))', '+                   result = 0;', '+                   break;', '+ \t        break;', '+         case 3: if (combineseparatesamples24bits (srcbuffs, dst, width, rps,', '+                                                   spp, bps, dump->infile,', '+                                                   dump->format, dump->level))', '+ \t          {', '+                   result = 0;', '+                   break;', '+        \t          }', '+         case 8: if (combineseparatesamples32bits (srcbuffs, dst, width, rps,', '+                                                   spp, bps, dump->infile,', '+                                                   dump->format, dump->level))', '+                   result = 0;', '+                   break;', '+ \t        break;', '+                   result = 0;', '+                   break;', '+         }', '+ ', '+     if ((rows_processed + rps) > length)', '+       {', '+       rows_processed = length;', '+       rps = length - rows_processed;', '+       }', '+     else', '+       rows_processed += rps;', '+   return (result);', '+     if (((image->xres == 0) || (image->yres == 0)) &&', '+          (crop->res_unit != resunit_none) &&', '+ loadimage(tiff* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)', '+   float    xres = 0.0, yres = 0.0;', '+   uint16   nstrips = 0, ntiles = 0, planar = 0;', '+   uint16   bps = 0, spp = 0, res_unit = 0;', '+   uint16   photometric = 0, orientation = 0, input_compression = 0;', '+   uint32   width = 0, length = 0;', '+   uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;', '+   uint32   tile_rowsize = 0;', '+   if (! tiffgetfielddefaulted(in, tifftag_photometric, &photometric))', '+     tifferror(""loadimage"",""image lacks photometric interpreation tag"");', '+   if (! tiffgetfield(in, tifftag_imagewidth,  &width))', '+     tifferror(""loadimage"",""image lacks image width tag"");', '+   if(! tiffgetfield(in, tifftag_imagelength, &length))', '+     tifferror(""loadimage"",""image lacks image length tag"");', '+   tiffgetfielddefaulted(in, tifftag_xresolution, &xres);', '+   tiffgetfielddefaulted(in, tifftag_yresolution, &yres);', '+   if (!tiffgetfielddefaulted(in, tifftag_resolutionunit, &res_unit))', '+     res_unit = resunit_inch;', '+   if (!tiffgetfield(in, tifftag_compression, &input_compression))', '+     input_compression = compression_none;', '+     tiffgetfield(in, tifftag_tilewidth, &tw);', '+     tiffgetfield(in, tifftag_tilelength, &tl);', '+ ', '+     tile_rowsize  = tifftilerowsize(in);', '+ ', '+     if (buffsize < (uint32)(ntiles * tl * tile_rowsize))', '+       {', '+       buffsize = ntiles * tl * tile_rowsize;', '+ #ifdef debug2', '+       tifferror(""loadimage"",', '+ \t        ""tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu"",', '+                 tlsize, (unsigned long)buffsize);', '+ #endif', '+       }', '+ ', '+                  ""tilesize: %u, number of tiles: %u, tile row size: %u"",', '+                  tlsize, ntiles, tile_rowsize);', '+     if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))', '+       {', '+       buffsize =  ((length * width * spp * bps) + 7) / 8;', '+ #ifdef debug2', '+       tifferror(""loadimage"",', '+ \t        ""stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu"",', '+                 stsize, (unsigned long)buffsize);', '+ #endif', '+       }', '+ ', '+ ', '+   if (input_compression == compression_jpeg)', '+     {', '+     jpegcolormode = jpegcolormode_rgb;', '+     tiffsetfield(in, tifftag_jpegcolormode, jpegcolormode_rgb);', '+     }', '+ ', '+ \t     if (!(readcontigstripsintobuffer(in, read_buff, length, width, spp, dump)))', '+ \t   if (!(readcontigtilesintobuffer(in, read_buff, length, width, tw, tl, spp, bps)))', '+ \t   if (!(readseparatetilesintobuffer(in, read_buff, length, width, tw, tl, spp, bps)))', '+                case 1: if (bps == 1)', '+                          {', '+                          if (extractcontigsamplesshifted8bits (src, dst, img_width,', '+                            {', '+ \t\t           tifferror(""extractcompositeregions"",', '+                                      ""unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+ \t\t         break;', '+ \t\t\t }', '+                        else', '+                          if (extractcontigsamplesshifted16bits (src, dst, img_width,', '+                                                                 sample, spp, bps, count,', '+                                                                 first_col, last_col + 1,', '+                                                                 prev_trailing_bits))', '+                            {', '+ \t\t           tifferror(""extractcompositeregions"",', '+                                      ""unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+                case 2:  if (extractcontigsamplesshifted24bits (src, dst, img_width,', '+                case 3:', '+                case 1: if (bps == 1)', '+                          {', '+                          if (extractcontigsamplesshifted8bits (src, dst, img_width,', '+                            {', '+ \t\t           tifferror(""extractcompositeregions"",', '+                                      ""unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+ \t\t         break;', '+ \t\t\t }', '+                        else', '+                          if (extractcontigsamplesshifted16bits (src, dst, img_width,', '+                                                                 sample, spp, bps, count,', '+                                                                 first_col, last_col + 1,', '+                                                                 prev_trailing_bits))', '+                            {', '+ \t\t           tifferror(""extractcompositeregions"",', '+                                      ""unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+               case 2:  if (extractcontigsamplesshifted24bits (src, dst, img_width,', '+                case 3:', '+       case 1: if (bps == 1)', '+                 {', '+                 if (extractcontigsamplesshifted8bits (src, dst, img_width,', '+                                                       sample, spp, bps, count,', '+                                                       first_col, last_col + 1,', '+                                                       prev_trailing_bits))', '+                   {', '+ \t\t  tifferror(""extractseparateregion"",', '+                             ""unable to extract row %d"", row);', '+ \t\t  return (1);', '+ \t\t  }', '+ \t\t  break;', '+               else', '+                 if (extractcontigsamplesshifted16bits (src, dst, img_width,', '+                                                        sample, spp, bps, count,', '+                                                        first_col, last_col + 1,', '+                                                        prev_trailing_bits))', '+                   {', '+ \t\t  tifferror(""extractseparateregion"",', '+                             ""unable to extract row %d"", row);', '+ \t\t  return (1);', '+ \t\t  }', '+       case 2:  if (extractcontigsamplesshifted24bits (src, dst, img_width,', '+       case 3:', '+       case 4:', '+       case 5:  if (extractcontigsamplesshifted32bits (src, dst, img_width,', '+ #ifdef develmode', '+ #ifdef develmode', '+ #ifdef develmode', '+ #ifdef develmode', '+   uint16 input_compression, input_photometric;', '+   uint16 input_jpeg_colormode, input_planar;', '+ ', '+   tiffgetfield(in, tifftag_compression, &input_compression);', '+     {', '+     if (input_compression == compression_ojpeg)', '+       {', '+       tiffsetfield(out, tifftag_compression, compression_jpeg);', '+       compression = compression_jpeg;', '+       }', '+     else', '+       copyfield(tifftag_compression, compression);', '+     }', '+   tiffgetfield(in, tifftag_jpegcolormode, &input_jpeg_colormode);', '+ #ifdef debug2', '+   tifferror(""writesinglesection"", ""input compression: %s"",', '+ \t    (input_compression == compression_ojpeg) ? ""old jpeg"" :', '+ \t    ((input_compression == compression_jpeg) ?  ""new jpeg"" : ""non jpeg""));', '+ #endif', '+   if (compression == compression_jpeg)', '+     {', '+     if (tiffgetfield(in, tifftag_photometric, &input_photometric))', '+       {', '+       if (input_photometric == photometric_rgb)', '+         {', '+ \tif (jpegcolormode == jpegcolormode_rgb)', '+ \t  tiffsetfield(out, tifftag_photometric, photometric_ycbcr);', '+ \telse', '+ \t  tiffsetfield(out, tifftag_photometric, photometric_rgb);', '+ \t}', '+       else', '+ \ttiffsetfield(out, tifftag_photometric, input_photometric);', '+     }', '+   else', '+       tiffsetfield(out, tifftag_photometric, spp == 1 ?', '+ ', '+   if (((tifftag_photometric == photometric_logl) ||', '+        (tifftag_photometric ==  photometric_logluv)) &&', '+       ((compression != compression_sgilog) &&', '+        (compression != compression_sgilog24)))', '+     {', '+     tifferror(""writesinglesection"",', '+               ""logl and logluv data require sgi_log or sgi_log24"");', '+     return (-1);', '+     }', '+ ', '+     if (tilewidth == (uint32) 0)', '+     if (tilelength == (uint32) 0)', '+     if (tilewidth == 0 || tilelength == 0)', '+       tiffdefaulttilesize(out, &tilewidth, &tilelength);', '+ \tif (rowsperstrip == (uint32) 0)', '+           {', '+ \t  if (!tiffgetfield(in, tifftag_rowsperstrip, &rowsperstrip))', '+ \t    rowsperstrip = tiffdefaultstripsize(out, rowsperstrip);', '+           if (compression != compression_jpeg)', '+             {', '+   \t    if (rowsperstrip > length)', '+ \t      rowsperstrip = length;', '+ \t    }', '+ \telse', '+           if (rowsperstrip == (uint32) -1)', '+ \t    rowsperstrip = length;', '+ \ttiffsetfield(out, tifftag_rowsperstrip, rowsperstrip);', '+ ', '+   tiffgetfielddefaulted(in, tifftag_planarconfig, &input_planar);', '+          if (((bps % 8) == 0) || ((bps % 12) == 0))', '+ \t   {', '+            tiffsetfield(out, tifftag_jpegquality, quality);', '+ \t   tiffsetfield(out, tifftag_jpegcolormode, jpegcolormode_rgb);', '+            }', '+          else', '+            {', '+ \t   tifferror(""writecroppedimage"",', '+                      ""jpeg compression requires 8 or 12 bits per sample"");', '+            return (-1);', '+            }', '+       writebuffertocontigtiles (out, sect_buff, length, width, spp, dump);', '+       writebuffertocontigstrips (out, sect_buff, length);', '+   uint16 input_compression, input_photometric;', '+   uint16 input_jpeg_colormode, input_planar;', '+ ', '+   tiffgetfield(in, tifftag_compression, &input_compression);', '+     {', '+     if (input_compression == compression_ojpeg)', '+       {', '+       tiffsetfield(out, tifftag_compression, compression_jpeg);', '+       compression = compression_jpeg;', '+       }', '+     else', '+       copyfield(tifftag_compression, compression);', '+     }', '+   tiffgetfield(in, tifftag_jpegcolormode, &input_jpeg_colormode);', '+ #ifdef debug2', '+   tifferror(""writecroppedimage"", ""input compression: %s"",', '+ \t    (input_compression == compression_ojpeg) ? ""old jpeg"" :', '+ \t    ((input_compression == compression_jpeg) ?  ""new jpeg"" : ""non jpeg""));', '+ #endif', '+   if (compression == compression_jpeg)', '+     {', '+     if (tiffgetfield(in, tifftag_photometric, &input_photometric))', '+       {', '+       if (input_photometric == photometric_rgb)', '+         {', '+ \tif (jpegcolormode == jpegcolormode_rgb)', '+ \t  tiffsetfield(out, tifftag_photometric, photometric_ycbcr);', '+ \telse', '+ \t  tiffsetfield(out, tifftag_photometric, photometric_rgb);', '+ \t}', '+       else', '+ \ttiffsetfield(out, tifftag_photometric, input_photometric);', '+       }', '+     }', '+ ', '+   if (((tifftag_photometric == photometric_logl) ||', '+        (tifftag_photometric ==  photometric_logluv)) &&', '+       ((compression != compression_sgilog) &&', '+        (compression != compression_sgilog24)))', '+     {', '+     tifferror(""writecroppedimage"",', '+               ""logl and logluv data require sgi_log or sgi_log24"");', '+     return (-1);', '+     }', '+ ', '+     if (tilewidth == (uint32) 0)', '+     if (tilelength == (uint32) 0)', '+     if (tilewidth == 0 || tilelength == 0)', '+       tiffdefaulttilesize(out, &tilewidth, &tilelength);', '+           if (compression != compression_jpeg)', '+             {', '+   \t    if (rowsperstrip > length)', '+ \t      rowsperstrip = length;', '+ ', '+   tiffgetfielddefaulted(in, tifftag_planarconfig, &input_planar);', '+          if (((bps % 8) == 0) || ((bps % 12) == 0))', '+ \t   {', '+            tiffsetfield(out, tifftag_jpegquality, quality);', '+ \t   tiffsetfield(out, tifftag_jpegcolormode, jpegcolormode_rgb);', '+            }', '+          else', '+            {', '+ \t   tifferror(""writecroppedimage"",', '+                      ""jpeg compression requires 8 or 12 bits per sample"");', '+            return (-1);', '+            }', '+         if (bps != 1)', '+           {', '+ \t  tifferror(""writecroppedimage"",', '+             ""group 3/4 compression is not usable with bps > 1"");', '+           return (-1);', '+ \t  }', '+ \t break;', '+     case compression_none:', '+          break;', '+     default: break;', '+       writebuffertocontigtiles (out, crop_buff, length, width, spp, dump);', '+       writebuffertocontigstrips (out, crop_buff, length);', '+   uint8    match_bits = 0, mask_bits = 0;', '+   mask_bits =  (uint8)-1 >> ( 8 - bps);', '+       match_bits = mask_bits << (8 - src_bit - bps);', '+       buff1 = ((*src) & match_bits) << (src_bit);', '+ ', '+   uint32   src_byte = 0, high_bit = 0;', '+   uint16   match_bits = 0, mask_bits = 0;', '+   mask_bits =  (uint16)-1 >> (16 - bps);', '+         high_bit  = bit_offset % 8;', '+         high_bit  = (bit_offset + (sample * bps)) % 8;', '+       match_bits = mask_bits << (16 - high_bit - bps);', '+       buff1 = (buff1 & match_bits) << (high_bit);', '+   uint32   src_byte = 0, high_bit = 0;', '+   uint32   match_bits = 0, mask_bits = 0;', '+   mask_bits =  (uint32)-1 >> (32 - bps);', '+         high_bit  = bit_offset % 8;', '+         high_bit  = (bit_offset + (sample * bps)) % 8;', '+       match_bits = mask_bits << (32 - high_bit - bps);', '+       buff1 = (buff1 & match_bits) << (high_bit);', '+   uint32 src_byte = 0, high_bit = 0;', '+   uint64 mask_bits = 0, match_bits = 0;', '+   mask_bits =  (uint64)-1 >> (64 - bps);', '+         high_bit  = bit_offset % 8;', '+         high_bit  = (bit_offset + (sample * bps)) % 8;', '+       match_bits = mask_bits << (64 - high_bit - bps);', '+       buff1 = (buff3 & match_bits) << (high_bit);', '- static uint32 tilewidth;', '- static uint32 tilelength;', '- ', '- static uint16 config;', '- static uint16 compression;', '- static uint16 predictor;', '- static uint16 fillorder;', '- static uint32 rowsperstrip;', '- static uint32 g3opts;', '- static int    jpegcolormode = jpegcolormode_rgb;', '- static int readcontigstripsintobuffer   (tiff*, uint8*, uint32, uint32, tsample_t);', '- static int readseparatestripsintobuffer (tiff*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '- static int readcontigtilesintobuffer    (tiff*, uint8*, uint32, uint32, tsample_t);', '- static int readseparatetilesintobuffer  (tiff*, uint8*, uint32, uint32, tsample_t);', '- static int writebuffertocontigstrips    (tiff*, uint8*, uint32, uint32, tsample_t);', '- static int writebuffertocontigtiles     (tiff*, uint8*, uint32, uint32, tsample_t);', '- static int writebuffertoseparatestrips  (tiff*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '- static int writebuffertoseparatetiles   (tiff*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '- static int extractcontigsamplestobuffer (uint8 *, uint8 *, uint32, uint32, int, int,', '-                                          tsample_t, uint16, uint16, struct dump_opts *);', '- static void cpstriptotile (uint8*, uint8*, uint32, uint32, int, int);', '- static void cpseparatebuftocontigbuf(uint8 *, uint8 *, uint32, uint32 ,', '- \t\t\t\t     int, int, tsample_t, int);', '- ', '-                                        uint32, uint32, tsample_t, uint16,', '-                                        file *, int, int);', '- ', '- static   char tiffcrop_version_id[] = ""2.0"";', '- static   char tiffcrop_rev_date[] = ""01-06-2009"";', '- "" #\t\tset compression quality level (0-100, default 75)"",', '- "" r\t\toutput color image as rgb rather than ycbcr"",', '- ""             increase the level of detail. the program must be compiled with"",', '- ""             -ddebug -ddebug2 to enable full debug reporting"",', '- ""   format:txt|raw  format any logged data as ascii text or raw binary "",', '-                                       tsample_t spp)', '- {', '- \tint status = 1;', '- \ttdata_t tilebuf = _tiffmalloc(tifftilesize(in));', '- \tuint32 imagew = tiffscanlinesize(in);', '- \tuint32 tilew  = tifftilerowsize(in);', '- \tint iskew = imagew - tilew;', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tw, tl;', '- \tuint32 row;', '- ', '- \t(void) spp;', '- \tif (tilebuf == 0)', '- \t\treturn 0;', '- \t(void) tiffgetfield(in, tifftag_tilewidth, &tw);', '- \t(void) tiffgetfield(in, tifftag_tilelength, &tl);', '- ', '- \tfor (row = 0; row < imagelength; row += tl) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\tif (tiffreadtile(in, tilebuf, col, row, 0, 0) < 0', '- \t\t\t    && !ignore) {', '- \t\t\t\ttifferror(tifffilename(in),', '- \t\t\t\t\t  ""error, can\'t read tile at %lu %lu"",', '- \t\t\t\t\t  (unsigned long) col,', '- \t\t\t\t\t  (unsigned long) row);', '- \t\t\t\tstatus = 0;', '- \t\t\t\tgoto done;', '- \t\t\t}', '- \t\t\tif (colb + tilew > imagew) {', '- \t\t\t\tuint32 width = imagew - colb;', '- \t\t\t\tuint32 oskew = tilew - width;', '- \t\t\t\tcpstriptotile(bufp + colb,', '-                                               tilebuf, nrow, width,', '-                                               oskew + iskew, oskew );', '- \t\t\t} else', '- \t\t\t\tcpstriptotile(bufp + colb,', '-                                               tilebuf, nrow, tilew,', '-                                               iskew, 0);', '- \t\t\tcolb += tilew;', '- \t\t}', '- \t\tbufp += imagew * nrow;', '- done:', '- \t_tifffree(tilebuf);', '- \treturn status;', '- }', '- static int  readseparatetilesintobuffer (tiff* in, uint8 *buf,', '-             uint32 imagelength, uint32 imagewidth, uint16 spp)', '- {', '- \tint status = 1;', '- \tuint32 imagew = tiffrasterscanlinesize(in);', '- \tuint32 tilew = tifftilerowsize(in);', '- \tint iskew  = imagew - tilew*spp;', '- \ttdata_t tilebuf = _tiffmalloc(tifftilesize(in));', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tw, tl;', '- \tuint32 row;', '-         uint16 bps, bytes_per_sample;', '- ', '- \tif (tilebuf == 0)', '- \t\treturn 0;', '- \t(void) tiffgetfield(in, tifftag_tilewidth, &tw);', '- \t(void) tiffgetfield(in, tifftag_tilelength, &tl);', '- \t(void) tiffgetfield(in, tifftag_bitspersample, &bps);', '-         assert( bps % 8 == 0 );', '-         bytes_per_sample = bps/8;', '- ', '- \tfor (row = 0; row < imagelength; row += tl) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\ttsample_t s;', '- ', '- \t\t\tfor (s = 0; s < spp; s++) {', '- \t\t\t\tif (tiffreadtile(in, tilebuf, col, row, 0, s) < 0', '- \t\t\t\t    && !ignore) {', '- \t\t\t\t\ttifferror(tifffilename(in),', '- \t\t\t\t\t  ""error, can\'t read tile at %lu %lu, ""', '- \t\t\t\t\t  ""sample %lu"",', '- \t\t\t\t\t  (unsigned long) col,', '- \t\t\t\t\t  (unsigned long) row,', '- \t\t\t\t\t  (unsigned long) s);', '- \t\t\t\t\tstatus = 0;', '- \t\t\t\t\tgoto done;', '- \t\t\t\t}', '- \t\t\t\tif (colb + tilew*spp > imagew) {', '- \t\t\t\t\tuint32 width = imagew - colb;', '- \t\t\t\t\tint oskew = tilew*spp - width;', '- \t\t\t\t\tcpseparatebuftocontigbuf(', '-                                             bufp+colb+s*bytes_per_sample,', '- \t\t\t\t\t    tilebuf, nrow,', '-                                             width/(spp*bytes_per_sample),', '- \t\t\t\t\t    oskew + iskew,', '-                                             oskew/spp, spp,', '-                                             bytes_per_sample);', '- \t\t\t\t} else', '- \t\t\t\t\tcpseparatebuftocontigbuf(', '-                                             bufp+colb+s*bytes_per_sample,', '- \t\t\t\t\t    tilebuf, nrow, tw,', '- \t\t\t\t\t    iskew, 0, spp,', '-                                             bytes_per_sample);', '- \t\t\t}', '- \t\t\tcolb += tilew*spp;', '- \t\t}', '- \t\tbufp += imagew * nrow;', '- done:', '- \t_tifffree(tilebuf);', '- \treturn status;', '- }', '- static int writebuffertocontigstrips(tiff* out, uint8* buf, uint32 imagelength,', '-                                      uint32 imagewidth, tsample_t spp)', '- {', '- \tuint32 row, rowsperstrip;', '- \ttstrip_t strip = 0;', '- ', '- \t(void) imagewidth; (void) spp;', '- \t(void) tiffgetfielddefaulted(out, tifftag_rowsperstrip, &rowsperstrip);', '- \tfor (row = 0; row < imagelength; row += rowsperstrip) {', '- \t\tuint32 nrows = (row+rowsperstrip > imagelength) ?', '- \t\t    imagelength-row : rowsperstrip;', '- \t\ttsize_t stripsize = tiffvstripsize(out, nrows);', '- \t\tif (tiffwriteencodedstrip(out, strip++, buf, stripsize) < 0) {', '- \t\t\ttifferror(tifffilename(out),', '- \t\t\t\t  ""error, can\'t write strip %u"", strip - 1);', '- \t\t\treturn 0;', '- \t\t}', '- \t\tbuf += stripsize;', '- \treturn 1;', '- }', '-       if (extractcontigsamplestobuffer(obuf, src, nrows, width, 0, 0, s, spp, bps, dump))', '-   _tifffree(obuf);', '- }', '- ', '- static int writebuffertocontigtiles (tiff* out, uint8* buf, uint32 imagelength,', '-                                      uint32 imagewidth, tsample_t spp)', '- {', '- \tuint32 imagew = tiffscanlinesize(out);', '- \tuint32 tilew  = tifftilerowsize(out);', '- \tint iskew = imagew - tilew;', '- \ttdata_t obuf = _tiffmalloc(tifftilesize(out));', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tl, tw;', '- \tuint32 row;', '- ', '- \t(void) spp;', '- \tif (obuf == null)', '- \t\treturn 0;', '- \t(void) tiffgetfield(out, tifftag_tilelength, &tl);', '- \t(void) tiffgetfield(out, tifftag_tilewidth, &tw);', '- \tfor (row = 0; row < imagelength; row += tilelength) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\tif (colb + tilew > imagew) {', '- \t\t\t\tuint32 width = imagew - colb;', '- \t\t\t\tint oskew = tilew - width;', '- \t\t\t\tcpstriptotile(obuf, bufp + colb, nrow, width,', '- \t\t\t\t    oskew, oskew + iskew);', '- \t\t\t} else', '- \t\t\t\tcpstriptotile(obuf, bufp + colb, nrow, tilew,', '- \t\t\t\t    0, iskew);', '- \t\t\tif (tiffwritetile(out, obuf, col, row, 0, 0) < 0) {', '- \t\t\t\ttifferror(tifffilename(out),', '- \t\t\t\t\t  ""error, can\'t write tile at %lu %lu"",', '- \t\t\t\t\t  (unsigned long) col,', '- \t\t\t\t\t  (unsigned long) row);', '- \t\t\t\t_tifffree(obuf);', '- \t\t\t\treturn 0;', '- \t\t\t}', '- \t\t\tcolb += tilew;', '- \t\t}', '- \t\tbufp += nrow * imagew;', '- \t}', '- \t_tifffree(obuf);', '- \treturn 1;', '- }', '- \tuint32 imagew = tiffscanlinesize(out);', '- \ttsize_t tilew  = tifftilerowsize(out);', '- \tuint32 iimagew = tiffrasterscanlinesize(out);', '- \tint iskew = iimagew - tilew*spp;', '- \ttdata_t obuf = _tiffmalloc(tifftilesize(out));', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tl, tw;', '- \tuint32 row;', '-         uint16 bps, bytes_per_sample;', '- ', '- \tif (obuf == null)', '- \t\treturn 0;', '- \t(void) tiffgetfield(out, tifftag_tilelength, &tl);', '- \t(void) tiffgetfield(out, tifftag_tilewidth, &tw);', '- \t(void) tiffgetfield(out, tifftag_bitspersample, &bps);', '-         assert( bps % 8 == 0 );', '-         bytes_per_sample = (bps + 7)/8;', '- ', '- \tfor (row = 0; row < imagelength; row += tl) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\ttsample_t s;', '- \t\t\tfor (s = 0; s < spp; s++) {', '- \t\t\t\tif (colb + tilew > imagew) {', '- \t\t\t\t\tuint32 width = (imagew - colb);', '- \t\t\t\t\tint oskew = tilew - width;', '- ', '- \t\t\t\t  extractcontigsamplestobuffer(obuf,', '- \t\t\t\t\t    bufp + (colb*spp) + s,', '- \t\t\t\t\t    nrow, width/bytes_per_sample,', '- \t\t\t\t\t    oskew, (oskew*spp)+iskew, s,', '- \t\t\t\t\t    spp, bps, dump);', '- \t\t\t\t} else', '- \t\t\t\t    extractcontigsamplestobuffer(obuf,', '- \t\t\t\t\t    bufp + (colb*spp) + s,', '- \t\t\t\t\t    nrow, tilewidth,', '- \t\t\t\t\t    0, iskew, s, spp,', '- \t\t\t\t\t    bps, dump);', '- \t\t\t\tif (tiffwritetile(out, obuf, col, row, 0, s) < 0) {', '- \t\t\t\t\ttifferror(tifffilename(out),', '- \t\t\t\t\t""error, can\'t write tile at %lu %lu ""', '- \t\t\t\t\t""sample %lu"",', '- \t\t\t\t\t(unsigned long) col,', '- \t\t\t\t\t(unsigned long) row,', '- \t\t\t\t\t(unsigned long) s);', '- \t\t\t\t\t_tifffree(obuf);', '- \t\t\t\t\treturn 0;', '- \t\t\t\t}', '- \t\t\t}', '- \t\t\tcolb += tilew;', '- \t\t}', '- \t\tbufp += nrow * iimagew;', '- \t_tifffree(obuf);', '- \treturn 1;', '- }', '- {', '- \tif (streq(opt, ""none"")) {', '- \t\tdefcompression = compression_none;', '- \t} else if (streq(opt, ""packbits"")) {', '- \t\tdefcompression = compression_packbits;', '- \t} else if (strneq(opt, ""jpeg"", 4)) {', ""- \t\tchar* cp = strchr(opt, ':');"", '- ', '-                 defcompression = compression_jpeg;', '-                 while( cp )', '-                 {', '-                     if (isdigit((int)cp[1]))', '- \t\t\tquality = atoi(cp+1);', ""-                     else if (cp[1] == 'r' )"", '- \t\t\tjpegcolormode = jpegcolormode_raw;', '-                     else', '-                         usage();', ""-                     cp = strchr(cp+1,':');"", '-                 }', '- \t} else if (strneq(opt, ""g3"", 2)) {', '- \t\tprocessg3options(opt);', '- \t\tdefcompression = compression_ccittfax3;', '- \t} else if (streq(opt, ""g4"")) {', '- \t\tdefcompression = compression_ccittfax4;', '- \t} else if (strneq(opt, ""lzw"", 3)) {', ""- \t\tchar* cp = strchr(opt, ':');"", '- \t\tif (cp)', '- \t\t\tdefpredictor = atoi(cp+1);', '- \t\tdefcompression = compression_lzw;', '- \t} else if (strneq(opt, ""zip"", 3)) {', ""- \t\tchar* cp = strchr(opt, ':');"", '- \t\tif (cp)', '- \t\t\tdefpredictor = atoi(cp+1);', '- \t\tdefcompression = compression_adobe_deflate;', '- \t} else', '- \t\treturn (0);', '- \treturn (1);', '- }', '- {', '- \tchar buf[bufsiz];', '- \tint i;', '- ', '- \tsetbuf(stderr, buf);', '-         fprintf(stderr, ""\\n%s\\n"", tiffgetversion());', '- \tfor (i = 0; stuff[i] != null; i++)', '- \t\tfprintf(stderr, ""%s\\n"", stuff[i]);', '- \texit(-1);', '- }', '- static void', '- cpstriptotile(uint8* out, uint8* in,', '- \tuint32 rows, uint32 cols, int outskew, int inskew)', '- {', '- \twhile (rows-- > 0) {', '- \t\tuint32 j = cols;', '- \t\twhile (j-- > 0)', '- \t\t\t*out++ = *in++;', '- \t\tout += outskew;', '- \t\tin += inskew;', '- \t}', '- }', '- ', '- ', '-       case \'v\': tifferror (""tiffcrop version"", ""%s, last updated: %s"",', '-   uint32 deftilewidth = (uint32) -1;', '-   uint32 deftilelength = (uint32) -1;', '-   extern int   optind;', '- \t    tifferror (""unable to open dump file %s for writing"", ""%s"", temp_filename);', '- \t    tifferror (""unable to open dump file %s for writing"", ""%s"", temp_filename);', '- ', '-   \t                     int outskew, int inskew, tsample_t sample,', '-                              uint16 spp, uint16 bps, struct dump_opts *dump)', '-       case 1: if (extractcontigsamples8bits (src, dst, cols, sample,', '-                                              spp, bps, count, first_col, cols))', '-       case 2: if (extractcontigsamples16bits (src, dst, cols, sample,', '-       case 3: if (extractcontigsamples24bits (src, dst, cols, sample,', '-                                               spp, bps,  count, first_col, cols))', '- \t         return (1);', '-               break;', '- ', '-     out += outskew;', '-     in += inskew;', '- static void', '- cpseparatebuftocontigbuf(uint8  *out, uint8 *in, uint32 rows, uint32 cols,', '-                          int outskew, int inskew, tsample_t spp,', '-                          int bytes_per_sample)', '-   while (rows-- > 0)', '-     uint32 j = cols;', '-     while (j-- > 0)', '-       {', '-       int n = bytes_per_sample;', '-       while( n-- )', '-         {', '-         *out++ = *in++;', '-         }', '-       out += (spp-1)*bytes_per_sample;', '-     out += outskew;', '-     in += inskew;', '- static int readcontigstripsintobuffer (tiff* in, uint8* buf, uint32 imagelength,', '-                                          uint32 imagewidth, tsample_t spp)', '-   tsize_t scanlinesize = tiffscanlinesize(in);', '-   uint32 row;', '- ', '-  (void) imagewidth; (void) spp;', '-  for (row = 0; row < imagelength; row++)', '-    {', '-    if (tiffreadscanline(in, (tdata_t) bufp, row, 0) < 0', '- \t && !ignore)', '-      {', '-      tifferror(tifffilename(in),""error, can\'t read scanline %lu"",', '- \t       (unsigned long) row);', '-      return 0;', '-      }', '-    bufp += scanlinesize;', '-    }', '- combineseparatesamples8bits (uint8 *in[], uint8 *out, uint32 row,', '-                             uint32 cols, uint16 spp, uint16 bps,', '-   uint32 dst_rowsize;', '-   uint32 col, src_byte = 0, src_bit = 0;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '- ', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (8 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       buff1 = ((*src) & matchbits) << (src_bit);', '-       if (ready_bits >= 8)', '-         {', '-         *dst++ = buff2;', '-         buff2 = buff1;', '-         ready_bits -= 8;', '-         strcpy (action, ""flush"");', '-         }', '-       else', '-         buff2 = (buff2 | (buff1 >> ready_bits));', '-         strcpy (action, ""update"");', '-         }', '-       ready_bits += bps;', '-       if ((dumpfile != null) && (level == 3))', '-         {', '-         dump_info (dumpfile, format, """",', '-         dump_byte (dumpfile, format, ""match bits"", matchbits);', '-         dump_byte (dumpfile, format, ""src   bits"", *src);', '-         dump_byte (dumpfile, format, ""buff1 bits"", buff1);', '-         dump_byte (dumpfile, format, ""buff2 bits"", buff2);', '-         dump_info (dumpfile, format, """",""%s"", action);', '- \t}', '-     }', '-   if (ready_bits > 0)', '-     {', '-     buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));', '-     *dst++ = buff1;', '-     if ((dumpfile != null) && (level == 3))', '-       dump_info (dumpfile, format, """",', '-     }', '-   if ((dumpfile != null) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineseparatesamples8bits"",""output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '- ', '- combineseparatesamples16bits (uint8 *in[], uint8 *out, uint32 row,', '-                               uint32 cols, uint16 spp, uint16 bps,', '-   uint32 dst_rowsize;', '-   uint32 bit_offset;', '-   uint32 col, src_byte = 0, src_bit = 0;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (16 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       if (little_endian)', '-         swapbuff[1] = *src;', '-         swapbuff[0] = *(src + 1);', '-         }', '-       else', '-         swapbuff[0] = *src;', '-         swapbuff[1] = *(src + 1);', '-       buff1 = *((uint16 *)swapbuff);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-       if (ready_bits >= 8)', '-         bytebuff = (buff2 >> 8);', '-         *dst++ = bytebuff;', '-         ready_bits -= 8;', '-         buff2 = ((buff2 << 8) | (buff1 >> ready_bits));', '-         strcpy (action, ""flush"");', '-       else', '-       ready_bits += bps;', '- \t    ""row %3d, col %3d, samples %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '- \t    row + 1, col + 1, s, src_byte, src_bit, dst - out);', '- ', '-         dump_short (dumpfile, format, ""match bits"", matchbits);', '-         dump_data  (dumpfile, format, ""src   bits"", src, 2);', '-         dump_short (dumpfile, format, ""buff1 bits"", buff1);', '-         dump_short (dumpfile, format, ""buff2 bits"", buff2);', '-         dump_byte  (dumpfile, format, ""write byte"", bytebuff);', '-         dump_info  (dumpfile, format, """",""ready bits:  %d, %s"", ready_bits, action);', '-     }', '-   if (ready_bits > 0)', '-     {', '-     bytebuff = (buff2 >> 8);', '-     *dst++ = bytebuff;', '-     if ((dumpfile != null) && (level == 3))', '-       dump_info (dumpfile, format, """",', '- \t  ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '- \t  row + 1, col + 1, src_byte, src_bit, dst - out);', '-       dump_byte (dumpfile, format, ""final bits"", bytebuff);', '-   if ((dumpfile != null) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineseparatesamples16bits"",""output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '-     }', '- ', '- combineseparatesamples24bits (uint8 *in[], uint8 *out, uint32 row,', '-                               uint32 cols, uint16 spp, uint16 bps,', '- \t                      file *dumpfile, int format, int level)', '-   int    ready_bits = 0, bytes_per_sample = 0;', '-   uint32 dst_rowsize;', '-   uint32 bit_offset;', '-   uint32 col, src_byte = 0, src_bit = 0;', '-     tifferror(""combineseparatesamples24bits"",""invalid input or output buffer"");', '-   bytes_per_sample = (bps + 7) / 8;', '-   dst_rowsize = ((bps * cols) + 7) / 8;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (32 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       if (little_endian)', '-         {', '-         swapbuff[3] = *src;', '-         swapbuff[2] = *(src + 1);', '-         swapbuff[1] = *(src + 2);', '-         swapbuff[0] = *(src + 3);', '-         }', '-       else', '-         {', '-         swapbuff[0] = *src;', '-         swapbuff[1] = *(src + 1);', '-         swapbuff[2] = *(src + 2);', '-         swapbuff[3] = *(src + 3);', '- \t}', '- ', '-       buff1 = *((uint32 *)swapbuff);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-       if (ready_bits >= 16)', '-         bytebuff1 = (buff2 >> 24);', '-         *dst++ = bytebuff1;', '-         bytebuff2 = (buff2 >> 16);', '-         *dst++ = bytebuff2;', '-         ready_bits -= 16;', '- ', '-         buff2 = ((buff2 << 16) | (buff1 >> ready_bits));', '-         strcpy (action, ""flush"");', '-         }', '-       else', '-       ready_bits += bps;', '-       if ((dumpfile != null) && (level == 3))', '-         {', '-         dump_info (dumpfile, format, """",', '- \t        ""row %3d, col %3d, samples %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '- \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);', '-         dump_long (dumpfile, format, ""match bits "", matchbits);', '-         dump_data (dumpfile, format, ""src   bits "", src, 4);', '-         dump_long (dumpfile, format, ""buff1 bits "", buff1);', '-         dump_long (dumpfile, format, ""buff2 bits "", buff2);', '-         dump_byte (dumpfile, format, ""write bits1"", bytebuff1);', '-         dump_byte (dumpfile, format, ""write bits2"", bytebuff2);', '-         dump_info (dumpfile, format, """",""ready bits:   %d, %s"", ready_bits, action);', '-         }', '-     }', '-   while (ready_bits > 0)', '-     {', '-     bytebuff1 = (buff2 >> 24);', '-     *dst++ = bytebuff1;', '-     buff2 = (buff2 << 8);', '-     bytebuff2 = bytebuff1;', '-     ready_bits -= 8;', '-     }', '-   if ((dumpfile != null) && (level == 3))', '-     {', '-     dump_info (dumpfile, format, """",', '-       ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '-       row + 1, col + 1, src_byte, src_bit, dst - out);', '- ', '-     dump_long (dumpfile, format, ""match bits "", matchbits);', '-     dump_data (dumpfile, format, ""src   bits "", src, 4);', '-     dump_long (dumpfile, format, ""buff1 bits "", buff1);', '-     dump_long (dumpfile, format, ""buff2 bits "", buff2);', '-     dump_byte (dumpfile, format, ""write bits1"", bytebuff1);', '-     dump_byte (dumpfile, format, ""write bits2"", bytebuff2);', '-     dump_info (dumpfile, format, """", ""ready bits:  %2d"", ready_bits);', '-     }', '-   if ((dumpfile != null) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineseparatesamples24bits"",""output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '- combineseparatesamples32bits (uint8 *in[], uint8 *out, uint32 row,', '-                               uint32 cols, uint16 spp, uint16 bps,', '- \t                      file *dumpfile, int format, int level)', '-   int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;', '-   uint32 dst_rowsize;', '-   uint32 bit_offset;', '-   uint32 col;', '-     tifferror(""combineseparatesamples32bits"",""invalid input or output buffer"");', '-   bytes_per_sample = (bps + 7) / 8;', '-   dst_rowsize = ((bps * cols) + 7) / 8;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (64 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       if (little_endian)', '-         {', '-         swapbuff1[3] = *src;', '-         swapbuff1[2] = *(src + 1);', '-         swapbuff1[1] = *(src + 2);', '-         swapbuff1[0] = *(src + 3);', '-         }', '-       else', '-         {', '-         swapbuff1[0] = *src;', '-         swapbuff1[1] = *(src + 1);', '-         swapbuff1[2] = *(src + 2);', '-         swapbuff1[3] = *(src + 3);', '- \t}', '-       longbuff1 = *((uint32 *)swapbuff1);', '- ', ""-       memset (swapbuff2, '\\0', sizeof(swapbuff2));"", '-       if (little_endian)', '-         {', '-         swapbuff2[3] = *src;', '-         swapbuff2[2] = *(src + 1);', '-         swapbuff2[1] = *(src + 2);', '-         swapbuff2[0] = *(src + 3);', '-         }', '-       else', '-         {', '-         swapbuff2[0] = *src;', '-         swapbuff2[1] = *(src + 1);', '-         swapbuff2[2] = *(src + 2);', '-         swapbuff2[3] = *(src + 3);', '- \t}', '-       longbuff2 = *((uint32 *)swapbuff2);', '-       buff3 = ((uint64)longbuff1 << 32) | longbuff2;', '-       buff1 = (buff3 & matchbits) << (src_bit);', '-       if (ready_bits >= 32)', '-         {', '-         bytebuff1 = (buff2 >> 56);', '-         *dst++ = bytebuff1;', '-         bytebuff2 = (buff2 >> 48);', '-         *dst++ = bytebuff2;', '-         bytebuff3 = (buff2 >> 40);', '-         *dst++ = bytebuff3;', '-         bytebuff4 = (buff2 >> 32);', '-         *dst++ = bytebuff4;', '-         ready_bits -= 32;', '-         buff2 = ((buff2 << 32) | (buff1 >> ready_bits));', '-         strcpy (action, ""flush"");', '-         }', '-       else', '-       ready_bits += bps;', '- ', '-       if ((dumpfile != null) && (level == 3))', '-         {', '-         dump_info (dumpfile, format, """",', '- \t    ""row %3d, col %3d, sample %d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '- \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);', '-         dump_wide (dumpfile, format, ""match bits "", matchbits);', '-         dump_data (dumpfile, format, ""src   bits "", src, 8);', '-         dump_wide (dumpfile, format, ""buff1 bits "", buff1);', '-         dump_wide (dumpfile, format, ""buff2 bits "", buff2);', '-         dump_info (dumpfile, format, """", ""ready bits:   %d, %s"", ready_bits, action);', '-         }', '-     }', '-   while (ready_bits > 0)', '-     {', '-     bytebuff1 = (buff2 >> 56);', '-     *dst++ = bytebuff1;', '-     buff2 = (buff2 << 8);', '-     ready_bits -= 8;', '-     }', '- ', '-   if ((dumpfile != null) && (level == 3))', '-     {', '-     dump_info (dumpfile, format, """",', '-       ""row %3d, col %3d, src byte offset %3d  bit offset %2d  dst offset %3d"",', '-       row + 1, col + 1, src_byte, src_bit, dst - out);', '- ', '-     dump_long (dumpfile, format, ""match bits "", matchbits);', '-     dump_data (dumpfile, format, ""src   bits "", src, 4);', '-     dump_long (dumpfile, format, ""buff1 bits "", buff1);', '-     dump_long (dumpfile, format, ""buff2 bits "", buff2);', '-     dump_byte (dumpfile, format, ""write bits1"", bytebuff1);', '-     dump_byte (dumpfile, format, ""write bits2"", bytebuff2);', '-     dump_info (dumpfile, format, """", ""ready bits:  %2d"", ready_bits);', '-     }', '- ', '-   if ((dumpfile != null) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineseparatesamples32bits"",""output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '-     }', '- ', '-   return (0);', '- ', '- static int', '- combineseparatesamplesbytes (unsigned char *srcbuffs[], unsigned char *out,', '-                              uint32 row, uint32 width, uint16 spp, uint16 bps,', '-                              file *dumpfile, int format, int level)', '-   {', '-   int i, bytes_per_sample, bytes_per_pixel, dst_rowsize, shift_width;', '-   uint32 col, col_offset;', '-   unsigned char *src;', '-   unsigned char *dst;', '-   tsample_t s;', '- ', '-   src = srcbuffs[0];', '-   dst = out;', '-   if ((src == null) || (dst == null))', '-     {', '-     tifferror(""combineseparatesamplesbytes"",""invalid buffer address"");', '-     return (1);', '-     }', '- ', '-   bytes_per_sample = (bps + 7) / 8;', '-   bytes_per_pixel  = ((bps * spp) + 7) / 8;', '-   if (bytes_per_pixel < (bytes_per_sample + 1))', '-     shift_width = bytes_per_sample;', '-   else', '-     shift_width = bytes_per_pixel;', '- ', '-   if ((dumpfile != null) && (level == 2))', '-     {', '-     for (s = 0; s < spp; s++)', '-       dump_info (dumpfile, format, ""combineseparatesamplesbytes"",""input data, sample %d"", s);', '-       dump_buffer(dumpfile, format, 1, width, row, srcbuffs[s]);', '-     }', '-   dst_rowsize = ((bps * spp * width) + 7) / 8;', '-   for (col = 0; col < width; col++)', '-     {', '-     col_offset = col * (bps / 8);', '-     for (s = 0; (s < spp) && (s < max_samples); s++)', '-       src = srcbuffs[s] + col_offset;', '-       for (i = 0; i < bytes_per_sample; i++)', '-         *(dst + i) = *(src + i);', '-       src += bytes_per_sample;', '-       dst += bytes_per_sample;', '-       }', '-     }', '-   if ((dumpfile != null) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineseparatesamplesbytes"",""output data, combined samples"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '- ', '-   int i, bytes_per_sample, bytes_per_pixel, shift_width;', '-   uint16 bps;', '-   uint32 row, src_rowsize, dst_rowsize;', '-   (void) tiffgetfield(in, tifftag_bitspersample, &bps);', '- ', '-     buff = _tiffmalloc(src_rowsize);', '-                  ""unable to allocate read buffer for sample %d"", s);', '-   for (row = 0; row < length; row++)', '-       if (tiffreadscanline(in, buff, row, s) < 0', '- \t    && !ignore)', '- \t         ""error, can\'t read scanline %lu for sample %d"",', '- \t\t  (unsigned long) row, s + 1);', '-         for (i = 0; i < s; i++)', '-           _tifffree (srcbuffs[i]);', '-         return (0);', '-     dst = obuf + (row * dst_rowsize);', '-       if (combineseparatesamplesbytes (srcbuffs, dst, row, width,', '-                                       spp, bps, dump->infile,', '-                                       dump->format, dump->level))', '-         for (i = 0; i < spp; i++)', '-          _tifffree (srcbuffs[i]);', '- \treturn (0);', '-         case 1: if (combineseparatesamples8bits (srcbuffs, dst, row, width,', '-                                                 spp, bps, dump->infile,', '-                                                 dump->format, dump->level))', '- \t          {', '-                   for (i = 0; i < spp; i++)', '-                     _tifffree (srcbuffs[i]);', '- \t          return (0);', '- \t\t  }', '- \t\tbreak;', '-         case 2: if (combineseparatesamples16bits (srcbuffs, dst, row, width,', '-                   for (i = 0; i < spp; i++)', '-                     _tifffree (srcbuffs[i]);', '- \t          return (0);', '- \t\t  }', '-         case 3: if (combineseparatesamples24bits (srcbuffs, dst, row, width,', '-                                                  spp, bps, dump->infile,', '-                                                  dump->format, dump->level))', '-                   for (i = 0; i < spp; i++)', '-                     _tifffree (srcbuffs[i]);', '- \t          return (0);', '- ', '-         case 8: if (combineseparatesamples32bits (srcbuffs, dst, row, width,', '-                                                  spp, bps, dump->infile,', '-                                                  dump->format, dump->level))', '-                   for (i = 0; i < spp; i++)', '-                     _tifffree (srcbuffs[i]);', '- \t          return (0);', '- \t\tbreak;', '-                   for (i = 0; i < spp; i++)', '-                     _tifffree (srcbuffs[i]);', '- \t          return (0);', '- \t}', '-   return (1);', '-     if (((image->xres == 0) || (image->yres == 0)) &&', '- loadimage(tiff* in, struct image_data *image, struct dump_opts * dump, unsigned char **read_ptr)', '-   float    xres=0.0, yres=0.0;', '-   uint16   nstrips, ntiles, planar, bps, spp, res_unit, photometric, orientation;', '-   uint32   width, length, rowsperstrip;', '-   uint32   stsize, tlsize, buffsize, scanlinesize;', '-   tiffgetfield(in, tifftag_photometric, &photometric);', '-   tiffgetfield(in, tifftag_imagewidth,  &width);', '-   tiffgetfield(in, tifftag_imagelength, &length);', '-   tiffgetfield(in, tifftag_xresolution, &xres);', '-   tiffgetfield(in, tifftag_yresolution, &yres);', '-   tiffgetfield(in, tifftag_resolutionunit, &res_unit);', '-                  ""tilesize: %u, number of tiles: %u, scanline size: %u"",', '-                  tlsize, ntiles, scanlinesize);', ""-   _tiffmemset(read_buff, '\\0', buffsize);"", '- \t   if (!(readcontigstripsintobuffer(in, read_buff, length, width, spp)))', '- \t   if (!(readcontigtilesintobuffer(in, read_buff, length, width, spp)))', '- \t   if (!(readseparatetilesintobuffer(in, read_buff, length, width, spp)))', '-                case 1:  if (extractcontigsamplesshifted8bits (src, dst, img_width,', '-                                                               sample, spp, bps, count,', '-                                                               first_col, last_col + 1,', '-                                                               prev_trailing_bits))', '-                           {', '- \t\t          tifferror(""extractcompositeregions"",', '-                                     ""unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '- \t\t        break;', '-                case 2:  if (extractcontigsamplesshifted16bits (src, dst, img_width,', '-                           {', '- \t\t          tifferror(""extractcompositeregions"",', '-                                     ""unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '-                case 3:  if (extractcontigsamplesshifted24bits (src, dst, img_width,', '-                case 1:  if (extractcontigsamplesshifted8bits (src, dst, img_width,', '-                                                               sample, spp, bps, count,', '-                                                               first_col, last_col + 1,', '-                                                               prev_trailing_bits))', '-                           {', '- \t\t          tifferror(""extractcompositeregions"",', '-                                     ""unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '- \t\t        break;', '-                case 2:  if (extractcontigsamplesshifted16bits (src, dst, img_width,', '-                           {', '- \t\t          tifferror(""extractcompositeregions"",', '-                                     ""unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '-                case 3:  if (extractcontigsamplesshifted24bits (src, dst, img_width,', '-       case 1: if (extractcontigsamplesshifted8bits (src, dst, img_width,', '-                                                     sample, spp, bps, count,', '-                                                     first_col, last_col + 1,', '-                                                     prev_trailing_bits))', '-                 {', '- \t        tifferror(""extractseparateregion"",', '-                          ""unable to extract row %d"", row);', '- \t\treturn (1);', '- \t\t}', '- \t      break;', '-      case 2:  if (extractcontigsamplesshifted16bits (src, dst, img_width,', '-                                                      sample, spp, bps, count,', '-                                                      first_col, last_col + 1,', '-                                                      prev_trailing_bits))', '-                 {', '- \t\ttifferror(""extractseparateregion"",', '-                           ""unable to extract row %d"", row);', '- \t\treturn (1);', '-      case 3:  if (extractcontigsamplesshifted24bits (src, dst, img_width,', '-      case 4:', '-      case 5:  if (extractcontigsamplesshifted32bits (src, dst, img_width,', '- #ifdef debug2', '- #ifdef debug2', '- #ifdef debug2', '- #ifdef debug2', '- #ifdef debug', '-   tifferror("""",', '-     ""writing %d sections for each original page. hres: %3.2f vres: %3.2f\\n"",', '-           page->rows * page->cols, hres, vres);', '- #endif', '- #ifdef debug', '-     tifferror ("""", ""\\nsection: %d, width: %4d, length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d\\n"",', '-              i + 1, width, length, sections[i].x1, sections[i].x2, sections[i].y1, sections[i].y2);', '- #endif', '- ', '- #ifdef debug', '-   tifferror ("""",', '- ""\\nwriting single section: width %d length: %d hres: %4.1f, vres: %4.1f\\n\\n"",', '- \t   width, length, hres, vres);', '- #endif', '-     copyfield(tifftag_compression, compression);', '- ', '-   if (compression == compression_jpeg) {', '-     uint16 input_compression, input_photometric;', '-     if (tiffgetfield(in, tifftag_compression, &input_compression)', '-         && input_compression == compression_jpeg) {', '-           tiffsetfield(in, tifftag_jpegcolormode, jpegcolormode_rgb);', '-         }', '-     if (tiffgetfield(in, tifftag_photometric, &input_photometric)) {', '- \tif(input_photometric == photometric_rgb) {', '- \t   if (jpegcolormode == jpegcolormode_rgb)', '- \t     tiffsetfield(out, tifftag_photometric, photometric_ycbcr);', '- \t   else', '- \t     tiffsetfield(out, tifftag_photometric, photometric_rgb);', '- \t   } else', '- \t      tiffsetfield(out, tifftag_photometric, input_photometric);', '-   else', '-        tiffsetfield(out, tifftag_photometric, spp == 1 ?', '-     if (tilewidth == (uint32) -1)', '-     if (tilelength == (uint32) -1)', '-     if (tilewidth > width)', '-       tilewidth = width;', '-     if (tilelength > length)', '-       tilelength = length;', '- ', '- \tif (rowsperstrip == (uint32) 0) {', '- \t  if (!tiffgetfield(in, tifftag_rowsperstrip, &rowsperstrip)) {', '- \t      rowsperstrip = tiffdefaultstripsize(out, rowsperstrip);', '- \t     }', '- \t  if (rowsperstrip > length && rowsperstrip != (uint32)-1)', '- \t       rowsperstrip = length;', '- \telse if (rowsperstrip == (uint32) -1)', '- \t\trowsperstrip = length;', '- \t\ttiffsetfield(out, tifftag_rowsperstrip, rowsperstrip);', '-          tiffsetfield(out, tifftag_jpegquality, quality);', '- \t tiffsetfield(out, tifftag_jpegcolormode, jpegcolormode);', '-       {', '-       writebuffertocontigtiles (out, sect_buff, length, width, spp);', '-       }', '-       {', '-       writebuffertocontigstrips (out, sect_buff, length, width, spp);', '-       }', '-       {', '-       }', '-     copyfield(tifftag_compression, compression);', '- ', '-   if (compression == compression_jpeg) {', '-     uint16 input_compression, input_photometric;', '-     if (tiffgetfield(in, tifftag_compression, &input_compression)', '-         && input_compression == compression_jpeg) {', '-           tiffsetfield(in, tifftag_jpegcolormode, jpegcolormode_rgb);', '-         }', '-     if (tiffgetfield(in, tifftag_photometric, &input_photometric)) {', '- \tif(input_photometric == photometric_rgb) {', '- \t   if (jpegcolormode == jpegcolormode_rgb)', '- \t     tiffsetfield(out, tifftag_photometric, photometric_ycbcr);', '- \t   else', '- \t     tiffsetfield(out, tifftag_photometric, photometric_rgb);', '- \t   } else', '- \t      tiffsetfield(out, tifftag_photometric, input_photometric);', '-   }', '-     if (tilewidth == (uint32) -1)', '-     if (tilelength == (uint32) -1)', '-     if (tilewidth > width)', '-       tilewidth = width;', '-     if (tilelength > length)', '-       tilelength = length;', '- ', '-     tiffdefaulttilesize(out, &tilewidth, &tilelength);', '-             {', '- \t  if (rowsperstrip > length)', '- \t    rowsperstrip = length;', '-          tiffsetfield(out, tifftag_jpegquality, quality);', '- \t tiffsetfield(out, tifftag_jpegcolormode, jpegcolormode);', '- \tbreak;', '-       {', '-       writebuffertocontigtiles (out, crop_buff, length, width, spp);', '-       }', '-       {', '-       writebuffertocontigstrips (out, crop_buff, length, width, spp);', '-       }', '-       {', '-       }', '-   uint8    matchbits = 0, maskbits = 0;', '-   maskbits =  (uint8)-1 >> ( 8 - bps);', '-       matchbits = maskbits << (8 - src_bit - bps);', '-       buff1 = ((*src) & matchbits) << (src_bit);', '-   uint32   src_byte = 0, src_bit = 0;', '-   uint16   matchbits = 0, maskbits = 0;', '-   maskbits =  (uint16)-1 >> (16 - bps);', '-         src_bit  = bit_offset % 8;', '-         src_bit  = (bit_offset + (sample * bps)) % 8;', '-       matchbits = maskbits << (16 - src_bit - bps);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-   uint32   src_byte = 0, src_bit = 0;', '-   uint32   matchbits = 0, maskbits = 0;', '-   maskbits =  (uint32)-1 >> (32 - bps);', '-         src_bit  = bit_offset % 8;', '-         src_bit  = (bit_offset + (sample * bps)) % 8;', '-       matchbits = maskbits << (32 - src_bit - bps);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-   uint32 src_byte = 0, src_bit = 0;', '-   uint64 maskbits = 0, matchbits = 0;', '-   maskbits =  (uint64)-1 >> (64 - bps);', '-         src_bit  = bit_offset % 8;', '-         src_bit  = (bit_offset + (sample * bps)) % 8;', '-       matchbits = maskbits << (64 - src_bit - bps);', '-       buff1 = (buff3 & matchbits) << (src_bit);']]","[['+ static   char tiffcrop_version_id[] = ""2.1"";', '+ static   char tiffcrop_rev_date[] = ""09-18-2009"";', '+ ', '+ static uint32 tilewidth = 0;', '+ static uint32 tilelength = 0;', '+ ', '+ static uint16 config = 0;', '+ static uint16 compression = 0;', '+ static uint16 predictor = 0;', '+ static uint16 fillorder = 0;', '+ static uint32 rowsperstrip = 0;', '+ static uint32 g3opts = 0;', '+ static int  readContigStripsIntoBuffer   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);', '+ static int  readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, uint32, uint32, tsample_t, uint16);', '+ static int  writeBufferToContigStrips    (TIFF*, uint8*, uint32);', '+ static int  writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '+ static int  extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, tsample_t,', '+                                          uint16, uint16, struct dump_opts *);', '+ static int extractContigSamplesToTileBuffer(uint8 *, uint8 *, uint32, uint32,', '+   \t                                    uint32, uint32, tsample_t, uint16,', '+ \t\t\t\t\t    uint16, uint16, struct dump_opts *);', '+ ', '+ \t\t\t\t\tuint32, uint32, tsample_t, uint16,', '+                                         FILE *, int, int);', '+ ', '+ static int combineSeparateTileSamples8bits (uint8 *[], uint8 *, uint32, uint32,', '+                                             uint32, uint32, uint16, uint16,', '+                                             FILE *, int, int);', '+ static int combineSeparateTileSamples16bits (uint8 *[], uint8 *, uint32, uint32,', '+                                              uint32, uint32, uint16, uint16,', '+                                              FILE *, int, int);', '+ static int combineSeparateTileSamples24bits (uint8 *[], uint8 *, uint32, uint32,', '+                                              uint32, uint32, uint16, uint16,', '+                                              FILE *, int, int);', '+ static int combineSeparateTileSamples32bits (uint8 *[], uint8 *, uint32, uint32,', '+                                              uint32, uint32, uint16, uint16,', '+                                              FILE *, int, int);', '+ static int combineSeparateTileSamplesBytes (unsigned char *[], unsigned char *,', '+ \t\t\t  \t\t    uint32, uint32, uint32, uint32,', '+                                             tsample_t, uint16, FILE *, int, int);', '+ "" #\t\tSet compression quality level (0-100, default 100)"",', '+ "" r\t\tOutput color image as raw RGB rather than YCbCr"",', '+ "" a\t\tOutput color image as RGB or YCbCr with auto detection"",', '+ ""             when sectioning image into columns x rows using the -S cols:rows option"",', '+ ""             when sectioning image into columns x rows using the -S cols:rows option"",', '+ ""             increase the level of detail. Note: Tiffcrop may be compiled with"",', '+ ""             -DDEVELMODE to enable additional very low level debug reporting."",', '+ ""   Format:txt|raw  Format any logged data as ASCII text or raw binary "",', '+                                       uint32 tw, uint32 tl,', '+                                       tsample_t spp, uint16 bps)', '+   {', '+   int status = 1;', '+   tsample_t sample = 0;', '+   tsample_t count = spp;', '+   uint32 row, col, trow;', '+   uint32 nrow, ncol;', '+   uint32 dst_rowsize, shift_width;', '+   uint32 bytes_per_sample, bytes_per_pixel;', '+   uint32 trailing_bits, prev_trailing_bits;', '+   uint32 tile_rowsize  = TIFFTileRowSize(in);', '+   uint32 src_offset, dst_offset;', '+   uint32 row_offset, col_offset;', '+   uint8 *bufp = (uint8*) buf;', '+   unsigned char *src = NULL;', '+   unsigned char *dst = NULL;', '+   tsize_t tbytes = 0, tile_buffsize = 0;', '+   tsize_t tilesize = TIFFTileSize(in);', '+   unsigned char *tilebuf = NULL;', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   bytes_per_pixel  = ((bps * spp) + 7) / 8;', '+ ', '+   if ((bps % 8) == 0)', '+     shift_width = 0;', '+   else', '+     {', '+     if (bytes_per_pixel < (bytes_per_sample + 1))', '+       shift_width = bytes_per_pixel;', '+     else', '+       shift_width = bytes_per_sample + 1;', '+     }', '+ ', '+   tile_buffsize = tilesize;', '+ ', '+   if (tilesize < (tsize_t)(tl * tile_rowsize))', '+     {', '+ #ifdef DEBUG2', '+     TIFFError(""readContigTilesIntoBuffer"",', '+ \t      ""Tilesize %lu is too small, using alternate calculation %u"",', '+               tilesize, tl * tile_rowsize);', '+ #endif', '+     tile_buffsize = tl * tile_rowsize;', '+     }', '+ ', '+   tilebuf = _TIFFmalloc(tile_buffsize);', '+   if (tilebuf == 0)', '+     return 0;', '+ ', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   for (row = 0; row < imagelength; row += tl)', '+     {', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       {', '+       tbytes = TIFFReadTile(in, tilebuf, col, row, 0, 0);', '+       if (tbytes < tilesize  && !ignore)', '+         {', '+ \tTIFFError(TIFFFileName(in),', '+ \t\t  ""Error, can\'t read tile at row %lu col %lu, Read %lu bytes of %lu"",', '+ \t\t  (unsigned long) col, (unsigned long) row, (unsigned long)tbytes,', '+                   (unsigned long)tilesize);', '+ \t\t  status = 0;', '+                   _TIFFfree(tilebuf);', '+ \t\t  return status;', '+ ', '+       row_offset = row * dst_rowsize;', '+       col_offset = ((col * bps * spp) + 7)/ 8;', '+       bufp = buf + row_offset + col_offset;', '+       if (col + tw > imagewidth)', '+ \tncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       if (((bps % 8) == 0) && (count == spp))', '+         {', '+ \tfor (trow = 0; trow < nrow; trow++)', '+           {', '+ \t  src_offset = trow * tile_rowsize;', '+ \t  _TIFFmemcpy (bufp, tilebuf + src_offset, (ncol * spp * bps) / 8);', '+           bufp += (imagewidth * bps * spp) / 8;', '+ \t  }', '+         }', '+       else', '+         {', '+         prev_trailing_bits = trailing_bits = 0;', '+         trailing_bits = (ncol * bps * spp) % 8;', '+ ', '+ \tfor (trow = 0; trow < nrow; trow++)', '+           {', '+ \t  src_offset = trow * tile_rowsize;', '+           src = tilebuf + src_offset;', '+ \t  dst_offset = (row + trow) * dst_rowsize;', '+           dst = buf + dst_offset + col_offset;', '+           switch (shift_width)', '+             {', '+             case 0: if (extractContigSamplesBytes (src, dst, ncol, sample,', '+                                                    spp, bps, count, 0, ncol))', '+                       {', '+ \t\t      TIFFError(""readContigTilesIntoBuffer"",', '+                                 ""Unable to extract row %d from tile %lu"",', '+ \t\t\t\trow, (unsigned long)TIFFCurrentTile(in));', '+ \t\t      return (1);', '+ \t\t      }', '+ \t\t    break;', '+             case 1: if (bps == 1)', '+                       {', '+                       if (extractContigSamplesShifted8bits (src, dst, ncol,', '+                                                             sample, spp,', '+                                                             bps, count,', '+                                                             0, ncol,', '+                                                             prev_trailing_bits))', '+                         {', '+ \t\t        TIFFError(""readContigTilesIntoBuffer"",', '+                                   ""Unable to extract row %d from tile %lu"",', '+ \t\t\t\t  row, (unsigned long)TIFFCurrentTile(in));', '+ \t\t        return (1);', '+ \t\t        }', '+ \t\t      break;', '+ \t\t      }', '+                     else', '+                       if (extractContigSamplesShifted16bits (src, dst, ncol,', '+                                                              sample, spp,', '+                                                              bps, count,', '+                                                              0, ncol,', '+                                                              prev_trailing_bits))', '+                         {', '+ \t\t        TIFFError(""readContigTilesIntoBuffer"",', '+                                   ""Unable to extract row %d from tile %lu"",', '+ \t\t\t  \t  row, (unsigned long)TIFFCurrentTile(in));', '+ \t\t        return (1);', '+ \t\t        }', '+ \t            break;', '+             case 2: if (extractContigSamplesShifted24bits (src, dst, ncol,', '+                                                            sample, spp,', '+                                                            bps, count,', '+                                                            0, ncol,', '+                                                            prev_trailing_bits))', '+                       {', '+ \t\t      TIFFError(""readContigTilesIntoBuffer"",', '+                                 ""Unable to extract row %d from tile %lu"",', '+ \t\t  \t        row, (unsigned long)TIFFCurrentTile(in));', '+ \t\t      return (1);', '+ \t\t      }', '+ \t\t    break;', '+             case 3:', '+             case 4:', '+             case 5: if (extractContigSamplesShifted32bits (src, dst, ncol,', '+                                                            sample, spp,', '+                                                            bps, count,', '+                                                            0, ncol,', '+                                                            prev_trailing_bits))', '+                       {', '+ \t\t      TIFFError(""readContigTilesIntoBuffer"",', '+                                 ""Unable to extract row %d from tile %lu"",', '+ \t\t\t        row, (unsigned long)TIFFCurrentTile(in));', '+ \t\t      return (1);', '+ \t\t      }', '+ \t\t    break;', '+             default: TIFFError(""readContigTilesIntoBuffer"", ""Unsupported bit depth %d"", bps);', '+ \t\t     return (1);', '+ \t    }', '+           }', '+         prev_trailing_bits += trailing_bits;', '+         if (prev_trailing_bits > 7)', '+ \t  prev_trailing_bits-= 8;', '+       }', '+     }', '+   _TIFFfree(tilebuf);', '+   return status;', '+   }', '+ ', '+ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,', '+ \t\t\t\t\t uint32 imagelength, uint32 imagewidth,', '+                                          uint32 tw, uint32 tl,', '+                                          uint16 spp, uint16 bps)', '+   {', '+   int     i, status = 1, sample;', '+   int     shift_width, bytes_per_pixel;', '+   uint16  bytes_per_sample;', '+   tsize_t tbytes = 0, tilesize = TIFFTileSize(in);', '+   tsample_t s;', '+   uint8*  bufp = (uint8*)obuf;', '+   unsigned char *srcbuffs[MAX_SAMPLES];', '+   unsigned char *tbuff = NULL;', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+ ', '+   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)', '+     {', '+     srcbuffs[sample] = NULL;', '+     tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);', '+     if (!tbuff)', '+       {', '+       TIFFError (""readSeparateStripsIntoBuffer"",', '+                  ""Unable to allocate tile read buffer for sample %d"", sample);', '+       for (i = 0; i < sample; i++)', '+         _TIFFfree (srcbuffs[i]);', '+       return 0;', '+       }', '+     srcbuffs[sample] = tbuff;', '+     }', '+   for (row = 0; row < imagelength; row += tl)', '+     {', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       {', '+       for (s = 0; s < spp; s++)', '+       if (col + tw > imagewidth)', '+         ncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       row_offset = row * (((imagewidth * spp * bps) + 7) / 8);', '+       col_offset = ((col * spp * bps) + 7) / 8;', '+       bufp = obuf + row_offset + col_offset;', '+ ', '+       if ((bps % 8) == 0)', '+         {', '+         if (combineSeparateTileSamplesBytes(srcbuffs, bufp, ncol, nrow, imagewidth,', '+ \t\t\t\t\t    tw, spp, bps, NULL, 0, 0))', '+ \t  {', '+           status = 0;', '+           break;', '+       \t  }', '+ \t}', '+       else', '+         {', '+         bytes_per_pixel  = ((bps * spp) + 7) / 8;', '+         if (bytes_per_pixel < (bytes_per_sample + 1))', '+           shift_width = bytes_per_pixel;', '+         else', '+           shift_width = bytes_per_sample + 1;', '+ ', '+         switch (shift_width)', '+           {', '+           case 1: if (combineSeparateTileSamples8bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       NULL, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+       \t            }', '+ \t          break;', '+           case 2: if (combineSeparateTileSamples16bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       NULL, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+ \t\t    }', '+ \t          break;', '+           case 3: if (combineSeparateTileSamples24bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       NULL, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+        \t            }', '+                   break;', '+           case 4:', '+           case 5:', '+           case 6:', '+           case 7:', '+           case 8: if (combineSeparateTileSamples32bits (srcbuffs, bufp, ncol, nrow,', '+                                                        imagewidth, tw, spp, bps,', '+ \t\t\t\t\t\t       NULL, 0, 0))', '+ \t            {', '+                     status = 0;', '+                     break;', '+ \t\t    }', '+ \t          break;', '+           default: TIFFError (""readSeparateTilesIntoBuffer"", ""Unsupported bit depth: %d"", bps);', '+                   status = 0;', '+                   break;', '+           }', '+         }', '+       }', '+     }', '+ ', '+   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)', '+     {', '+     tbuff = srcbuffs[sample];', '+     if (tbuff != NULL)', '+       _TIFFfree(tbuff);', '+     }', '+ ', '+   return status;', '+   }', '+ ', '+ static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength)', '+   {', '+   uint32 row, nrows, rowsperstrip;', '+   tstrip_t strip = 0;', '+   tsize_t stripsize;', '+ ', '+   TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);', '+   for (row = 0; row < imagelength; row += rowsperstrip)', '+     {', '+     nrows = (row + rowsperstrip > imagelength) ?', '+ \t     imagelength - row : rowsperstrip;', '+     stripsize = TIFFVStripSize(out, nrows);', '+     if (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0)', '+       {', '+       TIFFError(TIFFFileName(out), ""Error, can\'t write strip %u"", strip - 1);', '+       return 0;', '+       }', '+     buf += stripsize;', '+     }', '+   return 1;', '+   }', '+ ', '+       if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))', '+   _TIFFfree(obuf);', '+   return 1;', '+ }', '+ static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,', '+ \t\t\t\t       uint32 imagewidth, tsample_t spp,', '+                                        struct dump_opts* dump)', '+   {', '+   uint16 bps;', '+   uint32 tl, tw;', '+   uint32 row, col, nrow, ncol;', '+   uint32 src_rowsize, col_offset;', '+   uint32 tile_rowsize  = TIFFTileRowSize(out);', '+   uint8* bufp = (uint8*) buf;', '+   tsize_t tile_buffsize = 0;', '+   tsize_t tilesize = TIFFTileSize(out);', '+   unsigned char *tilebuf = NULL;', '+ ', '+   TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);', '+   TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);', '+   TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);', '+ ', '+   tile_buffsize = tilesize;', '+   if (tilesize < (tsize_t)(tl * tile_rowsize))', '+     {', '+ #ifdef DEBUG2', '+     TIFFError(""writeBufferToContigTiles"",', '+ \t      ""Tilesize %lu is too small, using alternate calculation %u"",', '+               tilesize, tl * tile_rowsize);', '+ #endif', '+     tile_buffsize = tl * tile_rowsize;', '+     }', '+   tilebuf = _TIFFmalloc(tile_buffsize);', '+   if (tilebuf == 0)', '+     return 0;', '+   src_rowsize = ((imagewidth * spp * bps) + 7) / 8;', '+   for (row = 0; row < imagelength; row += tl)', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       if (col + tw > imagewidth)', '+ \tncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       col_offset = (((col * bps * spp) + 7) / 8);', '+       bufp = buf + (row * src_rowsize) + col_offset;', '+       if (extractContigSamplesToTileBuffer(tilebuf, bufp, nrow, ncol, imagewidth,', '+ \t\t\t\t\t   tw, 0, spp, spp, bps, dump) > 0)', '+ \tTIFFError(""writeBufferToContigTiles"",', '+                   ""Unable to extract data to tile for row %lu, col %lu"",', '+                   (unsigned long) row, (unsigned long)col);', '+ \t_TIFFfree(tilebuf);', '+ \treturn (0);', '+         }', '+       if (TIFFWriteTile(out, tilebuf, col, row, 0, 0) < 0)', '+ \tTIFFError(""writeBufferToContigTiles"",', '+ \t          ""Cannot write tile at %lu %lu"",', '+ \t          (unsigned long) col, (unsigned long) row);', '+ \t _TIFFfree(tilebuf);', '+     }', '+   _TIFFfree(tilebuf);', '+   tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));', '+   uint32 tl, tw;', '+   uint32 row, col, nrow, ncol;', '+   uint32 src_rowsize, col_offset;', '+   uint16 bps;', '+   tsample_t s;', '+   uint8* bufp = (uint8*) buf;', '+ ', '+   if (obuf == NULL)', '+     return 0;', '+ ', '+   TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);', '+   TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);', '+   TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);', '+   src_rowsize = ((imagewidth * spp * bps) + 7) / 8;', '+ ', '+   for (row = 0; row < imagelength; row += tl)', '+     {', '+     nrow = (row + tl > imagelength) ? imagelength - row : tl;', '+     for (col = 0; col < imagewidth; col += tw)', '+       {', '+       if (col + tw > imagewidth)', '+ \tncol = imagewidth - col;', '+       else', '+         ncol = tw;', '+ ', '+       col_offset = (((col * bps * spp) + 7) / 8);', '+       bufp = buf + (row * src_rowsize) + col_offset;', '+ ', '+       for (s = 0; s < spp; s++)', '+         {', '+ \tif (extractContigSamplesToTileBuffer(obuf, bufp, nrow, ncol, imagewidth,', '+ \t\t\t\t\t     tw, s, 1, spp, bps, dump) > 0)', '+           {', '+ \t  TIFFError(""writeBufferToSeparateTiles"",', '+                     ""Unable to extract data to tile for row %lu, col %lu sample %d"",', '+                     (unsigned long) row, (unsigned long)col, (int)s);', '+ \t  _TIFFfree(obuf);', '+ \t  return (0);', '+           }', '+ ', '+ \tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0)', '+           {', '+ \t   TIFFError(""writeBufferToseparateTiles"",', '+ \t             ""Cannot write tile at %lu %lu sample %lu"",', '+ \t             (unsigned long) col, (unsigned long) row,', '+ \t             (unsigned long) s);', '+ \t   _TIFFfree(obuf);', '+ \t  return 0;', '+ \t  }', '+       }', '+     }', '+   _TIFFfree(obuf);', '+   return 1;', '+   {', '+   char* cp = NULL;', '+   if (strneq(opt, ""none"",4))', '+     {', '+     defcompression = COMPRESSION_NONE;', ""+     cp = strchr(opt, ':');"", '+     if (cp)', '+       {', ""+       if (cp[1] == 'r' )"", '+ \tjpegcolormode = JPEGCOLORMODE_RAW;', ""+       else if (cp[1] == 'a' )"", '+ \tjpegcolormode = JPEGCOLORMODE_RGB;', '+       }', '+     }', '+   else if (streq(opt, ""packbits""))', '+     {', '+     defcompression = COMPRESSION_PACKBITS;', '+     }', '+   else if (strneq(opt, ""jpeg"", 4))', '+     {', ""+     cp = strchr(opt, ':');"", '+     defcompression = COMPRESSION_JPEG;', '+     while ( cp )', '+       {', '+       if (isdigit((int)cp[1]))', '+ \tquality = atoi(cp+1);', ""+       else if (cp[1] == 'r' )"", '+ \tjpegcolormode = JPEGCOLORMODE_RAW;', ""+       else if (cp[1] == 'a' )"", '+ \tjpegcolormode = JPEGCOLORMODE_RGB;', '+       else', '+         usage();', ""+       cp = strchr(cp+1,':');"", '+       }', '+     }', '+   else if (strneq(opt, ""g3"", 2))', '+     {', '+     processG3Options(opt);', '+     defcompression = COMPRESSION_CCITTFAX3;', '+     }', '+   else if (streq(opt, ""g4""))', '+     {', '+     defcompression = COMPRESSION_CCITTFAX4;', '+     }', '+   else if (strneq(opt, ""lzw"", 3))', '+     {', ""+     cp = strchr(opt, ':');"", '+     if (cp)', '+       defpredictor = atoi(cp+1);', '+     defcompression = COMPRESSION_LZW;', '+     }', '+   else if (strneq(opt, ""zip"", 3))', '+     {', ""+     cp = strchr(opt, ':');"", '+     if (cp)', '+       defpredictor = atoi(cp+1);', '+     defcompression = COMPRESSION_ADOBE_DEFLATE;', '+    }', '+   else', '+     return (0);', '+   return (1);', '+   }', '+   {', '+   char buf[BUFSIZ];', '+   int i;', '+ ', '+   setbuf(stderr, buf);', '+   fprintf(stderr, ""\\n%s\\n"", TIFFGetVersion());', '+   for (i = 0; stuff[i] != NULL; i++)', '+     fprintf(stderr, ""%s\\n"", stuff[i]);', '+   exit(-1);', '+   }', '+       case \'v\': TIFFError(""Library Release"", ""%s"", TIFFGetVersion());', '+                 TIFFError (""Tiffcrop version"", ""%s, last updated: %s"",', '+   uint32 deftilewidth = (uint32) 0;', '+   uint32 deftilelength = (uint32) 0;', '+ \t    TIFFError (""Unable to open dump file for writing"", ""%s"", temp_filename);', '+ \t      TIFFError (""Unable to open dump file for writing"", ""%s"", temp_filename);', '+   \t                     tsample_t sample, uint16 spp, uint16 bps,', '+                              struct dump_opts *dump)', '+       case 1: if (bps == 1)', '+                 {', '+                 if (extractContigSamples8bits (src, dst, cols, sample,', '+                                                spp, bps, count, first_col, cols))', '+ \t          return (1);', '+ \t        break;', '+ \t\t}', '+ \t      else', '+                  if (extractContigSamples16bits (src, dst, cols, sample,', '+                                                  spp, bps, count, first_col, cols))', '+       case 2: if (extractContigSamples24bits (src, dst, cols, sample,', '+       case 3:', '+ static int', '+ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols,', '+   \t                         uint32 imagewidth, uint32 tilewidth, tsample_t sample,', '+ \t\t\t\t uint16 count, uint16 spp, uint16 bps, struct dump_opts *dump)', '+   int    shift_width, bytes_per_sample, bytes_per_pixel;', '+   uint32 src_rowsize, src_offset, row;', '+   uint32 dst_rowsize, dst_offset;', '+   uint8 *src, *dst;', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   bytes_per_pixel  = ((bps * spp) + 7) / 8;', '+   if ((bps % 8) == 0)', '+     shift_width = 0;', '+   else', '+     if (bytes_per_pixel < (bytes_per_sample + 1))', '+       shift_width = bytes_per_pixel;', '+     else', '+       shift_width = bytes_per_sample + 1;', '+     }', '+ ', '+   if ((dump->outfile != NULL) && (dump->level == 4))', '+     {', '+     dump_info  (dump->outfile, dump->format, ""extractContigSamplesToTileBuffer"",', '+                 ""Sample %d, %d rows"", sample + 1, rows + 1);', '+     }', '+ ', '+   src_rowsize = ((bps * spp * imagewidth) + 7) / 8;', '+   dst_rowsize = ((bps * tilewidth * count) + 7) / 8;', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     src_offset = row * src_rowsize;', '+     dst_offset = row * dst_rowsize;', '+     src = in + src_offset;', '+     dst = out + dst_offset;', '+ ', '+     switch (shift_width)', '+       {', '+       case 0: if (extractContigSamplesBytes (src, dst, cols, sample,', '+                                              spp, bps,  count, 0, cols))', '+                 return (1);', '+  \t      break;', '+       case 1: if (bps == 1)', '+                 {', '+                 if (extractContigSamples8bits (src, dst, cols, sample,', '+                                                spp, bps, count, 0, cols))', '+ \t          return (1);', '+ \t        break;', '+ \t\t}', '+ \t      else', '+                  if (extractContigSamples16bits (src, dst, cols, sample,', '+                                                  spp, bps, count, 0, cols))', '+ \t         return (1);', '+ \t      break;', '+       case 2: if (extractContigSamples24bits (src, dst, cols, sample,', '+                                               spp, bps,  count, 0, cols))', '+ \t         return (1);', '+ \t      break;', '+       case 3:', '+       case 4:', '+       case 5: if (extractContigSamples32bits (src, dst, cols, sample,', '+                                               spp, bps,  count, 0, cols))', '+ \t         return (1);', '+ \t      break;', '+       default: TIFFError (""extractContigSamplesToTileBuffer"", ""Unsupported bit depth: %d"", bps);', '+ \t       return (1);', '+     if ((dump->outfile != NULL) && (dump->level == 4))', '+       dump_buffer(dump->outfile, dump->format, 1, dst_rowsize, row, dst);', '+   return (0);', '+ ', '+ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf, uint32 length, uint32 width,', '+                                        tsample_t spp, struct dump_opts * dump)', '+   int32  bytes_read = 0;', '+   uint16 nstrips   = TIFFNumberOfStrips(in);', '+   uint32 stripsize = TIFFStripSize(in);', '+   uint32 rows = 0, strip;', '+   uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);', '+   tsize_t scanline_size = TIFFScanlineSize(in);', '+ ', '+   for (strip = 0; strip < nstrips; strip++)', '+     {', '+     bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);', '+     rows = bytes_read / scanline_size;', '+     if (bytes_read != (int32)stripsize)', '+       TIFFError("""", ""Bytes read %lu does not match reported strip size %lu"",', '+ \t\t(unsigned long) bytes_read, (unsigned long)stripsize);', '+ ', '+     if (bytes_read < 0 && !ignore)', '+       {', '+       TIFFError("""", ""Error reading strip %lu after %lu rows"",', '+ \t\t(unsigned long) strip, (unsigned long)rows);', '+       return 0;', '+       }', '+     bufp += bytes_read;', '+     }', '+ static int', '+ combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,', '+                              uint32 cols, uint32 rows, uint16 spp, uint16 bps,', '+                              FILE *dumpfile, int format, int level)', '+   {', '+   int i, bytes_per_sample;', '+   uint32 row, col, col_offset, src_rowsize, dst_rowsize, row_offset;', '+   unsigned char *src;', '+   unsigned char *dst;', '+   tsample_t s;', '+ ', '+   src = srcbuffs[0];', '+   dst = out;', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateSamplesBytes"",""Invalid buffer address"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+ ', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   dst_rowsize = ((bps * spp * cols) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     {', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       for (s = 0; s < spp; s++)', '+         {', '+         dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Input data, Sample %d"", s);', '+         dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));', '+         }', '+       }', '+     dst = out + (row * dst_rowsize);', '+     row_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       col_offset = row_offset + (col * (bps / 8));', '+       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)', '+         {', '+         src = srcbuffs[s] + col_offset;', '+         for (i = 0; i < bytes_per_sample; i++)', '+           *(dst + i) = *(src + i);', '+         src += bytes_per_sample;', '+         dst += bytes_per_sample;', '+         }', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Output data, combined samples"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 cols,', '+                             uint32 rows, uint16 spp, uint16 bps,', '+   uint32 src_rowsize, dst_rowsize, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+       matchbits = maskbits << (8 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         buff1 = ((*src) & matchbits) << (src_bit);', '+ ', '+         if (ready_bits >= 8)', '+           {', '+           *dst++ = buff2;', '+           buff2 = buff1;', '+           ready_bits -= 8;', '+           strcpy (action, ""Flush"");', '+           }', '+         else', '+           {', '+           buff2 = (buff2 | (buff1 >> ready_bits));', '+           strcpy (action, ""Update"");', '+           }', '+         ready_bits += bps;', '+         if ((dumpfile != NULL) && (level == 3))', '+           {', '+           dump_info (dumpfile, format, """",', '+           dump_byte (dumpfile, format, ""Match bits"", matchbits);', '+           dump_byte (dumpfile, format, ""Src   bits"", *src);', '+           dump_byte (dumpfile, format, ""Buff1 bits"", buff1);', '+           dump_byte (dumpfile, format, ""Buff2 bits"", buff2);', '+           dump_info (dumpfile, format, """",""%s"", action);', '+ \t  }', '+         }', '+     if (ready_bits > 0)', '+       buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));', '+       *dst++ = buff1;', '+       if ((dumpfile != NULL) && (level == 3))', '+         {', '+         dump_info (dumpfile, format, """",', '+         }', '+     if ((dumpfile != NULL) && (level >= 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamples8bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+ ', '+ combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 cols,', '+                               uint32 rows, uint16 spp, uint16 bps,', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (16 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[1] = *src;', '+           swapbuff[0] = *(src + 1);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+ \t  }', '+ ', '+ \tbuff1 = *((uint16 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 8)', '+ \t  {', '+ \t    bytebuff = (buff2 >> 8);', '+ \t    *dst++ = bytebuff;', '+ \t    ready_bits -= 8;', '+ \t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ ', '+ \t  dump_short (dumpfile, format, ""Match bits"", matchbits);', '+ \t  dump_data  (dumpfile, format, ""Src   bits"", src, 2);', '+ \t  dump_short (dumpfile, format, ""Buff1 bits"", buff1);', '+ \t  dump_short (dumpfile, format, ""Buff2 bits"", buff2);', '+ \t  dump_byte  (dumpfile, format, ""Write byte"", bytebuff);', '+ \t  dump_info  (dumpfile, format, """",""Ready bits:  %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+       }', '+ ', '+     if (ready_bits > 0)', '+       {', '+       bytebuff = (buff2 >> 8);', '+       *dst++ = bytebuff;', '+       if ((dumpfile != NULL) && (level == 3))', '+ \t{', '+ \tdump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, src_byte, src_bit, dst - out);', '+ \tdump_byte (dumpfile, format, ""Final bits"", bytebuff);', '+ \t}', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamples16bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 cols,', '+                               uint32 rows, uint16 spp, uint16 bps,', '+ \t                      FILE *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0, bytes_per_sample = 0;', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   uint32 maskbits = 0, matchbits = 0;', '+   uint32 buff1 = 0, buff2 = 0;', '+   uint8  bytebuff1 = 0, bytebuff2 = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   unsigned char  swapbuff[4];', '+   char           action[8];', '+ ', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateSamples24bits"",""Invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   dst_rowsize = ((bps * cols * spp) + 7) / 8;', '+   maskbits =  (uint32)-1 >> ( 32 - bps);', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (32 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[3] = *src;', '+           swapbuff[2] = *(src + 1);', '+           swapbuff[1] = *(src + 2);', '+           swapbuff[0] = *(src + 3);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+           swapbuff[2] = *(src + 2);', '+           swapbuff[3] = *(src + 3);', '+ \t  }', '+ ', '+ \tbuff1 = *((uint32 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 16)', '+ \t  {', '+ \t    bytebuff1 = (buff2 >> 24);', '+ \t    *dst++ = bytebuff1;', '+ \t    bytebuff2 = (buff2 >> 16);', '+ \t    *dst++ = bytebuff2;', '+ \t    ready_bits -= 16;', '+ ', '+ \t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_long (dumpfile, format, ""Match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+ \t  dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+ \t  dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+ \t  dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+ \t  dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+ \t  dump_info (dumpfile, format, """",""Ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+       }', '+     while (ready_bits > 0)', '+       {', '+ \tbytebuff1 = (buff2 >> 24);', '+ \t*dst++ = bytebuff1;', '+ \tbuff2 = (buff2 << 8);', '+ \tbytebuff2 = bytebuff1;', '+ \tready_bits -= 8;', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 3))', '+       {', '+       dump_info (dumpfile, format, """",', '+ \t\t   ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t   row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""Match bits "", matchbits);', '+       dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamples24bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,', '+                               uint32 rows, uint16 spp, uint16 bps,', '+ \t                      FILE *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;', '+   uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;', '+   uint32 src_byte = 0, src_bit = 0;', '+   uint32 row, col;', '+   uint32 longbuff1 = 0, longbuff2 = 0;', '+   uint64 maskbits = 0, matchbits = 0;', '+   uint64 buff1 = 0, buff2 = 0, buff3 = 0;', '+   uint8  bytebuff1 = 0, bytebuff2 = 0, bytebuff3 = 0, bytebuff4 = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   unsigned char  swapbuff1[4];', '+   unsigned char  swapbuff2[4];', '+   char           action[8];', '+ ', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateSamples32bits"",""Invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   src_rowsize = ((bps * cols) + 7) / 8;', '+   dst_rowsize = ((bps * cols * spp) + 7) / 8;', '+   maskbits =  (uint64)-1 >> ( 64 - bps);', '+   shift_width = ((bps + 7) / 8) + 1;', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (64 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \t{', '+ \tsrc = in[s] + src_offset + src_byte;', '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff1[3] = *src;', '+ \t  swapbuff1[2] = *(src + 1);', '+ \t  swapbuff1[1] = *(src + 2);', '+ \t  swapbuff1[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff1[0] = *src;', '+ \t  swapbuff1[1] = *(src + 1);', '+ \t  swapbuff1[2] = *(src + 2);', '+ \t  swapbuff1[3] = *(src + 3);', '+ \t  }', '+         longbuff1 = *((uint32 *)swapbuff1);', '+ ', ""+ \tmemset (swapbuff2, '\\0', sizeof(swapbuff2));"", '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff2[3] = *src;', '+ \t  swapbuff2[2] = *(src + 1);', '+ \t  swapbuff2[1] = *(src + 2);', '+ \t  swapbuff2[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff2[0] = *src;', '+ \t  swapbuff2[1] = *(src + 1);', '+ \t  swapbuff2[2] = *(src + 2);', '+ \t  swapbuff2[3] = *(src + 3);', '+ \t  }', '+ ', '+ \tlongbuff2 = *((uint32 *)swapbuff2);', '+ \tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;', '+ \tbuff1 = (buff3 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 32)', '+ \t  {', '+ \t  bytebuff1 = (buff2 >> 56);', '+ \t  *dst++ = bytebuff1;', '+ \t  bytebuff2 = (buff2 >> 48);', '+ \t  *dst++ = bytebuff2;', '+ \t  bytebuff3 = (buff2 >> 40);', '+ \t  *dst++ = bytebuff3;', '+ \t  bytebuff4 = (buff2 >> 32);', '+ \t  *dst++ = bytebuff4;', '+ \t  ready_bits -= 32;', '+ ', '+ \t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));', '+ \t  strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t     ""Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_wide (dumpfile, format, ""Match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""Src   bits "", src, 8);', '+ \t  dump_wide (dumpfile, format, ""Buff1 bits "", buff1);', '+ \t  dump_wide (dumpfile, format, ""Buff2 bits "", buff2);', '+ \t  dump_info (dumpfile, format, """", ""Ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+       }', '+     while (ready_bits > 0)', '+       {', '+       bytebuff1 = (buff2 >> 56);', '+       *dst++ = bytebuff1;', '+       buff2 = (buff2 << 8);', '+       ready_bits -= 8;', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 3))', '+       {', '+       dump_info (dumpfile, format, """",', '+ \t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""Match bits "", matchbits);', '+       dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateSamples32bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateTileSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,', '+                                  uint32 cols, uint32 rows, uint32 imagewidth,', '+                                  uint32 tw, uint16 spp, uint16 bps,', '+                                  FILE *dumpfile, int format, int level)', '+   {', '+   int i, bytes_per_sample;', '+   uint32 row, col, col_offset, src_rowsize, dst_rowsize, src_offset;', '+   unsigned char *src;', '+   unsigned char *dst;', '+   tsample_t s;', '+ ', '+   src = srcbuffs[0];', '+   dst = out;', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateTileSamplesBytes"",""Invalid buffer address"");', '+     return (1);', '+     }', '+ ', '+   bytes_per_sample = (bps + 7) / 8;', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = imagewidth * bytes_per_sample * spp;', '+   for (row = 0; row < rows; row++)', '+     {', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       for (s = 0; s < spp; s++)', '+         dump_info (dumpfile, format, ""combineSeparateTileSamplesBytes"",""Input data, Sample %d"", s);', '+         dump_buffer(dumpfile, format, 1, cols, row, srcbuffs[s] + (row * src_rowsize));', '+       }', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+ #ifdef DEVELMODE', '+     TIFFError("""",""Tile row %4d, Src offset %6d   Dst offset %6d"",', '+               row, src_offset, dst - out);', '+ #endif', '+     for (col = 0; col < cols; col++)', '+       {', '+       col_offset = src_offset + (col * (bps / 8));', '+       for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)', '+         {', '+         src = srcbuffs[s] + col_offset;', '+         for (i = 0; i < bytes_per_sample; i++)', '+           *(dst + i) = *(src + i);', '+         dst += bytes_per_sample;', '+         }', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateTileSamplesBytes"",""Output data, combined samples"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateTileSamples8bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                  uint32 rows, uint32 imagewidth,', '+                                  uint32 tw, uint16 spp, uint16 bps,', '+  \t                         FILE *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0;', '+   uint32 src_rowsize, dst_rowsize, src_offset;', '+   uint32 bit_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   uint8  maskbits = 0, matchbits = 0;', '+   uint8  buff1 = 0, buff2 = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   char           action[32];', '+ ', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateTileSamples8bits"",""Invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   maskbits =  (uint8)-1 >> ( 8 - bps);', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (8 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+         {', '+ \tsrc = in[s] + src_offset + src_byte;', '+         buff1 = ((*src) & matchbits) << (src_bit);', '+ ', '+         if (ready_bits >= 8)', '+           {', '+           *dst++ = buff2;', '+           buff2 = buff1;', '+           ready_bits -= 8;', '+           strcpy (action, ""Flush"");', '+           }', '+         else', '+           {', '+           buff2 = (buff2 | (buff1 >> ready_bits));', '+           strcpy (action, ""Update"");', '+           }', '+         ready_bits += bps;', '+ ', '+         if ((dumpfile != NULL) && (level == 3))', '+           {', '+           dump_info (dumpfile, format, """",', '+                    ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+           dump_byte (dumpfile, format, ""Match bits"", matchbits);', '+           dump_byte (dumpfile, format, ""Src   bits"", *src);', '+           dump_byte (dumpfile, format, ""Buff1 bits"", buff1);', '+           dump_byte (dumpfile, format, ""Buff2 bits"", buff2);', '+           dump_info (dumpfile, format, """",""%s"", action);', '+ \t  }', '+       }', '+     if (ready_bits > 0)', '+       {', '+       buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));', '+       *dst++ = buff1;', '+ \t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t         row + 1, col + 1, src_byte, src_bit, dst - out);', '+                  dump_byte (dumpfile, format, ""Final bits"", buff1);', '+ ', '+     if ((dumpfile != NULL) && (level >= 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateTileSamples8bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+     }', '+ ', '+   return (0);', '+ ', '+ static int', '+ combineSeparateTileSamples16bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                   uint32 rows, uint32 imagewidth,', '+                                   uint32 tw, uint16 spp, uint16 bps,', '+  \t                          FILE *dumpfile, int format, int level)', '+   {', '+   int    ready_bits = 0;', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+   uint16 maskbits = 0, matchbits = 0;', '+   uint16 buff1 = 0, buff2 = 0;', '+   uint8  bytebuff = 0;', '+   tsample_t s;', '+   unsigned char *src = in[0];', '+   unsigned char *dst = out;', '+   unsigned char  swapbuff[2];', '+   char           action[8];', '+ ', '+   if ((src == NULL) || (dst == NULL))', '+     {', '+     TIFFError(""combineSeparateTileSamples16bits"",""Invalid input or output buffer"");', '+     return (1);', '+     }', '+ ', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   maskbits = (uint16)-1 >> (16 - bps);', '+ ', '+   for (row = 0; row < rows; row++)', '+     {', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       {', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+ ', '+       matchbits = maskbits << (16 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+         {', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[1] = *src;', '+           swapbuff[0] = *(src + 1);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+ \t  }', '+ ', '+ \tbuff1 = *((uint16 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 8)', '+ \t  {', '+ \t    bytebuff = (buff2 >> 8);', '+ \t    *dst++ = bytebuff;', '+ \t    ready_bits -= 8;', '+ \t    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ ', '+ \t  dump_short (dumpfile, format, ""Match bits"", matchbits);', '+ \t  dump_data  (dumpfile, format, ""Src   bits"", src, 2);', '+ \t  dump_short (dumpfile, format, ""Buff1 bits"", buff1);', '+ \t  dump_short (dumpfile, format, ""Buff2 bits"", buff2);', '+ \t  dump_byte  (dumpfile, format, ""Write byte"", bytebuff);', '+ \t  dump_info  (dumpfile, format, """",""Ready bits:  %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+       }', '+ ', '+     if (ready_bits > 0)', '+       {', '+       bytebuff = (buff2 >> 8);', '+       *dst++ = bytebuff;', '+       if ((dumpfile != NULL) && (level == 3))', '+ \t{', '+ \tdump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, src_byte, src_bit, dst - out);', '+ \tdump_byte (dumpfile, format, ""Final bits"", bytebuff);', '+ \t}', '+       }', '+ ', '+     if ((dumpfile != NULL) && (level == 2))', '+       dump_info (dumpfile, format, ""combineSeparateTileSamples16bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+ combineSeparateTileSamples24bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                   uint32 rows, uint32 imagewidth,', '+                                   uint32 tw, uint16 spp, uint16 bps,', '+  \t                          FILE *dumpfile, int format, int level)', '+   int    ready_bits = 0;', '+   uint32 src_rowsize, dst_rowsize;', '+   uint32 bit_offset, src_offset;', '+   uint32 row, col, src_byte = 0, src_bit = 0;', '+     TIFFError(""combineSeparateTileSamples24bits"",""Invalid input or output buffer"");', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+       matchbits = maskbits << (32 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \tsrc = in[s] + src_offset + src_byte;', '+         if (little_endian)', '+           {', '+           swapbuff[3] = *src;', '+           swapbuff[2] = *(src + 1);', '+           swapbuff[1] = *(src + 2);', '+           swapbuff[0] = *(src + 3);', '+           }', '+         else', '+           {', '+           swapbuff[0] = *src;', '+           swapbuff[1] = *(src + 1);', '+           swapbuff[2] = *(src + 2);', '+           swapbuff[3] = *(src + 3);', '+ \t  }', '+ \tbuff1 = *((uint32 *)swapbuff);', '+ \tbuff1 = (buff1 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 16)', '+ \t  {', '+ \t    bytebuff1 = (buff2 >> 24);', '+ \t    *dst++ = bytebuff1;', '+ \t    bytebuff2 = (buff2 >> 16);', '+ \t    *dst++ = bytebuff2;', '+ \t    ready_bits -= 16;', '+ ', '+ \t    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));', '+ \t    strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t       ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t       row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_long (dumpfile, format, ""Match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+ \t  dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+ \t  dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+ \t  dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+ \t  dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+ \t  dump_info (dumpfile, format, """",""Ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+     while (ready_bits > 0)', '+       {', '+ \tbytebuff1 = (buff2 >> 24);', '+ \t*dst++ = bytebuff1;', '+ \tbuff2 = (buff2 << 8);', '+ \tbytebuff2 = bytebuff1;', '+ \tready_bits -= 8;', '+       }', '+     if ((dumpfile != NULL) && (level == 3))', '+       {', '+       dump_info (dumpfile, format, """",', '+ \t\t   ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t   row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""Match bits "", matchbits);', '+       dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '+       }', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateTileSamples24bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out + (row * dst_rowsize));', '+       }', '+ combineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,', '+                                   uint32 rows, uint32 imagewidth,', '+                                   uint32 tw, uint16 spp, uint16 bps,', '+  \t                          FILE *dumpfile, int format, int level)', '+   int    ready_bits = 0, shift_width = 0;', '+   uint32 src_rowsize, dst_rowsize, bit_offset, src_offset;', '+   uint32 row, col;', '+     TIFFError(""combineSeparateTileSamples32bits"",""Invalid input or output buffer"");', '+   src_rowsize = ((bps * tw) + 7) / 8;', '+   dst_rowsize = ((imagewidth * bps * spp) + 7) / 8;', '+   for (row = 0; row < rows; row++)', '+     ready_bits = 0;', '+     buff1 = buff2 = 0;', '+     dst = out + (row * dst_rowsize);', '+     src_offset = row * src_rowsize;', '+     for (col = 0; col < cols; col++)', '+       bit_offset = col * bps;', '+       src_byte = bit_offset / 8;', '+       src_bit  = bit_offset % 8;', '+       matchbits = maskbits << (64 - src_bit - bps);', '+       for (s = 0; s < spp; s++)', '+ \t{', '+ \tsrc = in[s] + src_offset + src_byte;', '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff1[3] = *src;', '+ \t  swapbuff1[2] = *(src + 1);', '+ \t  swapbuff1[1] = *(src + 2);', '+ \t  swapbuff1[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff1[0] = *src;', '+ \t  swapbuff1[1] = *(src + 1);', '+ \t  swapbuff1[2] = *(src + 2);', '+ \t  swapbuff1[3] = *(src + 3);', '+ \t  }', '+         longbuff1 = *((uint32 *)swapbuff1);', '+ ', ""+ \tmemset (swapbuff2, '\\0', sizeof(swapbuff2));"", '+ \tif (little_endian)', '+ \t  {', '+ \t  swapbuff2[3] = *src;', '+ \t  swapbuff2[2] = *(src + 1);', '+ \t  swapbuff2[1] = *(src + 2);', '+ \t  swapbuff2[0] = *(src + 3);', '+ \t  }', '+ \telse', '+ \t  {', '+ \t  swapbuff2[0] = *src;', '+ \t  swapbuff2[1] = *(src + 1);', '+ \t  swapbuff2[2] = *(src + 2);', '+ \t  swapbuff2[3] = *(src + 3);', '+ \t  }', '+ \tlongbuff2 = *((uint32 *)swapbuff2);', '+ \tbuff3 = ((uint64)longbuff1 << 32) | longbuff2;', '+ \tbuff1 = (buff3 & matchbits) << (src_bit);', '+ ', '+ \tif (ready_bits >= 32)', '+ \t  {', '+ \t  bytebuff1 = (buff2 >> 56);', '+ \t  *dst++ = bytebuff1;', '+ \t  bytebuff2 = (buff2 >> 48);', '+ \t  *dst++ = bytebuff2;', '+ \t  bytebuff3 = (buff2 >> 40);', '+ \t  *dst++ = bytebuff3;', '+ \t  bytebuff4 = (buff2 >> 32);', '+ \t  *dst++ = bytebuff4;', '+ \t  ready_bits -= 32;', '+ \t  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));', '+ \t  strcpy (action, ""Flush"");', '+ \t  }', '+ \telse', '+ \tready_bits += bps;', '+ ', '+ \tif ((dumpfile != NULL) && (level == 3))', '+ \t  {', '+ \t  dump_info (dumpfile, format, """",', '+ \t\t     ""Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t     row + 1, col + 1, s, src_byte, src_bit, dst - out);', '+ \t  dump_wide (dumpfile, format, ""Match bits "", matchbits);', '+ \t  dump_data (dumpfile, format, ""Src   bits "", src, 8);', '+ \t  dump_wide (dumpfile, format, ""Buff1 bits "", buff1);', '+ \t  dump_wide (dumpfile, format, ""Buff2 bits "", buff2);', '+ \t  dump_info (dumpfile, format, """", ""Ready bits:   %d, %s"", ready_bits, action);', '+ \t  }', '+ \t}', '+     while (ready_bits > 0)', '+       bytebuff1 = (buff2 >> 56);', '+       *dst++ = bytebuff1;', '+       buff2 = (buff2 << 8);', '+       ready_bits -= 8;', '+     if ((dumpfile != NULL) && (level == 3))', '+       dump_info (dumpfile, format, """",', '+ \t         ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '+ \t\t row + 1, col + 1, src_byte, src_bit, dst - out);', '+ ', '+       dump_long (dumpfile, format, ""Match bits "", matchbits);', '+       dump_data (dumpfile, format, ""Src   bits "", src, 4);', '+       dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '+       dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '+       dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '+       dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '+       dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '+       }', '+     if ((dumpfile != NULL) && (level == 2))', '+       {', '+       dump_info (dumpfile, format, ""combineSeparateTileSamples32bits"",""Output data"");', '+       dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '+       }', '+ ', '+ ', '+   int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;', '+   int32  bytes_read = 0;', '+   uint16 bps, nstrips, planar, strips_per_sample;', '+   uint32 src_rowsize, dst_rowsize, rows_processed, rps;', '+   uint32 rows_this_strip = 0;', '+   tstrip_t  strip;', '+   tsize_t stripsize    = TIFFStripSize(in);', ""+   memset (srcbuffs, '\\0', sizeof(srcbuffs));"", '+   TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '+   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);', '+   TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);', '+   if (rps > length)', '+     rps = length;', '+ ', '+   nstrips = TIFFNumberOfStrips(in);', '+   strips_per_sample = nstrips /spp;', '+ ', '+     buff = _TIFFmalloc(stripsize);', '+                  ""Unable to allocate strip read buffer for sample %d"", s);', '+   rows_processed = 0;', '+   for (j = 0; (j < strips_per_sample) && (result == 1); j++)', '+       strip = (s * strips_per_sample) + j;', '+       bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);', '+       rows_this_strip = bytes_read / src_rowsize;', '+       if (bytes_read < 0 && !ignore)', '+ \t          ""Error, can\'t read strip %lu for sample %d"",', '+          \t   (unsigned long) strip, s + 1);', '+         result = 0;', '+         break;', '+ #ifdef DEVELMODE', '+       TIFFError("""", ""Strip %2d, read %5d bytes for %4d scanlines, shift width %d"",', '+ \t\tstrip, bytes_read, rows_this_strip, shift_width);', '+ #endif', '+     if (rps > rows_this_strip)', '+       rps = rows_this_strip;', '+     dst = obuf + (dst_rowsize * rows_processed);', '+       if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps,', '+                                        spp, bps, dump->infile,', '+                                        dump->format, dump->level))', '+         result = 0;', '+         break;', '+         case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps,', '+                   result = 0;', '+                   break;', '+       \t          }', '+         case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps,', '+                                                   spp, bps, dump->infile,', '+                                                   dump->format, dump->level))', '+                   result = 0;', '+                   break;', '+ \t        break;', '+         case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps,', '+                                                   spp, bps, dump->infile,', '+                                                   dump->format, dump->level))', '+ \t          {', '+                   result = 0;', '+                   break;', '+        \t          }', '+         case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps,', '+                                                   spp, bps, dump->infile,', '+                                                   dump->format, dump->level))', '+                   result = 0;', '+                   break;', '+ \t        break;', '+                   result = 0;', '+                   break;', '+         }', '+ ', '+     if ((rows_processed + rps) > length)', '+       {', '+       rows_processed = length;', '+       rps = length - rows_processed;', '+       }', '+     else', '+       rows_processed += rps;', '+   return (result);', '+     if (((image->xres == 0) || (image->yres == 0)) &&', '+          (crop->res_unit != RESUNIT_NONE) &&', '+ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)', '+   float    xres = 0.0, yres = 0.0;', '+   uint16   nstrips = 0, ntiles = 0, planar = 0;', '+   uint16   bps = 0, spp = 0, res_unit = 0;', '+   uint16   photometric = 0, orientation = 0, input_compression = 0;', '+   uint32   width = 0, length = 0;', '+   uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;', '+   uint32   tile_rowsize = 0;', '+   if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &photometric))', '+     TIFFError(""loadImage"",""Image lacks Photometric interpreation tag"");', '+   if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))', '+     TIFFError(""loadimage"",""Image lacks image width tag"");', '+   if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))', '+     TIFFError(""loadimage"",""Image lacks image length tag"");', '+   TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);', '+   TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);', '+   if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))', '+     res_unit = RESUNIT_INCH;', '+   if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))', '+     input_compression = COMPRESSION_NONE;', '+     TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);', '+     TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);', '+ ', '+     tile_rowsize  = TIFFTileRowSize(in);', '+ ', '+     if (buffsize < (uint32)(ntiles * tl * tile_rowsize))', '+       {', '+       buffsize = ntiles * tl * tile_rowsize;', '+ #ifdef DEBUG2', '+       TIFFError(""loadImage"",', '+ \t        ""Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu"",', '+                 tlsize, (unsigned long)buffsize);', '+ #endif', '+       }', '+ ', '+                  ""Tilesize: %u, Number of Tiles: %u, Tile row size: %u"",', '+                  tlsize, ntiles, tile_rowsize);', '+     if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))', '+       {', '+       buffsize =  ((length * width * spp * bps) + 7) / 8;', '+ #ifdef DEBUG2', '+       TIFFError(""loadImage"",', '+ \t        ""Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu"",', '+                 stsize, (unsigned long)buffsize);', '+ #endif', '+       }', '+ ', '+ ', '+   if (input_compression == COMPRESSION_JPEG)', '+     {', '+     jpegcolormode = JPEGCOLORMODE_RGB;', '+     TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '+     }', '+ ', '+ \t     if (!(readContigStripsIntoBuffer(in, read_buff, length, width, spp, dump)))', '+ \t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))', '+ \t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))', '+                case 1: if (bps == 1)', '+                          {', '+                          if (extractContigSamplesShifted8bits (src, dst, img_width,', '+                            {', '+ \t\t           TIFFError(""extractCompositeRegions"",', '+                                      ""Unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+ \t\t         break;', '+ \t\t\t }', '+                        else', '+                          if (extractContigSamplesShifted16bits (src, dst, img_width,', '+                                                                 sample, spp, bps, count,', '+                                                                 first_col, last_col + 1,', '+                                                                 prev_trailing_bits))', '+                            {', '+ \t\t           TIFFError(""extractCompositeRegions"",', '+                                      ""Unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+                case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '+                case 3:', '+                case 1: if (bps == 1)', '+                          {', '+                          if (extractContigSamplesShifted8bits (src, dst, img_width,', '+                            {', '+ \t\t           TIFFError(""extractCompositeRegions"",', '+                                      ""Unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+ \t\t         break;', '+ \t\t\t }', '+                        else', '+                          if (extractContigSamplesShifted16bits (src, dst, img_width,', '+                                                                 sample, spp, bps, count,', '+                                                                 first_col, last_col + 1,', '+                                                                 prev_trailing_bits))', '+                            {', '+ \t\t           TIFFError(""extractCompositeRegions"",', '+                                      ""Unable to extract row %d"", row);', '+ \t\t           return (1);', '+ \t\t           }', '+               case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '+                case 3:', '+       case 1: if (bps == 1)', '+                 {', '+                 if (extractContigSamplesShifted8bits (src, dst, img_width,', '+                                                       sample, spp, bps, count,', '+                                                       first_col, last_col + 1,', '+                                                       prev_trailing_bits))', '+                   {', '+ \t\t  TIFFError(""extractSeparateRegion"",', '+                             ""Unable to extract row %d"", row);', '+ \t\t  return (1);', '+ \t\t  }', '+ \t\t  break;', '+               else', '+                 if (extractContigSamplesShifted16bits (src, dst, img_width,', '+                                                        sample, spp, bps, count,', '+                                                        first_col, last_col + 1,', '+                                                        prev_trailing_bits))', '+                   {', '+ \t\t  TIFFError(""extractSeparateRegion"",', '+                             ""Unable to extract row %d"", row);', '+ \t\t  return (1);', '+ \t\t  }', '+       case 2:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '+       case 3:', '+       case 4:', '+       case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,', '+ #ifdef DEVELMODE', '+ #ifdef DEVELMODE', '+ #ifdef DEVELMODE', '+ #ifdef DEVELMODE', '+   uint16 input_compression, input_photometric;', '+   uint16 input_jpeg_colormode, input_planar;', '+ ', '+   TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression);', '+     {', '+     if (input_compression == COMPRESSION_OJPEG)', '+       {', '+       TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);', '+       compression = COMPRESSION_JPEG;', '+       }', '+     else', '+       CopyField(TIFFTAG_COMPRESSION, compression);', '+     }', '+   TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);', '+ #ifdef DEBUG2', '+   TIFFError(""writeSingleSection"", ""Input compression: %s"",', '+ \t    (input_compression == COMPRESSION_OJPEG) ? ""Old Jpeg"" :', '+ \t    ((input_compression == COMPRESSION_JPEG) ?  ""New Jpeg"" : ""Non Jpeg""));', '+ #endif', '+   if (compression == COMPRESSION_JPEG)', '+     {', '+     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric))', '+       {', '+       if (input_photometric == PHOTOMETRIC_RGB)', '+         {', '+ \tif (jpegcolormode == JPEGCOLORMODE_RGB)', '+ \t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);', '+ \telse', '+ \t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);', '+ \t}', '+       else', '+ \tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);', '+     }', '+   else', '+       TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?', '+ ', '+   if (((TIFFTAG_PHOTOMETRIC == PHOTOMETRIC_LOGL) ||', '+        (TIFFTAG_PHOTOMETRIC ==  PHOTOMETRIC_LOGLUV)) &&', '+       ((compression != COMPRESSION_SGILOG) &&', '+        (compression != COMPRESSION_SGILOG24)))', '+     {', '+     TIFFError(""writeSingleSection"",', '+               ""LogL and LogLuv data require SGI_LOG or SGI_LOG24"");', '+     return (-1);', '+     }', '+ ', '+     if (tilewidth == (uint32) 0)', '+     if (tilelength == (uint32) 0)', '+     if (tilewidth == 0 || tilelength == 0)', '+       TIFFDefaultTileSize(out, &tilewidth, &tilelength);', '+ \tif (rowsperstrip == (uint32) 0)', '+           {', '+ \t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))', '+ \t    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);', '+           if (compression != COMPRESSION_JPEG)', '+             {', '+   \t    if (rowsperstrip > length)', '+ \t      rowsperstrip = length;', '+ \t    }', '+ \telse', '+           if (rowsperstrip == (uint32) -1)', '+ \t    rowsperstrip = length;', '+ \tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);', '+ ', '+   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);', '+          if (((bps % 8) == 0) || ((bps % 12) == 0))', '+ \t   {', '+            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);', '+ \t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '+            }', '+          else', '+            {', '+ \t   TIFFError(""writeCroppedImage"",', '+                      ""JPEG compression requires 8 or 12 bits per sample"");', '+            return (-1);', '+            }', '+       writeBufferToContigTiles (out, sect_buff, length, width, spp, dump);', '+       writeBufferToContigStrips (out, sect_buff, length);', '+   uint16 input_compression, input_photometric;', '+   uint16 input_jpeg_colormode, input_planar;', '+ ', '+   TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression);', '+     {', '+     if (input_compression == COMPRESSION_OJPEG)', '+       {', '+       TIFFSetField(out, TIFFTAG_COMPRESSION, COMPRESSION_JPEG);', '+       compression = COMPRESSION_JPEG;', '+       }', '+     else', '+       CopyField(TIFFTAG_COMPRESSION, compression);', '+     }', '+   TIFFGetField(in, TIFFTAG_JPEGCOLORMODE, &input_jpeg_colormode);', '+ #ifdef DEBUG2', '+   TIFFError(""writeCroppedImage"", ""Input compression: %s"",', '+ \t    (input_compression == COMPRESSION_OJPEG) ? ""Old Jpeg"" :', '+ \t    ((input_compression == COMPRESSION_JPEG) ?  ""New Jpeg"" : ""Non Jpeg""));', '+ #endif', '+   if (compression == COMPRESSION_JPEG)', '+     {', '+     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric))', '+       {', '+       if (input_photometric == PHOTOMETRIC_RGB)', '+         {', '+ \tif (jpegcolormode == JPEGCOLORMODE_RGB)', '+ \t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);', '+ \telse', '+ \t  TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);', '+ \t}', '+       else', '+ \tTIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);', '+       }', '+     }', '+ ', '+   if (((TIFFTAG_PHOTOMETRIC == PHOTOMETRIC_LOGL) ||', '+        (TIFFTAG_PHOTOMETRIC ==  PHOTOMETRIC_LOGLUV)) &&', '+       ((compression != COMPRESSION_SGILOG) &&', '+        (compression != COMPRESSION_SGILOG24)))', '+     {', '+     TIFFError(""writeCroppedImage"",', '+               ""LogL and LogLuv data require SGI_LOG or SGI_LOG24"");', '+     return (-1);', '+     }', '+ ', '+     if (tilewidth == (uint32) 0)', '+     if (tilelength == (uint32) 0)', '+     if (tilewidth == 0 || tilelength == 0)', '+       TIFFDefaultTileSize(out, &tilewidth, &tilelength);', '+           if (compression != COMPRESSION_JPEG)', '+             {', '+   \t    if (rowsperstrip > length)', '+ \t      rowsperstrip = length;', '+ ', '+   TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &input_planar);', '+          if (((bps % 8) == 0) || ((bps % 12) == 0))', '+ \t   {', '+            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);', '+ \t   TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '+            }', '+          else', '+            {', '+ \t   TIFFError(""writeCroppedImage"",', '+                      ""JPEG compression requires 8 or 12 bits per sample"");', '+            return (-1);', '+            }', '+         if (bps != 1)', '+           {', '+ \t  TIFFError(""writeCroppedImage"",', '+             ""Group 3/4 compression is not usable with bps > 1"");', '+           return (-1);', '+ \t  }', '+ \t break;', '+     case COMPRESSION_NONE:', '+          break;', '+     default: break;', '+       writeBufferToContigTiles (out, crop_buff, length, width, spp, dump);', '+       writeBufferToContigStrips (out, crop_buff, length);', '+   uint8    match_bits = 0, mask_bits = 0;', '+   mask_bits =  (uint8)-1 >> ( 8 - bps);', '+       match_bits = mask_bits << (8 - src_bit - bps);', '+       buff1 = ((*src) & match_bits) << (src_bit);', '+ ', '+   uint32   src_byte = 0, high_bit = 0;', '+   uint16   match_bits = 0, mask_bits = 0;', '+   mask_bits =  (uint16)-1 >> (16 - bps);', '+         high_bit  = bit_offset % 8;', '+         high_bit  = (bit_offset + (sample * bps)) % 8;', '+       match_bits = mask_bits << (16 - high_bit - bps);', '+       buff1 = (buff1 & match_bits) << (high_bit);', '+   uint32   src_byte = 0, high_bit = 0;', '+   uint32   match_bits = 0, mask_bits = 0;', '+   mask_bits =  (uint32)-1 >> (32 - bps);', '+         high_bit  = bit_offset % 8;', '+         high_bit  = (bit_offset + (sample * bps)) % 8;', '+       match_bits = mask_bits << (32 - high_bit - bps);', '+       buff1 = (buff1 & match_bits) << (high_bit);', '+   uint32 src_byte = 0, high_bit = 0;', '+   uint64 mask_bits = 0, match_bits = 0;', '+   mask_bits =  (uint64)-1 >> (64 - bps);', '+         high_bit  = bit_offset % 8;', '+         high_bit  = (bit_offset + (sample * bps)) % 8;', '+       match_bits = mask_bits << (64 - high_bit - bps);', '+       buff1 = (buff3 & match_bits) << (high_bit);']]","[['- static uint32 tilewidth;', '- static uint32 tilelength;', '- ', '- static uint16 config;', '- static uint16 compression;', '- static uint16 predictor;', '- static uint16 fillorder;', '- static uint32 rowsperstrip;', '- static uint32 g3opts;', '- static int    jpegcolormode = JPEGCOLORMODE_RGB;', '- static int readContigStripsIntoBuffer   (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int readSeparateStripsIntoBuffer (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '- static int readContigTilesIntoBuffer    (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int readSeparateTilesIntoBuffer  (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int writeBufferToContigStrips    (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int writeBufferToContigTiles     (TIFF*, uint8*, uint32, uint32, tsample_t);', '- static int writeBufferToSeparateStrips  (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '- static int writeBufferToSeparateTiles   (TIFF*, uint8*, uint32, uint32, tsample_t, struct dump_opts *);', '- static int extractContigSamplesToBuffer (uint8 *, uint8 *, uint32, uint32, int, int,', '-                                          tsample_t, uint16, uint16, struct dump_opts *);', '- static void cpStripToTile (uint8*, uint8*, uint32, uint32, int, int);', '- static void cpSeparateBufToContigBuf(uint8 *, uint8 *, uint32, uint32 ,', '- \t\t\t\t     int, int, tsample_t, int);', '- ', '-                                        uint32, uint32, tsample_t, uint16,', '-                                        FILE *, int, int);', '- ', '- static   char tiffcrop_version_id[] = ""2.0"";', '- static   char tiffcrop_rev_date[] = ""01-06-2009"";', '- "" #\t\tSet compression quality level (0-100, default 75)"",', '- "" r\t\tOutput color image as RGB rather than YCbCr"",', '- ""             increase the level of detail. The program must be compiled with"",', '- ""             -DDEBUG -DDEBUG2 to enable full debug reporting"",', '- ""   format:txt|raw  Format any logged data as ASCII text or raw binary "",', '-                                       tsample_t spp)', '- {', '- \tint status = 1;', '- \ttdata_t tilebuf = _TIFFmalloc(TIFFTileSize(in));', '- \tuint32 imagew = TIFFScanlineSize(in);', '- \tuint32 tilew  = TIFFTileRowSize(in);', '- \tint iskew = imagew - tilew;', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tw, tl;', '- \tuint32 row;', '- ', '- \t(void) spp;', '- \tif (tilebuf == 0)', '- \t\treturn 0;', '- \t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);', '- \t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);', '- ', '- \tfor (row = 0; row < imagelength; row += tl) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, 0) < 0', '- \t\t\t    && !ignore) {', '- \t\t\t\tTIFFError(TIFFFileName(in),', '- \t\t\t\t\t  ""Error, can\'t read tile at %lu %lu"",', '- \t\t\t\t\t  (unsigned long) col,', '- \t\t\t\t\t  (unsigned long) row);', '- \t\t\t\tstatus = 0;', '- \t\t\t\tgoto done;', '- \t\t\t}', '- \t\t\tif (colb + tilew > imagew) {', '- \t\t\t\tuint32 width = imagew - colb;', '- \t\t\t\tuint32 oskew = tilew - width;', '- \t\t\t\tcpStripToTile(bufp + colb,', '-                                               tilebuf, nrow, width,', '-                                               oskew + iskew, oskew );', '- \t\t\t} else', '- \t\t\t\tcpStripToTile(bufp + colb,', '-                                               tilebuf, nrow, tilew,', '-                                               iskew, 0);', '- \t\t\tcolb += tilew;', '- \t\t}', '- \t\tbufp += imagew * nrow;', '- done:', '- \t_TIFFfree(tilebuf);', '- \treturn status;', '- }', '- static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *buf,', '-             uint32 imagelength, uint32 imagewidth, uint16 spp)', '- {', '- \tint status = 1;', '- \tuint32 imagew = TIFFRasterScanlineSize(in);', '- \tuint32 tilew = TIFFTileRowSize(in);', '- \tint iskew  = imagew - tilew*spp;', '- \ttdata_t tilebuf = _TIFFmalloc(TIFFTileSize(in));', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tw, tl;', '- \tuint32 row;', '-         uint16 bps, bytes_per_sample;', '- ', '- \tif (tilebuf == 0)', '- \t\treturn 0;', '- \t(void) TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);', '- \t(void) TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);', '- \t(void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '-         assert( bps % 8 == 0 );', '-         bytes_per_sample = bps/8;', '- ', '- \tfor (row = 0; row < imagelength; row += tl) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\ttsample_t s;', '- ', '- \t\t\tfor (s = 0; s < spp; s++) {', '- \t\t\t\tif (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0', '- \t\t\t\t    && !ignore) {', '- \t\t\t\t\tTIFFError(TIFFFileName(in),', '- \t\t\t\t\t  ""Error, can\'t read tile at %lu %lu, ""', '- \t\t\t\t\t  ""sample %lu"",', '- \t\t\t\t\t  (unsigned long) col,', '- \t\t\t\t\t  (unsigned long) row,', '- \t\t\t\t\t  (unsigned long) s);', '- \t\t\t\t\tstatus = 0;', '- \t\t\t\t\tgoto done;', '- \t\t\t\t}', '- \t\t\t\tif (colb + tilew*spp > imagew) {', '- \t\t\t\t\tuint32 width = imagew - colb;', '- \t\t\t\t\tint oskew = tilew*spp - width;', '- \t\t\t\t\tcpSeparateBufToContigBuf(', '-                                             bufp+colb+s*bytes_per_sample,', '- \t\t\t\t\t    tilebuf, nrow,', '-                                             width/(spp*bytes_per_sample),', '- \t\t\t\t\t    oskew + iskew,', '-                                             oskew/spp, spp,', '-                                             bytes_per_sample);', '- \t\t\t\t} else', '- \t\t\t\t\tcpSeparateBufToContigBuf(', '-                                             bufp+colb+s*bytes_per_sample,', '- \t\t\t\t\t    tilebuf, nrow, tw,', '- \t\t\t\t\t    iskew, 0, spp,', '-                                             bytes_per_sample);', '- \t\t\t}', '- \t\t\tcolb += tilew*spp;', '- \t\t}', '- \t\tbufp += imagew * nrow;', '- done:', '- \t_TIFFfree(tilebuf);', '- \treturn status;', '- }', '- static int writeBufferToContigStrips(TIFF* out, uint8* buf, uint32 imagelength,', '-                                      uint32 imagewidth, tsample_t spp)', '- {', '- \tuint32 row, rowsperstrip;', '- \ttstrip_t strip = 0;', '- ', '- \t(void) imagewidth; (void) spp;', '- \t(void) TIFFGetFieldDefaulted(out, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);', '- \tfor (row = 0; row < imagelength; row += rowsperstrip) {', '- \t\tuint32 nrows = (row+rowsperstrip > imagelength) ?', '- \t\t    imagelength-row : rowsperstrip;', '- \t\ttsize_t stripsize = TIFFVStripSize(out, nrows);', '- \t\tif (TIFFWriteEncodedStrip(out, strip++, buf, stripsize) < 0) {', '- \t\t\tTIFFError(TIFFFileName(out),', '- \t\t\t\t  ""Error, can\'t write strip %u"", strip - 1);', '- \t\t\treturn 0;', '- \t\t}', '- \t\tbuf += stripsize;', '- \treturn 1;', '- }', '-       if (extractContigSamplesToBuffer(obuf, src, nrows, width, 0, 0, s, spp, bps, dump))', '-   _TIFFfree(obuf);', '- }', '- ', '- static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,', '-                                      uint32 imagewidth, tsample_t spp)', '- {', '- \tuint32 imagew = TIFFScanlineSize(out);', '- \tuint32 tilew  = TIFFTileRowSize(out);', '- \tint iskew = imagew - tilew;', '- \ttdata_t obuf = _TIFFmalloc(TIFFTileSize(out));', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tl, tw;', '- \tuint32 row;', '- ', '- \t(void) spp;', '- \tif (obuf == NULL)', '- \t\treturn 0;', '- \t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);', '- \t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);', '- \tfor (row = 0; row < imagelength; row += tilelength) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\tif (colb + tilew > imagew) {', '- \t\t\t\tuint32 width = imagew - colb;', '- \t\t\t\tint oskew = tilew - width;', '- \t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, width,', '- \t\t\t\t    oskew, oskew + iskew);', '- \t\t\t} else', '- \t\t\t\tcpStripToTile(obuf, bufp + colb, nrow, tilew,', '- \t\t\t\t    0, iskew);', '- \t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0) {', '- \t\t\t\tTIFFError(TIFFFileName(out),', '- \t\t\t\t\t  ""Error, can\'t write tile at %lu %lu"",', '- \t\t\t\t\t  (unsigned long) col,', '- \t\t\t\t\t  (unsigned long) row);', '- \t\t\t\t_TIFFfree(obuf);', '- \t\t\t\treturn 0;', '- \t\t\t}', '- \t\t\tcolb += tilew;', '- \t\t}', '- \t\tbufp += nrow * imagew;', '- \t}', '- \t_TIFFfree(obuf);', '- \treturn 1;', '- }', '- \tuint32 imagew = TIFFScanlineSize(out);', '- \ttsize_t tilew  = TIFFTileRowSize(out);', '- \tuint32 iimagew = TIFFRasterScanlineSize(out);', '- \tint iskew = iimagew - tilew*spp;', '- \ttdata_t obuf = _TIFFmalloc(TIFFTileSize(out));', '- \tuint8* bufp = (uint8*) buf;', '- \tuint32 tl, tw;', '- \tuint32 row;', '-         uint16 bps, bytes_per_sample;', '- ', '- \tif (obuf == NULL)', '- \t\treturn 0;', '- \t(void) TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);', '- \t(void) TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);', '- \t(void) TIFFGetField(out, TIFFTAG_BITSPERSAMPLE, &bps);', '-         assert( bps % 8 == 0 );', '-         bytes_per_sample = (bps + 7)/8;', '- ', '- \tfor (row = 0; row < imagelength; row += tl) {', '- \t\tuint32 nrow = (row+tl > imagelength) ? imagelength-row : tl;', '- \t\tuint32 colb = 0;', '- \t\tuint32 col;', '- ', '- \t\tfor (col = 0; col < imagewidth; col += tw) {', '- \t\t\ttsample_t s;', '- \t\t\tfor (s = 0; s < spp; s++) {', '- \t\t\t\tif (colb + tilew > imagew) {', '- \t\t\t\t\tuint32 width = (imagew - colb);', '- \t\t\t\t\tint oskew = tilew - width;', '- ', '- \t\t\t\t  extractContigSamplesToBuffer(obuf,', '- \t\t\t\t\t    bufp + (colb*spp) + s,', '- \t\t\t\t\t    nrow, width/bytes_per_sample,', '- \t\t\t\t\t    oskew, (oskew*spp)+iskew, s,', '- \t\t\t\t\t    spp, bps, dump);', '- \t\t\t\t} else', '- \t\t\t\t    extractContigSamplesToBuffer(obuf,', '- \t\t\t\t\t    bufp + (colb*spp) + s,', '- \t\t\t\t\t    nrow, tilewidth,', '- \t\t\t\t\t    0, iskew, s, spp,', '- \t\t\t\t\t    bps, dump);', '- \t\t\t\tif (TIFFWriteTile(out, obuf, col, row, 0, s) < 0) {', '- \t\t\t\t\tTIFFError(TIFFFileName(out),', '- \t\t\t\t\t""Error, can\'t write tile at %lu %lu ""', '- \t\t\t\t\t""sample %lu"",', '- \t\t\t\t\t(unsigned long) col,', '- \t\t\t\t\t(unsigned long) row,', '- \t\t\t\t\t(unsigned long) s);', '- \t\t\t\t\t_TIFFfree(obuf);', '- \t\t\t\t\treturn 0;', '- \t\t\t\t}', '- \t\t\t}', '- \t\t\tcolb += tilew;', '- \t\t}', '- \t\tbufp += nrow * iimagew;', '- \t_TIFFfree(obuf);', '- \treturn 1;', '- }', '- {', '- \tif (streq(opt, ""none"")) {', '- \t\tdefcompression = COMPRESSION_NONE;', '- \t} else if (streq(opt, ""packbits"")) {', '- \t\tdefcompression = COMPRESSION_PACKBITS;', '- \t} else if (strneq(opt, ""jpeg"", 4)) {', ""- \t\tchar* cp = strchr(opt, ':');"", '- ', '-                 defcompression = COMPRESSION_JPEG;', '-                 while( cp )', '-                 {', '-                     if (isdigit((int)cp[1]))', '- \t\t\tquality = atoi(cp+1);', ""-                     else if (cp[1] == 'r' )"", '- \t\t\tjpegcolormode = JPEGCOLORMODE_RAW;', '-                     else', '-                         usage();', ""-                     cp = strchr(cp+1,':');"", '-                 }', '- \t} else if (strneq(opt, ""g3"", 2)) {', '- \t\tprocessG3Options(opt);', '- \t\tdefcompression = COMPRESSION_CCITTFAX3;', '- \t} else if (streq(opt, ""g4"")) {', '- \t\tdefcompression = COMPRESSION_CCITTFAX4;', '- \t} else if (strneq(opt, ""lzw"", 3)) {', ""- \t\tchar* cp = strchr(opt, ':');"", '- \t\tif (cp)', '- \t\t\tdefpredictor = atoi(cp+1);', '- \t\tdefcompression = COMPRESSION_LZW;', '- \t} else if (strneq(opt, ""zip"", 3)) {', ""- \t\tchar* cp = strchr(opt, ':');"", '- \t\tif (cp)', '- \t\t\tdefpredictor = atoi(cp+1);', '- \t\tdefcompression = COMPRESSION_ADOBE_DEFLATE;', '- \t} else', '- \t\treturn (0);', '- \treturn (1);', '- }', '- {', '- \tchar buf[BUFSIZ];', '- \tint i;', '- ', '- \tsetbuf(stderr, buf);', '-         fprintf(stderr, ""\\n%s\\n"", TIFFGetVersion());', '- \tfor (i = 0; stuff[i] != NULL; i++)', '- \t\tfprintf(stderr, ""%s\\n"", stuff[i]);', '- \texit(-1);', '- }', '- static void', '- cpStripToTile(uint8* out, uint8* in,', '- \tuint32 rows, uint32 cols, int outskew, int inskew)', '- {', '- \twhile (rows-- > 0) {', '- \t\tuint32 j = cols;', '- \t\twhile (j-- > 0)', '- \t\t\t*out++ = *in++;', '- \t\tout += outskew;', '- \t\tin += inskew;', '- \t}', '- }', '- ', '- ', '-       case \'v\': TIFFError (""Tiffcrop version"", ""%s, last updated: %s"",', '-   uint32 deftilewidth = (uint32) -1;', '-   uint32 deftilelength = (uint32) -1;', '-   extern int   optind;', '- \t    TIFFError (""Unable to open dump file %s for writing"", ""%s"", temp_filename);', '- \t    TIFFError (""Unable to open dump file %s for writing"", ""%s"", temp_filename);', '- ', '-   \t                     int outskew, int inskew, tsample_t sample,', '-                              uint16 spp, uint16 bps, struct dump_opts *dump)', '-       case 1: if (extractContigSamples8bits (src, dst, cols, sample,', '-                                              spp, bps, count, first_col, cols))', '-       case 2: if (extractContigSamples16bits (src, dst, cols, sample,', '-       case 3: if (extractContigSamples24bits (src, dst, cols, sample,', '-                                               spp, bps,  count, first_col, cols))', '- \t         return (1);', '-               break;', '- ', '-     out += outskew;', '-     in += inskew;', '- static void', '- cpSeparateBufToContigBuf(uint8  *out, uint8 *in, uint32 rows, uint32 cols,', '-                          int outskew, int inskew, tsample_t spp,', '-                          int bytes_per_sample)', '-   while (rows-- > 0)', '-     uint32 j = cols;', '-     while (j-- > 0)', '-       {', '-       int n = bytes_per_sample;', '-       while( n-- )', '-         {', '-         *out++ = *in++;', '-         }', '-       out += (spp-1)*bytes_per_sample;', '-     out += outskew;', '-     in += inskew;', '- static int readContigStripsIntoBuffer (TIFF* in, uint8* buf, uint32 imagelength,', '-                                          uint32 imagewidth, tsample_t spp)', '-   tsize_t scanlinesize = TIFFScanlineSize(in);', '-   uint32 row;', '- ', '-  (void) imagewidth; (void) spp;', '-  for (row = 0; row < imagelength; row++)', '-    {', '-    if (TIFFReadScanline(in, (tdata_t) bufp, row, 0) < 0', '- \t && !ignore)', '-      {', '-      TIFFError(TIFFFileName(in),""Error, can\'t read scanline %lu"",', '- \t       (unsigned long) row);', '-      return 0;', '-      }', '-    bufp += scanlinesize;', '-    }', '- combineSeparateSamples8bits (uint8 *in[], uint8 *out, uint32 row,', '-                             uint32 cols, uint16 spp, uint16 bps,', '-   uint32 dst_rowsize;', '-   uint32 col, src_byte = 0, src_bit = 0;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '- ', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (8 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       buff1 = ((*src) & matchbits) << (src_bit);', '-       if (ready_bits >= 8)', '-         {', '-         *dst++ = buff2;', '-         buff2 = buff1;', '-         ready_bits -= 8;', '-         strcpy (action, ""Flush"");', '-         }', '-       else', '-         buff2 = (buff2 | (buff1 >> ready_bits));', '-         strcpy (action, ""Update"");', '-         }', '-       ready_bits += bps;', '-       if ((dumpfile != NULL) && (level == 3))', '-         {', '-         dump_info (dumpfile, format, """",', '-         dump_byte (dumpfile, format, ""Match bits"", matchbits);', '-         dump_byte (dumpfile, format, ""Src   bits"", *src);', '-         dump_byte (dumpfile, format, ""Buff1 bits"", buff1);', '-         dump_byte (dumpfile, format, ""Buff2 bits"", buff2);', '-         dump_info (dumpfile, format, """",""%s"", action);', '- \t}', '-     }', '-   if (ready_bits > 0)', '-     {', '-     buff1 = (buff2 & ((unsigned int)255 << (8 - ready_bits)));', '-     *dst++ = buff1;', '-     if ((dumpfile != NULL) && (level == 3))', '-       dump_info (dumpfile, format, """",', '-     }', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamples8bits"",""Output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '- ', '- combineSeparateSamples16bits (uint8 *in[], uint8 *out, uint32 row,', '-                               uint32 cols, uint16 spp, uint16 bps,', '-   uint32 dst_rowsize;', '-   uint32 bit_offset;', '-   uint32 col, src_byte = 0, src_bit = 0;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (16 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       if (little_endian)', '-         swapbuff[1] = *src;', '-         swapbuff[0] = *(src + 1);', '-         }', '-       else', '-         swapbuff[0] = *src;', '-         swapbuff[1] = *(src + 1);', '-       buff1 = *((uint16 *)swapbuff);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-       if (ready_bits >= 8)', '-         bytebuff = (buff2 >> 8);', '-         *dst++ = bytebuff;', '-         ready_bits -= 8;', '-         buff2 = ((buff2 << 8) | (buff1 >> ready_bits));', '-         strcpy (action, ""Flush"");', '-       else', '-       ready_bits += bps;', '- \t    ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '- \t    row + 1, col + 1, s, src_byte, src_bit, dst - out);', '- ', '-         dump_short (dumpfile, format, ""Match bits"", matchbits);', '-         dump_data  (dumpfile, format, ""Src   bits"", src, 2);', '-         dump_short (dumpfile, format, ""Buff1 bits"", buff1);', '-         dump_short (dumpfile, format, ""Buff2 bits"", buff2);', '-         dump_byte  (dumpfile, format, ""Write byte"", bytebuff);', '-         dump_info  (dumpfile, format, """",""Ready bits:  %d, %s"", ready_bits, action);', '-     }', '-   if (ready_bits > 0)', '-     {', '-     bytebuff = (buff2 >> 8);', '-     *dst++ = bytebuff;', '-     if ((dumpfile != NULL) && (level == 3))', '-       dump_info (dumpfile, format, """",', '- \t  ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '- \t  row + 1, col + 1, src_byte, src_bit, dst - out);', '-       dump_byte (dumpfile, format, ""Final bits"", bytebuff);', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamples16bits"",""Output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '-     }', '- ', '- combineSeparateSamples24bits (uint8 *in[], uint8 *out, uint32 row,', '-                               uint32 cols, uint16 spp, uint16 bps,', '- \t                      FILE *dumpfile, int format, int level)', '-   int    ready_bits = 0, bytes_per_sample = 0;', '-   uint32 dst_rowsize;', '-   uint32 bit_offset;', '-   uint32 col, src_byte = 0, src_bit = 0;', '-     TIFFError(""combineSeparateSamples24bits"",""Invalid input or output buffer"");', '-   bytes_per_sample = (bps + 7) / 8;', '-   dst_rowsize = ((bps * cols) + 7) / 8;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (32 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       if (little_endian)', '-         {', '-         swapbuff[3] = *src;', '-         swapbuff[2] = *(src + 1);', '-         swapbuff[1] = *(src + 2);', '-         swapbuff[0] = *(src + 3);', '-         }', '-       else', '-         {', '-         swapbuff[0] = *src;', '-         swapbuff[1] = *(src + 1);', '-         swapbuff[2] = *(src + 2);', '-         swapbuff[3] = *(src + 3);', '- \t}', '- ', '-       buff1 = *((uint32 *)swapbuff);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-       if (ready_bits >= 16)', '-         bytebuff1 = (buff2 >> 24);', '-         *dst++ = bytebuff1;', '-         bytebuff2 = (buff2 >> 16);', '-         *dst++ = bytebuff2;', '-         ready_bits -= 16;', '- ', '-         buff2 = ((buff2 << 16) | (buff1 >> ready_bits));', '-         strcpy (action, ""Flush"");', '-         }', '-       else', '-       ready_bits += bps;', '-       if ((dumpfile != NULL) && (level == 3))', '-         {', '-         dump_info (dumpfile, format, """",', '- \t        ""Row %3d, Col %3d, Samples %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '- \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);', '-         dump_long (dumpfile, format, ""Match bits "", matchbits);', '-         dump_data (dumpfile, format, ""Src   bits "", src, 4);', '-         dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '-         dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '-         dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '-         dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '-         dump_info (dumpfile, format, """",""Ready bits:   %d, %s"", ready_bits, action);', '-         }', '-     }', '-   while (ready_bits > 0)', '-     {', '-     bytebuff1 = (buff2 >> 24);', '-     *dst++ = bytebuff1;', '-     buff2 = (buff2 << 8);', '-     bytebuff2 = bytebuff1;', '-     ready_bits -= 8;', '-     }', '-   if ((dumpfile != NULL) && (level == 3))', '-     {', '-     dump_info (dumpfile, format, """",', '-       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '-       row + 1, col + 1, src_byte, src_bit, dst - out);', '- ', '-     dump_long (dumpfile, format, ""Match bits "", matchbits);', '-     dump_data (dumpfile, format, ""Src   bits "", src, 4);', '-     dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '-     dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '-     dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '-     dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '-     dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '-     }', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamples24bits"",""Output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '- combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 row,', '-                               uint32 cols, uint16 spp, uint16 bps,', '- \t                      FILE *dumpfile, int format, int level)', '-   int    ready_bits = 0, bytes_per_sample = 0, shift_width = 0;', '-   uint32 dst_rowsize;', '-   uint32 bit_offset;', '-   uint32 col;', '-     TIFFError(""combineSeparateSamples32bits"",""Invalid input or output buffer"");', '-   bytes_per_sample = (bps + 7) / 8;', '-   dst_rowsize = ((bps * cols) + 7) / 8;', '-   ready_bits = 0;', '-   buff1 = buff2 = 0;', '-   for (col = 0; col < cols; col++)', '-     bit_offset = col * bps;', '-     src_byte = bit_offset / 8;', '-     src_bit  = bit_offset % 8;', '- ', '-     matchbits = maskbits << (64 - src_bit - bps);', '-     for (s = 0; s < spp; s++)', '-       src = in[s] + src_byte;', '-       if (little_endian)', '-         {', '-         swapbuff1[3] = *src;', '-         swapbuff1[2] = *(src + 1);', '-         swapbuff1[1] = *(src + 2);', '-         swapbuff1[0] = *(src + 3);', '-         }', '-       else', '-         {', '-         swapbuff1[0] = *src;', '-         swapbuff1[1] = *(src + 1);', '-         swapbuff1[2] = *(src + 2);', '-         swapbuff1[3] = *(src + 3);', '- \t}', '-       longbuff1 = *((uint32 *)swapbuff1);', '- ', ""-       memset (swapbuff2, '\\0', sizeof(swapbuff2));"", '-       if (little_endian)', '-         {', '-         swapbuff2[3] = *src;', '-         swapbuff2[2] = *(src + 1);', '-         swapbuff2[1] = *(src + 2);', '-         swapbuff2[0] = *(src + 3);', '-         }', '-       else', '-         {', '-         swapbuff2[0] = *src;', '-         swapbuff2[1] = *(src + 1);', '-         swapbuff2[2] = *(src + 2);', '-         swapbuff2[3] = *(src + 3);', '- \t}', '-       longbuff2 = *((uint32 *)swapbuff2);', '-       buff3 = ((uint64)longbuff1 << 32) | longbuff2;', '-       buff1 = (buff3 & matchbits) << (src_bit);', '-       if (ready_bits >= 32)', '-         {', '-         bytebuff1 = (buff2 >> 56);', '-         *dst++ = bytebuff1;', '-         bytebuff2 = (buff2 >> 48);', '-         *dst++ = bytebuff2;', '-         bytebuff3 = (buff2 >> 40);', '-         *dst++ = bytebuff3;', '-         bytebuff4 = (buff2 >> 32);', '-         *dst++ = bytebuff4;', '-         ready_bits -= 32;', '-         buff2 = ((buff2 << 32) | (buff1 >> ready_bits));', '-         strcpy (action, ""Flush"");', '-         }', '-       else', '-       ready_bits += bps;', '- ', '-       if ((dumpfile != NULL) && (level == 3))', '-         {', '-         dump_info (dumpfile, format, """",', '- \t    ""Row %3d, Col %3d, Sample %d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '- \t\t   row + 1, col + 1, s, src_byte, src_bit, dst - out);', '-         dump_wide (dumpfile, format, ""Match bits "", matchbits);', '-         dump_data (dumpfile, format, ""Src   bits "", src, 8);', '-         dump_wide (dumpfile, format, ""Buff1 bits "", buff1);', '-         dump_wide (dumpfile, format, ""Buff2 bits "", buff2);', '-         dump_info (dumpfile, format, """", ""Ready bits:   %d, %s"", ready_bits, action);', '-         }', '-     }', '-   while (ready_bits > 0)', '-     {', '-     bytebuff1 = (buff2 >> 56);', '-     *dst++ = bytebuff1;', '-     buff2 = (buff2 << 8);', '-     ready_bits -= 8;', '-     }', '- ', '-   if ((dumpfile != NULL) && (level == 3))', '-     {', '-     dump_info (dumpfile, format, """",', '-       ""Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d"",', '-       row + 1, col + 1, src_byte, src_bit, dst - out);', '- ', '-     dump_long (dumpfile, format, ""Match bits "", matchbits);', '-     dump_data (dumpfile, format, ""Src   bits "", src, 4);', '-     dump_long (dumpfile, format, ""Buff1 bits "", buff1);', '-     dump_long (dumpfile, format, ""Buff2 bits "", buff2);', '-     dump_byte (dumpfile, format, ""Write bits1"", bytebuff1);', '-     dump_byte (dumpfile, format, ""Write bits2"", bytebuff2);', '-     dump_info (dumpfile, format, """", ""Ready bits:  %2d"", ready_bits);', '-     }', '- ', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamples32bits"",""Output data"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '-     }', '- ', '-   return (0);', '- ', '- static int', '- combineSeparateSamplesBytes (unsigned char *srcbuffs[], unsigned char *out,', '-                              uint32 row, uint32 width, uint16 spp, uint16 bps,', '-                              FILE *dumpfile, int format, int level)', '-   {', '-   int i, bytes_per_sample, bytes_per_pixel, dst_rowsize, shift_width;', '-   uint32 col, col_offset;', '-   unsigned char *src;', '-   unsigned char *dst;', '-   tsample_t s;', '- ', '-   src = srcbuffs[0];', '-   dst = out;', '-   if ((src == NULL) || (dst == NULL))', '-     {', '-     TIFFError(""combineSeparateSamplesBytes"",""Invalid buffer address"");', '-     return (1);', '-     }', '- ', '-   bytes_per_sample = (bps + 7) / 8;', '-   bytes_per_pixel  = ((bps * spp) + 7) / 8;', '-   if (bytes_per_pixel < (bytes_per_sample + 1))', '-     shift_width = bytes_per_sample;', '-   else', '-     shift_width = bytes_per_pixel;', '- ', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     for (s = 0; s < spp; s++)', '-       dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Input data, Sample %d"", s);', '-       dump_buffer(dumpfile, format, 1, width, row, srcbuffs[s]);', '-     }', '-   dst_rowsize = ((bps * spp * width) + 7) / 8;', '-   for (col = 0; col < width; col++)', '-     {', '-     col_offset = col * (bps / 8);', '-     for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)', '-       src = srcbuffs[s] + col_offset;', '-       for (i = 0; i < bytes_per_sample; i++)', '-         *(dst + i) = *(src + i);', '-       src += bytes_per_sample;', '-       dst += bytes_per_sample;', '-       }', '-     }', '-   if ((dumpfile != NULL) && (level == 2))', '-     {', '-     dump_info (dumpfile, format, ""combineSeparateSamplesBytes"",""Output data, combined samples"");', '-     dump_buffer(dumpfile, format, 1, dst_rowsize, row, out);', '- ', '-   int i, bytes_per_sample, bytes_per_pixel, shift_width;', '-   uint16 bps;', '-   uint32 row, src_rowsize, dst_rowsize;', '-   (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '- ', '-     buff = _TIFFmalloc(src_rowsize);', '-                  ""Unable to allocate read buffer for sample %d"", s);', '-   for (row = 0; row < length; row++)', '-       if (TIFFReadScanline(in, buff, row, s) < 0', '- \t    && !ignore)', '- \t         ""Error, can\'t read scanline %lu for sample %d"",', '- \t\t  (unsigned long) row, s + 1);', '-         for (i = 0; i < s; i++)', '-           _TIFFfree (srcbuffs[i]);', '-         return (0);', '-     dst = obuf + (row * dst_rowsize);', '-       if (combineSeparateSamplesBytes (srcbuffs, dst, row, width,', '-                                       spp, bps, dump->infile,', '-                                       dump->format, dump->level))', '-         for (i = 0; i < spp; i++)', '-          _TIFFfree (srcbuffs[i]);', '- \treturn (0);', '-         case 1: if (combineSeparateSamples8bits (srcbuffs, dst, row, width,', '-                                                 spp, bps, dump->infile,', '-                                                 dump->format, dump->level))', '- \t          {', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- \t\t  }', '- \t\tbreak;', '-         case 2: if (combineSeparateSamples16bits (srcbuffs, dst, row, width,', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- \t\t  }', '-         case 3: if (combineSeparateSamples24bits (srcbuffs, dst, row, width,', '-                                                  spp, bps, dump->infile,', '-                                                  dump->format, dump->level))', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- ', '-         case 8: if (combineSeparateSamples32bits (srcbuffs, dst, row, width,', '-                                                  spp, bps, dump->infile,', '-                                                  dump->format, dump->level))', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- \t\tbreak;', '-                   for (i = 0; i < spp; i++)', '-                     _TIFFfree (srcbuffs[i]);', '- \t          return (0);', '- \t}', '-   return (1);', '-     if (((image->xres == 0) || (image->yres == 0)) &&', '- loadImage(TIFF* in, struct image_data *image, struct dump_opts * dump, unsigned char **read_ptr)', '-   float    xres=0.0, yres=0.0;', '-   uint16   nstrips, ntiles, planar, bps, spp, res_unit, photometric, orientation;', '-   uint32   width, length, rowsperstrip;', '-   uint32   stsize, tlsize, buffsize, scanlinesize;', '-   TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &photometric);', '-   TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width);', '-   TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length);', '-   TIFFGetField(in, TIFFTAG_XRESOLUTION, &xres);', '-   TIFFGetField(in, TIFFTAG_YRESOLUTION, &yres);', '-   TIFFGetField(in, TIFFTAG_RESOLUTIONUNIT, &res_unit);', '-                  ""Tilesize: %u, Number of Tiles: %u, Scanline size: %u"",', '-                  tlsize, ntiles, scanlinesize);', ""-   _TIFFmemset(read_buff, '\\0', buffsize);"", '- \t   if (!(readContigStripsIntoBuffer(in, read_buff, length, width, spp)))', '- \t   if (!(readContigTilesIntoBuffer(in, read_buff, length, width, spp)))', '- \t   if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, spp)))', '-                case 1:  if (extractContigSamplesShifted8bits (src, dst, img_width,', '-                                                               sample, spp, bps, count,', '-                                                               first_col, last_col + 1,', '-                                                               prev_trailing_bits))', '-                           {', '- \t\t          TIFFError(""extractCompositeRegions"",', '-                                     ""Unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '- \t\t        break;', '-                case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,', '-                           {', '- \t\t          TIFFError(""extractCompositeRegions"",', '-                                     ""Unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '-                case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '-                case 1:  if (extractContigSamplesShifted8bits (src, dst, img_width,', '-                                                               sample, spp, bps, count,', '-                                                               first_col, last_col + 1,', '-                                                               prev_trailing_bits))', '-                           {', '- \t\t          TIFFError(""extractCompositeRegions"",', '-                                     ""Unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '- \t\t        break;', '-                case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,', '-                           {', '- \t\t          TIFFError(""extractCompositeRegions"",', '-                                     ""Unable to extract row %d"", row);', '- \t\t          return (1);', '- \t\t          }', '-                case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '-       case 1: if (extractContigSamplesShifted8bits (src, dst, img_width,', '-                                                     sample, spp, bps, count,', '-                                                     first_col, last_col + 1,', '-                                                     prev_trailing_bits))', '-                 {', '- \t        TIFFError(""extractSeparateRegion"",', '-                          ""Unable to extract row %d"", row);', '- \t\treturn (1);', '- \t\t}', '- \t      break;', '-      case 2:  if (extractContigSamplesShifted16bits (src, dst, img_width,', '-                                                      sample, spp, bps, count,', '-                                                      first_col, last_col + 1,', '-                                                      prev_trailing_bits))', '-                 {', '- \t\tTIFFError(""extractSeparateRegion"",', '-                           ""Unable to extract row %d"", row);', '- \t\treturn (1);', '-      case 3:  if (extractContigSamplesShifted24bits (src, dst, img_width,', '-      case 4:', '-      case 5:  if (extractContigSamplesShifted32bits (src, dst, img_width,', '- #ifdef DEBUG2', '- #ifdef DEBUG2', '- #ifdef DEBUG2', '- #ifdef DEBUG2', '- #ifdef DEBUG', '-   TIFFError("""",', '-     ""Writing %d sections for each original page. Hres: %3.2f Vres: %3.2f\\n"",', '-           page->rows * page->cols, hres, vres);', '- #endif', '- #ifdef DEBUG', '-     TIFFError ("""", ""\\nSection: %d, Width: %4d, Length: %4d, x1: %4d  x2: %4d  y1: %4d  y2: %4d\\n"",', '-              i + 1, width, length, sections[i].x1, sections[i].x2, sections[i].y1, sections[i].y2);', '- #endif', '- ', '- #ifdef DEBUG', '-   TIFFError ("""",', '- ""\\nWriting single section: Width %d Length: %d Hres: %4.1f, Vres: %4.1f\\n\\n"",', '- \t   width, length, hres, vres);', '- #endif', '-     CopyField(TIFFTAG_COMPRESSION, compression);', '- ', '-   if (compression == COMPRESSION_JPEG) {', '-     uint16 input_compression, input_photometric;', '-     if (TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)', '-         && input_compression == COMPRESSION_JPEG) {', '-           TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '-         }', '-     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) {', '- \tif(input_photometric == PHOTOMETRIC_RGB) {', '- \t   if (jpegcolormode == JPEGCOLORMODE_RGB)', '- \t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);', '- \t   else', '- \t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);', '- \t   } else', '- \t      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);', '-   else', '-        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, spp == 1 ?', '-     if (tilewidth == (uint32) -1)', '-     if (tilelength == (uint32) -1)', '-     if (tilewidth > width)', '-       tilewidth = width;', '-     if (tilelength > length)', '-       tilelength = length;', '- ', '- \tif (rowsperstrip == (uint32) 0) {', '- \t  if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip)) {', '- \t      rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);', '- \t     }', '- \t  if (rowsperstrip > length && rowsperstrip != (uint32)-1)', '- \t       rowsperstrip = length;', '- \telse if (rowsperstrip == (uint32) -1)', '- \t\trowsperstrip = length;', '- \t\tTIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);', '-          TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);', '- \t TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);', '-       {', '-       writeBufferToContigTiles (out, sect_buff, length, width, spp);', '-       }', '-       {', '-       writeBufferToContigStrips (out, sect_buff, length, width, spp);', '-       }', '-       {', '-       }', '-     CopyField(TIFFTAG_COMPRESSION, compression);', '- ', '-   if (compression == COMPRESSION_JPEG) {', '-     uint16 input_compression, input_photometric;', '-     if (TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression)', '-         && input_compression == COMPRESSION_JPEG) {', '-           TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);', '-         }', '-     if (TIFFGetField(in, TIFFTAG_PHOTOMETRIC, &input_photometric)) {', '- \tif(input_photometric == PHOTOMETRIC_RGB) {', '- \t   if (jpegcolormode == JPEGCOLORMODE_RGB)', '- \t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);', '- \t   else', '- \t     TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);', '- \t   } else', '- \t      TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);', '-   }', '-     if (tilewidth == (uint32) -1)', '-     if (tilelength == (uint32) -1)', '-     if (tilewidth > width)', '-       tilewidth = width;', '-     if (tilelength > length)', '-       tilelength = length;', '- ', '-     TIFFDefaultTileSize(out, &tilewidth, &tilelength);', '-             {', '- \t  if (rowsperstrip > length)', '- \t    rowsperstrip = length;', '-          TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);', '- \t TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);', '- \tbreak;', '-       {', '-       writeBufferToContigTiles (out, crop_buff, length, width, spp);', '-       }', '-       {', '-       writeBufferToContigStrips (out, crop_buff, length, width, spp);', '-       }', '-       {', '-       }', '-   uint8    matchbits = 0, maskbits = 0;', '-   maskbits =  (uint8)-1 >> ( 8 - bps);', '-       matchbits = maskbits << (8 - src_bit - bps);', '-       buff1 = ((*src) & matchbits) << (src_bit);', '-   uint32   src_byte = 0, src_bit = 0;', '-   uint16   matchbits = 0, maskbits = 0;', '-   maskbits =  (uint16)-1 >> (16 - bps);', '-         src_bit  = bit_offset % 8;', '-         src_bit  = (bit_offset + (sample * bps)) % 8;', '-       matchbits = maskbits << (16 - src_bit - bps);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-   uint32   src_byte = 0, src_bit = 0;', '-   uint32   matchbits = 0, maskbits = 0;', '-   maskbits =  (uint32)-1 >> (32 - bps);', '-         src_bit  = bit_offset % 8;', '-         src_bit  = (bit_offset + (sample * bps)) % 8;', '-       matchbits = maskbits << (32 - src_bit - bps);', '-       buff1 = (buff1 & matchbits) << (src_bit);', '-   uint32 src_byte = 0, src_bit = 0;', '-   uint64 maskbits = 0, matchbits = 0;', '-   maskbits =  (uint64)-1 >> (64 - bps);', '-         src_bit  = bit_offset % 8;', '-         src_bit  = (bit_offset + (sample * bps)) % 8;', '-       matchbits = maskbits << (64 - src_bit - bps);', '-       buff1 = (buff3 & matchbits) << (src_bit);']]",1977,1003.0,2980.0,6b6496bb513826866bfd5fdc71f81566b7e5e924vadz/libtiff,['ae9365db1b271b62b35ce018eac8799b1d5e8a53']
5c080298d59efa53264d7248bbe3a04660db6ef7,vadz/libtiff,tools/tiffcp.c,val,C,1,"['@@ -591,7 +591,7 @@ static\tcopyFunc pickCopyFunc(TIFF*, TIFF*, uint16, uint16);\n static int\n tiffcp(TIFF* in, TIFF* out)\n {\n-\tuint16 bitspersample, samplesperpixel = 1;\n+\tuint16 bitspersample = 1, samplesperpixel = 1;\n \tuint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;\n \tcopyFunc cf;\n \tuint32 width, length;\n@@ -1067,6 +1067,16 @@ DECLAREcpFunc(cpContig2SeparateByRow)\n \tregister uint32 n;\n \tuint32 row;\n \ttsample_t s;\n+        uint16 bps = 0;\n+\n+        (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n+        if( bps != 8 )\n+        {\n+            TIFFError(TIFFFileName(in),\n+                      ""Error, can only handle BitsPerSample=8 in %s"",\n+                      ""cpContig2SeparateByRow"");\n+            return 0;\n+        }\n \n \tinbuf = _TIFFmalloc(scanlinesizein);\n \toutbuf = _TIFFmalloc(scanlinesizeout);\n@@ -1120,6 +1130,16 @@ DECLAREcpFunc(cpSeparate2ContigByRow)\n \tregister uint32 n;\n \tuint32 row;\n \ttsample_t s;\n+        uint16 bps = 0;\n+\n+        (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n+        if( bps != 8 )\n+        {\n+            TIFFError(TIFFFileName(in),\n+                      ""Error, can only handle BitsPerSample=8 in %s"",\n+                      ""cpSeparate2ContigByRow"");\n+            return 0;\n+        }\n \n \tinbuf = _TIFFmalloc(scanlinesizein);\n \toutbuf = _TIFFmalloc(scanlinesizeout);\n@@ -1784,7 +1804,7 @@ pickCopyFunc(TIFF* in, TIFF* out, uint16 bitspersample, uint16 samplesperpixel)\n \tuint32 w, l, tw, tl;\n \tint bychunk;\n \n-\t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);\n+\t(void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);\n \tif (shortv != config && bitspersample != 8 && samplesperpixel > 1) {\n \t\tfprintf(stderr,\n \t\t    ""%s: Cannot handle different planar configuration w/ bits/sample != 8\\n"",\n']",2017-01-11 19:25:44+00:00,"* tools/tiffcp.c: error out cleanly in cpContig2SeparateByRow and
cpSeparate2ContigByRow if BitsPerSample != 8 to avoid heap based overflow.
Fixes http://bugzilla.maptools.org/show_bug.cgi?id=2656 and
http://bugzilla.maptools.org/show_bug.cgi?id=2657","[['+ \tuint16 bitspersample = 1, samplesperpixel = 1;', '+         uint16 bps = 0;', '+ ', '+         (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '+         if( bps != 8 )', '+         {', '+             TIFFError(TIFFFileName(in),', '+                       ""Error, can only handle BitsPerSample=8 in %s"",', '+                       ""cpContig2SeparateByRow"");', '+             return 0;', '+         }', '+         uint16 bps = 0;', '+ ', '+         (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '+         if( bps != 8 )', '+         {', '+             TIFFError(TIFFFileName(in),', '+                       ""Error, can only handle BitsPerSample=8 in %s"",', '+                       ""cpSeparate2ContigByRow"");', '+             return 0;', '+         }', '+ \t(void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);', '- \tuint16 bitspersample, samplesperpixel = 1;', '- \t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);']]","[['+ \tuint16 bitspersample = 1, samplesperpixel = 1;', '+         uint16 bps = 0;', '+ ', '+         (void) tiffgetfield(in, tifftag_bitspersample, &bps);', '+         if( bps != 8 )', '+         {', '+             tifferror(tifffilename(in),', '+                       ""error, can only handle bitspersample=8 in %s"",', '+                       ""cpcontig2separatebyrow"");', '+             return 0;', '+         }', '+         uint16 bps = 0;', '+ ', '+         (void) tiffgetfield(in, tifftag_bitspersample, &bps);', '+         if( bps != 8 )', '+         {', '+             tifferror(tifffilename(in),', '+                       ""error, can only handle bitspersample=8 in %s"",', '+                       ""cpseparate2contigbyrow"");', '+             return 0;', '+         }', '+ \t(void) tiffgetfielddefaulted(in, tifftag_planarconfig, &shortv);', '- \tuint16 bitspersample, samplesperpixel = 1;', '- \t(void) tiffgetfield(in, tifftag_planarconfig, &shortv);']]","[['+ \tuint16 bitspersample = 1, samplesperpixel = 1;', '+         uint16 bps = 0;', '+ ', '+         (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '+         if( bps != 8 )', '+         {', '+             TIFFError(TIFFFileName(in),', '+                       ""Error, can only handle BitsPerSample=8 in %s"",', '+                       ""cpContig2SeparateByRow"");', '+             return 0;', '+         }', '+         uint16 bps = 0;', '+ ', '+         (void) TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);', '+         if( bps != 8 )', '+         {', '+             TIFFError(TIFFFileName(in),', '+                       ""Error, can only handle BitsPerSample=8 in %s"",', '+                       ""cpSeparate2ContigByRow"");', '+             return 0;', '+         }', '+ \t(void) TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &shortv);']]","[['- \tuint16 bitspersample, samplesperpixel = 1;', '- \t(void) TIFFGetField(in, TIFFTAG_PLANARCONFIG, &shortv);']]",22,2.0,24.0,5c080298d59efa53264d7248bbe3a04660db6ef7vadz/libtiff,['5c080298d59efa53264d7248bbe3a04660db6ef7']
1ba5bad25f7d8a749e729f0f47fc6aed3859349c,file/file,file.c,train,C,0,"['@@ -15,7 +15,11 @@ int check = 0,\t\t/* check format of magic file */\n \tnbytes = 0,\t/* number of bytes read from a datafile */\n \tnmagic = 0;\t/* number of valid magic[]s */\n FILE *efopen();\n+#ifdef MAGIC\n+char *magicfile = MAGIC;\t/* where magic be found */\n+#else\n char *magicfile = ""/etc/magic"";\t/* where magic be found */\n+#endif\n char *progname;\n struct stat statbuf;\n struct utimbuf {\t/* for utime(2), belongs in a .h file */\n']",,,['+ #ifdef MAGIC'],['+ #ifdef magic'],['+ #ifdef MAGIC'],[],1,0.0,1.0,1ba5bad25f7d8a749e729f0f47fc6aed3859349cfile/file,[]
3f73e20d9d7c9818f3f5dfa65573046ce745e764,file/file,ascmagic.c,test,C,0,"['@@ -32,7 +32,8 @@\n #include ""names.h""\n \n #ifndef\tlint\n-static char *moduleid = ""$Header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.4 1987/09/16 10:11:40 ian Exp $"";\n+static char *moduleid = \n+\t""@(#)$Header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.5 1987/09/16 14:44:45 ian Exp $"";\n #endif\t/* lint */\n \n char ckfmsg[] = ""write error on output"";\n']",,,"['+ static char *moduleid =', '+ \t""@(#)$Header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.5 1987/09/16 14:44:45 ian Exp $"";', '- static char *moduleid = ""$Header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.4 1987/09/16 10:11:40 ian Exp $"";']","['+ static char *moduleid =', '+ \t""@(#)$header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.5 1987/09/16 14:44:45 ian exp $"";', '- static char *moduleid = ""$header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.4 1987/09/16 10:11:40 ian exp $"";']","['+ static char *moduleid =', '+ \t""@(#)$Header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.5 1987/09/16 14:44:45 ian Exp $"";']","['- static char *moduleid = ""$Header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.4 1987/09/16 10:11:40 ian Exp $"";']",2,1.0,3.0,3f73e20d9d7c9818f3f5dfa65573046ce745e764file/file,[]
9f27ae7aee7a12b3c99d0ce7dc4c7384e3189fa2,ivmai/bdwgc,mallocx.c,train,C,1,"['@@ -2,6 +2,7 @@\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -21,7 +22,7 @@\n  */\n \n #include <stdio.h>\n-#include ""gc_priv.h""\n+#include ""private/gc_priv.h""\n \n extern ptr_t GC_clear_stack();  /* in misc.c, behaves like identity */\n void GC_extend_size_map();      /* in misc.c. */\n@@ -30,69 +31,179 @@ GC_bool GC_alloc_reclaim_list();\t/* in malloc.c */\n /* Some externally visible but unadvertised variables to allow access to */\n /* free lists from inlined allocators without including gc_priv.h\t */\n /* or introducing dependencies on internal data structure layouts.\t */\n-ptr_t * CONST GC_objfreelist_ptr = GC_objfreelist;\n-ptr_t * CONST GC_aobjfreelist_ptr = GC_aobjfreelist;\n-ptr_t * CONST GC_uobjfreelist_ptr = GC_uobjfreelist;\n+ptr_t * GC_CONST GC_objfreelist_ptr = GC_objfreelist;\n+ptr_t * GC_CONST GC_aobjfreelist_ptr = GC_aobjfreelist;\n+ptr_t * GC_CONST GC_uobjfreelist_ptr = GC_uobjfreelist;\n # ifdef ATOMIC_UNCOLLECTABLE\n-    ptr_t * CONST GC_auobjfreelist_ptr = GC_auobjfreelist;\n+    ptr_t * GC_CONST GC_auobjfreelist_ptr = GC_auobjfreelist;\n # endif\n \n-/* Allocate a composite object of size n bytes.  The caller guarantees  */\n-/* that pointers past the first page are not relevant.  Caller holds    */\n-/* allocation lock.                                                     */\n-ptr_t GC_generic_malloc_inner_ignore_off_page(lb, k)\n-register size_t lb;\n-register int k;\n+\n+GC_PTR GC_generic_or_special_malloc(lb,knd)\n+word lb;\n+int knd;\n {\n-    register struct hblk * h;\n-    register word n_blocks;\n-    register word lw;\n-    register ptr_t op;\n-\n-    if (lb <= HBLKSIZE)\n-        return(GC_generic_malloc_inner((word)lb, k));\n-    n_blocks = divHBLKSZ(ADD_SLOP(lb) + HDR_BYTES + HBLKSIZE-1);\n-    if (!GC_is_initialized) GC_init_inner();\n-    /* Do our share of marking work */\n-    if(GC_incremental && !GC_dont_gc)\n-        GC_collect_a_little_inner((int)n_blocks);\n-    lw = ROUNDED_UP_WORDS(lb);\n-    h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);\n-#   ifdef USE_MUNMAP\n-      if (0 == h) {\n-        GC_merge_unmapped();\n-        h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);\n-      }\n-#   endif\n-    while (0 == h && GC_collect_or_expand(n_blocks, TRUE)) {\n-      h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);\n+    switch(knd) {\n+#     ifdef STUBBORN_ALLOC\n+\tcase STUBBORN:\n+\t    return(GC_malloc_stubborn((size_t)lb));\n+#     endif\n+\tcase PTRFREE:\n+\t    return(GC_malloc_atomic((size_t)lb));\n+\tcase NORMAL:\n+\t    return(GC_malloc((size_t)lb));\n+\tcase UNCOLLECTABLE:\n+\t    return(GC_malloc_uncollectable((size_t)lb));\n+#       ifdef ATOMIC_UNCOLLECTABLE\n+\t  case AUNCOLLECTABLE:\n+\t    return(GC_malloc_atomic_uncollectable((size_t)lb));\n+#\tendif /* ATOMIC_UNCOLLECTABLE */\n+\tdefault:\n+\t    return(GC_generic_malloc(lb,knd));\n+    }\n+}\n+\n+\n+/* Change the size of the block pointed to by p to contain at least   */\n+/* lb bytes.  The object may be (and quite likely will be) moved.     */\n+/* The kind (e.g. atomic) is the same as that of the old.\t      */\n+/* Shrinking of large blocks is not implemented well.                 */\n+# ifdef __STDC__\n+    GC_PTR GC_realloc(GC_PTR p, size_t lb)\n+# else\n+    GC_PTR GC_realloc(p,lb)\n+    GC_PTR p;\n+    size_t lb;\n+# endif\n+{\n+register struct hblk * h;\n+register hdr * hhdr;\n+register word sz;\t /* Current size in bytes\t*/\n+register word orig_sz;\t /* Original sz in bytes\t*/\n+int obj_kind;\n+\n+    if (p == 0) return(GC_malloc(lb));\t/* Required by ANSI */\n+    h = HBLKPTR(p);\n+    hhdr = HDR(h);\n+    sz = hhdr -> hb_sz;\n+    obj_kind = hhdr -> hb_obj_kind;\n+    sz = WORDS_TO_BYTES(sz);\n+    orig_sz = sz;\n+\n+    if (sz > MAXOBJBYTES) {\n+\t/* Round it up to the next whole heap block */\n+\t  register word descr;\n+\t  \n+\t  sz = (sz+HBLKSIZE-1) & (~HBLKMASK);\n+\t  hhdr -> hb_sz = BYTES_TO_WORDS(sz);\n+\t  descr = GC_obj_kinds[obj_kind].ok_descriptor;\n+          if (GC_obj_kinds[obj_kind].ok_relocate_descr) descr += sz;\n+          hhdr -> hb_descr = descr;\n+\t  if (IS_UNCOLLECTABLE(obj_kind)) GC_non_gc_bytes += (sz - orig_sz);\n+\t  /* Extra area is already cleared by GC_alloc_large_and_clear. */\n     }\n-    if (h == 0) {\n-        op = 0;\n+    if (ADD_SLOP(lb) <= sz) {\n+\tif (lb >= (sz >> 1)) {\n+#\t    ifdef STUBBORN_ALLOC\n+\t        if (obj_kind == STUBBORN) GC_change_stubborn(p);\n+#\t    endif\n+\t    if (orig_sz > lb) {\n+\t      /* Clear unneeded part of object to avoid bogus pointer */\n+\t      /* tracing.\t\t\t\t\t      */\n+\t      /* Safe for stubborn objects.\t\t\t      */\n+\t        BZERO(((ptr_t)p) + lb, orig_sz - lb);\n+\t    }\n+\t    return(p);\n+\t} else {\n+\t    /* shrink */\n+\t      GC_PTR result =\n+\t      \t\tGC_generic_or_special_malloc((word)lb, obj_kind);\n+\n+\t      if (result == 0) return(0);\n+\t          /* Could also return original object.  But this \t*/\n+\t          /* gives the client warning of imminent disaster.\t*/\n+\t      BCOPY(p, result, lb);\n+#\t      ifndef IGNORE_FREE\n+\t        GC_free(p);\n+#\t      endif\n+\t      return(result);\n+\t}\n     } else {\n-        op = (ptr_t) (h -> hb_body);\n-        GC_words_wasted += BYTES_TO_WORDS(n_blocks * HBLKSIZE) - lw;\n+\t/* grow */\n+\t  GC_PTR result =\n+\t  \tGC_generic_or_special_malloc((word)lb, obj_kind);\n+\n+\t  if (result == 0) return(0);\n+\t  BCOPY(p, result, sz);\n+#\t  ifndef IGNORE_FREE\n+\t    GC_free(p);\n+#\t  endif\n+\t  return(result);\n     }\n-    GC_words_allocd += lw;\n-    return((ptr_t)op);\n }\n \n+# if defined(REDIRECT_MALLOC) || defined(REDIRECT_REALLOC)\n+# ifdef __STDC__\n+    GC_PTR realloc(GC_PTR p, size_t lb)\n+# else\n+    GC_PTR realloc(p,lb)\n+    GC_PTR p;\n+    size_t lb;\n+# endif\n+  {\n+#   ifdef REDIRECT_REALLOC\n+      return(REDIRECT_REALLOC(p, lb));\n+#   else\n+      return(GC_realloc(p, lb));\n+#   endif\n+  }\n+# endif /* REDIRECT_MALLOC */\n+\n+\n+/* The same thing, except caller does not hold allocation lock.\t*/\n+/* We avoid holding allocation lock while we clear memory.\t*/\n ptr_t GC_generic_malloc_ignore_off_page(lb, k)\n register size_t lb;\n register int k;\n {\n     register ptr_t result;\n+    word lw;\n+    word n_blocks;\n+    GC_bool init;\n     DCL_LOCK_STATE;\n     \n+    if (SMALL_OBJ(lb))\n+        return(GC_generic_malloc((word)lb, k));\n+    lw = ROUNDED_UP_WORDS(lb);\n+    n_blocks = OBJ_SZ_TO_BLOCKS(lw);\n+    init = GC_obj_kinds[k].ok_init;\n     GC_INVOKE_FINALIZERS();\n     DISABLE_SIGNALS();\n     LOCK();\n-    result = GC_generic_malloc_inner_ignore_off_page(lb,k);\n+    result = (ptr_t)GC_alloc_large(lw, k, IGNORE_OFF_PAGE);\n+    if (0 != result) {\n+        if (GC_debugging_started) {\n+\t    BZERO(result, n_blocks * HBLKSIZE);\n+        } else {\n+#           ifdef THREADS\n+\t      /* Clear any memory that might be used for GC descriptors */\n+\t      /* before we release the lock.\t\t\t      */\n+\t        ((word *)result)[0] = 0;\n+\t        ((word *)result)[1] = 0;\n+\t        ((word *)result)[lw-1] = 0;\n+\t        ((word *)result)[lw-2] = 0;\n+#\t    endif\n+        }\n+    }\n+    GC_words_allocd += lw;\n     UNLOCK();\n     ENABLE_SIGNALS();\n     if (0 == result) {\n         return((*GC_oom_fn)(lb));\n     } else {\n+    \tif (init & !GC_debugging_started) {\n+\t    BZERO(result, n_blocks * HBLKSIZE);\n+        }\n         return(result);\n     }\n }\n@@ -185,6 +296,24 @@ DCL_LOCK_STATE;\n }\n \n #if defined(THREADS) && !defined(SRC_M3)\n+\n+extern signed_word GC_mem_found;   /* Protected by GC lock.  */\n+\n+#ifdef PARALLEL_MARK\n+volatile signed_word GC_words_allocd_tmp = 0;\n+                        /* Number of words of memory allocated since    */\n+                        /* we released the GC lock.  Instead of         */\n+                        /* reacquiring the GC lock just to add this in, */\n+                        /* we add it in the next time we reacquire      */\n+                        /* the lock.  (Atomically adding it doesn\'t     */\n+                        /* work, since we would have to atomically      */\n+                        /* update it in GC_malloc, which is too         */\n+                        /* expensive.                                   */\n+#endif /* PARALLEL_MARK */\n+\n+/* See reclaim.c: */\n+extern ptr_t GC_reclaim_generic();\n+\n /* Return a list of 1 or more objects of the indicated size, linked\t*/\n /* through the first word in the object.  This has the advantage that\t*/\n /* it acquires the allocation lock only once, and may greatly reduce\t*/\n@@ -194,63 +323,191 @@ DCL_LOCK_STATE;\n /* GC_malloc_many or friends to replenish it.  (We do not round up\t*/\n /* object sizes, since a call indicates the intention to consume many\t*/\n /* objects of exactly this size.)\t\t\t\t\t*/\n+/* We return the free-list by assigning it to *result, since it is\t*/\n+/* not safe to return, e.g. a linked list of pointer-free objects,\t*/\n+/* since the collector would not retain the entire list if it were \t*/\n+/* invoked just as we were returning.\t\t\t\t\t*/\n /* Note that the client should usually clear the link field.\t\t*/\n-ptr_t GC_generic_malloc_many(lb, k)\n+void GC_generic_malloc_many(lb, k, result)\n register word lb;\n register int k;\n+ptr_t *result;\n {\n ptr_t op;\n-register ptr_t p;\n+ptr_t p;\n ptr_t *opp;\n word lw;\n-register word my_words_allocd;\n+word my_words_allocd = 0;\n+struct obj_kind * ok = &(GC_obj_kinds[k]);\n DCL_LOCK_STATE;\n \n+#   if defined(GATHERSTATS) || defined(PARALLEL_MARK)\n+#     define COUNT_ARG , &my_words_allocd\n+#   else\n+#     define COUNT_ARG\n+#     define NEED_TO_COUNT\n+#   endif\n     if (!SMALL_OBJ(lb)) {\n         op = GC_generic_malloc(lb, k);\n         if(0 != op) obj_link(op) = 0;\n-        return(op);\n+\t*result = op;\n+        return;\n     }\n     lw = ALIGNED_WORDS(lb);\n     GC_INVOKE_FINALIZERS();\n     DISABLE_SIGNALS();\n     LOCK();\n-    opp = &(GC_obj_kinds[k].ok_freelist[lw]);\n-    if( (op = *opp) == 0 ) {\n-        if (!GC_is_initialized) {\n-            GC_init_inner();\n-        }\n-\top = GC_clear_stack(GC_allocobj(lw, k));\n-\tif (op == 0) {\n-\t    UNLOCK();\n-\t    ENABLE_SIGNALS();\n-\t    op = (*GC_oom_fn)(lb);\n-\t    if(0 != op) obj_link(op) = 0;\n-            return(op);\n-\t}\n+    if (!GC_is_initialized) GC_init_inner();\n+    /* Do our share of marking work */\n+      if (GC_incremental && !GC_dont_gc) {\n+        ENTER_GC();\n+\tGC_collect_a_little_inner(1);\n+        EXIT_GC();\n+      }\n+    /* First see if we can reclaim a page of objects waiting to be */\n+    /* reclaimed.\t\t\t\t\t\t   */\n+    {\n+\tstruct hblk ** rlh = ok -> ok_reclaim_list;\n+\tstruct hblk * hbp;\n+\thdr * hhdr;\n+\n+\trlh += lw;\n+    \twhile ((hbp = *rlh) != 0) {\n+            hhdr = HDR(hbp);\n+            *rlh = hhdr -> hb_next;\n+#\t    ifdef PARALLEL_MARK\n+\t\t{\n+\t\t  signed_word my_words_allocd_tmp = GC_words_allocd_tmp;\n+\n+\t\t  GC_ASSERT(my_words_allocd_tmp >= 0);\n+\t\t  /* We only decrement it while holding the GC lock.\t*/\n+\t\t  /* Thus we can\'t accidentally adjust it down in more\t*/\n+\t\t  /* than one thread simultaneously.\t\t\t*/\n+\t\t  if (my_words_allocd_tmp != 0) {\n+\t\t    (void)GC_atomic_add(\n+\t\t\t\t(volatile GC_word *)(&GC_words_allocd_tmp),\n+\t\t\t\t(GC_word)(-my_words_allocd_tmp));\n+\t\t    GC_words_allocd += my_words_allocd_tmp;\n+\t\t  }\n+\t\t}\n+\t\tGC_acquire_mark_lock();\n+\t\t++ GC_fl_builder_count;\n+\t\tUNLOCK();\n+\t\tENABLE_SIGNALS();\n+\t\tGC_release_mark_lock();\n+#\t    endif\n+\t    op = GC_reclaim_generic(hbp, hhdr, lw,\n+\t\t\t\t    ok -> ok_init, 0 COUNT_ARG);\n+            if (op != 0) {\n+#\t      ifdef NEED_TO_COUNT\n+\t\t/* We are neither gathering statistics, nor marking in\t*/\n+\t\t/* parallel.  Thus GC_reclaim_generic doesn\'t count\t*/\n+\t\t/* for us.\t\t\t\t\t\t*/\n+    \t\tfor (p = op; p != 0; p = obj_link(p)) {\n+        \t  my_words_allocd += lw;\n+\t\t}\n+#\t      endif\n+#\t      if defined(GATHERSTATS)\n+\t        /* We also reclaimed memory, so we need to adjust \t*/\n+\t        /* that count.\t\t\t\t\t\t*/\n+\t\t/* This should be atomic, so the results may be\t\t*/\n+\t\t/* inaccurate.\t\t\t\t\t\t*/\n+\t\tGC_mem_found += my_words_allocd;\n+#\t      endif\n+#\t      ifdef PARALLEL_MARK\n+\t\t*result = op;\n+\t\t(void)GC_atomic_add(\n+\t\t\t\t(volatile GC_word *)(&GC_words_allocd_tmp),\n+\t\t\t\t(GC_word)(my_words_allocd));\n+\t\tGC_acquire_mark_lock();\n+\t\t-- GC_fl_builder_count;\n+\t\tif (GC_fl_builder_count == 0) GC_notify_all_builder();\n+\t\tGC_release_mark_lock();\n+\t\t(void) GC_clear_stack(0);\n+\t\treturn;\n+#\t      else\n+\t        GC_words_allocd += my_words_allocd;\n+\t        goto out;\n+#\t      endif\n+\t    }\n+#\t    ifdef PARALLEL_MARK\n+\t      GC_acquire_mark_lock();\n+\t      -- GC_fl_builder_count;\n+\t      if (GC_fl_builder_count == 0) GC_notify_all_builder();\n+\t      GC_release_mark_lock();\n+\t      DISABLE_SIGNALS();\n+\t      LOCK();\n+\t      /* GC lock is needed for reclaim list access.\tWe\t*/\n+\t      /* must decrement fl_builder_count before reaquiring GC\t*/\n+\t      /* lock.  Hopefully this path is rare.\t\t\t*/\n+#\t    endif\n+    \t}\n     }\n-    *opp = 0;\n-    my_words_allocd = 0;\n-    for (p = op; p != 0; p = obj_link(p)) {\n-        my_words_allocd += lw;\n-        if (my_words_allocd >= BODY_SZ) {\n+    /* Next try to use prefix of global free list if there is one.\t*/\n+    /* We don\'t refill it, but we need to use it up before allocating\t*/\n+    /* a new block ourselves.\t\t\t\t\t\t*/\n+      opp = &(GC_obj_kinds[k].ok_freelist[lw]);\n+      if ( (op = *opp) != 0 ) {\n+\t*opp = 0;\n+        my_words_allocd = 0;\n+        for (p = op; p != 0; p = obj_link(p)) {\n+          my_words_allocd += lw;\n+          if (my_words_allocd >= BODY_SZ) {\n             *opp = obj_link(p);\n             obj_link(p) = 0;\n             break;\n+\t  }\n         }\n+\tGC_words_allocd += my_words_allocd;\n+\tgoto out;\n+      }\n+    /* Next try to allocate a new block worth of objects of this size.\t*/\n+    {\n+\tstruct hblk *h = GC_allochblk(lw, k, 0);\n+\tif (h != 0) {\n+\t  if (IS_UNCOLLECTABLE(k)) GC_set_hdr_marks(HDR(h));\n+\t  GC_words_allocd += BYTES_TO_WORDS(HBLKSIZE)\n+\t\t\t       - BYTES_TO_WORDS(HBLKSIZE) % lw;\n+#\t  ifdef PARALLEL_MARK\n+\t    GC_acquire_mark_lock();\n+\t    ++ GC_fl_builder_count;\n+\t    UNLOCK();\n+\t    ENABLE_SIGNALS();\n+\t    GC_release_mark_lock();\n+#\t  endif\n+\n+\t  op = GC_build_fl(h, lw, ok -> ok_init, 0);\n+#\t  ifdef PARALLEL_MARK\n+\t    *result = op;\n+\t    GC_acquire_mark_lock();\n+\t    -- GC_fl_builder_count;\n+\t    if (GC_fl_builder_count == 0) GC_notify_all_builder();\n+\t    GC_release_mark_lock();\n+\t    (void) GC_clear_stack(0);\n+\t    return;\n+#\t  else\n+\t    goto out;\n+#\t  endif\n+\t}\n     }\n-    GC_words_allocd += my_words_allocd;\n     \n-out:\n+    /* As a last attempt, try allocating a single object.  Note that\t*/\n+    /* this may trigger a collection or expand the heap.\t\t*/\n+      op = GC_generic_malloc_inner(lb, k);\n+      if (0 != op) obj_link(op) = 0;\n+    \n+  out:\n+    *result = op;\n     UNLOCK();\n     ENABLE_SIGNALS();\n-    return(op);\n-\n+    (void) GC_clear_stack(0);\n }\n \n-void * GC_malloc_many(size_t lb)\n+GC_PTR GC_malloc_many(size_t lb)\n {\n-    return(GC_generic_malloc_many(lb, NORMAL));\n+    ptr_t result;\n+    GC_generic_malloc_many(lb, NORMAL, &result);\n+    return result;\n }\n \n /* Note that the ""atomic"" version of this would be unsafe, since the\t*/\n@@ -272,11 +529,9 @@ DCL_LOCK_STATE;\n \n     if( SMALL_OBJ(lb) ) {\n #       ifdef MERGE_SIZES\n-#\t  ifdef ADD_BYTE_AT_END\n-\t    if (lb != 0) lb--;\n+\t  if (EXTRA_BYTES != 0 && lb != 0) lb--;\n \t    \t  /* We don\'t need the extra byte, since this won\'t be\t*/\n \t    \t  /* collected anyway.\t\t\t\t\t*/\n-#\t  endif\n \t  lw = GC_size_map[lb];\n #\telse\n \t  lw = ALIGNED_WORDS(lb);\n@@ -338,11 +593,9 @@ DCL_LOCK_STATE;\n \n     if( SMALL_OBJ(lb) ) {\n #       ifdef MERGE_SIZES\n-#\t  ifdef ADD_BYTE_AT_END\n-\t    if (lb != 0) lb--;\n+\t  if (EXTRA_BYTES != 0 && lb != 0) lb--;\n \t    \t  /* We don\'t need the extra byte, since this won\'t be\t*/\n \t    \t  /* collected anyway.\t\t\t\t\t*/\n-#\t  endif\n \t  lw = GC_size_map[lb];\n #\telse\n \t  lw = ALIGNED_WORDS(lb);\n']",2011-07-26 17:03:41+04:00,gc6.0 tarball import,"[['+ #include ""private/gc_priv.h""', '+ ptr_t * GC_CONST GC_objfreelist_ptr = GC_objfreelist;', '+ ptr_t * GC_CONST GC_aobjfreelist_ptr = GC_aobjfreelist;', '+ ptr_t * GC_CONST GC_uobjfreelist_ptr = GC_uobjfreelist;', '+     ptr_t * GC_CONST GC_auobjfreelist_ptr = GC_auobjfreelist;', '+ ', '+ GC_PTR GC_generic_or_special_malloc(lb,knd)', '+ word lb;', '+ int knd;', '+     switch(knd) {', '+ #     ifdef STUBBORN_ALLOC', '+ \tcase STUBBORN:', '+ \t    return(GC_malloc_stubborn((size_t)lb));', '+ #     endif', '+ \tcase PTRFREE:', '+ \t    return(GC_malloc_atomic((size_t)lb));', '+ \tcase NORMAL:', '+ \t    return(GC_malloc((size_t)lb));', '+ \tcase UNCOLLECTABLE:', '+ \t    return(GC_malloc_uncollectable((size_t)lb));', '+ #       ifdef ATOMIC_UNCOLLECTABLE', '+ \t  case AUNCOLLECTABLE:', '+ \t    return(GC_malloc_atomic_uncollectable((size_t)lb));', '+ \tdefault:', '+ \t    return(GC_generic_malloc(lb,knd));', '+     }', '+ }', '+ ', '+ ', '+ # ifdef __STDC__', '+     GC_PTR GC_realloc(GC_PTR p, size_t lb)', '+ # else', '+     GC_PTR GC_realloc(p,lb)', '+     GC_PTR p;', '+     size_t lb;', '+ # endif', '+ {', '+ register struct hblk * h;', '+ register hdr * hhdr;', '+ int obj_kind;', '+ ', '+     h = HBLKPTR(p);', '+     hhdr = HDR(h);', '+     sz = hhdr -> hb_sz;', '+     obj_kind = hhdr -> hb_obj_kind;', '+     sz = WORDS_TO_BYTES(sz);', '+     orig_sz = sz;', '+ ', '+     if (sz > MAXOBJBYTES) {', '+ \t  register word descr;', '+ ', '+ \t  sz = (sz+HBLKSIZE-1) & (~HBLKMASK);', '+ \t  hhdr -> hb_sz = BYTES_TO_WORDS(sz);', '+ \t  descr = GC_obj_kinds[obj_kind].ok_descriptor;', '+           if (GC_obj_kinds[obj_kind].ok_relocate_descr) descr += sz;', '+           hhdr -> hb_descr = descr;', '+ \t  if (IS_UNCOLLECTABLE(obj_kind)) GC_non_gc_bytes += (sz - orig_sz);', '+     if (ADD_SLOP(lb) <= sz) {', '+ \tif (lb >= (sz >> 1)) {', '+ #\t    ifdef STUBBORN_ALLOC', '+ \t        if (obj_kind == STUBBORN) GC_change_stubborn(p);', '+ #\t    endif', '+ \t    if (orig_sz > lb) {', '+ \t        BZERO(((ptr_t)p) + lb, orig_sz - lb);', '+ \t    }', '+ \t    return(p);', '+ \t} else {', '+ \t      GC_PTR result =', '+ \t      \t\tGC_generic_or_special_malloc((word)lb, obj_kind);', '+ ', '+ \t      if (result == 0) return(0);', '+ \t      BCOPY(p, result, lb);', '+ #\t      ifndef IGNORE_FREE', '+ \t        GC_free(p);', '+ #\t      endif', '+ \t      return(result);', '+ \t}', '+ \t  GC_PTR result =', '+ \t  \tGC_generic_or_special_malloc((word)lb, obj_kind);', '+ ', '+ \t  if (result == 0) return(0);', '+ \t  BCOPY(p, result, sz);', '+ #\t  ifndef IGNORE_FREE', '+ \t    GC_free(p);', '+ #\t  endif', '+ \t  return(result);', '+ # if defined(REDIRECT_MALLOC) || defined(REDIRECT_REALLOC)', '+ # ifdef __STDC__', '+     GC_PTR realloc(GC_PTR p, size_t lb)', '+ # else', '+     GC_PTR realloc(p,lb)', '+     GC_PTR p;', '+     size_t lb;', '+ # endif', '+   {', '+ #   ifdef REDIRECT_REALLOC', '+       return(REDIRECT_REALLOC(p, lb));', '+ #   else', '+       return(GC_realloc(p, lb));', '+ #   endif', '+   }', '+ ', '+ ', '+     word lw;', '+     word n_blocks;', '+     GC_bool init;', '+     if (SMALL_OBJ(lb))', '+         return(GC_generic_malloc((word)lb, k));', '+     lw = ROUNDED_UP_WORDS(lb);', '+     n_blocks = OBJ_SZ_TO_BLOCKS(lw);', '+     init = GC_obj_kinds[k].ok_init;', '+     result = (ptr_t)GC_alloc_large(lw, k, IGNORE_OFF_PAGE);', '+     if (0 != result) {', '+         if (GC_debugging_started) {', '+ \t    BZERO(result, n_blocks * HBLKSIZE);', '+         } else {', '+ #           ifdef THREADS', '+ \t        ((word *)result)[0] = 0;', '+ \t        ((word *)result)[1] = 0;', '+ \t        ((word *)result)[lw-1] = 0;', '+ \t        ((word *)result)[lw-2] = 0;', '+ #\t    endif', '+         }', '+     }', '+     GC_words_allocd += lw;', '+     \tif (init & !GC_debugging_started) {', '+ \t    BZERO(result, n_blocks * HBLKSIZE);', '+         }', '+ ', '+ ', '+ extern ptr_t GC_reclaim_generic();', '+ ', '+ void GC_generic_malloc_many(lb, k, result)', '+ ptr_t *result;', '+ ptr_t p;', '+ word my_words_allocd = 0;', '+ struct obj_kind * ok = &(GC_obj_kinds[k]);', '+ #   if defined(GATHERSTATS) || defined(PARALLEL_MARK)', '+ #     define COUNT_ARG , &my_words_allocd', '+ #   else', '+ #     define COUNT_ARG', '+ #     define NEED_TO_COUNT', '+ #   endif', '+ \t*result = op;', '+         return;', '+     if (!GC_is_initialized) GC_init_inner();', '+       if (GC_incremental && !GC_dont_gc) {', '+         ENTER_GC();', '+ \tGC_collect_a_little_inner(1);', '+         EXIT_GC();', '+       }', '+     {', '+ \tstruct hblk ** rlh = ok -> ok_reclaim_list;', '+ \tstruct hblk * hbp;', '+ \thdr * hhdr;', '+ ', '+ \trlh += lw;', '+     \twhile ((hbp = *rlh) != 0) {', '+             hhdr = HDR(hbp);', '+             *rlh = hhdr -> hb_next;', '+ #\t    ifdef PARALLEL_MARK', '+ \t\t{', '+ \t\t  signed_word my_words_allocd_tmp = GC_words_allocd_tmp;', '+ ', '+ \t\t  GC_ASSERT(my_words_allocd_tmp >= 0);', '+ \t\t  if (my_words_allocd_tmp != 0) {', '+ \t\t    (void)GC_atomic_add(', '+ \t\t\t\t(volatile GC_word *)(&GC_words_allocd_tmp),', '+ \t\t\t\t(GC_word)(-my_words_allocd_tmp));', '+ \t\t    GC_words_allocd += my_words_allocd_tmp;', '+ \t\t  }', '+ \t\t}', '+ \t\tGC_acquire_mark_lock();', '+ \t\t++ GC_fl_builder_count;', '+ \t\tUNLOCK();', '+ \t\tENABLE_SIGNALS();', '+ \t\tGC_release_mark_lock();', '+ #\t    endif', '+ \t    op = GC_reclaim_generic(hbp, hhdr, lw,', '+ \t\t\t\t    ok -> ok_init, 0 COUNT_ARG);', '+             if (op != 0) {', '+ #\t      ifdef NEED_TO_COUNT', '+     \t\tfor (p = op; p != 0; p = obj_link(p)) {', '+         \t  my_words_allocd += lw;', '+ \t\t}', '+ #\t      endif', '+ #\t      if defined(GATHERSTATS)', '+ \t\tGC_mem_found += my_words_allocd;', '+ #\t      endif', '+ #\t      ifdef PARALLEL_MARK', '+ \t\t*result = op;', '+ \t\t(void)GC_atomic_add(', '+ \t\t\t\t(volatile GC_word *)(&GC_words_allocd_tmp),', '+ \t\t\t\t(GC_word)(my_words_allocd));', '+ \t\tGC_acquire_mark_lock();', '+ \t\t-- GC_fl_builder_count;', '+ \t\tif (GC_fl_builder_count == 0) GC_notify_all_builder();', '+ \t\tGC_release_mark_lock();', '+ \t\t(void) GC_clear_stack(0);', '+ \t\treturn;', '+ #\t      else', '+ \t        GC_words_allocd += my_words_allocd;', '+ \t        goto out;', '+ #\t      endif', '+ \t    }', '+ #\t    ifdef PARALLEL_MARK', '+ \t      GC_acquire_mark_lock();', '+ \t      -- GC_fl_builder_count;', '+ \t      if (GC_fl_builder_count == 0) GC_notify_all_builder();', '+ \t      GC_release_mark_lock();', '+ \t      DISABLE_SIGNALS();', '+ \t      LOCK();', '+ #\t    endif', '+     \t}', '+       opp = &(GC_obj_kinds[k].ok_freelist[lw]);', '+       if ( (op = *opp) != 0 ) {', '+ \t*opp = 0;', '+         my_words_allocd = 0;', '+         for (p = op; p != 0; p = obj_link(p)) {', '+           my_words_allocd += lw;', '+           if (my_words_allocd >= BODY_SZ) {', '+ \t  }', '+ \tGC_words_allocd += my_words_allocd;', '+ \tgoto out;', '+       }', '+     {', '+ \tstruct hblk *h = GC_allochblk(lw, k, 0);', '+ \tif (h != 0) {', '+ \t  if (IS_UNCOLLECTABLE(k)) GC_set_hdr_marks(HDR(h));', '+ \t  GC_words_allocd += BYTES_TO_WORDS(HBLKSIZE)', '+ \t\t\t       - BYTES_TO_WORDS(HBLKSIZE) % lw;', '+ #\t  ifdef PARALLEL_MARK', '+ \t    GC_acquire_mark_lock();', '+ \t    ++ GC_fl_builder_count;', '+ \t    UNLOCK();', '+ \t    ENABLE_SIGNALS();', '+ \t    GC_release_mark_lock();', '+ #\t  endif', '+ ', '+ \t  op = GC_build_fl(h, lw, ok -> ok_init, 0);', '+ #\t  ifdef PARALLEL_MARK', '+ \t    *result = op;', '+ \t    GC_acquire_mark_lock();', '+ \t    -- GC_fl_builder_count;', '+ \t    if (GC_fl_builder_count == 0) GC_notify_all_builder();', '+ \t    GC_release_mark_lock();', '+ \t    (void) GC_clear_stack(0);', '+ \t    return;', '+ #\t  else', '+ \t    goto out;', '+ #\t  endif', '+ \t}', '+       op = GC_generic_malloc_inner(lb, k);', '+       if (0 != op) obj_link(op) = 0;', '+ ', '+   out:', '+     *result = op;', '+     (void) GC_clear_stack(0);', '+ GC_PTR GC_malloc_many(size_t lb)', '+     ptr_t result;', '+     GC_generic_malloc_many(lb, NORMAL, &result);', '+     return result;', '+ \t  if (EXTRA_BYTES != 0 && lb != 0) lb--;', '+ \t  if (EXTRA_BYTES != 0 && lb != 0) lb--;', '- #include ""gc_priv.h""', '- ptr_t * CONST GC_objfreelist_ptr = GC_objfreelist;', '- ptr_t * CONST GC_aobjfreelist_ptr = GC_aobjfreelist;', '- ptr_t * CONST GC_uobjfreelist_ptr = GC_uobjfreelist;', '-     ptr_t * CONST GC_auobjfreelist_ptr = GC_auobjfreelist;', '- ptr_t GC_generic_malloc_inner_ignore_off_page(lb, k)', '- register size_t lb;', '- register int k;', '-     register struct hblk * h;', '-     register word n_blocks;', '-     register word lw;', '-     register ptr_t op;', '- ', '-     if (lb <= HBLKSIZE)', '-         return(GC_generic_malloc_inner((word)lb, k));', '-     n_blocks = divHBLKSZ(ADD_SLOP(lb) + HDR_BYTES + HBLKSIZE-1);', '-     if (!GC_is_initialized) GC_init_inner();', '-     if(GC_incremental && !GC_dont_gc)', '-         GC_collect_a_little_inner((int)n_blocks);', '-     lw = ROUNDED_UP_WORDS(lb);', '-     h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);', '- #   ifdef USE_MUNMAP', '-       if (0 == h) {', '-         GC_merge_unmapped();', '-         h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);', '-       }', '- #   endif', '-     while (0 == h && GC_collect_or_expand(n_blocks, TRUE)) {', '-       h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);', '-     if (h == 0) {', '-         op = 0;', '-         op = (ptr_t) (h -> hb_body);', '-         GC_words_wasted += BYTES_TO_WORDS(n_blocks * HBLKSIZE) - lw;', '-     GC_words_allocd += lw;', '-     return((ptr_t)op);', '-     result = GC_generic_malloc_inner_ignore_off_page(lb,k);', '- ptr_t GC_generic_malloc_many(lb, k)', '- register ptr_t p;', '- register word my_words_allocd;', '-         return(op);', '-     opp = &(GC_obj_kinds[k].ok_freelist[lw]);', '-     if( (op = *opp) == 0 ) {', '-         if (!GC_is_initialized) {', '-             GC_init_inner();', '-         }', '- \top = GC_clear_stack(GC_allocobj(lw, k));', '- \tif (op == 0) {', '- \t    UNLOCK();', '- \t    ENABLE_SIGNALS();', '- \t    op = (*GC_oom_fn)(lb);', '- \t    if(0 != op) obj_link(op) = 0;', '-             return(op);', '- \t}', '-     *opp = 0;', '-     my_words_allocd = 0;', '-     for (p = op; p != 0; p = obj_link(p)) {', '-         my_words_allocd += lw;', '-         if (my_words_allocd >= BODY_SZ) {', '-     GC_words_allocd += my_words_allocd;', '- out:', '-     return(op);', '- ', '- void * GC_malloc_many(size_t lb)', '-     return(GC_generic_malloc_many(lb, NORMAL));', '- #\t  ifdef ADD_BYTE_AT_END', '- \t    if (lb != 0) lb--;', '- #\t  endif', '- #\t  ifdef ADD_BYTE_AT_END', '- \t    if (lb != 0) lb--;', '- #\t  endif']]","[['+ #include ""private/gc_priv.h""', '+ ptr_t * gc_const gc_objfreelist_ptr = gc_objfreelist;', '+ ptr_t * gc_const gc_aobjfreelist_ptr = gc_aobjfreelist;', '+ ptr_t * gc_const gc_uobjfreelist_ptr = gc_uobjfreelist;', '+     ptr_t * gc_const gc_auobjfreelist_ptr = gc_auobjfreelist;', '+ ', '+ gc_ptr gc_generic_or_special_malloc(lb,knd)', '+ word lb;', '+ int knd;', '+     switch(knd) {', '+ #     ifdef stubborn_alloc', '+ \tcase stubborn:', '+ \t    return(gc_malloc_stubborn((size_t)lb));', '+ #     endif', '+ \tcase ptrfree:', '+ \t    return(gc_malloc_atomic((size_t)lb));', '+ \tcase normal:', '+ \t    return(gc_malloc((size_t)lb));', '+ \tcase uncollectable:', '+ \t    return(gc_malloc_uncollectable((size_t)lb));', '+ #       ifdef atomic_uncollectable', '+ \t  case auncollectable:', '+ \t    return(gc_malloc_atomic_uncollectable((size_t)lb));', '+ \tdefault:', '+ \t    return(gc_generic_malloc(lb,knd));', '+     }', '+ }', '+ ', '+ ', '+ # ifdef __stdc__', '+     gc_ptr gc_realloc(gc_ptr p, size_t lb)', '+ # else', '+     gc_ptr gc_realloc(p,lb)', '+     gc_ptr p;', '+     size_t lb;', '+ # endif', '+ {', '+ register struct hblk * h;', '+ register hdr * hhdr;', '+ int obj_kind;', '+ ', '+     h = hblkptr(p);', '+     hhdr = hdr(h);', '+     sz = hhdr -> hb_sz;', '+     obj_kind = hhdr -> hb_obj_kind;', '+     sz = words_to_bytes(sz);', '+     orig_sz = sz;', '+ ', '+     if (sz > maxobjbytes) {', '+ \t  register word descr;', '+ ', '+ \t  sz = (sz+hblksize-1) & (~hblkmask);', '+ \t  hhdr -> hb_sz = bytes_to_words(sz);', '+ \t  descr = gc_obj_kinds[obj_kind].ok_descriptor;', '+           if (gc_obj_kinds[obj_kind].ok_relocate_descr) descr += sz;', '+           hhdr -> hb_descr = descr;', '+ \t  if (is_uncollectable(obj_kind)) gc_non_gc_bytes += (sz - orig_sz);', '+     if (add_slop(lb) <= sz) {', '+ \tif (lb >= (sz >> 1)) {', '+ #\t    ifdef stubborn_alloc', '+ \t        if (obj_kind == stubborn) gc_change_stubborn(p);', '+ #\t    endif', '+ \t    if (orig_sz > lb) {', '+ \t        bzero(((ptr_t)p) + lb, orig_sz - lb);', '+ \t    }', '+ \t    return(p);', '+ \t} else {', '+ \t      gc_ptr result =', '+ \t      \t\tgc_generic_or_special_malloc((word)lb, obj_kind);', '+ ', '+ \t      if (result == 0) return(0);', '+ \t      bcopy(p, result, lb);', '+ #\t      ifndef ignore_free', '+ \t        gc_free(p);', '+ #\t      endif', '+ \t      return(result);', '+ \t}', '+ \t  gc_ptr result =', '+ \t  \tgc_generic_or_special_malloc((word)lb, obj_kind);', '+ ', '+ \t  if (result == 0) return(0);', '+ \t  bcopy(p, result, sz);', '+ #\t  ifndef ignore_free', '+ \t    gc_free(p);', '+ #\t  endif', '+ \t  return(result);', '+ # if defined(redirect_malloc) || defined(redirect_realloc)', '+ # ifdef __stdc__', '+     gc_ptr realloc(gc_ptr p, size_t lb)', '+ # else', '+     gc_ptr realloc(p,lb)', '+     gc_ptr p;', '+     size_t lb;', '+ # endif', '+   {', '+ #   ifdef redirect_realloc', '+       return(redirect_realloc(p, lb));', '+ #   else', '+       return(gc_realloc(p, lb));', '+ #   endif', '+   }', '+ ', '+ ', '+     word lw;', '+     word n_blocks;', '+     gc_bool init;', '+     if (small_obj(lb))', '+         return(gc_generic_malloc((word)lb, k));', '+     lw = rounded_up_words(lb);', '+     n_blocks = obj_sz_to_blocks(lw);', '+     init = gc_obj_kinds[k].ok_init;', '+     result = (ptr_t)gc_alloc_large(lw, k, ignore_off_page);', '+     if (0 != result) {', '+         if (gc_debugging_started) {', '+ \t    bzero(result, n_blocks * hblksize);', '+         } else {', '+ #           ifdef threads', '+ \t        ((word *)result)[0] = 0;', '+ \t        ((word *)result)[1] = 0;', '+ \t        ((word *)result)[lw-1] = 0;', '+ \t        ((word *)result)[lw-2] = 0;', '+ #\t    endif', '+         }', '+     }', '+     gc_words_allocd += lw;', '+     \tif (init & !gc_debugging_started) {', '+ \t    bzero(result, n_blocks * hblksize);', '+         }', '+ ', '+ ', '+ extern ptr_t gc_reclaim_generic();', '+ ', '+ void gc_generic_malloc_many(lb, k, result)', '+ ptr_t *result;', '+ ptr_t p;', '+ word my_words_allocd = 0;', '+ struct obj_kind * ok = &(gc_obj_kinds[k]);', '+ #   if defined(gatherstats) || defined(parallel_mark)', '+ #     define count_arg , &my_words_allocd', '+ #   else', '+ #     define count_arg', '+ #     define need_to_count', '+ #   endif', '+ \t*result = op;', '+         return;', '+     if (!gc_is_initialized) gc_init_inner();', '+       if (gc_incremental && !gc_dont_gc) {', '+         enter_gc();', '+ \tgc_collect_a_little_inner(1);', '+         exit_gc();', '+       }', '+     {', '+ \tstruct hblk ** rlh = ok -> ok_reclaim_list;', '+ \tstruct hblk * hbp;', '+ \thdr * hhdr;', '+ ', '+ \trlh += lw;', '+     \twhile ((hbp = *rlh) != 0) {', '+             hhdr = hdr(hbp);', '+             *rlh = hhdr -> hb_next;', '+ #\t    ifdef parallel_mark', '+ \t\t{', '+ \t\t  signed_word my_words_allocd_tmp = gc_words_allocd_tmp;', '+ ', '+ \t\t  gc_assert(my_words_allocd_tmp >= 0);', '+ \t\t  if (my_words_allocd_tmp != 0) {', '+ \t\t    (void)gc_atomic_add(', '+ \t\t\t\t(volatile gc_word *)(&gc_words_allocd_tmp),', '+ \t\t\t\t(gc_word)(-my_words_allocd_tmp));', '+ \t\t    gc_words_allocd += my_words_allocd_tmp;', '+ \t\t  }', '+ \t\t}', '+ \t\tgc_acquire_mark_lock();', '+ \t\t++ gc_fl_builder_count;', '+ \t\tunlock();', '+ \t\tenable_signals();', '+ \t\tgc_release_mark_lock();', '+ #\t    endif', '+ \t    op = gc_reclaim_generic(hbp, hhdr, lw,', '+ \t\t\t\t    ok -> ok_init, 0 count_arg);', '+             if (op != 0) {', '+ #\t      ifdef need_to_count', '+     \t\tfor (p = op; p != 0; p = obj_link(p)) {', '+         \t  my_words_allocd += lw;', '+ \t\t}', '+ #\t      endif', '+ #\t      if defined(gatherstats)', '+ \t\tgc_mem_found += my_words_allocd;', '+ #\t      endif', '+ #\t      ifdef parallel_mark', '+ \t\t*result = op;', '+ \t\t(void)gc_atomic_add(', '+ \t\t\t\t(volatile gc_word *)(&gc_words_allocd_tmp),', '+ \t\t\t\t(gc_word)(my_words_allocd));', '+ \t\tgc_acquire_mark_lock();', '+ \t\t-- gc_fl_builder_count;', '+ \t\tif (gc_fl_builder_count == 0) gc_notify_all_builder();', '+ \t\tgc_release_mark_lock();', '+ \t\t(void) gc_clear_stack(0);', '+ \t\treturn;', '+ #\t      else', '+ \t        gc_words_allocd += my_words_allocd;', '+ \t        goto out;', '+ #\t      endif', '+ \t    }', '+ #\t    ifdef parallel_mark', '+ \t      gc_acquire_mark_lock();', '+ \t      -- gc_fl_builder_count;', '+ \t      if (gc_fl_builder_count == 0) gc_notify_all_builder();', '+ \t      gc_release_mark_lock();', '+ \t      disable_signals();', '+ \t      lock();', '+ #\t    endif', '+     \t}', '+       opp = &(gc_obj_kinds[k].ok_freelist[lw]);', '+       if ( (op = *opp) != 0 ) {', '+ \t*opp = 0;', '+         my_words_allocd = 0;', '+         for (p = op; p != 0; p = obj_link(p)) {', '+           my_words_allocd += lw;', '+           if (my_words_allocd >= body_sz) {', '+ \t  }', '+ \tgc_words_allocd += my_words_allocd;', '+ \tgoto out;', '+       }', '+     {', '+ \tstruct hblk *h = gc_allochblk(lw, k, 0);', '+ \tif (h != 0) {', '+ \t  if (is_uncollectable(k)) gc_set_hdr_marks(hdr(h));', '+ \t  gc_words_allocd += bytes_to_words(hblksize)', '+ \t\t\t       - bytes_to_words(hblksize) % lw;', '+ #\t  ifdef parallel_mark', '+ \t    gc_acquire_mark_lock();', '+ \t    ++ gc_fl_builder_count;', '+ \t    unlock();', '+ \t    enable_signals();', '+ \t    gc_release_mark_lock();', '+ #\t  endif', '+ ', '+ \t  op = gc_build_fl(h, lw, ok -> ok_init, 0);', '+ #\t  ifdef parallel_mark', '+ \t    *result = op;', '+ \t    gc_acquire_mark_lock();', '+ \t    -- gc_fl_builder_count;', '+ \t    if (gc_fl_builder_count == 0) gc_notify_all_builder();', '+ \t    gc_release_mark_lock();', '+ \t    (void) gc_clear_stack(0);', '+ \t    return;', '+ #\t  else', '+ \t    goto out;', '+ #\t  endif', '+ \t}', '+       op = gc_generic_malloc_inner(lb, k);', '+       if (0 != op) obj_link(op) = 0;', '+ ', '+   out:', '+     *result = op;', '+     (void) gc_clear_stack(0);', '+ gc_ptr gc_malloc_many(size_t lb)', '+     ptr_t result;', '+     gc_generic_malloc_many(lb, normal, &result);', '+     return result;', '+ \t  if (extra_bytes != 0 && lb != 0) lb--;', '+ \t  if (extra_bytes != 0 && lb != 0) lb--;', '- #include ""gc_priv.h""', '- ptr_t * const gc_objfreelist_ptr = gc_objfreelist;', '- ptr_t * const gc_aobjfreelist_ptr = gc_aobjfreelist;', '- ptr_t * const gc_uobjfreelist_ptr = gc_uobjfreelist;', '-     ptr_t * const gc_auobjfreelist_ptr = gc_auobjfreelist;', '- ptr_t gc_generic_malloc_inner_ignore_off_page(lb, k)', '- register size_t lb;', '- register int k;', '-     register struct hblk * h;', '-     register word n_blocks;', '-     register word lw;', '-     register ptr_t op;', '- ', '-     if (lb <= hblksize)', '-         return(gc_generic_malloc_inner((word)lb, k));', '-     n_blocks = divhblksz(add_slop(lb) + hdr_bytes + hblksize-1);', '-     if (!gc_is_initialized) gc_init_inner();', '-     if(gc_incremental && !gc_dont_gc)', '-         gc_collect_a_little_inner((int)n_blocks);', '-     lw = rounded_up_words(lb);', '-     h = gc_allochblk(lw, k, ignore_off_page);', '- #   ifdef use_munmap', '-       if (0 == h) {', '-         gc_merge_unmapped();', '-         h = gc_allochblk(lw, k, ignore_off_page);', '-       }', '- #   endif', '-     while (0 == h && gc_collect_or_expand(n_blocks, true)) {', '-       h = gc_allochblk(lw, k, ignore_off_page);', '-     if (h == 0) {', '-         op = 0;', '-         op = (ptr_t) (h -> hb_body);', '-         gc_words_wasted += bytes_to_words(n_blocks * hblksize) - lw;', '-     gc_words_allocd += lw;', '-     return((ptr_t)op);', '-     result = gc_generic_malloc_inner_ignore_off_page(lb,k);', '- ptr_t gc_generic_malloc_many(lb, k)', '- register ptr_t p;', '- register word my_words_allocd;', '-         return(op);', '-     opp = &(gc_obj_kinds[k].ok_freelist[lw]);', '-     if( (op = *opp) == 0 ) {', '-         if (!gc_is_initialized) {', '-             gc_init_inner();', '-         }', '- \top = gc_clear_stack(gc_allocobj(lw, k));', '- \tif (op == 0) {', '- \t    unlock();', '- \t    enable_signals();', '- \t    op = (*gc_oom_fn)(lb);', '- \t    if(0 != op) obj_link(op) = 0;', '-             return(op);', '- \t}', '-     *opp = 0;', '-     my_words_allocd = 0;', '-     for (p = op; p != 0; p = obj_link(p)) {', '-         my_words_allocd += lw;', '-         if (my_words_allocd >= body_sz) {', '-     gc_words_allocd += my_words_allocd;', '- out:', '-     return(op);', '- ', '- void * gc_malloc_many(size_t lb)', '-     return(gc_generic_malloc_many(lb, normal));', '- #\t  ifdef add_byte_at_end', '- \t    if (lb != 0) lb--;', '- #\t  endif', '- #\t  ifdef add_byte_at_end', '- \t    if (lb != 0) lb--;', '- #\t  endif']]","[['+ #include ""private/gc_priv.h""', '+ ptr_t * GC_CONST GC_objfreelist_ptr = GC_objfreelist;', '+ ptr_t * GC_CONST GC_aobjfreelist_ptr = GC_aobjfreelist;', '+ ptr_t * GC_CONST GC_uobjfreelist_ptr = GC_uobjfreelist;', '+     ptr_t * GC_CONST GC_auobjfreelist_ptr = GC_auobjfreelist;', '+ ', '+ GC_PTR GC_generic_or_special_malloc(lb,knd)', '+ word lb;', '+ int knd;', '+     switch(knd) {', '+ #     ifdef STUBBORN_ALLOC', '+ \tcase STUBBORN:', '+ \t    return(GC_malloc_stubborn((size_t)lb));', '+ #     endif', '+ \tcase PTRFREE:', '+ \t    return(GC_malloc_atomic((size_t)lb));', '+ \tcase NORMAL:', '+ \t    return(GC_malloc((size_t)lb));', '+ \tcase UNCOLLECTABLE:', '+ \t    return(GC_malloc_uncollectable((size_t)lb));', '+ #       ifdef ATOMIC_UNCOLLECTABLE', '+ \t  case AUNCOLLECTABLE:', '+ \t    return(GC_malloc_atomic_uncollectable((size_t)lb));', '+ \tdefault:', '+ \t    return(GC_generic_malloc(lb,knd));', '+     }', '+ }', '+ ', '+ ', '+ # ifdef __STDC__', '+     GC_PTR GC_realloc(GC_PTR p, size_t lb)', '+ # else', '+     GC_PTR GC_realloc(p,lb)', '+     GC_PTR p;', '+     size_t lb;', '+ # endif', '+ {', '+ register struct hblk * h;', '+ register hdr * hhdr;', '+ int obj_kind;', '+ ', '+     h = HBLKPTR(p);', '+     hhdr = HDR(h);', '+     sz = hhdr -> hb_sz;', '+     obj_kind = hhdr -> hb_obj_kind;', '+     sz = WORDS_TO_BYTES(sz);', '+     orig_sz = sz;', '+ ', '+     if (sz > MAXOBJBYTES) {', '+ \t  register word descr;', '+ ', '+ \t  sz = (sz+HBLKSIZE-1) & (~HBLKMASK);', '+ \t  hhdr -> hb_sz = BYTES_TO_WORDS(sz);', '+ \t  descr = GC_obj_kinds[obj_kind].ok_descriptor;', '+           if (GC_obj_kinds[obj_kind].ok_relocate_descr) descr += sz;', '+           hhdr -> hb_descr = descr;', '+ \t  if (IS_UNCOLLECTABLE(obj_kind)) GC_non_gc_bytes += (sz - orig_sz);', '+     if (ADD_SLOP(lb) <= sz) {', '+ \tif (lb >= (sz >> 1)) {', '+ #\t    ifdef STUBBORN_ALLOC', '+ \t        if (obj_kind == STUBBORN) GC_change_stubborn(p);', '+ #\t    endif', '+ \t    if (orig_sz > lb) {', '+ \t        BZERO(((ptr_t)p) + lb, orig_sz - lb);', '+ \t    }', '+ \t    return(p);', '+ \t} else {', '+ \t      GC_PTR result =', '+ \t      \t\tGC_generic_or_special_malloc((word)lb, obj_kind);', '+ ', '+ \t      if (result == 0) return(0);', '+ \t      BCOPY(p, result, lb);', '+ #\t      ifndef IGNORE_FREE', '+ \t        GC_free(p);', '+ #\t      endif', '+ \t      return(result);', '+ \t}', '+ \t  GC_PTR result =', '+ \t  \tGC_generic_or_special_malloc((word)lb, obj_kind);', '+ ', '+ \t  if (result == 0) return(0);', '+ \t  BCOPY(p, result, sz);', '+ #\t  ifndef IGNORE_FREE', '+ \t    GC_free(p);', '+ #\t  endif', '+ \t  return(result);', '+ # if defined(REDIRECT_MALLOC) || defined(REDIRECT_REALLOC)', '+ # ifdef __STDC__', '+     GC_PTR realloc(GC_PTR p, size_t lb)', '+ # else', '+     GC_PTR realloc(p,lb)', '+     GC_PTR p;', '+     size_t lb;', '+ # endif', '+   {', '+ #   ifdef REDIRECT_REALLOC', '+       return(REDIRECT_REALLOC(p, lb));', '+ #   else', '+       return(GC_realloc(p, lb));', '+ #   endif', '+   }', '+ ', '+ ', '+     word lw;', '+     word n_blocks;', '+     GC_bool init;', '+     if (SMALL_OBJ(lb))', '+         return(GC_generic_malloc((word)lb, k));', '+     lw = ROUNDED_UP_WORDS(lb);', '+     n_blocks = OBJ_SZ_TO_BLOCKS(lw);', '+     init = GC_obj_kinds[k].ok_init;', '+     result = (ptr_t)GC_alloc_large(lw, k, IGNORE_OFF_PAGE);', '+     if (0 != result) {', '+         if (GC_debugging_started) {', '+ \t    BZERO(result, n_blocks * HBLKSIZE);', '+         } else {', '+ #           ifdef THREADS', '+ \t        ((word *)result)[0] = 0;', '+ \t        ((word *)result)[1] = 0;', '+ \t        ((word *)result)[lw-1] = 0;', '+ \t        ((word *)result)[lw-2] = 0;', '+ #\t    endif', '+         }', '+     }', '+     GC_words_allocd += lw;', '+     \tif (init & !GC_debugging_started) {', '+ \t    BZERO(result, n_blocks * HBLKSIZE);', '+         }', '+ ', '+ ', '+ extern ptr_t GC_reclaim_generic();', '+ ', '+ void GC_generic_malloc_many(lb, k, result)', '+ ptr_t *result;', '+ ptr_t p;', '+ word my_words_allocd = 0;', '+ struct obj_kind * ok = &(GC_obj_kinds[k]);', '+ #   if defined(GATHERSTATS) || defined(PARALLEL_MARK)', '+ #     define COUNT_ARG , &my_words_allocd', '+ #   else', '+ #     define COUNT_ARG', '+ #     define NEED_TO_COUNT', '+ #   endif', '+ \t*result = op;', '+         return;', '+     if (!GC_is_initialized) GC_init_inner();', '+       if (GC_incremental && !GC_dont_gc) {', '+         ENTER_GC();', '+ \tGC_collect_a_little_inner(1);', '+         EXIT_GC();', '+       }', '+     {', '+ \tstruct hblk ** rlh = ok -> ok_reclaim_list;', '+ \tstruct hblk * hbp;', '+ \thdr * hhdr;', '+ ', '+ \trlh += lw;', '+     \twhile ((hbp = *rlh) != 0) {', '+             hhdr = HDR(hbp);', '+             *rlh = hhdr -> hb_next;', '+ #\t    ifdef PARALLEL_MARK', '+ \t\t{', '+ \t\t  signed_word my_words_allocd_tmp = GC_words_allocd_tmp;', '+ ', '+ \t\t  GC_ASSERT(my_words_allocd_tmp >= 0);', '+ \t\t  if (my_words_allocd_tmp != 0) {', '+ \t\t    (void)GC_atomic_add(', '+ \t\t\t\t(volatile GC_word *)(&GC_words_allocd_tmp),', '+ \t\t\t\t(GC_word)(-my_words_allocd_tmp));', '+ \t\t    GC_words_allocd += my_words_allocd_tmp;', '+ \t\t  }', '+ \t\t}', '+ \t\tGC_acquire_mark_lock();', '+ \t\t++ GC_fl_builder_count;', '+ \t\tUNLOCK();', '+ \t\tENABLE_SIGNALS();', '+ \t\tGC_release_mark_lock();', '+ #\t    endif', '+ \t    op = GC_reclaim_generic(hbp, hhdr, lw,', '+ \t\t\t\t    ok -> ok_init, 0 COUNT_ARG);', '+             if (op != 0) {', '+ #\t      ifdef NEED_TO_COUNT', '+     \t\tfor (p = op; p != 0; p = obj_link(p)) {', '+         \t  my_words_allocd += lw;', '+ \t\t}', '+ #\t      endif', '+ #\t      if defined(GATHERSTATS)', '+ \t\tGC_mem_found += my_words_allocd;', '+ #\t      endif', '+ #\t      ifdef PARALLEL_MARK', '+ \t\t*result = op;', '+ \t\t(void)GC_atomic_add(', '+ \t\t\t\t(volatile GC_word *)(&GC_words_allocd_tmp),', '+ \t\t\t\t(GC_word)(my_words_allocd));', '+ \t\tGC_acquire_mark_lock();', '+ \t\t-- GC_fl_builder_count;', '+ \t\tif (GC_fl_builder_count == 0) GC_notify_all_builder();', '+ \t\tGC_release_mark_lock();', '+ \t\t(void) GC_clear_stack(0);', '+ \t\treturn;', '+ #\t      else', '+ \t        GC_words_allocd += my_words_allocd;', '+ \t        goto out;', '+ #\t      endif', '+ \t    }', '+ #\t    ifdef PARALLEL_MARK', '+ \t      GC_acquire_mark_lock();', '+ \t      -- GC_fl_builder_count;', '+ \t      if (GC_fl_builder_count == 0) GC_notify_all_builder();', '+ \t      GC_release_mark_lock();', '+ \t      DISABLE_SIGNALS();', '+ \t      LOCK();', '+ #\t    endif', '+     \t}', '+       opp = &(GC_obj_kinds[k].ok_freelist[lw]);', '+       if ( (op = *opp) != 0 ) {', '+ \t*opp = 0;', '+         my_words_allocd = 0;', '+         for (p = op; p != 0; p = obj_link(p)) {', '+           my_words_allocd += lw;', '+           if (my_words_allocd >= BODY_SZ) {', '+ \t  }', '+ \tGC_words_allocd += my_words_allocd;', '+ \tgoto out;', '+       }', '+     {', '+ \tstruct hblk *h = GC_allochblk(lw, k, 0);', '+ \tif (h != 0) {', '+ \t  if (IS_UNCOLLECTABLE(k)) GC_set_hdr_marks(HDR(h));', '+ \t  GC_words_allocd += BYTES_TO_WORDS(HBLKSIZE)', '+ \t\t\t       - BYTES_TO_WORDS(HBLKSIZE) % lw;', '+ #\t  ifdef PARALLEL_MARK', '+ \t    GC_acquire_mark_lock();', '+ \t    ++ GC_fl_builder_count;', '+ \t    UNLOCK();', '+ \t    ENABLE_SIGNALS();', '+ \t    GC_release_mark_lock();', '+ #\t  endif', '+ ', '+ \t  op = GC_build_fl(h, lw, ok -> ok_init, 0);', '+ #\t  ifdef PARALLEL_MARK', '+ \t    *result = op;', '+ \t    GC_acquire_mark_lock();', '+ \t    -- GC_fl_builder_count;', '+ \t    if (GC_fl_builder_count == 0) GC_notify_all_builder();', '+ \t    GC_release_mark_lock();', '+ \t    (void) GC_clear_stack(0);', '+ \t    return;', '+ #\t  else', '+ \t    goto out;', '+ #\t  endif', '+ \t}', '+       op = GC_generic_malloc_inner(lb, k);', '+       if (0 != op) obj_link(op) = 0;', '+ ', '+   out:', '+     *result = op;', '+     (void) GC_clear_stack(0);', '+ GC_PTR GC_malloc_many(size_t lb)', '+     ptr_t result;', '+     GC_generic_malloc_many(lb, NORMAL, &result);', '+     return result;', '+ \t  if (EXTRA_BYTES != 0 && lb != 0) lb--;', '+ \t  if (EXTRA_BYTES != 0 && lb != 0) lb--;']]","[['- #include ""gc_priv.h""', '- ptr_t * CONST GC_objfreelist_ptr = GC_objfreelist;', '- ptr_t * CONST GC_aobjfreelist_ptr = GC_aobjfreelist;', '- ptr_t * CONST GC_uobjfreelist_ptr = GC_uobjfreelist;', '-     ptr_t * CONST GC_auobjfreelist_ptr = GC_auobjfreelist;', '- ptr_t GC_generic_malloc_inner_ignore_off_page(lb, k)', '- register size_t lb;', '- register int k;', '-     register struct hblk * h;', '-     register word n_blocks;', '-     register word lw;', '-     register ptr_t op;', '- ', '-     if (lb <= HBLKSIZE)', '-         return(GC_generic_malloc_inner((word)lb, k));', '-     n_blocks = divHBLKSZ(ADD_SLOP(lb) + HDR_BYTES + HBLKSIZE-1);', '-     if (!GC_is_initialized) GC_init_inner();', '-     if(GC_incremental && !GC_dont_gc)', '-         GC_collect_a_little_inner((int)n_blocks);', '-     lw = ROUNDED_UP_WORDS(lb);', '-     h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);', '- #   ifdef USE_MUNMAP', '-       if (0 == h) {', '-         GC_merge_unmapped();', '-         h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);', '-       }', '- #   endif', '-     while (0 == h && GC_collect_or_expand(n_blocks, TRUE)) {', '-       h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);', '-     if (h == 0) {', '-         op = 0;', '-         op = (ptr_t) (h -> hb_body);', '-         GC_words_wasted += BYTES_TO_WORDS(n_blocks * HBLKSIZE) - lw;', '-     GC_words_allocd += lw;', '-     return((ptr_t)op);', '-     result = GC_generic_malloc_inner_ignore_off_page(lb,k);', '- ptr_t GC_generic_malloc_many(lb, k)', '- register ptr_t p;', '- register word my_words_allocd;', '-         return(op);', '-     opp = &(GC_obj_kinds[k].ok_freelist[lw]);', '-     if( (op = *opp) == 0 ) {', '-         if (!GC_is_initialized) {', '-             GC_init_inner();', '-         }', '- \top = GC_clear_stack(GC_allocobj(lw, k));', '- \tif (op == 0) {', '- \t    UNLOCK();', '- \t    ENABLE_SIGNALS();', '- \t    op = (*GC_oom_fn)(lb);', '- \t    if(0 != op) obj_link(op) = 0;', '-             return(op);', '- \t}', '-     *opp = 0;', '-     my_words_allocd = 0;', '-     for (p = op; p != 0; p = obj_link(p)) {', '-         my_words_allocd += lw;', '-         if (my_words_allocd >= BODY_SZ) {', '-     GC_words_allocd += my_words_allocd;', '- out:', '-     return(op);', '- ', '- void * GC_malloc_many(size_t lb)', '-     return(GC_generic_malloc_many(lb, NORMAL));', '- #\t  ifdef ADD_BYTE_AT_END', '- \t    if (lb != 0) lb--;', '- #\t  endif', '- #\t  ifdef ADD_BYTE_AT_END', '- \t    if (lb != 0) lb--;', '- #\t  endif']]",264,70.0,334.0,9f27ae7aee7a12b3c99d0ce7dc4c7384e3189fa2ivmai/bdwgc,"['be9df82919960214ee4b9d3313523bff44fd99e1', 'be9df82919960214ee4b9d3313523bff44fd99e1']"
3f2fe30962d6e06854759bc00209747f70f21d1f,file/file,softmagic.c,test,C,0,"[""@@ -110,7 +110,8 @@ struct magic *m;\n \t\tl = 0;\n \t\t/* What we want here is:\n \t\t * v = strncmp(m->value.s, p->s, m->vallen);\n-\t\t * but ignoring any nulls.  bcmp doesn't give -/+/0.\n+\t\t * but ignoring any nulls.  bcmp doesn't give -/+/0\n+\t\t * and isn't universally available anyway.\n \t\t */\n \t\t{\n \t\t\tregister unsigned char *a = (unsigned char*)m->value.s;\n@@ -118,7 +119,8 @@ struct magic *m;\n \t\t\tregister int len = m->vallen;\n \n \t\t\twhile (--len >= 0)\n-\t\t\t\tif (0 != (v = *b++ - *a++)) break;\n+\t\t\t\tif ((v = *b++ - *a++) != 0)\n+\t\t\t\t\tbreak;\n \t\t}\n \t\tbreak;\n \tdefault:\n""]",,,"['+ \t\t\t\tif ((v = *b++ - *a++) != 0)', '+ \t\t\t\t\tbreak;', '- \t\t\t\tif (0 != (v = *b++ - *a++)) break;']","['+ \t\t\t\tif ((v = *b++ - *a++) != 0)', '+ \t\t\t\t\tbreak;', '- \t\t\t\tif (0 != (v = *b++ - *a++)) break;']","['+ \t\t\t\tif ((v = *b++ - *a++) != 0)', '+ \t\t\t\t\tbreak;']",['- \t\t\t\tif (0 != (v = *b++ - *a++)) break;'],2,1.0,3.0,3f2fe30962d6e06854759bc00209747f70f21d1ffile/file,[]
3bb4e23a8aa15fc93b91b92d8c6437358fd71113,FFmpeg/FFmpeg,mpeg12.c,train,C,0,"['@@ -542,6 +542,7 @@ static int mpeg_decode_mb(MpegEncContext *s,\n             s->mv[1][0][0] = s->last_mv[1][0][0];\n             s->mv[1][0][1] = s->last_mv[1][0][1];\n         }\n+        s->mb_skiped = 1;\n         return 0;\n     }\n \n']",,,['+         s->mb_skiped = 1;'],['+         s->mb_skiped = 1;'],['+         s->mb_skiped = 1;'],[],1,0.0,1.0,3bb4e23a8aa15fc93b91b92d8c6437358fd71113FFmpeg/FFmpeg,[]
1b533267341d3735a680ddc443f60bae0e6f4ee3,memcached/memcached,items.c,test,C,0,"['@@ -14,6 +14,7 @@\n #include <unistd.h>\n #include <netinet/in.h>\n #include <errno.h>\n+#include <time.h>\n #include <event.h>\n #include <malloc.h>\n #include <Judy.h>\n@@ -190,7 +191,7 @@ char *item_cachedump(unsigned int slabs_clsid, unsigned int limit, unsigned int\n             break;\n         if (!it)\n             break;\n-        sprintf(temp, ""ITEM %s [%u b; %u s]\\r\\n"", it->key, it->nbytes - 2, it->time);\n+        sprintf(temp, ""ITEM %s [%u b; %lu s]\\r\\n"", it->key, it->nbytes - 2, it->time);\n         len = strlen(temp);\n         if (bufcurr + len +5 > memlimit)  /* 5 is END\\r\\n */\n             break;\n@@ -219,7 +220,7 @@ void item_stats(char *buffer, int buflen) {\n \n     for (i=0; i<LARGEST_ID; i++) {\n         if (tails[i])\n-            bufcurr += sprintf(bufcurr, ""STAT items:%u:number %u\\r\\nSTAT items:%u:age %u\\r\\n"", \n+            bufcurr += sprintf(bufcurr, ""STAT items:%u:number %u\\r\\nSTAT items:%u:age %lu\\r\\n"", \n                                i, sizes[i], i, now - tails[i]->time);\n     }\n     strcpy(bufcurr, ""END"");\n@@ -237,7 +238,6 @@ char* item_stats_sizes(int *bytes) {\n         if (histogram) free(histogram);\n         if (buf) free(buf);\n         return 0;\n-        return;\n     }\n \n     /* build the histogram */\n']",,,"['+ #include <time.h>', '+         sprintf(temp, ""ITEM %s [%u b; %lu s]\\r\\n"", it->key, it->nbytes - 2, it->time);', '+             bufcurr += sprintf(bufcurr, ""STAT items:%u:number %u\\r\\nSTAT items:%u:age %lu\\r\\n"",', '-         sprintf(temp, ""ITEM %s [%u b; %u s]\\r\\n"", it->key, it->nbytes - 2, it->time);', '-             bufcurr += sprintf(bufcurr, ""STAT items:%u:number %u\\r\\nSTAT items:%u:age %u\\r\\n"",', '-         return;']","['+ #include <time.h>', '+         sprintf(temp, ""item %s [%u b; %lu s]\\r\\n"", it->key, it->nbytes - 2, it->time);', '+             bufcurr += sprintf(bufcurr, ""stat items:%u:number %u\\r\\nstat items:%u:age %lu\\r\\n"",', '-         sprintf(temp, ""item %s [%u b; %u s]\\r\\n"", it->key, it->nbytes - 2, it->time);', '-             bufcurr += sprintf(bufcurr, ""stat items:%u:number %u\\r\\nstat items:%u:age %u\\r\\n"",', '-         return;']","['+ #include <time.h>', '+         sprintf(temp, ""ITEM %s [%u b; %lu s]\\r\\n"", it->key, it->nbytes - 2, it->time);', '+             bufcurr += sprintf(bufcurr, ""STAT items:%u:number %u\\r\\nSTAT items:%u:age %lu\\r\\n"",']","['-         sprintf(temp, ""ITEM %s [%u b; %u s]\\r\\n"", it->key, it->nbytes - 2, it->time);', '-             bufcurr += sprintf(bufcurr, ""STAT items:%u:number %u\\r\\nSTAT items:%u:age %u\\r\\n"",', '-         return;']",3,3.0,6.0,1b533267341d3735a680ddc443f60bae0e6f4ee3memcached/memcached,[]
7c8bb5dfff48e47bd102d2b57b1e5eb1f332d903,curl/curl,progress.c,train,C,0,"['@@ -83,7 +83,8 @@ void ProgressInit(struct UrlData *data, int max)\n \n   if ( data->progressmode == CURL_PROGRESS_STATS )\n     fprintf(data->err,\n-            ""  %%   Received   Total  Speed   Time left  Total   Curr.Speed\\n"");\n+            ""  %%   Received    Total    Speed  Estimated   Time      Left   Curr.Speed\\n"");\n+\n }\n \n void time2str(char *r, int t)\n@@ -144,18 +145,21 @@ void ProgressShow(struct UrlData *data,\n         return;\n \n       if(-1 != progressmax) {\n-        char left[20],estim[20];\n+        char left[20];\n+        char estim[20];\n+        char timespent[20];\n         int estimate = progressmax/(int) speed;\n     \n         time2str(left,estimate-(int) spent); \n         time2str(estim,estimate);\n+        time2str(timespent,spent);\n \n         percen=(double)point/progressmax;\n         percen=percen*100;\n \n-        fprintf(data->err, ""\\r%3d %8d  %8d %6.0lf %s %s %6.0lf   "",\n+        fprintf(stderr, ""\\r%3d %10d %10d %6.0lf %s %s %s %6.0lf   "",\n                 (int)percen, point, progressmax,\n-                speed, left, estim, data->current_speed);\n+                speed, estim, timespent, left, data->current_speed);\n       }\n       else\n         fprintf(data->err,\n']",,,"['+             ""  %%   Received    Total    Speed  Estimated   Time      Left   Curr.Speed\\n"");', '+         char left[20];', '+         char estim[20];', '+         char timespent[20];', '+         time2str(timespent,spent);', '+         fprintf(stderr, ""\\r%3d %10d %10d %6.0lf %s %s %s %6.0lf   "",', '+                 speed, estim, timespent, left, data->current_speed);', '-             ""  %%   Received   Total  Speed   Time left  Total   Curr.Speed\\n"");', '-         char left[20],estim[20];', '-         fprintf(data->err, ""\\r%3d %8d  %8d %6.0lf %s %s %6.0lf   "",', '-                 speed, left, estim, data->current_speed);']","['+             ""  %%   received    total    speed  estimated   time      left   curr.speed\\n"");', '+         char left[20];', '+         char estim[20];', '+         char timespent[20];', '+         time2str(timespent,spent);', '+         fprintf(stderr, ""\\r%3d %10d %10d %6.0lf %s %s %s %6.0lf   "",', '+                 speed, estim, timespent, left, data->current_speed);', '-             ""  %%   received   total  speed   time left  total   curr.speed\\n"");', '-         char left[20],estim[20];', '-         fprintf(data->err, ""\\r%3d %8d  %8d %6.0lf %s %s %6.0lf   "",', '-                 speed, left, estim, data->current_speed);']","['+             ""  %%   Received    Total    Speed  Estimated   Time      Left   Curr.Speed\\n"");', '+         char left[20];', '+         char estim[20];', '+         char timespent[20];', '+         time2str(timespent,spent);', '+         fprintf(stderr, ""\\r%3d %10d %10d %6.0lf %s %s %s %6.0lf   "",', '+                 speed, estim, timespent, left, data->current_speed);']","['-             ""  %%   Received   Total  Speed   Time left  Total   Curr.Speed\\n"");', '-         char left[20],estim[20];', '-         fprintf(data->err, ""\\r%3d %8d  %8d %6.0lf %s %s %6.0lf   "",', '-                 speed, left, estim, data->current_speed);']",7,4.0,11.0,7c8bb5dfff48e47bd102d2b57b1e5eb1f332d903curl/curl,[]
5e9d6243184a5e2d20f4719966689dffa16dca9b,dajobe/raptor,raptor_rdfxml.c,val,C,0,"['@@ -182,6 +182,7 @@ typedef enum {\n   RAPIER_STATE_IN_RDF   = 6010,\n \n   /* No need for 6.2 - already chose 6.3, 6.25, 6.26 or 6.27 */\n+  RAPIER_STATE_NOT_USED_1   = 6020,\n \n   /* Met production 6.3 (description) <rdf:Description> element\n    * OR 6.13 (typedNode) [pretty much anything else]\n@@ -196,6 +197,8 @@ typedef enum {\n    */\n   RAPIER_STATE_IN_DESCRIPTION = 6031,\n \n+\n+\n   /* met production 6.12 (propertyElt)\n    */\n   RAPIER_STATE_PROPERTYELT = 6120,\n@@ -204,6 +207,8 @@ typedef enum {\n    */\n   RAPIER_STATE_TYPED_NODE = 6130,\n   \n+\n+\n   /* Met production 6.25 (sequence) <rdf:Seq> element seen. Goto 6.28  */\n   RAPIER_STATE_SEQ = 6250,\n \n@@ -228,6 +233,12 @@ typedef enum {\n    * Found a container item with content - <rdf:li> */\n   RAPIER_STATE_INLINEITEM = 6300,\n \n+  /* ******************************************************************* */\n+  /* Additional non-M&S states */\n+\n+  /* Another kind of container, not Seq, Bag or Alt */\n+  RAPIER_STATE_CONTAINER = 7000,\n+\n } rapier_state;\n \n \n@@ -238,10 +249,16 @@ typedef enum {\n  */\n struct rapier_ns_map_s {\n   struct rapier_ns_map_s* next; /* next down the stack, NULL at bottom */\n-  char *prefix;          /* NULL means is the default namespace */\n-  char *uri;\n+  const char *prefix;           /* NULL means is the default namespace */\n+  int prefix_length;            /* needed to safely compare prefixed-names */\n+#ifdef LIBRDF_INTERNAL\n+  librdf_uri *uri;\n+#else  \n+  const char *uri;\n   int uri_length;\n-  int depth;             /* parse depth that this was added, delete when parser leaves this */\n+#endif\n+  int depth;             /* parsing depth that this ns was added.  It will\n+                            be deleted when the parser leaves this depth */\n   int is_rdf_ms;         /* Non 0 if is RDF M&S Namespace */\n   int is_rdf_schema;     /* Non 0 if is RDF Schema Namespace */\n };\n@@ -259,7 +276,11 @@ struct rapier_ns_map_s {\n typedef struct {\n   const rapier_ns_map *namespace;\n   const char *qname;\n+#ifdef LIBRDF_INTERNAL\n+  librdf_uri *uri;\n+#else  \n   const char *uri;   /* URI of namespace+qname or NULL if not defined */\n+#endif\n   const char *value; /* optional value - used when name is an attribute */\n } rapier_ns_name;\n \n@@ -277,7 +298,7 @@ typedef enum {\n   RDF_ATTR_LAST            = RDF_ATTR_parseType\n } rdf_attr;\n \n-static const char *rdf_attr_names[]={\n+static const char * const rdf_attr_names[]={\n   ""about"",\n   ""aboutEach"",\n   ""aboutEachPrefix"",\n@@ -297,7 +318,8 @@ struct rapier_element_s {\n   rapier_ns_name *name;\n   rapier_ns_name **attributes;\n   int attribute_count;\n-  const char * rdf_attr[8];      /* attributes declared in M&S */\n+  const char * rdf_attr[RDF_ATTR_LAST+1];     /* attributes declared in M&S */\n+  int rdf_attr_count;                         /* how many of above seen */\n \n   rapier_state state; /* state that this production matches */\n \n@@ -349,7 +371,7 @@ struct rapier_parser_s {\n   /* non 0 to forbid non-namespaced resource, ID etc attributes\n    * on RDF namespaced-elements\n    */\n-  int forbid_rdf_non_ns_attributes;\n+  int forbid_rdf_non_ns_attributes; /* negative logic - FIXME */\n \n   /* stuff for our user */\n   void *user_data;\n@@ -357,43 +379,37 @@ struct rapier_parser_s {\n   void *fatal_error_user_data;\n   void *error_user_data;\n   void *warning_user_data;\n-  void (*fatal_error_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);\n-  void (*error_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);\n-  void (*warning_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);\n+\n+  rapier_message_handler fatal_error_handler;\n+  rapier_message_handler error_handler;\n+  rapier_message_handler warning_handler;\n+\n+  rapier_container_test_handler container_test_handler;\n \n   /* parser callbacks */\n-  void (*triple_handler)(void *userData, const char *subject, rapier_subject_type subject_type, const char *predicate, rapier_predicate_type predicate_type, const char *object, rapier_object_type object_type);\n+  rapier_triple_handler triple_handler;\n };\n \n \n \n \n /* static variables */\n-static const char *rapier_rdf_ms_uri=RAPIER_RDF_MS_URI;\n-static const char *rapier_rdf_schema_uri=RAPIER_RDF_SCHEMA_URI;\n \n+#ifndef LIBRDF_INTERNAL\n+static const char * const rapier_rdf_ms_uri=RAPIER_RDF_MS_URI;\n+static const char * const rapier_rdf_schema_uri=RAPIER_RDF_SCHEMA_URI;\n+#endif\n+static const char * const rapier_xml_uri=""http://www.w3.org/XML/1998/namespace"";\n \n \n /* Prototypes for common expat/libxml parsing event-handling functions */\n-static void rapier_xml_start_element_handler(void *userData,\n-                                         const XML_Char *name,\n-                                         const XML_Char **atts);\n-\n-static void rapier_xml_end_element_handler(void *userData,\n-                                       const XML_Char *name);\n-\n-\n+static void rapier_xml_start_element_handler(void *user_data, const XML_Char *name, const XML_Char **atts);\n+static void rapier_xml_end_element_handler(void *user_data, const XML_Char *name);\n /* s is not 0 terminated. */\n-static void rapier_xml_cdata_handler(void *userData,\n-                                 const XML_Char *s,\n-                                 int len);\n+static void rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len);\n #ifdef HAVE_XML_SetNamespaceDeclHandler\n-static void rapier_start_namespace_decl_handler(void *userData,\n-                                                const XML_Char *prefix,\n-                                                const XML_Char *uri);\n-\n-static void rapier_end_namespace_decl_handler(void *userData,\n-                                              const XML_Char *prefix);\n+static void rapier_start_namespace_decl_handler(void *user_data, const XML_Char *prefix, const XML_Char *uri);\n+static void rapier_end_namespace_decl_handler(void *user_data, const XML_Char *prefix);\n #endif\n \n /* libxml-only prototypes */\n@@ -433,6 +449,19 @@ static void rapier_print_element(rapier_element *element, FILE* stream);\n #endif\n \n \n+/* prototypes for grammar functions */\n+static void rapier_start_element_grammar(rapier_parser *parser, rapier_element *element);\n+static void rapier_end_element_grammar(rapier_parser *parser, rapier_element *element);\n+\n+\n+#ifdef LIBRDF_INTERNAL\n+#define IS_RDF_MS_CONCEPT(name, uri, qname) librdf_uri_equals(uri, librdf_concept_uris[LIBRDF_CONCEPT_MS_##qname])\n+#else\n+#define IS_RDF_MS_CONCEPT(name, uri, qname) !strcmp(name, #qname)\n+#endif\n+\n+\n+\n \n /*\n  * Namespaces in XML\n@@ -451,16 +480,19 @@ static void rapier_print_element(rapier_element *element, FILE* stream);\n  */\n static void\n rapier_init_namespaces(rapier_parser *rdf_parser) {\n-  rapier_start_namespace(rdf_parser, ""xml"", ""http://www.w3.org/XML/1998/namespace"", -1);\n+  /* defined at level -1 since always \'present\' when inside the XML world */\n+  rapier_start_namespace(rdf_parser, ""xml"", rapier_xml_uri, -1);\n }\n \n \n static void\n rapier_start_namespace(rapier_parser *rdf_parser, \n-                       const char *prefix, const char *namespace,\n-                       int depth)\n+                       const char *prefix, const char *namespace, int depth)\n {\n+  int prefix_length=0;\n+#ifndef LIBRDF_INTERNAL\n   int uri_length=0;\n+#endif\n   int len;\n   rapier_ns_map *map;\n   void *p;\n@@ -474,34 +506,58 @@ rapier_start_namespace(rapier_parser *rdf_parser,\n     namespace=NULL;\n   \n   len=sizeof(rapier_ns_map);\n+#ifndef LIBRDF_INTERNAL\n   if(namespace) {\n     uri_length=strlen(namespace);\n     len+=uri_length+1;\n   }\n-  if(prefix)\n-    len+=strlen(prefix)+1;\n+#endif\n+  if(prefix) {\n+    prefix_length=strlen(prefix);\n+    len+=prefix_length+1;\n+  }\n   \n   /* Just one malloc for map structure + namespace (maybe) + prefix (maybe)*/\n   map=(rapier_ns_map*)LIBRDF_CALLOC(rapier_ns_map, len, 1);\n-  if(!map)\n+  if(!map) {\n     rapier_parser_fatal_error(rdf_parser, ""Out of memory"");\n+    return;\n+  }\n   \n   p=(void*)map+sizeof(rapier_ns_map);\n+#ifndef LIBRDF_INTERNAL\n   if(namespace) {\n     map->uri=strcpy((char*)p, namespace);\n     map->uri_length=uri_length;\n     p+= uri_length+1;\n   }\n-  if(prefix)\n+#else\n+  map->uri=librdf_new_uri(namespace);\n+  if(!map->uri) {\n+    rapier_parser_fatal_error(rdf_parser, ""Out of memory"");\n+    LIBRDF_FREE(rapier_ns_map, map);\n+    return;\n+  }\n+#endif\n+  if(prefix) {\n     map->prefix=strcpy((char*)p, prefix);\n+    map->prefix_length=prefix_length;\n+  }\n   map->depth=depth;\n \n   /* set convienience flags when there is a defined namespace URI */\n   if(namespace) {\n-    if(!strncmp(namespace, rapier_rdf_ms_uri, uri_length))\n+#ifdef LIBRDF_INTERNAL\n+    if(librdf_uri_equals(map->uri, librdf_concept_ms_namespace_uri))\n+      map->is_rdf_ms=1;\n+    else if(librdf_uri_equals(map->uri, librdf_concept_schema_namespace_uri))\n+      map->is_rdf_schema=1;\n+#else\n+    if(!strcmp(namespace, rapier_rdf_ms_uri))\n       map->is_rdf_ms=1;\n-    else if(!strncmp(namespace, rapier_rdf_schema_uri, uri_length))\n+    else if(!strcmp(namespace, rapier_rdf_schema_uri))\n       map->is_rdf_schema=1;\n+#endif\n   }\n   \n   if(rdf_parser->namespaces)\n@@ -513,6 +569,10 @@ rapier_start_namespace(rapier_parser *rdf_parser,\n static void \n rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* namespace)\n {\n+#ifdef LIBRDF_INTERNAL\n+  if(namespace->uri)\n+    librdf_free_uri(namespace->uri);\n+#endif\n   LIBRDF_FREE(rapier_ns_map, namespace);\n }\n \n@@ -534,7 +594,12 @@ rapier_end_namespaces_for_depth(rapier_parser *rdf_parser)\n     rapier_ns_map* ns=rdf_parser->namespaces;\n     rapier_ns_map* next=ns->next;\n \n+#ifdef LIBRDF_INTERNAL\n+    rapier_end_namespace(rdf_parser, ns->prefix, \n+                         librdf_uri_as_string(ns->uri));\n+#else  \n     rapier_end_namespace(rdf_parser, ns->prefix, ns->uri);\n+#endif\n     rapier_free_namespace(rdf_parser, ns);\n \n     rdf_parser->namespaces=next;\n@@ -615,8 +680,8 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n   for(p=name; *p && *p != \':\'; p++)\n     ;\n \n-  /* No : - pick up default namespace, if there is one */\n   if(!*p) {\n+    /* No : - pick up default namespace, if there is one */\n     new_name=(char*)LIBRDF_MALLOC(cstring, strlen(name)+1);\n     if(!new_name) {\n       rapier_parser_fatal_error(rdf_parser, ""Out of memory"");\n@@ -646,6 +711,8 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n     }\n \n   } else {\n+    /* There is a namespace prefix */\n+\n     prefix_length=p-name;\n     p++; /* move to start of qname */\n     qname_length=strlen(p);\n@@ -660,7 +727,8 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n \n     /* Find the namespace */\n     for(ns=rdf_parser->namespaces; ns ; ns=ns->next)\n-      if(ns->prefix && !strncmp(name, ns->prefix, prefix_length))\n+      if(ns->prefix && prefix_length == ns->prefix_length && \n+         !strncmp(name, ns->prefix, prefix_length))\n         break;\n \n     if(!ns) {\n@@ -677,10 +745,21 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n     ns_name->namespace=ns;\n   }\n \n+\n+\n   /* If namespace has a URI and a qname is defined, create the URI\n    * for this element \n    */\n   if(ns_name->namespace && ns_name->namespace->uri && qname_length) {\n+#ifdef LIBRDF_INTERNAL\n+    librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->namespace->uri,\n+                                                  new_name);\n+    if(!uri) {\n+      rapier_free_ns_name(ns_name);\n+      return NULL;\n+    }\n+    ns_name->uri=uri;\n+#else\n     char *uri_string=(char*)LIBRDF_MALLOC(cstring, \n                                           ns_name->namespace->uri_length + \n                                           qname_length + 1);\n@@ -688,7 +767,10 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n       rapier_free_ns_name(ns_name);\n       return NULL;\n     }\n+    strcpy(uri_string, ns_name->namespace->uri);\n+    strncpy(uri_string+ns_name->namespace->uri_length, new_name, qname_length);\n     ns_name->uri=uri_string;\n+#endif\n   }\n \n   \n@@ -713,13 +795,18 @@ static void\n rapier_free_ns_name(rapier_ns_name* name) \n {\n   if(name->qname)\n-    LIBRDF_FREE(cstring, name->qname);\n+    LIBRDF_FREE(cstring, (void*)name->qname);\n \n+#ifdef LIBRDF_INTERNAL\n+  if(name->uri)\n+    librdf_free_uri(name->uri);\n+#else\n   if(name->uri)\n     LIBRDF_FREE(cstring, name->uri);\n+#endif\n   \n   if(name->value)\n-    LIBRDF_FREE(cstring, name->value);\n+    LIBRDF_FREE(cstring, (void*)name->value);\n   LIBRDF_FREE(rapier_ns_name, name);\n }\n \n@@ -727,10 +814,15 @@ rapier_free_ns_name(rapier_ns_name* name)\n static int\n rapier_ns_names_equal(rapier_ns_name *name1, rapier_ns_name *name2)\n {\n-  if(strcmp(name1->qname, name2->qname))\n-    return 0;\n+#ifdef LIBRDF_INTERNAL\n+  if(name1->uri && name2->uri)\n+    return librdf_uri_equals(name1->uri, name2->uri);\n+#else\n   if(name1->namespace != name2->namespace)\n     return 0;\n+#endif\n+  if(strcmp(name1->qname, name2->qname))\n+    return 0;\n   return 1;\n }\n \n@@ -776,7 +868,7 @@ rapier_free_element(rapier_element *element)\n   /* Free special RDF M&S attributes */\n   for(i=0; i<= RDF_ATTR_LAST; i++) \n     if(element->rdf_attr[i])\n-      LIBRDF_FREE(cstring, element->rdf_attr[i]);\n+      LIBRDF_FREE(cstring, (void*)element->rdf_attr[i]);\n   \n   if(element->content_cdata_length)\n     LIBRDF_FREE(rapier_ns_name_array, element->content_cdata);\n@@ -811,18 +903,16 @@ rapier_print_element(rapier_element *element, FILE* stream)\n  \n \n static void\n-rapier_xml_start_element_handler(void *userData,\n+rapier_xml_start_element_handler(void *user_data,\n                                  const XML_Char *name, const XML_Char **atts)\n {\n-  rapier_parser* rdf_parser=(rapier_parser*)userData;\n+  rapier_parser* rdf_parser=(rapier_parser*)user_data;\n   int all_atts_count=0;\n   int ns_attributes_count=0;\n   rapier_ns_name** named_attrs=NULL;\n   int i;\n   rapier_ns_name* element_name;\n   rapier_element* element=NULL;\n-  int finished;\n-  rapier_state state;\n #ifdef NEED_EXPAT\n   rapier_locator *locator=&rdf_parser->locator; /* for storing error info */\n #endif\n@@ -835,9 +925,9 @@ rapier_xml_start_element_handler(void *userData,\n \n   rdf_parser->depth++;\n \n-  if (atts != NULL) {\n+  if (atts) {\n     /* Round 1 - find special attributes, at present just namespaces */\n-    for (i = 0;(atts[i] != NULL);i+=2) {\n+    for (i = 0; atts[i]; i+=2) {\n       all_atts_count++;\n \n       /* synthesise the XML NS events */\n@@ -845,7 +935,8 @@ rapier_xml_start_element_handler(void *userData,\n         /* there is more i.e. xmlns:foo */\n         const char *prefix=atts[i][5] ? &atts[i][6] : NULL;\n \n-        rapier_start_namespace(userData, prefix, atts[i+1], rdf_parser->depth);\n+        rapier_start_namespace(user_data, prefix, atts[i+1],\n+                               rdf_parser->depth);\n         atts[i]=NULL; /* Is it allowed to zap XML parser array things? FIXME */\n         continue;\n       }\n@@ -929,6 +1020,7 @@ rapier_xml_start_element_handler(void *userData,\n         for(j=0; j<= RDF_ATTR_LAST; j++)\n           if(!strcmp(attr_name, rdf_attr_names[j])) {\n             element->rdf_attr[j]=attribute->value;\n+            element->rdf_attr_count++;            \n             /* Delete it if it was stored elsewhere */\n #if RAPIER_DEBUG\n             LIBRDF_DEBUG3(rapier_xml_start_element_handler,\n@@ -1008,186 +1100,18 @@ rapier_xml_start_element_handler(void *userData,\n \n \n   /* Right, now ready to enter the grammar */\n-\n-  finished= 0;\n-  if(element->parent)\n-    state=element->parent->state;\n-  else\n-    state=RAPIER_STATE_UNKNOWN;\n-\n-  while(!finished) {\n-    const char *el_name=element->name->qname;\n-    int element_in_rdf_ns=(element->name->namespace && \n-                           element->name->namespace->is_rdf_ms);\n-    \n-    switch(state) {\n-      case RAPIER_STATE_UNKNOWN:\n-        if(element_in_rdf_ns && !strcmp(el_name, ""RDF"")) {\n-          state=RAPIER_STATE_IN_RDF;\n-          /* need more content before can continue */\n-          finished=1;\n-          break;\n-        }\n-        /* If scanning for element, can continue */\n-        if(rdf_parser->scanning_for_rdf_RDF) {\n-          finished=1;\n-          break;\n-        }\n-        /* Otherwise choice of next state can be made from the current\n-         * element by IN_RDF state */\n-\n-        state=RAPIER_STATE_IN_RDF;\n-        break;\n-\n-      case RAPIER_STATE_IN_RDF:\n-        if(element_in_rdf_ns) {\n-          if(!strcmp(el_name, ""Description"")) {\n-            state=RAPIER_STATE_DESCRIPTION;\n-            break;\n-          } else if(!strcmp(el_name, ""Seq"")) {\n-            state=RAPIER_STATE_SEQ;\n-            break;\n-          } else if(!strcmp(el_name, ""Bag"")) {\n-            state=RAPIER_STATE_BAG;\n-            break;\n-          } else if(!strcmp(el_name, ""Alt"")) {\n-            state=RAPIER_STATE_ALT;\n-            break;\n-          }\n-\n-          /* Unexpected rdf: element at outer layer */\n-          rapier_parser_error(rdf_parser, ""Unexpected RDF M&S element %s in <rdf:RDF> - from productions 6.2, 6.3 and 6.4 expected rdf:Description, rdf:Seq, rdf:Bag or rdf:Alt only."", el_name);\n-          finished=1;\n-        }\n-        \n-        /* Hmm, must be a typedNode, handled by the description state \n-         * so that ID, BagID are handled in one place.\n-         */\n-        state=RAPIER_STATE_DESCRIPTION;          \n-        break;\n-\n-\n-      /* No need for 6.2 - already chose 6.3, 6.25, 6.26 or 6.27 */\n-\n-\n-      case RAPIER_STATE_DESCRIPTION:\n-        /* choices here from production 6.3 (description)\n-         * <rdf:Description idAboutAttr? bagIdAttr? propAttr* >\n-         *   Attributes: (ID|about|aboutEach|aboutEachPrefix)? bagID? propAttr*\n-         * <typeName idAboutAttr? bagIdAttr? propAttr*>\n-         *   Attributes: (ID|about|aboutEach|aboutEachPrefix)? bagID? propAttr*\n-         * (either may have no content, that is tested in the end element code)\n-         */\n-\n-        /* lets add booleans - isn\'t C wonderful! */\n-        if((element->rdf_attr[RDF_ATTR_ID] != NULL) +\n-           (element->rdf_attr[RDF_ATTR_about] != NULL) +\n-           (element->rdf_attr[RDF_ATTR_aboutEach] != NULL) +\n-           (element->rdf_attr[RDF_ATTR_aboutEachPrefix] != NULL) > 1) {\n-          rapier_parser_warning(rdf_parser, ""More than one of RDF ID, about, aboutEach or aboutEachPrefix attributes on element %s - from productions 6.5, 6.6, 6.7 and 6.8 expect at most one."", el_name);\n-        }\n-        \n-\n-        /* has to be rdf:Description OR typedNode - checked above */\n-        if(element_in_rdf_ns)\n-          state=RAPIER_STATE_IN_DESCRIPTION;\n-        else\n-          /* otherwise must match the typedNode production - checked below */\n-          state=RAPIER_STATE_TYPED_NODE;\n-\n-        finished=1;\n-        break;\n-\n-\n-      /* Inside a <rdf:Description> so expecting a list of\n-       * propertyElt elements\n-       */\n-      case RAPIER_STATE_IN_DESCRIPTION:\n-        state=RAPIER_STATE_PROPERTYELT;\n-        finished=1;\n-        break;\n-\n-\n-      /* Expect to meet the typedNode production having \n-       * fallen through and not met other productions -\n-       * 6.3, 6.25, 6.26, 6.27.  This is the last choice.\n-       *\n-       * choices here from production 6.13 (typedNode)\n-       * <typeName idAboutAttr? bagIdAttr? propAttr* />\n-       *   Attributes: (ID|about|aboutEach|aboutEachPrefix)? bagID?\n-       * <typeName idAboutAttr? bagIdAttr? propAttr* > propertyElt* </typeName>\n-       *   Attributes: (ID|about|aboutEach|aboutEachPrefix)? bagID? propAttr*\n-       */\n-      case RAPIER_STATE_TYPED_NODE:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_SEQ:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_BAG:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_ALT:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_MEMBER:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_REFERENCEDITEM:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_INLINEITEM:\n-        finished=1;\n-        break;\n-\n-        /* choices here from production 6.12 (propertyElt)\n-         *   <propName idAttr?> value </propName>\n-         *     Attributes: ID?\n-         *   <propName idAttr? parseLiteral> literal </propName>\n-         *     Attributes: ID? parseType=""literal""\n-         *   <propName idAttr? parseResource> propertyElt* </propName>\n-         *     Attributes: ID? parseType=""resource""\n-         *   <propName idRefAttr? bagIdAttr? propAttr* />\n-         *     Attributes: (ID|resource)? bagIdAttr? propAttr*\n-         */\n-      case RAPIER_STATE_PROPERTYELT:\n-        finished=1;\n-        break;\n-\n-      default:\n-        rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."", \n-                                  state);\n-        finished=1;\n-        \n-    } /* end switch */\n-\n-    if(state != element->state) {\n-      element->state=state;\n-      fprintf(stderr, ""rapier_xml_start_element_handler: moved to state %d\\n"", state);\n-    }\n+  rapier_start_element_grammar(rdf_parser, element);\n   \n-  } /* end while */\n-\n-  /* store final state that matched */\n-  element->state=state;\n }\n-  \n \n \n static void\n-rapier_xml_end_element_handler(void *userData, const XML_Char *name)\n+rapier_xml_end_element_handler(void *user_data, const XML_Char *name)\n {\n-  rapier_parser* rdf_parser=(rapier_parser*)userData;\n+  rapier_parser* rdf_parser=(rapier_parser*)user_data;\n   rapier_element* element;\n-  int finished;\n-  rapier_state state;\n   rapier_ns_name *element_name;\n+\n #ifdef NEED_EXPAT\n   rapier_locator *locator=&rdf_parser->locator; /* for storing error info */\n #endif\n@@ -1220,109 +1144,9 @@ rapier_xml_end_element_handler(void *userData, const XML_Char *name)\n     return;\n   }\n \n+  rapier_end_element_grammar(rdf_parser, element);\n \n-  state=element->state;\n-  finished= 0;\n-  while(!finished) {\n-    const char *el_name=element->name->qname;\n-    int element_in_rdf_ns=(element->name->namespace && \n-                           element->name->namespace->is_rdf_ms);\n-    \n-    switch(state) {\n-      case RAPIER_STATE_UNKNOWN:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_IN_RDF:\n-        if(element_in_rdf_ns && !strcmp(el_name, ""RDF"")) {\n-          /* end of RDF - boo hoo */\n-          state=RAPIER_STATE_UNKNOWN;\n-          finished=1;\n-          break;\n-        }\n-        /* When scanning, another element ending is outside the RDF\n-         * world so this can happen without further work\n-         */\n-        if(rdf_parser->scanning_for_rdf_RDF) {\n-          state=RAPIER_STATE_UNKNOWN;\n-          finished=1;\n-          break;\n-        }\n-        /* otherwise found some junk after RDF content in an RDF-only \n-         * document (probably never get here since this would be\n-         * a mismatched XML tag and cause an error earlier)\n-         */\n-        rapier_parser_warning(rdf_parser, ""Element %s ended, expected end of RDF element\\n"", el_name);\n-        state=RAPIER_STATE_UNKNOWN;\n-        finished=1;\n-        break;\n-\n-      /* No need for 6.2 - already chose 6.3, 6.25, 6.26 or 6.27 */\n-\n-      case RAPIER_STATE_DESCRIPTION:\n-        /* Never reached in any code outside start element \n-         * since immediately moves on to RAPIER_STATE_IN_DESCRIPTION\n-         * or RAPIER_STATE_TYPED_NODE\n-         */\n-        abort();\n-        break;\n-\n-      case RAPIER_STATE_IN_DESCRIPTION:\n-        /* Must be end of description production </rdf:Description> */\n-        state=RAPIER_STATE_IN_RDF;\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_TYPED_NODE:\n-        /* Must be end of typedNode production element <typeName> */\n-        state=RAPIER_STATE_IN_RDF;\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_SEQ:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_BAG:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_ALT:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_MEMBER:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_REFERENCEDITEM:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_INLINEITEM:\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_PROPERTYELT:\n-        finished=1;\n-        break;\n-\n-      default:\n-        rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."", \n-                                  state);\n-        finished=1;\n-        \n-    } /* end switch */\n-\n-    if(state != element->state) {\n-      element->state=state;\n-      fprintf(stderr, ""rapier_xml_end_element_handler: moved to state %d\\n"", state);\n-    }\n-  \n-  } /* end while */\n-\n-\n-  rapier_free_ns_name(element_name);\n+  rapier_free_ns_name(element_name);\n \n   rapier_end_namespaces_for_depth(rdf_parser);\n   rapier_free_element(element);\n@@ -1336,9 +1160,9 @@ rapier_xml_end_element_handler(void *userData, const XML_Char *name)\n  * s is not 0 terminated for expat, is for libxml - grrrr.\n  */\n static void\n-rapier_xml_cdata_handler(void *userData, const XML_Char *s, int len)\n+rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len)\n {\n-  rapier_parser* rdf_parser=(rapier_parser*)userData;\n+  rapier_parser* rdf_parser=(rapier_parser*)user_data;\n   rapier_element* element;\n   rapier_state state;\n   char *buffer;\n@@ -1354,6 +1178,8 @@ rapier_xml_cdata_handler(void *userData, const XML_Char *s, int len)\n     }\n   \n   element=rdf_parser->current_element;\n+\n+  /* cdata never changes the parser state */\n   \n   state=element->state;\n   switch(state) {\n@@ -1401,6 +1227,7 @@ rapier_xml_cdata_handler(void *userData, const XML_Char *s, int len)\n     default:\n       rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."", \n                                 state);\n+      return;\n     } /* end switch */\n \n \n@@ -1417,11 +1244,11 @@ rapier_xml_cdata_handler(void *userData, const XML_Char *s, int len)\n     return;\n   }\n   \n-  /* +1 here is for \\0 at end */\n   buffer=(char*)LIBRDF_MALLOC(cstring, element->content_cdata_length + len + 1);\n-  /* FIXME - no error return possible */\n-  if(!buffer)\n+  if(!buffer) {\n+    rapier_parser_fatal_error(rdf_parser, ""Out of memory"");\n     return;\n+  }\n \n   if(element->content_cdata_length) {\n     strncpy(buffer, element->content_cdata, element->content_cdata_length);\n@@ -1447,10 +1274,10 @@ rapier_xml_cdata_handler(void *userData, const XML_Char *s, int len)\n \n #ifdef HAVE_XML_SetNamespaceDeclHandler\n static void\n-rapier_start_namespace_decl_handler(void *userData,\n+rapier_start_namespace_decl_handler(void *user_data,\n                                     const XML_Char *prefix, const XML_Char *uri)\n {\n-  rapier_parser* rdf_parser=(rapier_parser*)userData;\n+  rapier_parser* rdf_parser=(rapier_parser*)user_data;\n \n #ifdef RAPIER_DEBUG\n   fprintf(stderr_parser->locator, ""saw namespace %s URI %s\\n"", prefix, uri);\n@@ -1459,9 +1286,9 @@ rapier_start_namespace_decl_handler(void *userData,\n \n \n static void\n-rapier_end_namespace_decl_handler(void *userData, const XML_Char *prefix)\n+rapier_end_namespace_decl_handler(void *user_data, const XML_Char *prefix)\n {\n-  rapier_parser* rdf_parser=(rapier_parser*)userData;\n+  rapier_parser* rdf_parser=(rapier_parser*)user_data;\n \n #ifdef RAPIER_DEBUG\n   fprintf(stderr_parser->locator, ""saw end namespace prefix %s\\n"", prefix);\n@@ -1470,6 +1297,45 @@ rapier_end_namespace_decl_handler(void *userData, const XML_Char *prefix)\n #endif\n \n \n+/* This is called for a declaration of an unparsed (NDATA) entity */\n+static void\n+rapier_xml_unparsed_entity_decl_handler(void *user_data,\n+                                        const XML_Char *entityName,\n+                                        const XML_Char *base,\n+                                        const XML_Char *systemId,\n+                                        const XML_Char *publicId,\n+                                        const XML_Char *notationName) \n+{\n+/*  rapier_parser* rdf_parser=(rapier_parser*)user_data; */\n+  fprintf(stderr,\n+          ""rapier_xml_unparsed_entity_decl_handler: entityName %s base %s systemId %s publicId %s notationName %s\\n"",\n+          entityName, (base ? base : ""(None)""), \n+          systemId, (publicId ? publicId: ""(None)""),\n+          notationName);\n+}\n+  \n+\n+static int \n+rapier_xml_external_entity_ref_handler(XML_Parser parser,\n+                                       const XML_Char *context,\n+                                       const XML_Char *base,\n+                                       const XML_Char *systemId,\n+                                       const XML_Char *publicId)\n+{\n+/*  rapier_parser* rdf_parser=(rapier_parser*)user_data; */\n+  fprintf(stderr,\n+          ""rapier_xml_external_entity_ref_handler: context %s base %s systemId %s publicId %s\\n"",\n+          context, (base ? base : ""(None)""), \n+          systemId, (publicId ? publicId: ""(None)""));\n+\n+  /* ""The handler should return 0 if processing should not continue\n+   * because of a fatal error in the handling of the external entity.""\n+   */\n+  return 1;\n+}\n+\n+\n+\n #ifdef NEED_LIBXML\n #include <stdarg.h>\n \n@@ -1585,9 +1451,9 @@ rapier_parser_fatal_error(rapier_parser* parser, const char *message, ...)\n \n   parser->failed=1;\n   \n-  if(parser->fatal_error_fn) {\n-    parser->fatal_error_fn(parser->fatal_error_user_data, \n-                           &parser->locator, message);\n+  if(parser->fatal_error_handler) {\n+    parser->fatal_error_handler(parser->fatal_error_user_data, \n+                                &parser->locator, message);\n     abort();\n   }\n \n@@ -1612,8 +1478,9 @@ rapier_parser_error(rapier_parser* parser, const char *message, ...)\n {\n   va_list arguments;\n \n-  if(parser->error_fn) {\n-    parser->error_fn(parser->error_user_data, &parser->locator, message);\n+  if(parser->error_handler) {\n+    parser->error_handler(parser->error_user_data, \n+                          &parser->locator, message);\n     return;\n   }\n   \n@@ -1636,8 +1503,9 @@ rapier_parser_warning(rapier_parser* parser, const char *message, ...)\n {\n   va_list arguments;\n \n-  if(parser->warning_fn) {\n-    parser->warning_fn(parser->warning_user_data, &parser->locator, message);\n+  if(parser->warning_handler) {\n+    parser->warning_handler(parser->warning_user_data,\n+                            &parser->locator, message);\n     return;\n   }\n   \n@@ -1675,7 +1543,7 @@ myXmlSAXParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename)\n     ret = 0;\n   else\n     ret = -1;\n-  if (sax != NULL)\n+  if (sax)\n     ctxt->sax = NULL;\n   xmlFreeParserCtxt(ctxt);\n   \n@@ -1717,6 +1585,14 @@ rapier_new(void)\n   XML_SetElementHandler(xp, rapier_xml_start_element_handler,\n                         rapier_xml_end_element_handler);\n   XML_SetCharacterDataHandler(xp, rapier_xml_cdata_handler);\n+\n+  XML_SetUnparsedEntityDeclHandler(xp,\n+                                   rapier_xml_unparsed_entity_decl_handler);\n+\n+  XML_SetExternalEntityRefHandler(xp,\n+                                  rapier_xml_external_entity_ref_handler);\n+\n+\n #ifdef HAVE_XML_SetNamespaceDeclHandler\n   XML_SetNamespaceDeclHandler(xp,\n                               rapier_start_namespace_decl_handler,\n@@ -1776,68 +1652,66 @@ rapier_free(rapier_parser *rdf_parser)\n \n \n /**\n- * rapier_parser_set_fatal_error - Set the parser error handling function\n+ * rapier_set_fatal_error_handler - Set the parser error handling function\n  * @parser: the parser\n  * @user_data: user data to pass to function\n- * @fatal_error_fn: pointer to the function\n+ * @handler: pointer to the function\n  * \n  * The function will receive callbacks when the parser fails.\n  * \n  **/\n void\n-rapier_parser_set_fatal_error(rapier_parser* parser, void *user_data,\n-                        void (*fatal_error_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))\n+rapier_set_fatal_error_handler(rapier_parser* parser, void *user_data,\n+                               rapier_message_handler handler)\n {\n   parser->fatal_error_user_data=user_data;\n-  parser->fatal_error_fn=fatal_error_fn;\n+  parser->fatal_error_handler=handler;\n }\n \n \n /**\n- * rapier_parser_set_error - Set the parser error handling function\n+ * rapier_set_error_handler - Set the parser error handling function\n  * @parser: the parser\n  * @user_data: user data to pass to function\n- * @error_fn: pointer to the function\n+ * @handler: pointer to the function\n  * \n  * The function will receive callbacks when the parser fails.\n  * \n  **/\n void\n-rapier_parser_set_error(rapier_parser* parser, void *user_data,\n-                        void (*error_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))\n+rapier_set_error_handler(rapier_parser* parser, void *user_data,\n+                         rapier_message_handler handler)\n {\n   parser->error_user_data=user_data;\n-  parser->error_fn=error_fn;\n+  parser->error_handler=handler;\n }\n \n \n /**\n- * rapier_parser_set_warning - Set the parser warning handling function\n+ * rapier_set_warning_handler - Set the parser warning handling function\n  * @parser: the parser\n  * @user_data: user data to pass to function\n- * @warning_fn: pointer to the function\n+ * @handler: pointer to the function\n  * \n  * The function will receive callbacks when the parser gives a warning.\n  * \n  **/\n void\n-rapier_parser_set_warning(rapier_parser* parser, void *user_data,\n-                          void (*warning_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))\n+rapier_set_warning_handler(rapier_parser* parser, void *user_data,\n+                           rapier_message_handler handler)\n {\n   parser->warning_user_data=user_data;\n-  parser->warning_fn=warning_fn;\n+  parser->warning_handler=handler;\n }\n \n \n void\n rapier_set_triple_handler(rapier_parser* parser,\n-                          void *userData, \n-                          void (*triple_handler)(void *userData, \n-                                                const char *subject, rapier_subject_type subject_type,\n-                                                const char *predicate, rapier_predicate_type predicate_type,\n-                                                const char *object, rapier_object_type object_type)) \n+                          void *user_data, \n+                          rapier_triple_handler handler)\n {\n-  parser->triple_handler=triple_handler;\n+  parser->user_data=user_data;\n+  parser->triple_handler=handler;\n }\n \n \n@@ -1898,7 +1772,7 @@ rapier_parse_file(rapier_parser* rdf_parser,  const char *uri,\n #ifdef NEED_EXPAT\n     XML_ParserFree(xp);\n #endif /* EXPAT */\n-    LIBRDF_FREE(cstring, filename);\n+    LIBRDF_FREE(cstring, (void*)filename);\n     return 1;\n   }\n   \n@@ -1965,7 +1839,7 @@ rapier_parse_file(rapier_parser* rdf_parser,  const char *uri,\n     rapier_parser_error(parser, ""XML Parsing failed"");\n #endif\n \n-  LIBRDF_FREE(cstring, filename);\n+  LIBRDF_FREE(cstring, (void*)filename);\n \n   return (rc != 0);\n }\n@@ -2007,3 +1881,302 @@ rapier_set_feature(rapier_parser *parser, rapier_feature feature, int value) {\n       break;\n   }\n }\n+\n+\n+\n+static void\n+rapier_start_element_grammar(rapier_parser *rdf_parser,\n+                             rapier_element *element) \n+{\n+  int finished;\n+  rapier_state state;\n+  \n+  finished= 0;\n+  if(element->parent)\n+    state=element->parent->state;\n+  else\n+    state=RAPIER_STATE_UNKNOWN;\n+\n+  while(!finished) {\n+    const char *el_name=element->name->qname;\n+    int element_in_rdf_ns=(element->name->namespace && \n+                           element->name->namespace->is_rdf_ms);\n+    \n+    switch(state) {\n+      case RAPIER_STATE_UNKNOWN:\n+        if(element_in_rdf_ns && \n+          IS_RDF_MS_CONCEPT(el_name, element->name->uri,RDF)) {\n+          state=RAPIER_STATE_IN_RDF;\n+          /* need more content before can continue */\n+          finished=1;\n+          break;\n+        }\n+        /* If scanning for element, can continue */\n+        if(rdf_parser->scanning_for_rdf_RDF) {\n+          finished=1;\n+          break;\n+        }\n+        /* Otherwise choice of next state can be made from the current\n+         * element by IN_RDF state */\n+\n+        state=RAPIER_STATE_IN_RDF;\n+        break;\n+\n+      case RAPIER_STATE_IN_RDF:\n+        if(element_in_rdf_ns) {\n+          if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Description)) {\n+            state=RAPIER_STATE_DESCRIPTION;\n+            break;\n+          } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Seq)) {\n+            state=RAPIER_STATE_SEQ;\n+            break;\n+          } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Bag)) {\n+            state=RAPIER_STATE_BAG;\n+            break;\n+          } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Alt)) {\n+            state=RAPIER_STATE_ALT;\n+            break;\n+          } else if(rdf_parser->container_test_handler) {\n+            if(rdf_parser->container_test_handler(element->name->uri)) {\n+              state=RAPIER_STATE_CONTAINER;\n+              break;\n+            }\n+          }\n+\n+\n+          /* Unexpected rdf: element at outer layer */\n+          rapier_parser_error(rdf_parser, ""Unexpected RDF M&S element %s in <rdf:RDF> - from productions 6.2, 6.3 and 6.4 expected rdf:Description, rdf:Seq, rdf:Bag or rdf:Alt only."", el_name);\n+          finished=1;\n+        }\n+        \n+        /* Hmm, must be a typedNode, handled by the description state \n+         * so that ID, BagID are handled in one place.\n+         */\n+        state=RAPIER_STATE_DESCRIPTION;          \n+        break;\n+\n+\n+      /* No need for 6.2 - already chose 6.3, 6.25, 6.26 or 6.27 */\n+\n+\n+      case RAPIER_STATE_DESCRIPTION:\n+        /* choices here from production 6.3 (description)\n+         * <rdf:Description idAboutAttr? bagIdAttr? propAttr* >\n+         *   Attributes: (ID|about|aboutEach|aboutEachPrefix)? bagID? propAttr*\n+         * <typeName idAboutAttr? bagIdAttr? propAttr*>\n+         *   Attributes: (ID|about|aboutEach|aboutEachPrefix)? bagID? propAttr*\n+         * (either may have no content, that is tested in the end element code)\n+         */\n+\n+        /* lets add booleans - isn\'t C wonderful! */\n+        if((element->rdf_attr[RDF_ATTR_ID] != NULL) +\n+           (element->rdf_attr[RDF_ATTR_about] != NULL) +\n+           (element->rdf_attr[RDF_ATTR_aboutEach] != NULL) +\n+           (element->rdf_attr[RDF_ATTR_aboutEachPrefix] != NULL) > 1) {\n+          rapier_parser_warning(rdf_parser, ""More than one of RDF ID, about, aboutEach or aboutEachPrefix attributes on element %s - from productions 6.5, 6.6, 6.7 and 6.8 expect at most one."", el_name);\n+        }\n+        \n+\n+        /* has to be rdf:Description OR typedNode - checked above */\n+        if(element_in_rdf_ns)\n+          state=RAPIER_STATE_IN_DESCRIPTION;\n+        else\n+          /* otherwise must match the typedNode production - checked below */\n+          state=RAPIER_STATE_TYPED_NODE;\n+\n+        finished=1;\n+        break;\n+\n+\n+      /* Inside a <rdf:Description> so expecting a list of\n+       * propertyElt elements\n+       */\n+      case RAPIER_STATE_IN_DESCRIPTION:\n+        state=RAPIER_STATE_PROPERTYELT;\n+        finished=1;\n+        break;\n+\n+\n+      /* Expect to meet the typedNode production having \n+       * fallen through and not met other productions -\n+       * 6.3, 6.25, 6.26, 6.27.  This is the last choice.\n+       *\n+       * choices here from production 6.13 (typedNode)\n+       * <typeName idAboutAttr? bagIdAttr? propAttr* />\n+       *   Attributes: (ID|about|aboutEach|aboutEachPrefix)? bagID?\n+       * <typeName idAboutAttr? bagIdAttr? propAttr* > propertyElt* </typeName>\n+       *   Attributes: (ID|about|aboutEach|aboutEachPrefix)? bagID? propAttr*\n+       */\n+      case RAPIER_STATE_TYPED_NODE:\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_SEQ:\n+      case RAPIER_STATE_BAG:\n+      case RAPIER_STATE_ALT:\n+      case RAPIER_STATE_CONTAINER:\n+        /* choices here from production 6.25 (sequence), 6.26 (bag)\n+         * and 6.27 (alternative)\n+         * <rdf:Seq idAttr?>...</rdf:Seq> (attribute productions: 6.6)\n+         *   Attributes: ID?\n+         * <rdf:Seq idAttr? memberAttr* /> (attribute productions: 6.6, 6.31)\n+         *   Attributes: ID? rdf:_<n> (where n is an integer)\n+         *\n+         * Note: The second case implies the element must have no content.\n+         */\n+\n+        /* Enforce allowed rdf: attributes - i.e. ID only (optional) */\n+        if ((element->rdf_attr - (element->rdf_attr[RDF_ATTR_ID] != NULL))) {\n+          rapier_parser_warning(rdf_parser, ""Illegal rdf: attribute(s) seen on container element %s - from production 6.25, 6.26 and 6.27 expected rdf:ID only."", el_name);\n+        }\n+\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_MEMBER:\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_REFERENCEDITEM:\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_INLINEITEM:\n+        finished=1;\n+        break;\n+\n+        /* choices here from production 6.12 (propertyElt)\n+         *   <propName idAttr?> value </propName>\n+         *     Attributes: ID?\n+         *   <propName idAttr? parseLiteral> literal </propName>\n+         *     Attributes: ID? parseType=""literal""\n+         *   <propName idAttr? parseResource> propertyElt* </propName>\n+         *     Attributes: ID? parseType=""resource""\n+         *   <propName idRefAttr? bagIdAttr? propAttr* />\n+         *     Attributes: (ID|resource)? bagIdAttr? propAttr*\n+         */\n+      case RAPIER_STATE_PROPERTYELT:\n+        finished=1;\n+        break;\n+\n+      default:\n+        rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."", \n+                                  state);\n+        finished=1;\n+        \n+    } /* end switch */\n+\n+    if(state != element->state) {\n+      element->state=state;\n+      fprintf(stderr, ""rapier_start_element_grammar: moved to state %d\\n"", state);\n+    }\n+  \n+  } /* end while */\n+}\n+\n+\n+static void\n+rapier_end_element_grammar(rapier_parser *rdf_parser,\n+                           rapier_element *element) \n+{\n+  rapier_state state;\n+  int finished;\n+\n+  state=element->state;\n+  finished= 0;\n+  while(!finished) {\n+    const char *el_name=element->name->qname;\n+    int element_in_rdf_ns=(element->name->namespace && \n+                           element->name->namespace->is_rdf_ms);\n+    \n+    switch(state) {\n+      case RAPIER_STATE_UNKNOWN:\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_IN_RDF:\n+        if(element_in_rdf_ns && \n+          IS_RDF_MS_CONCEPT(el_name, element->name->uri,RDF)) {\n+          /* end of RDF - boo hoo */\n+          state=RAPIER_STATE_UNKNOWN;\n+          finished=1;\n+          break;\n+        }\n+        /* When scanning, another element ending is outside the RDF\n+         * world so this can happen without further work\n+         */\n+        if(rdf_parser->scanning_for_rdf_RDF) {\n+          state=RAPIER_STATE_UNKNOWN;\n+          finished=1;\n+          break;\n+        }\n+        /* otherwise found some junk after RDF content in an RDF-only \n+         * document (probably never get here since this would be\n+         * a mismatched XML tag and cause an error earlier)\n+         */\n+        rapier_parser_warning(rdf_parser, ""Element %s ended, expected end of RDF element\\n"", el_name);\n+        state=RAPIER_STATE_UNKNOWN;\n+        finished=1;\n+        break;\n+\n+      /* No need for 6.2 - already chose 6.3, 6.25, 6.26 or 6.27 */\n+\n+      case RAPIER_STATE_DESCRIPTION:\n+        /* Never reached in any code outside start element \n+         * since immediately moves on to RAPIER_STATE_IN_DESCRIPTION\n+         * or RAPIER_STATE_TYPED_NODE\n+         */\n+        abort();\n+        break;\n+\n+      case RAPIER_STATE_IN_DESCRIPTION:\n+        /* Must be end of description production </rdf:Description> */\n+        state=RAPIER_STATE_IN_RDF;\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_TYPED_NODE:\n+        /* Must be end of typedNode production element <typeName> */\n+        state=RAPIER_STATE_IN_RDF;\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_SEQ:\n+      case RAPIER_STATE_BAG:\n+      case RAPIER_STATE_ALT:\n+      case RAPIER_STATE_CONTAINER:\n+\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_MEMBER:\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_REFERENCEDITEM:\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_INLINEITEM:\n+        finished=1;\n+        break;\n+\n+      case RAPIER_STATE_PROPERTYELT:\n+        finished=1;\n+        break;\n+\n+      default:\n+        rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."", \n+                                  state);\n+        finished=1;\n+        \n+    } /* end switch */\n+\n+    if(state != element->state) {\n+      element->state=state;\n+      fprintf(stderr, ""rapier_end_element_grammar: moved to state %d\\n"", state);\n+    }\n+  \n+  } /* end while */\n+\n+}\n']",,,"['+   RAPIER_STATE_NOT_USED_1   = 6020,', '+   RAPIER_STATE_CONTAINER = 7000,', '+ #else', '+   const char *uri;', '+ #endif', '+                             be deleted when the parser leaves this depth */', '+ #ifdef LIBRDF_INTERNAL', '+   librdf_uri *uri;', '+ #else', '+ static const char * const rdf_attr_names[]={', '+   rapier_message_handler fatal_error_handler;', '+   rapier_message_handler error_handler;', '+   rapier_message_handler warning_handler;', '+   rapier_container_test_handler container_test_handler;', '+   rapier_triple_handler triple_handler;', '+ #ifndef LIBRDF_INTERNAL', '+ static const char * const rapier_rdf_ms_uri=RAPIER_RDF_MS_URI;', '+ static const char * const rapier_rdf_schema_uri=RAPIER_RDF_SCHEMA_URI;', '+ #endif', '+ static const char * const rapier_xml_uri=""http://www.w3.org/XML/1998/namespace"";', '+ static void rapier_xml_start_element_handler(void *user_data, const XML_Char *name, const XML_Char **atts);', '+ static void rapier_xml_end_element_handler(void *user_data, const XML_Char *name);', '+ static void rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len);', '+ static void rapier_start_namespace_decl_handler(void *user_data, const XML_Char *prefix, const XML_Char *uri);', '+ static void rapier_end_namespace_decl_handler(void *user_data, const XML_Char *prefix);', '+ static void rapier_start_element_grammar(rapier_parser *parser, rapier_element *element);', '+ static void rapier_end_element_grammar(rapier_parser *parser, rapier_element *element);', '+ #ifdef LIBRDF_INTERNAL', '+ #define IS_RDF_MS_CONCEPT(name, uri, qname) librdf_uri_equals(uri, librdf_concept_uris[LIBRDF_CONCEPT_MS_##qname])', '+ #else', '+ #define IS_RDF_MS_CONCEPT(name, uri, qname) !strcmp(name, #qname)', '+ #endif', '+   rapier_start_namespace(rdf_parser, ""xml"", rapier_xml_uri, -1);', '+                        const char *prefix, const char *namespace, int depth)', '+   int prefix_length=0;', '+ #ifndef LIBRDF_INTERNAL', '+ #endif', '+ #ifndef LIBRDF_INTERNAL', '+ #endif', '+   if(prefix) {', '+     prefix_length=strlen(prefix);', '+     len+=prefix_length+1;', '+   }', '+   if(!map) {', '+     return;', '+   }', '+ #ifndef LIBRDF_INTERNAL', '+ #else', '+   map->uri=librdf_new_uri(namespace);', '+   if(!map->uri) {', '+     rapier_parser_fatal_error(rdf_parser, ""Out of memory"");', '+     LIBRDF_FREE(rapier_ns_map, map);', '+     return;', '+   }', '+ #endif', '+   if(prefix) {', '+     map->prefix_length=prefix_length;', '+   }', '+ #ifdef LIBRDF_INTERNAL', '+     if(librdf_uri_equals(map->uri, librdf_concept_ms_namespace_uri))', '+       map->is_rdf_ms=1;', '+     else if(librdf_uri_equals(map->uri, librdf_concept_schema_namespace_uri))', '+       map->is_rdf_schema=1;', '+ #else', '+     if(!strcmp(namespace, rapier_rdf_ms_uri))', '+     else if(!strcmp(namespace, rapier_rdf_schema_uri))', '+ #endif', '+ #ifdef LIBRDF_INTERNAL', '+   if(namespace->uri)', '+     librdf_free_uri(namespace->uri);', '+ #endif', '+ #ifdef LIBRDF_INTERNAL', '+     rapier_end_namespace(rdf_parser, ns->prefix,', '+                          librdf_uri_as_string(ns->uri));', '+ #else', '+ #endif', '+       if(ns->prefix && prefix_length == ns->prefix_length &&', '+          !strncmp(name, ns->prefix, prefix_length))', '+ #ifdef LIBRDF_INTERNAL', '+     librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->namespace->uri,', '+                                                   new_name);', '+     if(!uri) {', '+       rapier_free_ns_name(ns_name);', '+       return NULL;', '+     }', '+     ns_name->uri=uri;', '+ #else', '+     strcpy(uri_string, ns_name->namespace->uri);', '+     strncpy(uri_string+ns_name->namespace->uri_length, new_name, qname_length);', '+ #endif', '+     LIBRDF_FREE(cstring, (void*)name->qname);', '+ #ifdef LIBRDF_INTERNAL', '+   if(name->uri)', '+     librdf_free_uri(name->uri);', '+ #else', '+ #endif', '+     LIBRDF_FREE(cstring, (void*)name->value);', '+ #ifdef LIBRDF_INTERNAL', '+   if(name1->uri && name2->uri)', '+     return librdf_uri_equals(name1->uri, name2->uri);', '+ #else', '+ #endif', '+   if(strcmp(name1->qname, name2->qname))', '+     return 0;', '+       LIBRDF_FREE(cstring, (void*)element->rdf_attr[i]);', '+ rapier_xml_start_element_handler(void *user_data,', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+   if (atts) {', '+     for (i = 0; atts[i]; i+=2) {', '+         rapier_start_namespace(user_data, prefix, atts[i+1],', '+                                rdf_parser->depth);', '+             element->rdf_attr_count++;', '+   rapier_start_element_grammar(rdf_parser, element);', '+ rapier_xml_end_element_handler(void *user_data, const XML_Char *name)', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+   rapier_end_element_grammar(rdf_parser, element);', '+   rapier_free_ns_name(element_name);', '+ rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len)', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+       return;', '+   if(!buffer) {', '+     rapier_parser_fatal_error(rdf_parser, ""Out of memory"");', '+   }', '+ rapier_start_namespace_decl_handler(void *user_data,', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+ rapier_end_namespace_decl_handler(void *user_data, const XML_Char *prefix)', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+ static void', '+ rapier_xml_unparsed_entity_decl_handler(void *user_data,', '+                                         const XML_Char *entityName,', '+                                         const XML_Char *base,', '+                                         const XML_Char *systemId,', '+                                         const XML_Char *publicId,', '+                                         const XML_Char *notationName)', '+ {', '+   fprintf(stderr,', '+           ""rapier_xml_unparsed_entity_decl_handler: entityName %s base %s systemId %s publicId %s notationName %s\\n"",', '+           entityName, (base ? base : ""(None)""),', '+           systemId, (publicId ? publicId: ""(None)""),', '+           notationName);', '+ }', '+ static int', '+ rapier_xml_external_entity_ref_handler(XML_Parser parser,', '+                                        const XML_Char *context,', '+                                        const XML_Char *base,', '+                                        const XML_Char *systemId,', '+                                        const XML_Char *publicId)', '+ {', '+   fprintf(stderr,', '+           ""rapier_xml_external_entity_ref_handler: context %s base %s systemId %s publicId %s\\n"",', '+           context, (base ? base : ""(None)""),', '+           systemId, (publicId ? publicId: ""(None)""));', '+   return 1;', '+ }', '+   if(parser->fatal_error_handler) {', '+     parser->fatal_error_handler(parser->fatal_error_user_data,', '+                                 &parser->locator, message);', '+   if(parser->error_handler) {', '+     parser->error_handler(parser->error_user_data,', '+                           &parser->locator, message);', '+   if(parser->warning_handler) {', '+     parser->warning_handler(parser->warning_user_data,', '+                             &parser->locator, message);', '+   if (sax)', '+   XML_SetUnparsedEntityDeclHandler(xp,', '+                                    rapier_xml_unparsed_entity_decl_handler);', '+   XML_SetExternalEntityRefHandler(xp,', '+                                   rapier_xml_external_entity_ref_handler);', '+ rapier_set_fatal_error_handler(rapier_parser* parser, void *user_data,', '+                                rapier_message_handler handler)', '+   parser->fatal_error_handler=handler;', '+ rapier_set_error_handler(rapier_parser* parser, void *user_data,', '+                          rapier_message_handler handler)', '+   parser->error_handler=handler;', '+ rapier_set_warning_handler(rapier_parser* parser, void *user_data,', '+                            rapier_message_handler handler)', '+   parser->warning_handler=handler;', '+                           void *user_data,', '+                           rapier_triple_handler handler)', '+   parser->user_data=user_data;', '+   parser->triple_handler=handler;', '+     LIBRDF_FREE(cstring, (void*)filename);', '+   LIBRDF_FREE(cstring, (void*)filename);', '+ static void', '+ rapier_start_element_grammar(rapier_parser *rdf_parser,', '+                              rapier_element *element)', '+ {', '+   int finished;', '+   rapier_state state;', '+   finished= 0;', '+   if(element->parent)', '+     state=element->parent->state;', '+   else', '+     state=RAPIER_STATE_UNKNOWN;', '+   while(!finished) {', '+     const char *el_name=element->name->qname;', '+     int element_in_rdf_ns=(element->name->namespace &&', '+                            element->name->namespace->is_rdf_ms);', '+     switch(state) {', '+       case RAPIER_STATE_UNKNOWN:', '+         if(element_in_rdf_ns &&', '+           IS_RDF_MS_CONCEPT(el_name, element->name->uri,RDF)) {', '+           state=RAPIER_STATE_IN_RDF;', '+           finished=1;', '+           break;', '+         }', '+         if(rdf_parser->scanning_for_rdf_RDF) {', '+           finished=1;', '+           break;', '+         }', '+         state=RAPIER_STATE_IN_RDF;', '+         break;', '+       case RAPIER_STATE_IN_RDF:', '+         if(element_in_rdf_ns) {', '+           if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Description)) {', '+             state=RAPIER_STATE_DESCRIPTION;', '+             break;', '+           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Seq)) {', '+             state=RAPIER_STATE_SEQ;', '+             break;', '+           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Bag)) {', '+             state=RAPIER_STATE_BAG;', '+             break;', '+           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Alt)) {', '+             state=RAPIER_STATE_ALT;', '+             break;', '+           } else if(rdf_parser->container_test_handler) {', '+             if(rdf_parser->container_test_handler(element->name->uri)) {', '+               state=RAPIER_STATE_CONTAINER;', '+               break;', '+             }', '+           }', '+           rapier_parser_error(rdf_parser, ""Unexpected RDF M&S element %s in <rdf:RDF> - from productions 6.2, 6.3 and 6.4 expected rdf:Description, rdf:Seq, rdf:Bag or rdf:Alt only."", el_name);', '+           finished=1;', '+         }', '+         state=RAPIER_STATE_DESCRIPTION;', '+         break;', '+       case RAPIER_STATE_DESCRIPTION:', '+         if((element->rdf_attr[RDF_ATTR_ID] != NULL) +', '+            (element->rdf_attr[RDF_ATTR_about] != NULL) +', '+            (element->rdf_attr[RDF_ATTR_aboutEach] != NULL) +', '+            (element->rdf_attr[RDF_ATTR_aboutEachPrefix] != NULL) > 1) {', '+           rapier_parser_warning(rdf_parser, ""More than one of RDF ID, about, aboutEach or aboutEachPrefix attributes on element %s - from productions 6.5, 6.6, 6.7 and 6.8 expect at most one."", el_name);', '+         }', '+         if(element_in_rdf_ns)', '+           state=RAPIER_STATE_IN_DESCRIPTION;', '+         else', '+           state=RAPIER_STATE_TYPED_NODE;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_IN_DESCRIPTION:', '+         state=RAPIER_STATE_PROPERTYELT;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_TYPED_NODE:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_SEQ:', '+       case RAPIER_STATE_BAG:', '+       case RAPIER_STATE_ALT:', '+       case RAPIER_STATE_CONTAINER:', '+         if ((element->rdf_attr - (element->rdf_attr[RDF_ATTR_ID] != NULL))) {', '+           rapier_parser_warning(rdf_parser, ""Illegal rdf: attribute(s) seen on container element %s - from production 6.25, 6.26 and 6.27 expected rdf:ID only."", el_name);', '+         }', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_MEMBER:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_REFERENCEDITEM:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_INLINEITEM:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_PROPERTYELT:', '+         finished=1;', '+         break;', '+       default:', '+         rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."",', '+                                   state);', '+         finished=1;', '+     if(state != element->state) {', '+       element->state=state;', '+       fprintf(stderr, ""rapier_start_element_grammar: moved to state %d\\n"", state);', '+     }', '+ }', '+ static void', '+ rapier_end_element_grammar(rapier_parser *rdf_parser,', '+                            rapier_element *element)', '+ {', '+   rapier_state state;', '+   int finished;', '+   state=element->state;', '+   finished= 0;', '+   while(!finished) {', '+     const char *el_name=element->name->qname;', '+     int element_in_rdf_ns=(element->name->namespace &&', '+                            element->name->namespace->is_rdf_ms);', '+     switch(state) {', '+       case RAPIER_STATE_UNKNOWN:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_IN_RDF:', '+         if(element_in_rdf_ns &&', '+           IS_RDF_MS_CONCEPT(el_name, element->name->uri,RDF)) {', '+           state=RAPIER_STATE_UNKNOWN;', '+           finished=1;', '+           break;', '+         }', '+         if(rdf_parser->scanning_for_rdf_RDF) {', '+           state=RAPIER_STATE_UNKNOWN;', '+           finished=1;', '+           break;', '+         }', '+         rapier_parser_warning(rdf_parser, ""Element %s ended, expected end of RDF element\\n"", el_name);', '+         state=RAPIER_STATE_UNKNOWN;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_DESCRIPTION:', '+         abort();', '+         break;', '+       case RAPIER_STATE_IN_DESCRIPTION:', '+         state=RAPIER_STATE_IN_RDF;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_TYPED_NODE:', '+         state=RAPIER_STATE_IN_RDF;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_SEQ:', '+       case RAPIER_STATE_BAG:', '+       case RAPIER_STATE_ALT:', '+       case RAPIER_STATE_CONTAINER:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_MEMBER:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_REFERENCEDITEM:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_INLINEITEM:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_PROPERTYELT:', '+         finished=1;', '+         break;', '+       default:', '+         rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."",', '+                                   state);', '+         finished=1;', '+     if(state != element->state) {', '+       element->state=state;', '+       fprintf(stderr, ""rapier_end_element_grammar: moved to state %d\\n"", state);', '+     }', '+ }', '-   char *uri;', '- static const char *rdf_attr_names[]={', '-   int forbid_rdf_non_ns_attributes;', '-   void (*fatal_error_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);', '-   void (*error_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);', '-   void (*warning_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);', '-   void (*triple_handler)(void *userData, const char *subject, rapier_subject_type subject_type, const char *predicate, rapier_predicate_type predicate_type, const char *object, rapier_object_type object_type);', '- static const char *rapier_rdf_ms_uri=RAPIER_RDF_MS_URI;', '- static const char *rapier_rdf_schema_uri=RAPIER_RDF_SCHEMA_URI;', '- static void rapier_xml_start_element_handler(void *userData,', '-                                          const XML_Char *name,', '-                                          const XML_Char **atts);', '- static void rapier_xml_end_element_handler(void *userData,', '-                                        const XML_Char *name);', '- static void rapier_xml_cdata_handler(void *userData,', '-                                  const XML_Char *s,', '-                                  int len);', '- static void rapier_start_namespace_decl_handler(void *userData,', '-                                                 const XML_Char *prefix,', '-                                                 const XML_Char *uri);', '- static void rapier_end_namespace_decl_handler(void *userData,', '-                                               const XML_Char *prefix);', '-   rapier_start_namespace(rdf_parser, ""xml"", ""http://www.w3.org/XML/1998/namespace"", -1);', '-                        const char *prefix, const char *namespace,', '-                        int depth)', '-   if(prefix)', '-     len+=strlen(prefix)+1;', '-   if(!map)', '-   if(prefix)', '-     if(!strncmp(namespace, rapier_rdf_ms_uri, uri_length))', '-     else if(!strncmp(namespace, rapier_rdf_schema_uri, uri_length))', '-       if(ns->prefix && !strncmp(name, ns->prefix, prefix_length))', '-     LIBRDF_FREE(cstring, name->qname);', '-     LIBRDF_FREE(cstring, name->value);', '-   if(strcmp(name1->qname, name2->qname))', '-     return 0;', '-       LIBRDF_FREE(cstring, element->rdf_attr[i]);', '- rapier_xml_start_element_handler(void *userData,', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '-   int finished;', '-   rapier_state state;', '-   if (atts != NULL) {', '-     for (i = 0;(atts[i] != NULL);i+=2) {', '-         rapier_start_namespace(userData, prefix, atts[i+1], rdf_parser->depth);', '-   finished= 0;', '-   if(element->parent)', '-     state=element->parent->state;', '-   else', '-     state=RAPIER_STATE_UNKNOWN;', '-   while(!finished) {', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-     switch(state) {', '-       case RAPIER_STATE_UNKNOWN:', '-         if(element_in_rdf_ns && !strcmp(el_name, ""RDF"")) {', '-           state=RAPIER_STATE_IN_RDF;', '-           finished=1;', '-           break;', '-         }', '-         if(rdf_parser->scanning_for_rdf_RDF) {', '-           finished=1;', '-           break;', '-         }', '-         state=RAPIER_STATE_IN_RDF;', '-         break;', '-       case RAPIER_STATE_IN_RDF:', '-         if(element_in_rdf_ns) {', '-           if(!strcmp(el_name, ""Description"")) {', '-             state=RAPIER_STATE_DESCRIPTION;', '-             break;', '-           } else if(!strcmp(el_name, ""Seq"")) {', '-             state=RAPIER_STATE_SEQ;', '-             break;', '-           } else if(!strcmp(el_name, ""Bag"")) {', '-             state=RAPIER_STATE_BAG;', '-             break;', '-           } else if(!strcmp(el_name, ""Alt"")) {', '-             state=RAPIER_STATE_ALT;', '-             break;', '-           }', '-           rapier_parser_error(rdf_parser, ""Unexpected RDF M&S element %s in <rdf:RDF> - from productions 6.2, 6.3 and 6.4 expected rdf:Description, rdf:Seq, rdf:Bag or rdf:Alt only."", el_name);', '-           finished=1;', '-         }', '-         state=RAPIER_STATE_DESCRIPTION;', '-         break;', '-       case RAPIER_STATE_DESCRIPTION:', '-         if((element->rdf_attr[RDF_ATTR_ID] != NULL) +', '-            (element->rdf_attr[RDF_ATTR_about] != NULL) +', '-            (element->rdf_attr[RDF_ATTR_aboutEach] != NULL) +', '-            (element->rdf_attr[RDF_ATTR_aboutEachPrefix] != NULL) > 1) {', '-           rapier_parser_warning(rdf_parser, ""More than one of RDF ID, about, aboutEach or aboutEachPrefix attributes on element %s - from productions 6.5, 6.6, 6.7 and 6.8 expect at most one."", el_name);', '-         }', '-         if(element_in_rdf_ns)', '-           state=RAPIER_STATE_IN_DESCRIPTION;', '-         else', '-           state=RAPIER_STATE_TYPED_NODE;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_IN_DESCRIPTION:', '-         state=RAPIER_STATE_PROPERTYELT;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_TYPED_NODE:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_SEQ:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_BAG:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_ALT:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_MEMBER:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_REFERENCEDITEM:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_INLINEITEM:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PROPERTYELT:', '-         finished=1;', '-         break;', '-       default:', '-         rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."",', '-                                   state);', '-         finished=1;', '-     if(state != element->state) {', '-       element->state=state;', '-       fprintf(stderr, ""rapier_xml_start_element_handler: moved to state %d\\n"", state);', '-     }', '-   element->state=state;', '- rapier_xml_end_element_handler(void *userData, const XML_Char *name)', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '-   int finished;', '-   rapier_state state;', '-   state=element->state;', '-   finished= 0;', '-   while(!finished) {', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-     switch(state) {', '-       case RAPIER_STATE_UNKNOWN:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_IN_RDF:', '-         if(element_in_rdf_ns && !strcmp(el_name, ""RDF"")) {', '-           state=RAPIER_STATE_UNKNOWN;', '-           finished=1;', '-           break;', '-         }', '-         if(rdf_parser->scanning_for_rdf_RDF) {', '-           state=RAPIER_STATE_UNKNOWN;', '-           finished=1;', '-           break;', '-         }', '-         rapier_parser_warning(rdf_parser, ""Element %s ended, expected end of RDF element\\n"", el_name);', '-         state=RAPIER_STATE_UNKNOWN;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_DESCRIPTION:', '-         abort();', '-         break;', '-       case RAPIER_STATE_IN_DESCRIPTION:', '-         state=RAPIER_STATE_IN_RDF;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_TYPED_NODE:', '-         state=RAPIER_STATE_IN_RDF;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_SEQ:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_BAG:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_ALT:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_MEMBER:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_REFERENCEDITEM:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_INLINEITEM:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PROPERTYELT:', '-         finished=1;', '-         break;', '-       default:', '-         rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."",', '-                                   state);', '-         finished=1;', '-     if(state != element->state) {', '-       element->state=state;', '-       fprintf(stderr, ""rapier_xml_end_element_handler: moved to state %d\\n"", state);', '-     }', '-   rapier_free_ns_name(element_name);', '- rapier_xml_cdata_handler(void *userData, const XML_Char *s, int len)', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '-   if(!buffer)', '- rapier_start_namespace_decl_handler(void *userData,', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '- rapier_end_namespace_decl_handler(void *userData, const XML_Char *prefix)', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '-   if(parser->fatal_error_fn) {', '-     parser->fatal_error_fn(parser->fatal_error_user_data,', '-                            &parser->locator, message);', '-   if(parser->error_fn) {', '-     parser->error_fn(parser->error_user_data, &parser->locator, message);', '-   if(parser->warning_fn) {', '-     parser->warning_fn(parser->warning_user_data, &parser->locator, message);', '-   if (sax != NULL)', '- rapier_parser_set_fatal_error(rapier_parser* parser, void *user_data,', '-                         void (*fatal_error_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))', '-   parser->fatal_error_fn=fatal_error_fn;', '- rapier_parser_set_error(rapier_parser* parser, void *user_data,', '-                         void (*error_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))', '-   parser->error_fn=error_fn;', '- rapier_parser_set_warning(rapier_parser* parser, void *user_data,', '-                           void (*warning_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))', '-   parser->warning_fn=warning_fn;', '-                           void *userData,', '-                           void (*triple_handler)(void *userData,', '-                                                 const char *subject, rapier_subject_type subject_type,', '-                                                 const char *predicate, rapier_predicate_type predicate_type,', '-                                                 const char *object, rapier_object_type object_type))', '-   parser->triple_handler=triple_handler;', '-     LIBRDF_FREE(cstring, filename);', '-   LIBRDF_FREE(cstring, filename);']","['+   rapier_state_not_used_1   = 6020,', '+   rapier_state_container = 7000,', '+ #else', '+   const char *uri;', '+ #endif', '+                             be deleted when the parser leaves this depth */', '+ #ifdef librdf_internal', '+   librdf_uri *uri;', '+ #else', '+ static const char * const rdf_attr_names[]={', '+   rapier_message_handler fatal_error_handler;', '+   rapier_message_handler error_handler;', '+   rapier_message_handler warning_handler;', '+   rapier_container_test_handler container_test_handler;', '+   rapier_triple_handler triple_handler;', '+ #ifndef librdf_internal', '+ static const char * const rapier_rdf_ms_uri=rapier_rdf_ms_uri;', '+ static const char * const rapier_rdf_schema_uri=rapier_rdf_schema_uri;', '+ #endif', '+ static const char * const rapier_xml_uri=""http://www.w3.org/xml/1998/namespace"";', '+ static void rapier_xml_start_element_handler(void *user_data, const xml_char *name, const xml_char **atts);', '+ static void rapier_xml_end_element_handler(void *user_data, const xml_char *name);', '+ static void rapier_xml_cdata_handler(void *user_data, const xml_char *s, int len);', '+ static void rapier_start_namespace_decl_handler(void *user_data, const xml_char *prefix, const xml_char *uri);', '+ static void rapier_end_namespace_decl_handler(void *user_data, const xml_char *prefix);', '+ static void rapier_start_element_grammar(rapier_parser *parser, rapier_element *element);', '+ static void rapier_end_element_grammar(rapier_parser *parser, rapier_element *element);', '+ #ifdef librdf_internal', '+ #define is_rdf_ms_concept(name, uri, qname) librdf_uri_equals(uri, librdf_concept_uris[librdf_concept_ms_##qname])', '+ #else', '+ #define is_rdf_ms_concept(name, uri, qname) !strcmp(name, #qname)', '+ #endif', '+   rapier_start_namespace(rdf_parser, ""xml"", rapier_xml_uri, -1);', '+                        const char *prefix, const char *namespace, int depth)', '+   int prefix_length=0;', '+ #ifndef librdf_internal', '+ #endif', '+ #ifndef librdf_internal', '+ #endif', '+   if(prefix) {', '+     prefix_length=strlen(prefix);', '+     len+=prefix_length+1;', '+   }', '+   if(!map) {', '+     return;', '+   }', '+ #ifndef librdf_internal', '+ #else', '+   map->uri=librdf_new_uri(namespace);', '+   if(!map->uri) {', '+     rapier_parser_fatal_error(rdf_parser, ""out of memory"");', '+     librdf_free(rapier_ns_map, map);', '+     return;', '+   }', '+ #endif', '+   if(prefix) {', '+     map->prefix_length=prefix_length;', '+   }', '+ #ifdef librdf_internal', '+     if(librdf_uri_equals(map->uri, librdf_concept_ms_namespace_uri))', '+       map->is_rdf_ms=1;', '+     else if(librdf_uri_equals(map->uri, librdf_concept_schema_namespace_uri))', '+       map->is_rdf_schema=1;', '+ #else', '+     if(!strcmp(namespace, rapier_rdf_ms_uri))', '+     else if(!strcmp(namespace, rapier_rdf_schema_uri))', '+ #endif', '+ #ifdef librdf_internal', '+   if(namespace->uri)', '+     librdf_free_uri(namespace->uri);', '+ #endif', '+ #ifdef librdf_internal', '+     rapier_end_namespace(rdf_parser, ns->prefix,', '+                          librdf_uri_as_string(ns->uri));', '+ #else', '+ #endif', '+       if(ns->prefix && prefix_length == ns->prefix_length &&', '+          !strncmp(name, ns->prefix, prefix_length))', '+ #ifdef librdf_internal', '+     librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->namespace->uri,', '+                                                   new_name);', '+     if(!uri) {', '+       rapier_free_ns_name(ns_name);', '+       return null;', '+     }', '+     ns_name->uri=uri;', '+ #else', '+     strcpy(uri_string, ns_name->namespace->uri);', '+     strncpy(uri_string+ns_name->namespace->uri_length, new_name, qname_length);', '+ #endif', '+     librdf_free(cstring, (void*)name->qname);', '+ #ifdef librdf_internal', '+   if(name->uri)', '+     librdf_free_uri(name->uri);', '+ #else', '+ #endif', '+     librdf_free(cstring, (void*)name->value);', '+ #ifdef librdf_internal', '+   if(name1->uri && name2->uri)', '+     return librdf_uri_equals(name1->uri, name2->uri);', '+ #else', '+ #endif', '+   if(strcmp(name1->qname, name2->qname))', '+     return 0;', '+       librdf_free(cstring, (void*)element->rdf_attr[i]);', '+ rapier_xml_start_element_handler(void *user_data,', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+   if (atts) {', '+     for (i = 0; atts[i]; i+=2) {', '+         rapier_start_namespace(user_data, prefix, atts[i+1],', '+                                rdf_parser->depth);', '+             element->rdf_attr_count++;', '+   rapier_start_element_grammar(rdf_parser, element);', '+ rapier_xml_end_element_handler(void *user_data, const xml_char *name)', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+   rapier_end_element_grammar(rdf_parser, element);', '+   rapier_free_ns_name(element_name);', '+ rapier_xml_cdata_handler(void *user_data, const xml_char *s, int len)', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+       return;', '+   if(!buffer) {', '+     rapier_parser_fatal_error(rdf_parser, ""out of memory"");', '+   }', '+ rapier_start_namespace_decl_handler(void *user_data,', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+ rapier_end_namespace_decl_handler(void *user_data, const xml_char *prefix)', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+ static void', '+ rapier_xml_unparsed_entity_decl_handler(void *user_data,', '+                                         const xml_char *entityname,', '+                                         const xml_char *base,', '+                                         const xml_char *systemid,', '+                                         const xml_char *publicid,', '+                                         const xml_char *notationname)', '+ {', '+   fprintf(stderr,', '+           ""rapier_xml_unparsed_entity_decl_handler: entityname %s base %s systemid %s publicid %s notationname %s\\n"",', '+           entityname, (base ? base : ""(none)""),', '+           systemid, (publicid ? publicid: ""(none)""),', '+           notationname);', '+ }', '+ static int', '+ rapier_xml_external_entity_ref_handler(xml_parser parser,', '+                                        const xml_char *context,', '+                                        const xml_char *base,', '+                                        const xml_char *systemid,', '+                                        const xml_char *publicid)', '+ {', '+   fprintf(stderr,', '+           ""rapier_xml_external_entity_ref_handler: context %s base %s systemid %s publicid %s\\n"",', '+           context, (base ? base : ""(none)""),', '+           systemid, (publicid ? publicid: ""(none)""));', '+   return 1;', '+ }', '+   if(parser->fatal_error_handler) {', '+     parser->fatal_error_handler(parser->fatal_error_user_data,', '+                                 &parser->locator, message);', '+   if(parser->error_handler) {', '+     parser->error_handler(parser->error_user_data,', '+                           &parser->locator, message);', '+   if(parser->warning_handler) {', '+     parser->warning_handler(parser->warning_user_data,', '+                             &parser->locator, message);', '+   if (sax)', '+   xml_setunparsedentitydeclhandler(xp,', '+                                    rapier_xml_unparsed_entity_decl_handler);', '+   xml_setexternalentityrefhandler(xp,', '+                                   rapier_xml_external_entity_ref_handler);', '+ rapier_set_fatal_error_handler(rapier_parser* parser, void *user_data,', '+                                rapier_message_handler handler)', '+   parser->fatal_error_handler=handler;', '+ rapier_set_error_handler(rapier_parser* parser, void *user_data,', '+                          rapier_message_handler handler)', '+   parser->error_handler=handler;', '+ rapier_set_warning_handler(rapier_parser* parser, void *user_data,', '+                            rapier_message_handler handler)', '+   parser->warning_handler=handler;', '+                           void *user_data,', '+                           rapier_triple_handler handler)', '+   parser->user_data=user_data;', '+   parser->triple_handler=handler;', '+     librdf_free(cstring, (void*)filename);', '+   librdf_free(cstring, (void*)filename);', '+ static void', '+ rapier_start_element_grammar(rapier_parser *rdf_parser,', '+                              rapier_element *element)', '+ {', '+   int finished;', '+   rapier_state state;', '+   finished= 0;', '+   if(element->parent)', '+     state=element->parent->state;', '+   else', '+     state=rapier_state_unknown;', '+   while(!finished) {', '+     const char *el_name=element->name->qname;', '+     int element_in_rdf_ns=(element->name->namespace &&', '+                            element->name->namespace->is_rdf_ms);', '+     switch(state) {', '+       case rapier_state_unknown:', '+         if(element_in_rdf_ns &&', '+           is_rdf_ms_concept(el_name, element->name->uri,rdf)) {', '+           state=rapier_state_in_rdf;', '+           finished=1;', '+           break;', '+         }', '+         if(rdf_parser->scanning_for_rdf_rdf) {', '+           finished=1;', '+           break;', '+         }', '+         state=rapier_state_in_rdf;', '+         break;', '+       case rapier_state_in_rdf:', '+         if(element_in_rdf_ns) {', '+           if(is_rdf_ms_concept(el_name, element->name->uri,description)) {', '+             state=rapier_state_description;', '+             break;', '+           } else if(is_rdf_ms_concept(el_name, element->name->uri,seq)) {', '+             state=rapier_state_seq;', '+             break;', '+           } else if(is_rdf_ms_concept(el_name, element->name->uri,bag)) {', '+             state=rapier_state_bag;', '+             break;', '+           } else if(is_rdf_ms_concept(el_name, element->name->uri,alt)) {', '+             state=rapier_state_alt;', '+             break;', '+           } else if(rdf_parser->container_test_handler) {', '+             if(rdf_parser->container_test_handler(element->name->uri)) {', '+               state=rapier_state_container;', '+               break;', '+             }', '+           }', '+           rapier_parser_error(rdf_parser, ""unexpected rdf m&s element %s in <rdf:rdf> - from productions 6.2, 6.3 and 6.4 expected rdf:description, rdf:seq, rdf:bag or rdf:alt only."", el_name);', '+           finished=1;', '+         }', '+         state=rapier_state_description;', '+         break;', '+       case rapier_state_description:', '+         if((element->rdf_attr[rdf_attr_id] != null) +', '+            (element->rdf_attr[rdf_attr_about] != null) +', '+            (element->rdf_attr[rdf_attr_abouteach] != null) +', '+            (element->rdf_attr[rdf_attr_abouteachprefix] != null) > 1) {', '+           rapier_parser_warning(rdf_parser, ""more than one of rdf id, about, abouteach or abouteachprefix attributes on element %s - from productions 6.5, 6.6, 6.7 and 6.8 expect at most one."", el_name);', '+         }', '+         if(element_in_rdf_ns)', '+           state=rapier_state_in_description;', '+         else', '+           state=rapier_state_typed_node;', '+         finished=1;', '+         break;', '+       case rapier_state_in_description:', '+         state=rapier_state_propertyelt;', '+         finished=1;', '+         break;', '+       case rapier_state_typed_node:', '+         finished=1;', '+         break;', '+       case rapier_state_seq:', '+       case rapier_state_bag:', '+       case rapier_state_alt:', '+       case rapier_state_container:', '+         if ((element->rdf_attr - (element->rdf_attr[rdf_attr_id] != null))) {', '+           rapier_parser_warning(rdf_parser, ""illegal rdf: attribute(s) seen on container element %s - from production 6.25, 6.26 and 6.27 expected rdf:id only."", el_name);', '+         }', '+         finished=1;', '+         break;', '+       case rapier_state_member:', '+         finished=1;', '+         break;', '+       case rapier_state_referenceditem:', '+         finished=1;', '+         break;', '+       case rapier_state_inlineitem:', '+         finished=1;', '+         break;', '+       case rapier_state_propertyelt:', '+         finished=1;', '+         break;', '+       default:', '+         rapier_parser_fatal_error(rdf_parser, ""unexpected parser state %d."",', '+                                   state);', '+         finished=1;', '+     if(state != element->state) {', '+       element->state=state;', '+       fprintf(stderr, ""rapier_start_element_grammar: moved to state %d\\n"", state);', '+     }', '+ }', '+ static void', '+ rapier_end_element_grammar(rapier_parser *rdf_parser,', '+                            rapier_element *element)', '+ {', '+   rapier_state state;', '+   int finished;', '+   state=element->state;', '+   finished= 0;', '+   while(!finished) {', '+     const char *el_name=element->name->qname;', '+     int element_in_rdf_ns=(element->name->namespace &&', '+                            element->name->namespace->is_rdf_ms);', '+     switch(state) {', '+       case rapier_state_unknown:', '+         finished=1;', '+         break;', '+       case rapier_state_in_rdf:', '+         if(element_in_rdf_ns &&', '+           is_rdf_ms_concept(el_name, element->name->uri,rdf)) {', '+           state=rapier_state_unknown;', '+           finished=1;', '+           break;', '+         }', '+         if(rdf_parser->scanning_for_rdf_rdf) {', '+           state=rapier_state_unknown;', '+           finished=1;', '+           break;', '+         }', '+         rapier_parser_warning(rdf_parser, ""element %s ended, expected end of rdf element\\n"", el_name);', '+         state=rapier_state_unknown;', '+         finished=1;', '+         break;', '+       case rapier_state_description:', '+         abort();', '+         break;', '+       case rapier_state_in_description:', '+         state=rapier_state_in_rdf;', '+         finished=1;', '+         break;', '+       case rapier_state_typed_node:', '+         state=rapier_state_in_rdf;', '+         finished=1;', '+         break;', '+       case rapier_state_seq:', '+       case rapier_state_bag:', '+       case rapier_state_alt:', '+       case rapier_state_container:', '+         finished=1;', '+         break;', '+       case rapier_state_member:', '+         finished=1;', '+         break;', '+       case rapier_state_referenceditem:', '+         finished=1;', '+         break;', '+       case rapier_state_inlineitem:', '+         finished=1;', '+         break;', '+       case rapier_state_propertyelt:', '+         finished=1;', '+         break;', '+       default:', '+         rapier_parser_fatal_error(rdf_parser, ""unexpected parser state %d."",', '+                                   state);', '+         finished=1;', '+     if(state != element->state) {', '+       element->state=state;', '+       fprintf(stderr, ""rapier_end_element_grammar: moved to state %d\\n"", state);', '+     }', '+ }', '-   char *uri;', '- static const char *rdf_attr_names[]={', '-   int forbid_rdf_non_ns_attributes;', '-   void (*fatal_error_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);', '-   void (*error_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);', '-   void (*warning_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);', '-   void (*triple_handler)(void *userdata, const char *subject, rapier_subject_type subject_type, const char *predicate, rapier_predicate_type predicate_type, const char *object, rapier_object_type object_type);', '- static const char *rapier_rdf_ms_uri=rapier_rdf_ms_uri;', '- static const char *rapier_rdf_schema_uri=rapier_rdf_schema_uri;', '- static void rapier_xml_start_element_handler(void *userdata,', '-                                          const xml_char *name,', '-                                          const xml_char **atts);', '- static void rapier_xml_end_element_handler(void *userdata,', '-                                        const xml_char *name);', '- static void rapier_xml_cdata_handler(void *userdata,', '-                                  const xml_char *s,', '-                                  int len);', '- static void rapier_start_namespace_decl_handler(void *userdata,', '-                                                 const xml_char *prefix,', '-                                                 const xml_char *uri);', '- static void rapier_end_namespace_decl_handler(void *userdata,', '-                                               const xml_char *prefix);', '-   rapier_start_namespace(rdf_parser, ""xml"", ""http://www.w3.org/xml/1998/namespace"", -1);', '-                        const char *prefix, const char *namespace,', '-                        int depth)', '-   if(prefix)', '-     len+=strlen(prefix)+1;', '-   if(!map)', '-   if(prefix)', '-     if(!strncmp(namespace, rapier_rdf_ms_uri, uri_length))', '-     else if(!strncmp(namespace, rapier_rdf_schema_uri, uri_length))', '-       if(ns->prefix && !strncmp(name, ns->prefix, prefix_length))', '-     librdf_free(cstring, name->qname);', '-     librdf_free(cstring, name->value);', '-   if(strcmp(name1->qname, name2->qname))', '-     return 0;', '-       librdf_free(cstring, element->rdf_attr[i]);', '- rapier_xml_start_element_handler(void *userdata,', '-   rapier_parser* rdf_parser=(rapier_parser*)userdata;', '-   int finished;', '-   rapier_state state;', '-   if (atts != null) {', '-     for (i = 0;(atts[i] != null);i+=2) {', '-         rapier_start_namespace(userdata, prefix, atts[i+1], rdf_parser->depth);', '-   finished= 0;', '-   if(element->parent)', '-     state=element->parent->state;', '-   else', '-     state=rapier_state_unknown;', '-   while(!finished) {', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-     switch(state) {', '-       case rapier_state_unknown:', '-         if(element_in_rdf_ns && !strcmp(el_name, ""rdf"")) {', '-           state=rapier_state_in_rdf;', '-           finished=1;', '-           break;', '-         }', '-         if(rdf_parser->scanning_for_rdf_rdf) {', '-           finished=1;', '-           break;', '-         }', '-         state=rapier_state_in_rdf;', '-         break;', '-       case rapier_state_in_rdf:', '-         if(element_in_rdf_ns) {', '-           if(!strcmp(el_name, ""description"")) {', '-             state=rapier_state_description;', '-             break;', '-           } else if(!strcmp(el_name, ""seq"")) {', '-             state=rapier_state_seq;', '-             break;', '-           } else if(!strcmp(el_name, ""bag"")) {', '-             state=rapier_state_bag;', '-             break;', '-           } else if(!strcmp(el_name, ""alt"")) {', '-             state=rapier_state_alt;', '-             break;', '-           }', '-           rapier_parser_error(rdf_parser, ""unexpected rdf m&s element %s in <rdf:rdf> - from productions 6.2, 6.3 and 6.4 expected rdf:description, rdf:seq, rdf:bag or rdf:alt only."", el_name);', '-           finished=1;', '-         }', '-         state=rapier_state_description;', '-         break;', '-       case rapier_state_description:', '-         if((element->rdf_attr[rdf_attr_id] != null) +', '-            (element->rdf_attr[rdf_attr_about] != null) +', '-            (element->rdf_attr[rdf_attr_abouteach] != null) +', '-            (element->rdf_attr[rdf_attr_abouteachprefix] != null) > 1) {', '-           rapier_parser_warning(rdf_parser, ""more than one of rdf id, about, abouteach or abouteachprefix attributes on element %s - from productions 6.5, 6.6, 6.7 and 6.8 expect at most one."", el_name);', '-         }', '-         if(element_in_rdf_ns)', '-           state=rapier_state_in_description;', '-         else', '-           state=rapier_state_typed_node;', '-         finished=1;', '-         break;', '-       case rapier_state_in_description:', '-         state=rapier_state_propertyelt;', '-         finished=1;', '-         break;', '-       case rapier_state_typed_node:', '-         finished=1;', '-         break;', '-       case rapier_state_seq:', '-         finished=1;', '-         break;', '-       case rapier_state_bag:', '-         finished=1;', '-         break;', '-       case rapier_state_alt:', '-         finished=1;', '-         break;', '-       case rapier_state_member:', '-         finished=1;', '-         break;', '-       case rapier_state_referenceditem:', '-         finished=1;', '-         break;', '-       case rapier_state_inlineitem:', '-         finished=1;', '-         break;', '-       case rapier_state_propertyelt:', '-         finished=1;', '-         break;', '-       default:', '-         rapier_parser_fatal_error(rdf_parser, ""unexpected parser state %d."",', '-                                   state);', '-         finished=1;', '-     if(state != element->state) {', '-       element->state=state;', '-       fprintf(stderr, ""rapier_xml_start_element_handler: moved to state %d\\n"", state);', '-     }', '-   element->state=state;', '- rapier_xml_end_element_handler(void *userdata, const xml_char *name)', '-   rapier_parser* rdf_parser=(rapier_parser*)userdata;', '-   int finished;', '-   rapier_state state;', '-   state=element->state;', '-   finished= 0;', '-   while(!finished) {', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-     switch(state) {', '-       case rapier_state_unknown:', '-         finished=1;', '-         break;', '-       case rapier_state_in_rdf:', '-         if(element_in_rdf_ns && !strcmp(el_name, ""rdf"")) {', '-           state=rapier_state_unknown;', '-           finished=1;', '-           break;', '-         }', '-         if(rdf_parser->scanning_for_rdf_rdf) {', '-           state=rapier_state_unknown;', '-           finished=1;', '-           break;', '-         }', '-         rapier_parser_warning(rdf_parser, ""element %s ended, expected end of rdf element\\n"", el_name);', '-         state=rapier_state_unknown;', '-         finished=1;', '-         break;', '-       case rapier_state_description:', '-         abort();', '-         break;', '-       case rapier_state_in_description:', '-         state=rapier_state_in_rdf;', '-         finished=1;', '-         break;', '-       case rapier_state_typed_node:', '-         state=rapier_state_in_rdf;', '-         finished=1;', '-         break;', '-       case rapier_state_seq:', '-         finished=1;', '-         break;', '-       case rapier_state_bag:', '-         finished=1;', '-         break;', '-       case rapier_state_alt:', '-         finished=1;', '-         break;', '-       case rapier_state_member:', '-         finished=1;', '-         break;', '-       case rapier_state_referenceditem:', '-         finished=1;', '-         break;', '-       case rapier_state_inlineitem:', '-         finished=1;', '-         break;', '-       case rapier_state_propertyelt:', '-         finished=1;', '-         break;', '-       default:', '-         rapier_parser_fatal_error(rdf_parser, ""unexpected parser state %d."",', '-                                   state);', '-         finished=1;', '-     if(state != element->state) {', '-       element->state=state;', '-       fprintf(stderr, ""rapier_xml_end_element_handler: moved to state %d\\n"", state);', '-     }', '-   rapier_free_ns_name(element_name);', '- rapier_xml_cdata_handler(void *userdata, const xml_char *s, int len)', '-   rapier_parser* rdf_parser=(rapier_parser*)userdata;', '-   if(!buffer)', '- rapier_start_namespace_decl_handler(void *userdata,', '-   rapier_parser* rdf_parser=(rapier_parser*)userdata;', '- rapier_end_namespace_decl_handler(void *userdata, const xml_char *prefix)', '-   rapier_parser* rdf_parser=(rapier_parser*)userdata;', '-   if(parser->fatal_error_fn) {', '-     parser->fatal_error_fn(parser->fatal_error_user_data,', '-                            &parser->locator, message);', '-   if(parser->error_fn) {', '-     parser->error_fn(parser->error_user_data, &parser->locator, message);', '-   if(parser->warning_fn) {', '-     parser->warning_fn(parser->warning_user_data, &parser->locator, message);', '-   if (sax != null)', '- rapier_parser_set_fatal_error(rapier_parser* parser, void *user_data,', '-                         void (*fatal_error_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))', '-   parser->fatal_error_fn=fatal_error_fn;', '- rapier_parser_set_error(rapier_parser* parser, void *user_data,', '-                         void (*error_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))', '-   parser->error_fn=error_fn;', '- rapier_parser_set_warning(rapier_parser* parser, void *user_data,', '-                           void (*warning_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))', '-   parser->warning_fn=warning_fn;', '-                           void *userdata,', '-                           void (*triple_handler)(void *userdata,', '-                                                 const char *subject, rapier_subject_type subject_type,', '-                                                 const char *predicate, rapier_predicate_type predicate_type,', '-                                                 const char *object, rapier_object_type object_type))', '-   parser->triple_handler=triple_handler;', '-     librdf_free(cstring, filename);', '-   librdf_free(cstring, filename);']","['+   RAPIER_STATE_NOT_USED_1   = 6020,', '+   RAPIER_STATE_CONTAINER = 7000,', '+ #else', '+   const char *uri;', '+ #endif', '+                             be deleted when the parser leaves this depth */', '+ #ifdef LIBRDF_INTERNAL', '+   librdf_uri *uri;', '+ #else', '+ static const char * const rdf_attr_names[]={', '+   rapier_message_handler fatal_error_handler;', '+   rapier_message_handler error_handler;', '+   rapier_message_handler warning_handler;', '+   rapier_container_test_handler container_test_handler;', '+   rapier_triple_handler triple_handler;', '+ #ifndef LIBRDF_INTERNAL', '+ static const char * const rapier_rdf_ms_uri=RAPIER_RDF_MS_URI;', '+ static const char * const rapier_rdf_schema_uri=RAPIER_RDF_SCHEMA_URI;', '+ #endif', '+ static const char * const rapier_xml_uri=""http://www.w3.org/XML/1998/namespace"";', '+ static void rapier_xml_start_element_handler(void *user_data, const XML_Char *name, const XML_Char **atts);', '+ static void rapier_xml_end_element_handler(void *user_data, const XML_Char *name);', '+ static void rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len);', '+ static void rapier_start_namespace_decl_handler(void *user_data, const XML_Char *prefix, const XML_Char *uri);', '+ static void rapier_end_namespace_decl_handler(void *user_data, const XML_Char *prefix);', '+ static void rapier_start_element_grammar(rapier_parser *parser, rapier_element *element);', '+ static void rapier_end_element_grammar(rapier_parser *parser, rapier_element *element);', '+ #ifdef LIBRDF_INTERNAL', '+ #define IS_RDF_MS_CONCEPT(name, uri, qname) librdf_uri_equals(uri, librdf_concept_uris[LIBRDF_CONCEPT_MS_##qname])', '+ #else', '+ #define IS_RDF_MS_CONCEPT(name, uri, qname) !strcmp(name, #qname)', '+ #endif', '+   rapier_start_namespace(rdf_parser, ""xml"", rapier_xml_uri, -1);', '+                        const char *prefix, const char *namespace, int depth)', '+   int prefix_length=0;', '+ #ifndef LIBRDF_INTERNAL', '+ #endif', '+ #ifndef LIBRDF_INTERNAL', '+ #endif', '+   if(prefix) {', '+     prefix_length=strlen(prefix);', '+     len+=prefix_length+1;', '+   }', '+   if(!map) {', '+     return;', '+   }', '+ #ifndef LIBRDF_INTERNAL', '+ #else', '+   map->uri=librdf_new_uri(namespace);', '+   if(!map->uri) {', '+     rapier_parser_fatal_error(rdf_parser, ""Out of memory"");', '+     LIBRDF_FREE(rapier_ns_map, map);', '+     return;', '+   }', '+ #endif', '+   if(prefix) {', '+     map->prefix_length=prefix_length;', '+   }', '+ #ifdef LIBRDF_INTERNAL', '+     if(librdf_uri_equals(map->uri, librdf_concept_ms_namespace_uri))', '+       map->is_rdf_ms=1;', '+     else if(librdf_uri_equals(map->uri, librdf_concept_schema_namespace_uri))', '+       map->is_rdf_schema=1;', '+ #else', '+     if(!strcmp(namespace, rapier_rdf_ms_uri))', '+     else if(!strcmp(namespace, rapier_rdf_schema_uri))', '+ #endif', '+ #ifdef LIBRDF_INTERNAL', '+   if(namespace->uri)', '+     librdf_free_uri(namespace->uri);', '+ #endif', '+ #ifdef LIBRDF_INTERNAL', '+     rapier_end_namespace(rdf_parser, ns->prefix,', '+                          librdf_uri_as_string(ns->uri));', '+ #else', '+ #endif', '+       if(ns->prefix && prefix_length == ns->prefix_length &&', '+          !strncmp(name, ns->prefix, prefix_length))', '+ #ifdef LIBRDF_INTERNAL', '+     librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->namespace->uri,', '+                                                   new_name);', '+     if(!uri) {', '+       rapier_free_ns_name(ns_name);', '+       return NULL;', '+     }', '+     ns_name->uri=uri;', '+ #else', '+     strcpy(uri_string, ns_name->namespace->uri);', '+     strncpy(uri_string+ns_name->namespace->uri_length, new_name, qname_length);', '+ #endif', '+     LIBRDF_FREE(cstring, (void*)name->qname);', '+ #ifdef LIBRDF_INTERNAL', '+   if(name->uri)', '+     librdf_free_uri(name->uri);', '+ #else', '+ #endif', '+     LIBRDF_FREE(cstring, (void*)name->value);', '+ #ifdef LIBRDF_INTERNAL', '+   if(name1->uri && name2->uri)', '+     return librdf_uri_equals(name1->uri, name2->uri);', '+ #else', '+ #endif', '+   if(strcmp(name1->qname, name2->qname))', '+     return 0;', '+       LIBRDF_FREE(cstring, (void*)element->rdf_attr[i]);', '+ rapier_xml_start_element_handler(void *user_data,', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+   if (atts) {', '+     for (i = 0; atts[i]; i+=2) {', '+         rapier_start_namespace(user_data, prefix, atts[i+1],', '+                                rdf_parser->depth);', '+             element->rdf_attr_count++;', '+   rapier_start_element_grammar(rdf_parser, element);', '+ rapier_xml_end_element_handler(void *user_data, const XML_Char *name)', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+   rapier_end_element_grammar(rdf_parser, element);', '+   rapier_free_ns_name(element_name);', '+ rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len)', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+       return;', '+   if(!buffer) {', '+     rapier_parser_fatal_error(rdf_parser, ""Out of memory"");', '+   }', '+ rapier_start_namespace_decl_handler(void *user_data,', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+ rapier_end_namespace_decl_handler(void *user_data, const XML_Char *prefix)', '+   rapier_parser* rdf_parser=(rapier_parser*)user_data;', '+ static void', '+ rapier_xml_unparsed_entity_decl_handler(void *user_data,', '+                                         const XML_Char *entityName,', '+                                         const XML_Char *base,', '+                                         const XML_Char *systemId,', '+                                         const XML_Char *publicId,', '+                                         const XML_Char *notationName)', '+ {', '+   fprintf(stderr,', '+           ""rapier_xml_unparsed_entity_decl_handler: entityName %s base %s systemId %s publicId %s notationName %s\\n"",', '+           entityName, (base ? base : ""(None)""),', '+           systemId, (publicId ? publicId: ""(None)""),', '+           notationName);', '+ }', '+ static int', '+ rapier_xml_external_entity_ref_handler(XML_Parser parser,', '+                                        const XML_Char *context,', '+                                        const XML_Char *base,', '+                                        const XML_Char *systemId,', '+                                        const XML_Char *publicId)', '+ {', '+   fprintf(stderr,', '+           ""rapier_xml_external_entity_ref_handler: context %s base %s systemId %s publicId %s\\n"",', '+           context, (base ? base : ""(None)""),', '+           systemId, (publicId ? publicId: ""(None)""));', '+   return 1;', '+ }', '+   if(parser->fatal_error_handler) {', '+     parser->fatal_error_handler(parser->fatal_error_user_data,', '+                                 &parser->locator, message);', '+   if(parser->error_handler) {', '+     parser->error_handler(parser->error_user_data,', '+                           &parser->locator, message);', '+   if(parser->warning_handler) {', '+     parser->warning_handler(parser->warning_user_data,', '+                             &parser->locator, message);', '+   if (sax)', '+   XML_SetUnparsedEntityDeclHandler(xp,', '+                                    rapier_xml_unparsed_entity_decl_handler);', '+   XML_SetExternalEntityRefHandler(xp,', '+                                   rapier_xml_external_entity_ref_handler);', '+ rapier_set_fatal_error_handler(rapier_parser* parser, void *user_data,', '+                                rapier_message_handler handler)', '+   parser->fatal_error_handler=handler;', '+ rapier_set_error_handler(rapier_parser* parser, void *user_data,', '+                          rapier_message_handler handler)', '+   parser->error_handler=handler;', '+ rapier_set_warning_handler(rapier_parser* parser, void *user_data,', '+                            rapier_message_handler handler)', '+   parser->warning_handler=handler;', '+                           void *user_data,', '+                           rapier_triple_handler handler)', '+   parser->user_data=user_data;', '+   parser->triple_handler=handler;', '+     LIBRDF_FREE(cstring, (void*)filename);', '+   LIBRDF_FREE(cstring, (void*)filename);', '+ static void', '+ rapier_start_element_grammar(rapier_parser *rdf_parser,', '+                              rapier_element *element)', '+ {', '+   int finished;', '+   rapier_state state;', '+   finished= 0;', '+   if(element->parent)', '+     state=element->parent->state;', '+   else', '+     state=RAPIER_STATE_UNKNOWN;', '+   while(!finished) {', '+     const char *el_name=element->name->qname;', '+     int element_in_rdf_ns=(element->name->namespace &&', '+                            element->name->namespace->is_rdf_ms);', '+     switch(state) {', '+       case RAPIER_STATE_UNKNOWN:', '+         if(element_in_rdf_ns &&', '+           IS_RDF_MS_CONCEPT(el_name, element->name->uri,RDF)) {', '+           state=RAPIER_STATE_IN_RDF;', '+           finished=1;', '+           break;', '+         }', '+         if(rdf_parser->scanning_for_rdf_RDF) {', '+           finished=1;', '+           break;', '+         }', '+         state=RAPIER_STATE_IN_RDF;', '+         break;', '+       case RAPIER_STATE_IN_RDF:', '+         if(element_in_rdf_ns) {', '+           if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Description)) {', '+             state=RAPIER_STATE_DESCRIPTION;', '+             break;', '+           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Seq)) {', '+             state=RAPIER_STATE_SEQ;', '+             break;', '+           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Bag)) {', '+             state=RAPIER_STATE_BAG;', '+             break;', '+           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri,Alt)) {', '+             state=RAPIER_STATE_ALT;', '+             break;', '+           } else if(rdf_parser->container_test_handler) {', '+             if(rdf_parser->container_test_handler(element->name->uri)) {', '+               state=RAPIER_STATE_CONTAINER;', '+               break;', '+             }', '+           }', '+           rapier_parser_error(rdf_parser, ""Unexpected RDF M&S element %s in <rdf:RDF> - from productions 6.2, 6.3 and 6.4 expected rdf:Description, rdf:Seq, rdf:Bag or rdf:Alt only."", el_name);', '+           finished=1;', '+         }', '+         state=RAPIER_STATE_DESCRIPTION;', '+         break;', '+       case RAPIER_STATE_DESCRIPTION:', '+         if((element->rdf_attr[RDF_ATTR_ID] != NULL) +', '+            (element->rdf_attr[RDF_ATTR_about] != NULL) +', '+            (element->rdf_attr[RDF_ATTR_aboutEach] != NULL) +', '+            (element->rdf_attr[RDF_ATTR_aboutEachPrefix] != NULL) > 1) {', '+           rapier_parser_warning(rdf_parser, ""More than one of RDF ID, about, aboutEach or aboutEachPrefix attributes on element %s - from productions 6.5, 6.6, 6.7 and 6.8 expect at most one."", el_name);', '+         }', '+         if(element_in_rdf_ns)', '+           state=RAPIER_STATE_IN_DESCRIPTION;', '+         else', '+           state=RAPIER_STATE_TYPED_NODE;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_IN_DESCRIPTION:', '+         state=RAPIER_STATE_PROPERTYELT;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_TYPED_NODE:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_SEQ:', '+       case RAPIER_STATE_BAG:', '+       case RAPIER_STATE_ALT:', '+       case RAPIER_STATE_CONTAINER:', '+         if ((element->rdf_attr - (element->rdf_attr[RDF_ATTR_ID] != NULL))) {', '+           rapier_parser_warning(rdf_parser, ""Illegal rdf: attribute(s) seen on container element %s - from production 6.25, 6.26 and 6.27 expected rdf:ID only."", el_name);', '+         }', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_MEMBER:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_REFERENCEDITEM:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_INLINEITEM:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_PROPERTYELT:', '+         finished=1;', '+         break;', '+       default:', '+         rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."",', '+                                   state);', '+         finished=1;', '+     if(state != element->state) {', '+       element->state=state;', '+       fprintf(stderr, ""rapier_start_element_grammar: moved to state %d\\n"", state);', '+     }', '+ }', '+ static void', '+ rapier_end_element_grammar(rapier_parser *rdf_parser,', '+                            rapier_element *element)', '+ {', '+   rapier_state state;', '+   int finished;', '+   state=element->state;', '+   finished= 0;', '+   while(!finished) {', '+     const char *el_name=element->name->qname;', '+     int element_in_rdf_ns=(element->name->namespace &&', '+                            element->name->namespace->is_rdf_ms);', '+     switch(state) {', '+       case RAPIER_STATE_UNKNOWN:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_IN_RDF:', '+         if(element_in_rdf_ns &&', '+           IS_RDF_MS_CONCEPT(el_name, element->name->uri,RDF)) {', '+           state=RAPIER_STATE_UNKNOWN;', '+           finished=1;', '+           break;', '+         }', '+         if(rdf_parser->scanning_for_rdf_RDF) {', '+           state=RAPIER_STATE_UNKNOWN;', '+           finished=1;', '+           break;', '+         }', '+         rapier_parser_warning(rdf_parser, ""Element %s ended, expected end of RDF element\\n"", el_name);', '+         state=RAPIER_STATE_UNKNOWN;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_DESCRIPTION:', '+         abort();', '+         break;', '+       case RAPIER_STATE_IN_DESCRIPTION:', '+         state=RAPIER_STATE_IN_RDF;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_TYPED_NODE:', '+         state=RAPIER_STATE_IN_RDF;', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_SEQ:', '+       case RAPIER_STATE_BAG:', '+       case RAPIER_STATE_ALT:', '+       case RAPIER_STATE_CONTAINER:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_MEMBER:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_REFERENCEDITEM:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_INLINEITEM:', '+         finished=1;', '+         break;', '+       case RAPIER_STATE_PROPERTYELT:', '+         finished=1;', '+         break;', '+       default:', '+         rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."",', '+                                   state);', '+         finished=1;', '+     if(state != element->state) {', '+       element->state=state;', '+       fprintf(stderr, ""rapier_end_element_grammar: moved to state %d\\n"", state);', '+     }', '+ }']","['-   char *uri;', '- static const char *rdf_attr_names[]={', '-   int forbid_rdf_non_ns_attributes;', '-   void (*fatal_error_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);', '-   void (*error_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);', '-   void (*warning_fn)(void *user_data, rapier_locator *locator, const char *msg, ...);', '-   void (*triple_handler)(void *userData, const char *subject, rapier_subject_type subject_type, const char *predicate, rapier_predicate_type predicate_type, const char *object, rapier_object_type object_type);', '- static const char *rapier_rdf_ms_uri=RAPIER_RDF_MS_URI;', '- static const char *rapier_rdf_schema_uri=RAPIER_RDF_SCHEMA_URI;', '- static void rapier_xml_start_element_handler(void *userData,', '-                                          const XML_Char *name,', '-                                          const XML_Char **atts);', '- static void rapier_xml_end_element_handler(void *userData,', '-                                        const XML_Char *name);', '- static void rapier_xml_cdata_handler(void *userData,', '-                                  const XML_Char *s,', '-                                  int len);', '- static void rapier_start_namespace_decl_handler(void *userData,', '-                                                 const XML_Char *prefix,', '-                                                 const XML_Char *uri);', '- static void rapier_end_namespace_decl_handler(void *userData,', '-                                               const XML_Char *prefix);', '-   rapier_start_namespace(rdf_parser, ""xml"", ""http://www.w3.org/XML/1998/namespace"", -1);', '-                        const char *prefix, const char *namespace,', '-                        int depth)', '-   if(prefix)', '-     len+=strlen(prefix)+1;', '-   if(!map)', '-   if(prefix)', '-     if(!strncmp(namespace, rapier_rdf_ms_uri, uri_length))', '-     else if(!strncmp(namespace, rapier_rdf_schema_uri, uri_length))', '-       if(ns->prefix && !strncmp(name, ns->prefix, prefix_length))', '-     LIBRDF_FREE(cstring, name->qname);', '-     LIBRDF_FREE(cstring, name->value);', '-   if(strcmp(name1->qname, name2->qname))', '-     return 0;', '-       LIBRDF_FREE(cstring, element->rdf_attr[i]);', '- rapier_xml_start_element_handler(void *userData,', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '-   int finished;', '-   rapier_state state;', '-   if (atts != NULL) {', '-     for (i = 0;(atts[i] != NULL);i+=2) {', '-         rapier_start_namespace(userData, prefix, atts[i+1], rdf_parser->depth);', '-   finished= 0;', '-   if(element->parent)', '-     state=element->parent->state;', '-   else', '-     state=RAPIER_STATE_UNKNOWN;', '-   while(!finished) {', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-     switch(state) {', '-       case RAPIER_STATE_UNKNOWN:', '-         if(element_in_rdf_ns && !strcmp(el_name, ""RDF"")) {', '-           state=RAPIER_STATE_IN_RDF;', '-           finished=1;', '-           break;', '-         }', '-         if(rdf_parser->scanning_for_rdf_RDF) {', '-           finished=1;', '-           break;', '-         }', '-         state=RAPIER_STATE_IN_RDF;', '-         break;', '-       case RAPIER_STATE_IN_RDF:', '-         if(element_in_rdf_ns) {', '-           if(!strcmp(el_name, ""Description"")) {', '-             state=RAPIER_STATE_DESCRIPTION;', '-             break;', '-           } else if(!strcmp(el_name, ""Seq"")) {', '-             state=RAPIER_STATE_SEQ;', '-             break;', '-           } else if(!strcmp(el_name, ""Bag"")) {', '-             state=RAPIER_STATE_BAG;', '-             break;', '-           } else if(!strcmp(el_name, ""Alt"")) {', '-             state=RAPIER_STATE_ALT;', '-             break;', '-           }', '-           rapier_parser_error(rdf_parser, ""Unexpected RDF M&S element %s in <rdf:RDF> - from productions 6.2, 6.3 and 6.4 expected rdf:Description, rdf:Seq, rdf:Bag or rdf:Alt only."", el_name);', '-           finished=1;', '-         }', '-         state=RAPIER_STATE_DESCRIPTION;', '-         break;', '-       case RAPIER_STATE_DESCRIPTION:', '-         if((element->rdf_attr[RDF_ATTR_ID] != NULL) +', '-            (element->rdf_attr[RDF_ATTR_about] != NULL) +', '-            (element->rdf_attr[RDF_ATTR_aboutEach] != NULL) +', '-            (element->rdf_attr[RDF_ATTR_aboutEachPrefix] != NULL) > 1) {', '-           rapier_parser_warning(rdf_parser, ""More than one of RDF ID, about, aboutEach or aboutEachPrefix attributes on element %s - from productions 6.5, 6.6, 6.7 and 6.8 expect at most one."", el_name);', '-         }', '-         if(element_in_rdf_ns)', '-           state=RAPIER_STATE_IN_DESCRIPTION;', '-         else', '-           state=RAPIER_STATE_TYPED_NODE;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_IN_DESCRIPTION:', '-         state=RAPIER_STATE_PROPERTYELT;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_TYPED_NODE:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_SEQ:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_BAG:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_ALT:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_MEMBER:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_REFERENCEDITEM:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_INLINEITEM:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PROPERTYELT:', '-         finished=1;', '-         break;', '-       default:', '-         rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."",', '-                                   state);', '-         finished=1;', '-     if(state != element->state) {', '-       element->state=state;', '-       fprintf(stderr, ""rapier_xml_start_element_handler: moved to state %d\\n"", state);', '-     }', '-   element->state=state;', '- rapier_xml_end_element_handler(void *userData, const XML_Char *name)', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '-   int finished;', '-   rapier_state state;', '-   state=element->state;', '-   finished= 0;', '-   while(!finished) {', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-     switch(state) {', '-       case RAPIER_STATE_UNKNOWN:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_IN_RDF:', '-         if(element_in_rdf_ns && !strcmp(el_name, ""RDF"")) {', '-           state=RAPIER_STATE_UNKNOWN;', '-           finished=1;', '-           break;', '-         }', '-         if(rdf_parser->scanning_for_rdf_RDF) {', '-           state=RAPIER_STATE_UNKNOWN;', '-           finished=1;', '-           break;', '-         }', '-         rapier_parser_warning(rdf_parser, ""Element %s ended, expected end of RDF element\\n"", el_name);', '-         state=RAPIER_STATE_UNKNOWN;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_DESCRIPTION:', '-         abort();', '-         break;', '-       case RAPIER_STATE_IN_DESCRIPTION:', '-         state=RAPIER_STATE_IN_RDF;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_TYPED_NODE:', '-         state=RAPIER_STATE_IN_RDF;', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_SEQ:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_BAG:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_ALT:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_MEMBER:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_REFERENCEDITEM:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_INLINEITEM:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PROPERTYELT:', '-         finished=1;', '-         break;', '-       default:', '-         rapier_parser_fatal_error(rdf_parser, ""Unexpected parser state %d."",', '-                                   state);', '-         finished=1;', '-     if(state != element->state) {', '-       element->state=state;', '-       fprintf(stderr, ""rapier_xml_end_element_handler: moved to state %d\\n"", state);', '-     }', '-   rapier_free_ns_name(element_name);', '- rapier_xml_cdata_handler(void *userData, const XML_Char *s, int len)', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '-   if(!buffer)', '- rapier_start_namespace_decl_handler(void *userData,', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '- rapier_end_namespace_decl_handler(void *userData, const XML_Char *prefix)', '-   rapier_parser* rdf_parser=(rapier_parser*)userData;', '-   if(parser->fatal_error_fn) {', '-     parser->fatal_error_fn(parser->fatal_error_user_data,', '-                            &parser->locator, message);', '-   if(parser->error_fn) {', '-     parser->error_fn(parser->error_user_data, &parser->locator, message);', '-   if(parser->warning_fn) {', '-     parser->warning_fn(parser->warning_user_data, &parser->locator, message);', '-   if (sax != NULL)', '- rapier_parser_set_fatal_error(rapier_parser* parser, void *user_data,', '-                         void (*fatal_error_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))', '-   parser->fatal_error_fn=fatal_error_fn;', '- rapier_parser_set_error(rapier_parser* parser, void *user_data,', '-                         void (*error_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))', '-   parser->error_fn=error_fn;', '- rapier_parser_set_warning(rapier_parser* parser, void *user_data,', '-                           void (*warning_fn)(void *user_data, rapier_locator* locator, const char *msg, ...))', '-   parser->warning_fn=warning_fn;', '-                           void *userData,', '-                           void (*triple_handler)(void *userData,', '-                                                 const char *subject, rapier_subject_type subject_type,', '-                                                 const char *predicate, rapier_predicate_type predicate_type,', '-                                                 const char *object, rapier_object_type object_type))', '-   parser->triple_handler=triple_handler;', '-     LIBRDF_FREE(cstring, filename);', '-   LIBRDF_FREE(cstring, filename);']",357,238.0,595.0,5e9d6243184a5e2d20f4719966689dffa16dca9bdajobe/raptor,[]
a9b3f63084e59715da3a1dd5b365a2638aa54a1e,FFmpeg/FFmpeg,mpegvideo.c,test,C,0,"['@@ -24,6 +24,15 @@\n #include ""dsputil.h""\n #include ""mpegvideo.h""\n \n+#include ""../config.h""\n+\n+#ifdef ARCH_X86\n+#include ""i386/mpegvideo.c""\n+#endif\n+#ifndef DCT_UNQUANTIZE\n+#define DCT_UNQUANTIZE(a,b,c,d) dct_unquantize(a,b,c,d)\n+#endif\n+\n #define EDGE_WIDTH 16\n \n /* enable all paranoid tests for rounding, overflows, etc... */\n@@ -89,6 +98,9 @@ int MPV_common_init(MpegEncContext *s)\n     int c_size, i;\n     UINT8 *pict;\n \n+#if defined ( HAVE_MMX ) && defined ( BIN_PORTABILITY )\n+    MPV_common_init_mmx();\n+#endif\n     s->mb_width = (s->width + 15) / 16;\n     s->mb_height = (s->height + 15) / 16;\n     s->linesize = s->mb_width * 16 + 2 * EDGE_WIDTH;\n@@ -345,8 +357,8 @@ static void draw_edges(UINT8 *buf, int wrap, int width, int height, int w)\n     }\n }\n \n-\n /* generic function for encode/decode called before a frame is coded/decoded */\n+#ifndef ARCH_X86\n void MPV_frame_start(MpegEncContext *s)\n {\n     int i;\n@@ -366,7 +378,7 @@ void MPV_frame_start(MpegEncContext *s)\n         }\n     }\n }\n-\n+#endif\n /* generic function for encode/decode called after a frame has been coded/decoded */\n void MPV_frame_end(MpegEncContext *s)\n {\n@@ -621,7 +633,7 @@ static inline void put_dct(MpegEncContext *s,\n                            DCTELEM *block, int i, UINT8 *dest, int line_size)\n {\n     if (!s->mpeg2)\n-        dct_unquantize(s, block, i, s->qscale);\n+        DCT_UNQUANTIZE(s, block, i, s->qscale);\n     j_rev_dct (block);\n     put_pixels_clamped(block, dest, line_size);\n }\n@@ -632,7 +644,7 @@ static inline void add_dct(MpegEncContext *s,\n {\n     if (s->block_last_index[i] >= 0) {\n         if (!s->mpeg2)\n-            dct_unquantize(s, block, i, s->qscale);\n+            DCT_UNQUANTIZE(s, block, i, s->qscale);\n         j_rev_dct (block);\n         add_pixels_clamped(block, dest, line_size);\n     }\n@@ -1109,6 +1121,7 @@ static int dct_quantize_mmx(MpegEncContext *s,\n     return last_non_zero;\n }\n \n+#ifndef HAVE_DCT_UNQUANTIZE\n static void dct_unquantize(MpegEncContext *s, \n                            DCTELEM *block, int n, int qscale)\n {\n@@ -1172,7 +1185,7 @@ static void dct_unquantize(MpegEncContext *s,\n         }\n     }\n }\n-                         \n+#endif                         \n \n /* rate control */\n \n']",,,"['+ #include ""../config.h""', '+ #ifdef ARCH_X86', '+ #include ""i386/mpegvideo.c""', '+ #endif', '+ #ifndef DCT_UNQUANTIZE', '+ #define DCT_UNQUANTIZE(a,b,c,d) dct_unquantize(a,b,c,d)', '+ #endif', '+ #if defined ( HAVE_MMX ) && defined ( BIN_PORTABILITY )', '+     MPV_common_init_mmx();', '+ #endif', '+ #ifndef ARCH_X86', '+ #endif', '+         DCT_UNQUANTIZE(s, block, i, s->qscale);', '+             DCT_UNQUANTIZE(s, block, i, s->qscale);', '+ #ifndef HAVE_DCT_UNQUANTIZE', '+ #endif', '-         dct_unquantize(s, block, i, s->qscale);', '-             dct_unquantize(s, block, i, s->qscale);']","['+ #include ""../config.h""', '+ #ifdef arch_x86', '+ #include ""i386/mpegvideo.c""', '+ #endif', '+ #ifndef dct_unquantize', '+ #define dct_unquantize(a,b,c,d) dct_unquantize(a,b,c,d)', '+ #endif', '+ #if defined ( have_mmx ) && defined ( bin_portability )', '+     mpv_common_init_mmx();', '+ #endif', '+ #ifndef arch_x86', '+ #endif', '+         dct_unquantize(s, block, i, s->qscale);', '+             dct_unquantize(s, block, i, s->qscale);', '+ #ifndef have_dct_unquantize', '+ #endif', '-         dct_unquantize(s, block, i, s->qscale);', '-             dct_unquantize(s, block, i, s->qscale);']","['+ #include ""../config.h""', '+ #ifdef ARCH_X86', '+ #include ""i386/mpegvideo.c""', '+ #endif', '+ #ifndef DCT_UNQUANTIZE', '+ #define DCT_UNQUANTIZE(a,b,c,d) dct_unquantize(a,b,c,d)', '+ #endif', '+ #if defined ( HAVE_MMX ) && defined ( BIN_PORTABILITY )', '+     MPV_common_init_mmx();', '+ #endif', '+ #ifndef ARCH_X86', '+ #endif', '+         DCT_UNQUANTIZE(s, block, i, s->qscale);', '+             DCT_UNQUANTIZE(s, block, i, s->qscale);', '+ #ifndef HAVE_DCT_UNQUANTIZE', '+ #endif']","['-         dct_unquantize(s, block, i, s->qscale);', '-             dct_unquantize(s, block, i, s->qscale);']",16,2.0,18.0,a9b3f63084e59715da3a1dd5b365a2638aa54a1eFFmpeg/FFmpeg,[]
707773bb1b7bdeb04443c279705eb6d879e04fc0,file/file,src/readelf.c,train,C,1,"['@@ -38,7 +38,7 @@\n #include ""magic.h""\n \n #ifndef lint\n-FILE_RCSID(""@(#)$File: readelf.c,v 1.77 2008/08/30 17:51:09 christos Exp $"")\n+FILE_RCSID(""@(#)$File: readelf.c,v 1.78 2008/08/31 07:58:00 christos Exp $"")\n #endif\n \n #ifdef\tELFCORE\n@@ -875,7 +875,7 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \n \t\t\tnoff = 0;\n \t\t\tfor (;;) {\n-\t\t\t\tif (noff >= (size_t)xsh_size)\n+\t\t\t\tif (noff >= (off_t)xsh_size)\n \t\t\t\t\tbreak;\n \t\t\t\tnoff = donote(ms, nbuf, (size_t)noff,\n \t\t\t\t    (size_t)xsh_size, clazz, swap, 4,\n@@ -909,7 +909,7 @@ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n \t\t\t\tElf64_Cap cap64;\n \t\t\t\tchar cbuf[/*CONSTCOND*/\n \t\t\t\t    MAX(sizeof cap32, sizeof cap64)];\n-\t\t\t\tif ((coff += xcap_sizeof) >= (size_t)xsh_size)\n+\t\t\t\tif ((coff += xcap_sizeof) >= (off_t)xsh_size)\n \t\t\t\t\tbreak;\n \t\t\t\tif (read(fd, cbuf, (size_t)xcap_sizeof) !=\n \t\t\t\t    (ssize_t)xcap_sizeof) {\n']",2008-10-12 19:06:36+00:00,Deal with 64 bit machines (structure packing),"[['+ FILE_RCSID(""@(#)$File: readelf.c,v 1.78 2008/08/31 07:58:00 christos Exp $"")', '+ \t\t\t\tif (noff >= (off_t)xsh_size)', '+ \t\t\t\tif ((coff += xcap_sizeof) >= (off_t)xsh_size)', '- FILE_RCSID(""@(#)$File: readelf.c,v 1.77 2008/08/30 17:51:09 christos Exp $"")', '- \t\t\t\tif (noff >= (size_t)xsh_size)', '- \t\t\t\tif ((coff += xcap_sizeof) >= (size_t)xsh_size)']]","[['+ file_rcsid(""@(#)$file: readelf.c,v 1.78 2008/08/31 07:58:00 christos exp $"")', '+ \t\t\t\tif (noff >= (off_t)xsh_size)', '+ \t\t\t\tif ((coff += xcap_sizeof) >= (off_t)xsh_size)', '- file_rcsid(""@(#)$file: readelf.c,v 1.77 2008/08/30 17:51:09 christos exp $"")', '- \t\t\t\tif (noff >= (size_t)xsh_size)', '- \t\t\t\tif ((coff += xcap_sizeof) >= (size_t)xsh_size)']]","[['+ FILE_RCSID(""@(#)$File: readelf.c,v 1.78 2008/08/31 07:58:00 christos Exp $"")', '+ \t\t\t\tif (noff >= (off_t)xsh_size)', '+ \t\t\t\tif ((coff += xcap_sizeof) >= (off_t)xsh_size)']]","[['- FILE_RCSID(""@(#)$File: readelf.c,v 1.77 2008/08/30 17:51:09 christos Exp $"")', '- \t\t\t\tif (noff >= (size_t)xsh_size)', '- \t\t\t\tif ((coff += xcap_sizeof) >= (size_t)xsh_size)']]",3,3.0,6.0,707773bb1b7bdeb04443c279705eb6d879e04fc0file/file,['d7cdad007c507e6c79f51f058dd77fab70ceb9f6']
d09696a3bccb31d45abc1375b4016dd299557e57,LibRaw/LibRaw,src/libraw_datastream.cpp,test,C++,1,"['@@ -0,0 +1,513 @@\n+#define LIBRAW_LIBRARY_BUILD\n+#include ""libraw/libraw.h""\n+#include ""internal/defines.h""\n+#include ""libraw/libraw_datastream.h""\n+#include ""internal/libraw_bytebuffer.h""\n+\n+LibRaw_byte_buffer::LibRaw_byte_buffer(unsigned sz) \n+{ \n+    buf=0; size=sz; offt=0; do_free=0; \n+    if(size)\n+        { \n+            buf = (unsigned char*)malloc(size); do_free=1;\n+        }\n+}\n+\n+void LibRaw_byte_buffer::set_buffer(void *bb, unsigned int sz) \n+{ \n+    buf = (unsigned char*)bb; size = sz; offt=0; do_free=0;\n+}\n+\n+LibRaw_byte_buffer::~LibRaw_byte_buffer() \n+{ \n+    if(do_free) free(buf);\n+}\n+\n+LibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)\n+{\n+    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);\n+    read(ret->get_buffer(),sz,1);\n+    return ret;\n+}\n+\n+int LibRaw_abstract_datastream::tempbuffer_open(void  *buf, size_t size)\n+{\n+    if(substream) return EBUSY;\n+    substream = new LibRaw_buffer_datastream(buf,size);\n+    return substream?0:EINVAL;\n+}\n+\n+\n+void\tLibRaw_abstract_datastream::tempbuffer_close()\n+{\n+    if(substream) delete substream;\n+    substream = NULL;\n+}\n+\n+// == LibRaw_file_datastream ==\n+\n+LibRaw_file_datastream::LibRaw_file_datastream(const char *fname)\n+    :filename(fname)\n+{\n+    if (filename) {\n+        std::auto_ptr<std::filebuf> buf(new std::filebuf());\n+        buf->open(filename, std::ios_base::in | std::ios_base::binary);\n+        if (buf->is_open()) {\n+            f = buf;\n+        }\n+    }\n+}\n+ int LibRaw_file_datastream::valid()\n+{ \n+    return f.get() ? 1 : 0; \n+}\n+\n+#define LR_STREAM_CHK() do {if(!f.get()) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)\n+\n+int LibRaw_file_datastream::read(void * ptr,size_t size, size_t nmemb)\n+{\n+    if(substream) return substream->read(ptr,size,nmemb);\n+    \n+/* Visual Studio 2008 marks sgetn as insecure, but VS2010 does not. */\n+#if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)\n+    LR_STREAM_CHK(); return int(f->_Sgetn_s(static_cast<char*>(ptr), nmemb * size,nmemb * size) / size); \n+#else\n+    LR_STREAM_CHK(); return int(f->sgetn(static_cast<char*>(ptr), std::streamsize(nmemb * size)) / size); \n+#endif\n+}\n+\n+int LibRaw_file_datastream::eof() \n+{ \n+    if(substream) return substream->eof();\n+    LR_STREAM_CHK(); return f->sgetc() == EOF; \n+}\n+\n+int LibRaw_file_datastream::seek(INT64 o, int whence) \n+{ \n+    if(substream) return substream->seek(o,whence);\n+    LR_STREAM_CHK(); \n+    std::ios_base::seekdir dir;\n+    switch (whence) \n+        {\n+        case SEEK_SET: dir = std::ios_base::beg; break;\n+        case SEEK_CUR: dir = std::ios_base::cur; break;\n+        case SEEK_END: dir = std::ios_base::end; break;\n+        default: dir = std::ios_base::beg;\n+        }\n+    return (int)f->pubseekoff((long)o, dir);\n+}\n+\n+INT64 LibRaw_file_datastream::tell()     \n+{ \n+    if(substream) return substream->tell();\n+    LR_STREAM_CHK(); return f->pubseekoff(0, std::ios_base::cur);  \n+}\n+\n+char* LibRaw_file_datastream::gets(char *str, int sz) \n+{ \n+    if(substream) return substream->gets(str,sz);\n+    LR_STREAM_CHK(); \n+    std::istream is(f.get());\n+    is.getline(str, sz);\n+    if (is.fail()) return 0;\n+    return str;\n+}\n+\n+int LibRaw_file_datastream::scanf_one(const char *fmt, void*val) \n+{ \n+    if(substream) return substream->scanf_one(fmt,val);\n+    LR_STREAM_CHK(); \n+    \n+    std::istream is(f.get());\n+    \n+    /* HUGE ASSUMPTION: *fmt is either ""%d"" or ""%f"" */\n+    if (strcmp(fmt, ""%d"") == 0) {\n+        int d;\n+        is >> d;\n+        if (is.fail()) return EOF;\n+        *(static_cast<int*>(val)) = d;\n+    } else {\n+        float f;\n+        is >> f;\n+        if (is.fail()) return EOF;\n+        *(static_cast<float*>(val)) = f;\n+    }\n+    \n+    return 1;\n+}\n+\n+const char* LibRaw_file_datastream::fname() \n+{ \n+    return filename; \n+}\n+    \n+/* You can\'t have a ""subfile"" and a ""tempfile"" at the same time. */\n+int LibRaw_file_datastream::subfile_open(const char *fn)\n+{\n+    LR_STREAM_CHK();\n+    if (saved_f.get()) return EBUSY;\n+    saved_f = f;\n+        std::auto_ptr<std::filebuf> buf(new std::filebuf());\n+        \n+        buf->open(fn, std::ios_base::in | std::ios_base::binary);\n+        if (!buf->is_open()) {\n+            f = saved_f;\n+            return ENOENT;\n+        } else {\n+            f = buf;\n+        }\n+        \n+        return 0;\n+}\n+\n+\n+void LibRaw_file_datastream::subfile_close()\n+{ \n+    if (!saved_f.get()) return; \n+    f = saved_f;   \n+}\n+\n+#undef LR_STREAM_CHK\n+\n+void * LibRaw_file_datastream::make_jas_stream()\n+{\n+#ifdef NO_JASPER\n+    return NULL;\n+#else\n+    return jas_stream_fopen(fname(),""rb"");\n+#endif\n+}\n+\n+// == LibRaw_buffer_datastream\n+LibRaw_buffer_datastream::LibRaw_buffer_datastream(void *buffer, size_t bsize)\n+{    \n+    buf = (unsigned char*)buffer; streampos = 0; streamsize = bsize;\n+}\n+\n+LibRaw_buffer_datastream::~LibRaw_buffer_datastream(){}\n+\n+int LibRaw_buffer_datastream::read(void * ptr,size_t sz, size_t nmemb)\n+{ \n+    if(substream) return substream->read(ptr,sz,nmemb);\n+    size_t to_read = sz*nmemb;\n+    if(to_read > streamsize - streampos)\n+        to_read = streamsize-streampos;\n+    if(to_read<1) \n+        return 0;\n+    memmove(ptr,buf+streampos,to_read);\n+    streampos+=to_read;\n+    return int((to_read+sz-1)/sz);\n+}\n+\n+int LibRaw_buffer_datastream::seek(INT64 o, int whence)\n+{ \n+    if(substream) return substream->seek(o,whence);\n+    switch(whence)\n+        {\n+        case SEEK_SET:\n+            if(o<0)\n+                streampos = 0;\n+            else if (size_t(o) > streamsize)\n+                streampos = streamsize;\n+            else\n+                streampos = size_t(o);\n+            return 0;\n+        case SEEK_CUR:\n+            if(o<0)\n+                {\n+                    if(size_t(-o) >= streampos)\n+                        streampos = 0;\n+                    else\n+                        streampos += (size_t)o;\n+                }\n+            else if (o>0)\n+                {\n+                    if(o+streampos> streamsize)\n+                        streampos = streamsize;\n+                    else\n+                        streampos += (size_t)o;\n+                }\n+            return 0;\n+        case SEEK_END:\n+            if(o>0)\n+                streampos = streamsize;\n+            else if ( size_t(-o) > streamsize)\n+                streampos = 0;\n+            else\n+                streampos = streamsize+(size_t)o;\n+            return 0;\n+        default:\n+            return 0;\n+        }\n+}\n+\n+INT64 LibRaw_buffer_datastream::tell()\n+{ \n+    if(substream) return substream->tell();\n+    return INT64(streampos);\n+}\n+\n+char* LibRaw_buffer_datastream::gets(char *s, int sz)\n+{ \n+    if (substream) return substream->gets(s,sz);\n+    unsigned char *psrc,*pdest,*str;\n+    str = (unsigned char *)s;\n+    psrc = buf+streampos;\n+    pdest = str;\n+    while ( (size_t(psrc - buf) < streamsize)\n+            &&\n+            ((pdest-str)<sz)\n+        )\n+        {\n+            *pdest = *psrc;\n+            if(*psrc == \'\\n\')\n+                break;\n+            psrc++;\n+            pdest++;\n+        }\n+    if(size_t(psrc-buf) < streamsize)\n+        psrc++;\n+    if((pdest-str)<sz)\n+        *(++pdest)=0;\n+    streampos = psrc - buf;\n+    return s;\n+}\n+\n+int LibRaw_buffer_datastream::scanf_one(const char *fmt, void* val)\n+{ \n+    if(substream) return substream->scanf_one(fmt,val);\n+    int scanf_res;\n+    if(streampos>streamsize) return 0;\n+#ifndef WIN32SECURECALLS\n+    scanf_res = sscanf((char*)(buf+streampos),fmt,val);\n+#else\n+    scanf_res = sscanf_s((char*)(buf+streampos),fmt,val);\n+#endif\n+    if(scanf_res>0)\n+        {\n+            int xcnt=0;\n+            while(streampos<streamsize)\n+                {\n+                    streampos++;\n+                    xcnt++;\n+                    if(buf[streampos] == 0\n+                       || buf[streampos]==\' \'\n+                       || buf[streampos]==\'\\t\'\n+                       || buf[streampos]==\'\\n\'\n+                       || xcnt>24)\n+                        break;\n+                }\n+        }\n+    return scanf_res;\n+}\n+\n+LibRaw_byte_buffer *LibRaw_buffer_datastream::make_byte_buffer(unsigned int sz)\n+{\n+    LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(0);\n+    if(streampos + sz > streamsize)\n+        sz = streamsize - streampos;\n+    ret->set_buffer(buf+streampos,sz);\n+    return ret;\n+}\n+\n+int LibRaw_buffer_datastream::eof()\n+{ \n+    if(substream) return substream->eof();\n+    return streampos >= streamsize;\n+}\n+ int LibRaw_buffer_datastream::valid() \n+{ \n+    return buf?1:0;\n+}\n+\n+\n+void * LibRaw_buffer_datastream::make_jas_stream()\n+{\n+#ifdef NO_JASPER\n+    return NULL;\n+#else\n+    return jas_stream_memopen((char*)buf,streamsize);\n+#endif\n+}\n+\n+// == LibRaw_bigfile_datastream\n+LibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const char *fname)\n+{ \n+    if(fname)\n+        {\n+            filename = fname; \n+#ifndef WIN32SECURECALLS\n+            f = fopen(fname,""rb"");\n+#else\n+            if(fopen_s(&f,fname,""rb""))\n+                f = 0;\n+#endif\n+        }\n+    else \n+        {filename=0;f=0;}\n+    sav=0;\n+}\n+\n+LibRaw_bigfile_datastream::~LibRaw_bigfile_datastream() {if(f)fclose(f); if(sav)fclose(sav);}\n+int         LibRaw_bigfile_datastream::valid() { return f?1:0;}\n+\n+#define LR_BF_CHK() do {if(!f) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)\n+\n+int LibRaw_bigfile_datastream::read(void * ptr,size_t size, size_t nmemb) \n+{ \n+    LR_BF_CHK(); \n+    return substream?substream->read(ptr,size,nmemb):int(fread(ptr,size,nmemb,f));\n+}\n+\n+int LibRaw_bigfile_datastream::eof()\n+{ \n+    LR_BF_CHK(); \n+    return substream?substream->eof():feof(f);\n+}\n+\n+int     LibRaw_bigfile_datastream:: seek(INT64 o, int whence)\n+{ \n+    LR_BF_CHK(); \n+#if defined (WIN32) \n+#ifdef WIN32SECURECALLS\n+    return substream?substream->seek(o,whence):_fseeki64(f,o,whence);\n+#else\n+    return substream?substream->seek(o,whence):fseek(f,(long)o,whence);\n+#endif\n+#else\n+    return substream?substream->seek(o,whence):fseeko(f,o,whence);\n+#endif\n+}\n+\n+INT64 LibRaw_bigfile_datastream::tell()\n+{ \n+    LR_BF_CHK(); \n+#if defined (WIN32)\n+#ifdef WIN32SECURECALLS\n+    return substream?substream->tell():_ftelli64(f);\n+#else\n+    return substream?substream->tell():ftell(f);\n+#endif\n+#else\n+    return substream?substream->tell():ftello(f);\n+#endif\n+}\n+\n+char* LibRaw_bigfile_datastream::gets(char *str, int sz)\n+{ \n+    LR_BF_CHK(); \n+    return substream?substream->gets(str,sz):fgets(str,sz,f);\n+}\n+\n+int LibRaw_bigfile_datastream::scanf_one(const char *fmt, void*val)\n+{ \n+    LR_BF_CHK(); \n+    return substream?substream->scanf_one(fmt,val):\n+#ifndef WIN32SECURECALLS\t\t\t\n+        fscanf(f,fmt,val)\n+#else\n+        fscanf_s(f,fmt,val)\n+#endif\n+        ;\n+}\n+\n+const char *LibRaw_bigfile_datastream::fname() \n+{ \n+    return filename; \n+}\n+\n+int LibRaw_bigfile_datastream::subfile_open(const char *fn)\n+{\n+    if(sav) return EBUSY;\n+    sav = f;\n+#ifndef WIN32SECURECALLS\n+    f = fopen(fn,""rb"");\n+#else\n+    fopen_s(&f,fn,""rb"");\n+#endif\n+    if(!f)\n+        {\n+            f = sav;\n+            sav = NULL;\n+            return ENOENT;\n+        }\n+    else\n+        return 0;\n+}\n+\n+void LibRaw_bigfile_datastream::subfile_close()\n+{\n+    if(!sav) return;\n+    fclose(f);\n+    f = sav;\n+    sav = 0;\n+}\n+\n+\n+void *LibRaw_bigfile_datastream::make_jas_stream()\n+{\n+#ifdef NO_JASPER\n+    return NULL;\n+#else\n+    return jas_stream_freopen(fname(),""rb"",f);\n+#endif\n+}\n+\n+// == LibRaw_windows_datastream\n+#ifdef WIN32\n+\n+LibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR* sFile)\n+    : LibRaw_buffer_datastream(NULL, 0)\n+    , hMap_(0)\n+    , pView_(NULL)\n+{\n+    HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n+    if (hFile == INVALID_HANDLE_VALUE) \n+        throw std::runtime_error(""failed to open the file""); \n+    \n+    try { Open(hFile); \t}\tcatch(...) { CloseHandle(hFile); throw; }\n+    \n+    CloseHandle(hFile);\t\t// windows will defer the actual closing of this handle until the hMap_ is closed\n+    reconstruct_base();\n+}\n+\n+\t// ctor: construct with a file handle - caller is responsible for closing the file handle\n+LibRaw_windows_datastream::LibRaw_windows_datastream(HANDLE hFile)\n+    : LibRaw_buffer_datastream(NULL, 0)\n+    , hMap_(0)\n+    , pView_(NULL)\n+{\n+    Open(hFile);\n+    reconstruct_base();\n+}\n+\n+// dtor: unmap and close the mapping handle\n+LibRaw_windows_datastream::~LibRaw_windows_datastream()\n+{\n+    if (pView_ != NULL)\n+        ::UnmapViewOfFile(pView_);\n+    \n+    if (hMap_ != 0)\n+        ::CloseHandle(hMap_);\n+}\n+\n+void LibRaw_windows_datastream::Open(HANDLE hFile)\n+{\n+    // create a file mapping handle on the file handle\n+    hMap_ = ::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);\n+    if (hMap_ == NULL)\tthrow std::runtime_error(""failed to create file mapping""); \n+    \n+    // now map the whole file base view\n+    if (!::GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbView_))\n+        throw std::runtime_error(""failed to get the file size""); \n+    \n+    pView_ = ::MapViewOfFile(hMap_, FILE_MAP_READ, 0, 0, (size_t)cbView_);\n+    if (pView_ == NULL)\t\n+        throw std::runtime_error(""failed to map the file""); \n+}\n+\n+\n+#endif\n+\n+\n+    \n']",2011-08-12 15:58:30+04:00,LibRaw_datastream functions are moved to separate file,"[['+ #define LIBRAW_LIBRARY_BUILD', '+ #include ""libraw/libraw.h""', '+ #include ""internal/defines.h""', '+ #include ""libraw/libraw_datastream.h""', '+ #include ""internal/libraw_bytebuffer.h""', '+ ', '+ LibRaw_byte_buffer::LibRaw_byte_buffer(unsigned sz)', '+ {', '+     buf=0; size=sz; offt=0; do_free=0;', '+     if(size)', '+         {', '+             buf = (unsigned char*)malloc(size); do_free=1;', '+         }', '+ }', '+ ', '+ void LibRaw_byte_buffer::set_buffer(void *bb, unsigned int sz)', '+ {', '+     buf = (unsigned char*)bb; size = sz; offt=0; do_free=0;', '+ }', '+ ', '+ LibRaw_byte_buffer::~LibRaw_byte_buffer()', '+ {', '+     if(do_free) free(buf);', '+ }', '+ ', '+ LibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)', '+ {', '+     LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);', '+     read(ret->get_buffer(),sz,1);', '+     return ret;', '+ }', '+ ', '+ int LibRaw_abstract_datastream::tempbuffer_open(void  *buf, size_t size)', '+ {', '+     if(substream) return EBUSY;', '+     substream = new LibRaw_buffer_datastream(buf,size);', '+     return substream?0:EINVAL;', '+ }', '+ ', '+ ', '+ void\tLibRaw_abstract_datastream::tempbuffer_close()', '+ {', '+     if(substream) delete substream;', '+     substream = NULL;', '+ }', '+ ', '+ ', '+ LibRaw_file_datastream::LibRaw_file_datastream(const char *fname)', '+     :filename(fname)', '+ {', '+     if (filename) {', '+         std::auto_ptr<std::filebuf> buf(new std::filebuf());', '+         buf->open(filename, std::ios_base::in | std::ios_base::binary);', '+         if (buf->is_open()) {', '+             f = buf;', '+         }', '+     }', '+ }', '+  int LibRaw_file_datastream::valid()', '+ {', '+     return f.get() ? 1 : 0;', '+ }', '+ ', '+ #define LR_STREAM_CHK() do {if(!f.get()) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)', '+ ', '+ int LibRaw_file_datastream::read(void * ptr,size_t size, size_t nmemb)', '+ {', '+     if(substream) return substream->read(ptr,size,nmemb);', '+ ', '+ #if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)', '+     LR_STREAM_CHK(); return int(f->_Sgetn_s(static_cast<char*>(ptr), nmemb * size,nmemb * size) / size);', '+ #else', '+     LR_STREAM_CHK(); return int(f->sgetn(static_cast<char*>(ptr), std::streamsize(nmemb * size)) / size);', '+ #endif', '+ }', '+ ', '+ int LibRaw_file_datastream::eof()', '+ {', '+     if(substream) return substream->eof();', '+     LR_STREAM_CHK(); return f->sgetc() == EOF;', '+ }', '+ ', '+ int LibRaw_file_datastream::seek(INT64 o, int whence)', '+ {', '+     if(substream) return substream->seek(o,whence);', '+     LR_STREAM_CHK();', '+     std::ios_base::seekdir dir;', '+     switch (whence)', '+         {', '+         case SEEK_SET: dir = std::ios_base::beg; break;', '+         case SEEK_CUR: dir = std::ios_base::cur; break;', '+         case SEEK_END: dir = std::ios_base::end; break;', '+         default: dir = std::ios_base::beg;', '+         }', '+     return (int)f->pubseekoff((long)o, dir);', '+ }', '+ ', '+ INT64 LibRaw_file_datastream::tell()', '+ {', '+     if(substream) return substream->tell();', '+     LR_STREAM_CHK(); return f->pubseekoff(0, std::ios_base::cur);', '+ }', '+ ', '+ char* LibRaw_file_datastream::gets(char *str, int sz)', '+ {', '+     if(substream) return substream->gets(str,sz);', '+     LR_STREAM_CHK();', '+     std::istream is(f.get());', '+     is.getline(str, sz);', '+     if (is.fail()) return 0;', '+     return str;', '+ }', '+ ', '+ int LibRaw_file_datastream::scanf_one(const char *fmt, void*val)', '+ {', '+     if(substream) return substream->scanf_one(fmt,val);', '+     LR_STREAM_CHK();', '+ ', '+     std::istream is(f.get());', '+ ', '+     if (strcmp(fmt, ""%d"") == 0) {', '+         int d;', '+         is >> d;', '+         if (is.fail()) return EOF;', '+         *(static_cast<int*>(val)) = d;', '+     } else {', '+         float f;', '+         is >> f;', '+         if (is.fail()) return EOF;', '+         *(static_cast<float*>(val)) = f;', '+     }', '+ ', '+     return 1;', '+ }', '+ ', '+ const char* LibRaw_file_datastream::fname()', '+ {', '+     return filename;', '+ }', '+ ', '+ int LibRaw_file_datastream::subfile_open(const char *fn)', '+ {', '+     LR_STREAM_CHK();', '+     if (saved_f.get()) return EBUSY;', '+     saved_f = f;', '+         std::auto_ptr<std::filebuf> buf(new std::filebuf());', '+ ', '+         buf->open(fn, std::ios_base::in | std::ios_base::binary);', '+         if (!buf->is_open()) {', '+             f = saved_f;', '+             return ENOENT;', '+         } else {', '+             f = buf;', '+         }', '+ ', '+         return 0;', '+ }', '+ ', '+ ', '+ void LibRaw_file_datastream::subfile_close()', '+ {', '+     if (!saved_f.get()) return;', '+     f = saved_f;', '+ }', '+ ', '+ #undef LR_STREAM_CHK', '+ ', '+ void * LibRaw_file_datastream::make_jas_stream()', '+ {', '+ #ifdef NO_JASPER', '+     return NULL;', '+ #else', '+     return jas_stream_fopen(fname(),""rb"");', '+ #endif', '+ }', '+ ', '+ LibRaw_buffer_datastream::LibRaw_buffer_datastream(void *buffer, size_t bsize)', '+ {', '+     buf = (unsigned char*)buffer; streampos = 0; streamsize = bsize;', '+ }', '+ ', '+ LibRaw_buffer_datastream::~LibRaw_buffer_datastream(){}', '+ ', '+ int LibRaw_buffer_datastream::read(void * ptr,size_t sz, size_t nmemb)', '+ {', '+     if(substream) return substream->read(ptr,sz,nmemb);', '+     size_t to_read = sz*nmemb;', '+     if(to_read > streamsize - streampos)', '+         to_read = streamsize-streampos;', '+     if(to_read<1)', '+         return 0;', '+     memmove(ptr,buf+streampos,to_read);', '+     streampos+=to_read;', '+     return int((to_read+sz-1)/sz);', '+ }', '+ ', '+ int LibRaw_buffer_datastream::seek(INT64 o, int whence)', '+ {', '+     if(substream) return substream->seek(o,whence);', '+     switch(whence)', '+         {', '+         case SEEK_SET:', '+             if(o<0)', '+                 streampos = 0;', '+             else if (size_t(o) > streamsize)', '+                 streampos = streamsize;', '+             else', '+                 streampos = size_t(o);', '+             return 0;', '+         case SEEK_CUR:', '+             if(o<0)', '+                 {', '+                     if(size_t(-o) >= streampos)', '+                         streampos = 0;', '+                     else', '+                         streampos += (size_t)o;', '+                 }', '+             else if (o>0)', '+                 {', '+                     if(o+streampos> streamsize)', '+                         streampos = streamsize;', '+                     else', '+                         streampos += (size_t)o;', '+                 }', '+             return 0;', '+         case SEEK_END:', '+             if(o>0)', '+                 streampos = streamsize;', '+             else if ( size_t(-o) > streamsize)', '+                 streampos = 0;', '+             else', '+                 streampos = streamsize+(size_t)o;', '+             return 0;', '+         default:', '+             return 0;', '+         }', '+ }', '+ ', '+ INT64 LibRaw_buffer_datastream::tell()', '+ {', '+     if(substream) return substream->tell();', '+     return INT64(streampos);', '+ }', '+ ', '+ char* LibRaw_buffer_datastream::gets(char *s, int sz)', '+ {', '+     if (substream) return substream->gets(s,sz);', '+     unsigned char *psrc,*pdest,*str;', '+     str = (unsigned char *)s;', '+     psrc = buf+streampos;', '+     pdest = str;', '+     while ( (size_t(psrc - buf) < streamsize)', '+             &&', '+             ((pdest-str)<sz)', '+         )', '+         {', '+             *pdest = *psrc;', ""+             if(*psrc == '\\n')"", '+                 break;', '+             psrc++;', '+             pdest++;', '+         }', '+     if(size_t(psrc-buf) < streamsize)', '+         psrc++;', '+     if((pdest-str)<sz)', '+         *(++pdest)=0;', '+     streampos = psrc - buf;', '+     return s;', '+ }', '+ ', '+ int LibRaw_buffer_datastream::scanf_one(const char *fmt, void* val)', '+ {', '+     if(substream) return substream->scanf_one(fmt,val);', '+     int scanf_res;', '+     if(streampos>streamsize) return 0;', '+ #ifndef WIN32SECURECALLS', '+     scanf_res = sscanf((char*)(buf+streampos),fmt,val);', '+ #else', '+     scanf_res = sscanf_s((char*)(buf+streampos),fmt,val);', '+ #endif', '+     if(scanf_res>0)', '+         {', '+             int xcnt=0;', '+             while(streampos<streamsize)', '+                 {', '+                     streampos++;', '+                     xcnt++;', '+                     if(buf[streampos] == 0', ""+                        || buf[streampos]==' '"", ""+                        || buf[streampos]=='\\t'"", ""+                        || buf[streampos]=='\\n'"", '+                        || xcnt>24)', '+                         break;', '+                 }', '+         }', '+     return scanf_res;', '+ }', '+ ', '+ LibRaw_byte_buffer *LibRaw_buffer_datastream::make_byte_buffer(unsigned int sz)', '+ {', '+     LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(0);', '+     if(streampos + sz > streamsize)', '+         sz = streamsize - streampos;', '+     ret->set_buffer(buf+streampos,sz);', '+     return ret;', '+ }', '+ ', '+ int LibRaw_buffer_datastream::eof()', '+ {', '+     if(substream) return substream->eof();', '+     return streampos >= streamsize;', '+ }', '+  int LibRaw_buffer_datastream::valid()', '+ {', '+     return buf?1:0;', '+ }', '+ ', '+ ', '+ void * LibRaw_buffer_datastream::make_jas_stream()', '+ {', '+ #ifdef NO_JASPER', '+     return NULL;', '+ #else', '+     return jas_stream_memopen((char*)buf,streamsize);', '+ #endif', '+ }', '+ ', '+ LibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const char *fname)', '+ {', '+     if(fname)', '+         {', '+             filename = fname;', '+ #ifndef WIN32SECURECALLS', '+             f = fopen(fname,""rb"");', '+ #else', '+             if(fopen_s(&f,fname,""rb""))', '+                 f = 0;', '+ #endif', '+         }', '+     else', '+         {filename=0;f=0;}', '+     sav=0;', '+ }', '+ ', '+ LibRaw_bigfile_datastream::~LibRaw_bigfile_datastream() {if(f)fclose(f); if(sav)fclose(sav);}', '+ int         LibRaw_bigfile_datastream::valid() { return f?1:0;}', '+ ', '+ #define LR_BF_CHK() do {if(!f) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)', '+ ', '+ int LibRaw_bigfile_datastream::read(void * ptr,size_t size, size_t nmemb)', '+ {', '+     LR_BF_CHK();', '+     return substream?substream->read(ptr,size,nmemb):int(fread(ptr,size,nmemb,f));', '+ }', '+ ', '+ int LibRaw_bigfile_datastream::eof()', '+ {', '+     LR_BF_CHK();', '+     return substream?substream->eof():feof(f);', '+ }', '+ ', '+ int     LibRaw_bigfile_datastream:: seek(INT64 o, int whence)', '+ {', '+     LR_BF_CHK();', '+ #if defined (WIN32)', '+ #ifdef WIN32SECURECALLS', '+     return substream?substream->seek(o,whence):_fseeki64(f,o,whence);', '+ #else', '+     return substream?substream->seek(o,whence):fseek(f,(long)o,whence);', '+ #endif', '+ #else', '+     return substream?substream->seek(o,whence):fseeko(f,o,whence);', '+ #endif', '+ }', '+ ', '+ INT64 LibRaw_bigfile_datastream::tell()', '+ {', '+     LR_BF_CHK();', '+ #if defined (WIN32)', '+ #ifdef WIN32SECURECALLS', '+     return substream?substream->tell():_ftelli64(f);', '+ #else', '+     return substream?substream->tell():ftell(f);', '+ #endif', '+ #else', '+     return substream?substream->tell():ftello(f);', '+ #endif', '+ }', '+ ', '+ char* LibRaw_bigfile_datastream::gets(char *str, int sz)', '+ {', '+     LR_BF_CHK();', '+     return substream?substream->gets(str,sz):fgets(str,sz,f);', '+ }', '+ ', '+ int LibRaw_bigfile_datastream::scanf_one(const char *fmt, void*val)', '+ {', '+     LR_BF_CHK();', '+     return substream?substream->scanf_one(fmt,val):', '+ #ifndef WIN32SECURECALLS', '+         fscanf(f,fmt,val)', '+ #else', '+         fscanf_s(f,fmt,val)', '+ #endif', '+         ;', '+ }', '+ ', '+ const char *LibRaw_bigfile_datastream::fname()', '+ {', '+     return filename;', '+ }', '+ ', '+ int LibRaw_bigfile_datastream::subfile_open(const char *fn)', '+ {', '+     if(sav) return EBUSY;', '+     sav = f;', '+ #ifndef WIN32SECURECALLS', '+     f = fopen(fn,""rb"");', '+ #else', '+     fopen_s(&f,fn,""rb"");', '+ #endif', '+     if(!f)', '+         {', '+             f = sav;', '+             sav = NULL;', '+             return ENOENT;', '+         }', '+     else', '+         return 0;', '+ }', '+ ', '+ void LibRaw_bigfile_datastream::subfile_close()', '+ {', '+     if(!sav) return;', '+     fclose(f);', '+     f = sav;', '+     sav = 0;', '+ }', '+ ', '+ ', '+ void *LibRaw_bigfile_datastream::make_jas_stream()', '+ {', '+ #ifdef NO_JASPER', '+     return NULL;', '+ #else', '+     return jas_stream_freopen(fname(),""rb"",f);', '+ #endif', '+ }', '+ ', '+ #ifdef WIN32', '+ ', '+ LibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR* sFile)', '+     : LibRaw_buffer_datastream(NULL, 0)', '+     , hMap_(0)', '+     , pView_(NULL)', '+ {', '+     HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);', '+     if (hFile == INVALID_HANDLE_VALUE)', '+         throw std::runtime_error(""failed to open the file"");', '+ ', '+     try { Open(hFile); \t}\tcatch(...) { CloseHandle(hFile); throw; }', '+ ', '+     reconstruct_base();', '+ }', '+ ', '+ LibRaw_windows_datastream::LibRaw_windows_datastream(HANDLE hFile)', '+     : LibRaw_buffer_datastream(NULL, 0)', '+     , hMap_(0)', '+     , pView_(NULL)', '+ {', '+     Open(hFile);', '+     reconstruct_base();', '+ }', '+ ', '+ LibRaw_windows_datastream::~LibRaw_windows_datastream()', '+ {', '+     if (pView_ != NULL)', '+         ::UnmapViewOfFile(pView_);', '+ ', '+     if (hMap_ != 0)', '+         ::CloseHandle(hMap_);', '+ }', '+ ', '+ void LibRaw_windows_datastream::Open(HANDLE hFile)', '+ {', '+     hMap_ = ::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);', '+     if (hMap_ == NULL)\tthrow std::runtime_error(""failed to create file mapping"");', '+ ', '+     if (!::GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbView_))', '+         throw std::runtime_error(""failed to get the file size"");', '+ ', '+     pView_ = ::MapViewOfFile(hMap_, FILE_MAP_READ, 0, 0, (size_t)cbView_);', '+     if (pView_ == NULL)', '+         throw std::runtime_error(""failed to map the file"");', '+ }', '+ ', '+ ', '+ #endif', '+ ', '+ ', '+ ']]","[['+ #define libraw_library_build', '+ #include ""libraw/libraw.h""', '+ #include ""internal/defines.h""', '+ #include ""libraw/libraw_datastream.h""', '+ #include ""internal/libraw_bytebuffer.h""', '+ ', '+ libraw_byte_buffer::libraw_byte_buffer(unsigned sz)', '+ {', '+     buf=0; size=sz; offt=0; do_free=0;', '+     if(size)', '+         {', '+             buf = (unsigned char*)malloc(size); do_free=1;', '+         }', '+ }', '+ ', '+ void libraw_byte_buffer::set_buffer(void *bb, unsigned int sz)', '+ {', '+     buf = (unsigned char*)bb; size = sz; offt=0; do_free=0;', '+ }', '+ ', '+ libraw_byte_buffer::~libraw_byte_buffer()', '+ {', '+     if(do_free) free(buf);', '+ }', '+ ', '+ libraw_byte_buffer *libraw_abstract_datastream::make_byte_buffer(unsigned int sz)', '+ {', '+     libraw_byte_buffer *ret = new libraw_byte_buffer(sz);', '+     read(ret->get_buffer(),sz,1);', '+     return ret;', '+ }', '+ ', '+ int libraw_abstract_datastream::tempbuffer_open(void  *buf, size_t size)', '+ {', '+     if(substream) return ebusy;', '+     substream = new libraw_buffer_datastream(buf,size);', '+     return substream?0:einval;', '+ }', '+ ', '+ ', '+ void\tlibraw_abstract_datastream::tempbuffer_close()', '+ {', '+     if(substream) delete substream;', '+     substream = null;', '+ }', '+ ', '+ ', '+ libraw_file_datastream::libraw_file_datastream(const char *fname)', '+     :filename(fname)', '+ {', '+     if (filename) {', '+         std::auto_ptr<std::filebuf> buf(new std::filebuf());', '+         buf->open(filename, std::ios_base::in | std::ios_base::binary);', '+         if (buf->is_open()) {', '+             f = buf;', '+         }', '+     }', '+ }', '+  int libraw_file_datastream::valid()', '+ {', '+     return f.get() ? 1 : 0;', '+ }', '+ ', '+ #define lr_stream_chk() do {if(!f.get()) throw libraw_exception_io_eof;}while(0)', '+ ', '+ int libraw_file_datastream::read(void * ptr,size_t size, size_t nmemb)', '+ {', '+     if(substream) return substream->read(ptr,size,nmemb);', '+ ', '+ #if defined(win32securecalls) && (_msc_ver < 1600)', '+     lr_stream_chk(); return int(f->_sgetn_s(static_cast<char*>(ptr), nmemb * size,nmemb * size) / size);', '+ #else', '+     lr_stream_chk(); return int(f->sgetn(static_cast<char*>(ptr), std::streamsize(nmemb * size)) / size);', '+ #endif', '+ }', '+ ', '+ int libraw_file_datastream::eof()', '+ {', '+     if(substream) return substream->eof();', '+     lr_stream_chk(); return f->sgetc() == eof;', '+ }', '+ ', '+ int libraw_file_datastream::seek(int64 o, int whence)', '+ {', '+     if(substream) return substream->seek(o,whence);', '+     lr_stream_chk();', '+     std::ios_base::seekdir dir;', '+     switch (whence)', '+         {', '+         case seek_set: dir = std::ios_base::beg; break;', '+         case seek_cur: dir = std::ios_base::cur; break;', '+         case seek_end: dir = std::ios_base::end; break;', '+         default: dir = std::ios_base::beg;', '+         }', '+     return (int)f->pubseekoff((long)o, dir);', '+ }', '+ ', '+ int64 libraw_file_datastream::tell()', '+ {', '+     if(substream) return substream->tell();', '+     lr_stream_chk(); return f->pubseekoff(0, std::ios_base::cur);', '+ }', '+ ', '+ char* libraw_file_datastream::gets(char *str, int sz)', '+ {', '+     if(substream) return substream->gets(str,sz);', '+     lr_stream_chk();', '+     std::istream is(f.get());', '+     is.getline(str, sz);', '+     if (is.fail()) return 0;', '+     return str;', '+ }', '+ ', '+ int libraw_file_datastream::scanf_one(const char *fmt, void*val)', '+ {', '+     if(substream) return substream->scanf_one(fmt,val);', '+     lr_stream_chk();', '+ ', '+     std::istream is(f.get());', '+ ', '+     if (strcmp(fmt, ""%d"") == 0) {', '+         int d;', '+         is >> d;', '+         if (is.fail()) return eof;', '+         *(static_cast<int*>(val)) = d;', '+     } else {', '+         float f;', '+         is >> f;', '+         if (is.fail()) return eof;', '+         *(static_cast<float*>(val)) = f;', '+     }', '+ ', '+     return 1;', '+ }', '+ ', '+ const char* libraw_file_datastream::fname()', '+ {', '+     return filename;', '+ }', '+ ', '+ int libraw_file_datastream::subfile_open(const char *fn)', '+ {', '+     lr_stream_chk();', '+     if (saved_f.get()) return ebusy;', '+     saved_f = f;', '+         std::auto_ptr<std::filebuf> buf(new std::filebuf());', '+ ', '+         buf->open(fn, std::ios_base::in | std::ios_base::binary);', '+         if (!buf->is_open()) {', '+             f = saved_f;', '+             return enoent;', '+         } else {', '+             f = buf;', '+         }', '+ ', '+         return 0;', '+ }', '+ ', '+ ', '+ void libraw_file_datastream::subfile_close()', '+ {', '+     if (!saved_f.get()) return;', '+     f = saved_f;', '+ }', '+ ', '+ #undef lr_stream_chk', '+ ', '+ void * libraw_file_datastream::make_jas_stream()', '+ {', '+ #ifdef no_jasper', '+     return null;', '+ #else', '+     return jas_stream_fopen(fname(),""rb"");', '+ #endif', '+ }', '+ ', '+ libraw_buffer_datastream::libraw_buffer_datastream(void *buffer, size_t bsize)', '+ {', '+     buf = (unsigned char*)buffer; streampos = 0; streamsize = bsize;', '+ }', '+ ', '+ libraw_buffer_datastream::~libraw_buffer_datastream(){}', '+ ', '+ int libraw_buffer_datastream::read(void * ptr,size_t sz, size_t nmemb)', '+ {', '+     if(substream) return substream->read(ptr,sz,nmemb);', '+     size_t to_read = sz*nmemb;', '+     if(to_read > streamsize - streampos)', '+         to_read = streamsize-streampos;', '+     if(to_read<1)', '+         return 0;', '+     memmove(ptr,buf+streampos,to_read);', '+     streampos+=to_read;', '+     return int((to_read+sz-1)/sz);', '+ }', '+ ', '+ int libraw_buffer_datastream::seek(int64 o, int whence)', '+ {', '+     if(substream) return substream->seek(o,whence);', '+     switch(whence)', '+         {', '+         case seek_set:', '+             if(o<0)', '+                 streampos = 0;', '+             else if (size_t(o) > streamsize)', '+                 streampos = streamsize;', '+             else', '+                 streampos = size_t(o);', '+             return 0;', '+         case seek_cur:', '+             if(o<0)', '+                 {', '+                     if(size_t(-o) >= streampos)', '+                         streampos = 0;', '+                     else', '+                         streampos += (size_t)o;', '+                 }', '+             else if (o>0)', '+                 {', '+                     if(o+streampos> streamsize)', '+                         streampos = streamsize;', '+                     else', '+                         streampos += (size_t)o;', '+                 }', '+             return 0;', '+         case seek_end:', '+             if(o>0)', '+                 streampos = streamsize;', '+             else if ( size_t(-o) > streamsize)', '+                 streampos = 0;', '+             else', '+                 streampos = streamsize+(size_t)o;', '+             return 0;', '+         default:', '+             return 0;', '+         }', '+ }', '+ ', '+ int64 libraw_buffer_datastream::tell()', '+ {', '+     if(substream) return substream->tell();', '+     return int64(streampos);', '+ }', '+ ', '+ char* libraw_buffer_datastream::gets(char *s, int sz)', '+ {', '+     if (substream) return substream->gets(s,sz);', '+     unsigned char *psrc,*pdest,*str;', '+     str = (unsigned char *)s;', '+     psrc = buf+streampos;', '+     pdest = str;', '+     while ( (size_t(psrc - buf) < streamsize)', '+             &&', '+             ((pdest-str)<sz)', '+         )', '+         {', '+             *pdest = *psrc;', ""+             if(*psrc == '\\n')"", '+                 break;', '+             psrc++;', '+             pdest++;', '+         }', '+     if(size_t(psrc-buf) < streamsize)', '+         psrc++;', '+     if((pdest-str)<sz)', '+         *(++pdest)=0;', '+     streampos = psrc - buf;', '+     return s;', '+ }', '+ ', '+ int libraw_buffer_datastream::scanf_one(const char *fmt, void* val)', '+ {', '+     if(substream) return substream->scanf_one(fmt,val);', '+     int scanf_res;', '+     if(streampos>streamsize) return 0;', '+ #ifndef win32securecalls', '+     scanf_res = sscanf((char*)(buf+streampos),fmt,val);', '+ #else', '+     scanf_res = sscanf_s((char*)(buf+streampos),fmt,val);', '+ #endif', '+     if(scanf_res>0)', '+         {', '+             int xcnt=0;', '+             while(streampos<streamsize)', '+                 {', '+                     streampos++;', '+                     xcnt++;', '+                     if(buf[streampos] == 0', ""+                        || buf[streampos]==' '"", ""+                        || buf[streampos]=='\\t'"", ""+                        || buf[streampos]=='\\n'"", '+                        || xcnt>24)', '+                         break;', '+                 }', '+         }', '+     return scanf_res;', '+ }', '+ ', '+ libraw_byte_buffer *libraw_buffer_datastream::make_byte_buffer(unsigned int sz)', '+ {', '+     libraw_byte_buffer *ret = new libraw_byte_buffer(0);', '+     if(streampos + sz > streamsize)', '+         sz = streamsize - streampos;', '+     ret->set_buffer(buf+streampos,sz);', '+     return ret;', '+ }', '+ ', '+ int libraw_buffer_datastream::eof()', '+ {', '+     if(substream) return substream->eof();', '+     return streampos >= streamsize;', '+ }', '+  int libraw_buffer_datastream::valid()', '+ {', '+     return buf?1:0;', '+ }', '+ ', '+ ', '+ void * libraw_buffer_datastream::make_jas_stream()', '+ {', '+ #ifdef no_jasper', '+     return null;', '+ #else', '+     return jas_stream_memopen((char*)buf,streamsize);', '+ #endif', '+ }', '+ ', '+ libraw_bigfile_datastream::libraw_bigfile_datastream(const char *fname)', '+ {', '+     if(fname)', '+         {', '+             filename = fname;', '+ #ifndef win32securecalls', '+             f = fopen(fname,""rb"");', '+ #else', '+             if(fopen_s(&f,fname,""rb""))', '+                 f = 0;', '+ #endif', '+         }', '+     else', '+         {filename=0;f=0;}', '+     sav=0;', '+ }', '+ ', '+ libraw_bigfile_datastream::~libraw_bigfile_datastream() {if(f)fclose(f); if(sav)fclose(sav);}', '+ int         libraw_bigfile_datastream::valid() { return f?1:0;}', '+ ', '+ #define lr_bf_chk() do {if(!f) throw libraw_exception_io_eof;}while(0)', '+ ', '+ int libraw_bigfile_datastream::read(void * ptr,size_t size, size_t nmemb)', '+ {', '+     lr_bf_chk();', '+     return substream?substream->read(ptr,size,nmemb):int(fread(ptr,size,nmemb,f));', '+ }', '+ ', '+ int libraw_bigfile_datastream::eof()', '+ {', '+     lr_bf_chk();', '+     return substream?substream->eof():feof(f);', '+ }', '+ ', '+ int     libraw_bigfile_datastream:: seek(int64 o, int whence)', '+ {', '+     lr_bf_chk();', '+ #if defined (win32)', '+ #ifdef win32securecalls', '+     return substream?substream->seek(o,whence):_fseeki64(f,o,whence);', '+ #else', '+     return substream?substream->seek(o,whence):fseek(f,(long)o,whence);', '+ #endif', '+ #else', '+     return substream?substream->seek(o,whence):fseeko(f,o,whence);', '+ #endif', '+ }', '+ ', '+ int64 libraw_bigfile_datastream::tell()', '+ {', '+     lr_bf_chk();', '+ #if defined (win32)', '+ #ifdef win32securecalls', '+     return substream?substream->tell():_ftelli64(f);', '+ #else', '+     return substream?substream->tell():ftell(f);', '+ #endif', '+ #else', '+     return substream?substream->tell():ftello(f);', '+ #endif', '+ }', '+ ', '+ char* libraw_bigfile_datastream::gets(char *str, int sz)', '+ {', '+     lr_bf_chk();', '+     return substream?substream->gets(str,sz):fgets(str,sz,f);', '+ }', '+ ', '+ int libraw_bigfile_datastream::scanf_one(const char *fmt, void*val)', '+ {', '+     lr_bf_chk();', '+     return substream?substream->scanf_one(fmt,val):', '+ #ifndef win32securecalls', '+         fscanf(f,fmt,val)', '+ #else', '+         fscanf_s(f,fmt,val)', '+ #endif', '+         ;', '+ }', '+ ', '+ const char *libraw_bigfile_datastream::fname()', '+ {', '+     return filename;', '+ }', '+ ', '+ int libraw_bigfile_datastream::subfile_open(const char *fn)', '+ {', '+     if(sav) return ebusy;', '+     sav = f;', '+ #ifndef win32securecalls', '+     f = fopen(fn,""rb"");', '+ #else', '+     fopen_s(&f,fn,""rb"");', '+ #endif', '+     if(!f)', '+         {', '+             f = sav;', '+             sav = null;', '+             return enoent;', '+         }', '+     else', '+         return 0;', '+ }', '+ ', '+ void libraw_bigfile_datastream::subfile_close()', '+ {', '+     if(!sav) return;', '+     fclose(f);', '+     f = sav;', '+     sav = 0;', '+ }', '+ ', '+ ', '+ void *libraw_bigfile_datastream::make_jas_stream()', '+ {', '+ #ifdef no_jasper', '+     return null;', '+ #else', '+     return jas_stream_freopen(fname(),""rb"",f);', '+ #endif', '+ }', '+ ', '+ #ifdef win32', '+ ', '+ libraw_windows_datastream::libraw_windows_datastream(const tchar* sfile)', '+     : libraw_buffer_datastream(null, 0)', '+     , hmap_(0)', '+     , pview_(null)', '+ {', '+     handle hfile = createfile(sfile, generic_read, 0, 0, open_existing, file_attribute_normal, 0);', '+     if (hfile == invalid_handle_value)', '+         throw std::runtime_error(""failed to open the file"");', '+ ', '+     try { open(hfile); \t}\tcatch(...) { closehandle(hfile); throw; }', '+ ', '+     reconstruct_base();', '+ }', '+ ', '+ libraw_windows_datastream::libraw_windows_datastream(handle hfile)', '+     : libraw_buffer_datastream(null, 0)', '+     , hmap_(0)', '+     , pview_(null)', '+ {', '+     open(hfile);', '+     reconstruct_base();', '+ }', '+ ', '+ libraw_windows_datastream::~libraw_windows_datastream()', '+ {', '+     if (pview_ != null)', '+         ::unmapviewoffile(pview_);', '+ ', '+     if (hmap_ != 0)', '+         ::closehandle(hmap_);', '+ }', '+ ', '+ void libraw_windows_datastream::open(handle hfile)', '+ {', '+     hmap_ = ::createfilemapping(hfile, 0, page_readonly, 0, 0, 0);', '+     if (hmap_ == null)\tthrow std::runtime_error(""failed to create file mapping"");', '+ ', '+     if (!::getfilesizeex(hfile, (plarge_integer)&cbview_))', '+         throw std::runtime_error(""failed to get the file size"");', '+ ', '+     pview_ = ::mapviewoffile(hmap_, file_map_read, 0, 0, (size_t)cbview_);', '+     if (pview_ == null)', '+         throw std::runtime_error(""failed to map the file"");', '+ }', '+ ', '+ ', '+ #endif', '+ ', '+ ', '+ ']]","[['+ #define LIBRAW_LIBRARY_BUILD', '+ #include ""libraw/libraw.h""', '+ #include ""internal/defines.h""', '+ #include ""libraw/libraw_datastream.h""', '+ #include ""internal/libraw_bytebuffer.h""', '+ ', '+ LibRaw_byte_buffer::LibRaw_byte_buffer(unsigned sz)', '+ {', '+     buf=0; size=sz; offt=0; do_free=0;', '+     if(size)', '+         {', '+             buf = (unsigned char*)malloc(size); do_free=1;', '+         }', '+ }', '+ ', '+ void LibRaw_byte_buffer::set_buffer(void *bb, unsigned int sz)', '+ {', '+     buf = (unsigned char*)bb; size = sz; offt=0; do_free=0;', '+ }', '+ ', '+ LibRaw_byte_buffer::~LibRaw_byte_buffer()', '+ {', '+     if(do_free) free(buf);', '+ }', '+ ', '+ LibRaw_byte_buffer *LibRaw_abstract_datastream::make_byte_buffer(unsigned int sz)', '+ {', '+     LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(sz);', '+     read(ret->get_buffer(),sz,1);', '+     return ret;', '+ }', '+ ', '+ int LibRaw_abstract_datastream::tempbuffer_open(void  *buf, size_t size)', '+ {', '+     if(substream) return EBUSY;', '+     substream = new LibRaw_buffer_datastream(buf,size);', '+     return substream?0:EINVAL;', '+ }', '+ ', '+ ', '+ void\tLibRaw_abstract_datastream::tempbuffer_close()', '+ {', '+     if(substream) delete substream;', '+     substream = NULL;', '+ }', '+ ', '+ ', '+ LibRaw_file_datastream::LibRaw_file_datastream(const char *fname)', '+     :filename(fname)', '+ {', '+     if (filename) {', '+         std::auto_ptr<std::filebuf> buf(new std::filebuf());', '+         buf->open(filename, std::ios_base::in | std::ios_base::binary);', '+         if (buf->is_open()) {', '+             f = buf;', '+         }', '+     }', '+ }', '+  int LibRaw_file_datastream::valid()', '+ {', '+     return f.get() ? 1 : 0;', '+ }', '+ ', '+ #define LR_STREAM_CHK() do {if(!f.get()) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)', '+ ', '+ int LibRaw_file_datastream::read(void * ptr,size_t size, size_t nmemb)', '+ {', '+     if(substream) return substream->read(ptr,size,nmemb);', '+ ', '+ #if defined(WIN32SECURECALLS) && (_MSC_VER < 1600)', '+     LR_STREAM_CHK(); return int(f->_Sgetn_s(static_cast<char*>(ptr), nmemb * size,nmemb * size) / size);', '+ #else', '+     LR_STREAM_CHK(); return int(f->sgetn(static_cast<char*>(ptr), std::streamsize(nmemb * size)) / size);', '+ #endif', '+ }', '+ ', '+ int LibRaw_file_datastream::eof()', '+ {', '+     if(substream) return substream->eof();', '+     LR_STREAM_CHK(); return f->sgetc() == EOF;', '+ }', '+ ', '+ int LibRaw_file_datastream::seek(INT64 o, int whence)', '+ {', '+     if(substream) return substream->seek(o,whence);', '+     LR_STREAM_CHK();', '+     std::ios_base::seekdir dir;', '+     switch (whence)', '+         {', '+         case SEEK_SET: dir = std::ios_base::beg; break;', '+         case SEEK_CUR: dir = std::ios_base::cur; break;', '+         case SEEK_END: dir = std::ios_base::end; break;', '+         default: dir = std::ios_base::beg;', '+         }', '+     return (int)f->pubseekoff((long)o, dir);', '+ }', '+ ', '+ INT64 LibRaw_file_datastream::tell()', '+ {', '+     if(substream) return substream->tell();', '+     LR_STREAM_CHK(); return f->pubseekoff(0, std::ios_base::cur);', '+ }', '+ ', '+ char* LibRaw_file_datastream::gets(char *str, int sz)', '+ {', '+     if(substream) return substream->gets(str,sz);', '+     LR_STREAM_CHK();', '+     std::istream is(f.get());', '+     is.getline(str, sz);', '+     if (is.fail()) return 0;', '+     return str;', '+ }', '+ ', '+ int LibRaw_file_datastream::scanf_one(const char *fmt, void*val)', '+ {', '+     if(substream) return substream->scanf_one(fmt,val);', '+     LR_STREAM_CHK();', '+ ', '+     std::istream is(f.get());', '+ ', '+     if (strcmp(fmt, ""%d"") == 0) {', '+         int d;', '+         is >> d;', '+         if (is.fail()) return EOF;', '+         *(static_cast<int*>(val)) = d;', '+     } else {', '+         float f;', '+         is >> f;', '+         if (is.fail()) return EOF;', '+         *(static_cast<float*>(val)) = f;', '+     }', '+ ', '+     return 1;', '+ }', '+ ', '+ const char* LibRaw_file_datastream::fname()', '+ {', '+     return filename;', '+ }', '+ ', '+ int LibRaw_file_datastream::subfile_open(const char *fn)', '+ {', '+     LR_STREAM_CHK();', '+     if (saved_f.get()) return EBUSY;', '+     saved_f = f;', '+         std::auto_ptr<std::filebuf> buf(new std::filebuf());', '+ ', '+         buf->open(fn, std::ios_base::in | std::ios_base::binary);', '+         if (!buf->is_open()) {', '+             f = saved_f;', '+             return ENOENT;', '+         } else {', '+             f = buf;', '+         }', '+ ', '+         return 0;', '+ }', '+ ', '+ ', '+ void LibRaw_file_datastream::subfile_close()', '+ {', '+     if (!saved_f.get()) return;', '+     f = saved_f;', '+ }', '+ ', '+ #undef LR_STREAM_CHK', '+ ', '+ void * LibRaw_file_datastream::make_jas_stream()', '+ {', '+ #ifdef NO_JASPER', '+     return NULL;', '+ #else', '+     return jas_stream_fopen(fname(),""rb"");', '+ #endif', '+ }', '+ ', '+ LibRaw_buffer_datastream::LibRaw_buffer_datastream(void *buffer, size_t bsize)', '+ {', '+     buf = (unsigned char*)buffer; streampos = 0; streamsize = bsize;', '+ }', '+ ', '+ LibRaw_buffer_datastream::~LibRaw_buffer_datastream(){}', '+ ', '+ int LibRaw_buffer_datastream::read(void * ptr,size_t sz, size_t nmemb)', '+ {', '+     if(substream) return substream->read(ptr,sz,nmemb);', '+     size_t to_read = sz*nmemb;', '+     if(to_read > streamsize - streampos)', '+         to_read = streamsize-streampos;', '+     if(to_read<1)', '+         return 0;', '+     memmove(ptr,buf+streampos,to_read);', '+     streampos+=to_read;', '+     return int((to_read+sz-1)/sz);', '+ }', '+ ', '+ int LibRaw_buffer_datastream::seek(INT64 o, int whence)', '+ {', '+     if(substream) return substream->seek(o,whence);', '+     switch(whence)', '+         {', '+         case SEEK_SET:', '+             if(o<0)', '+                 streampos = 0;', '+             else if (size_t(o) > streamsize)', '+                 streampos = streamsize;', '+             else', '+                 streampos = size_t(o);', '+             return 0;', '+         case SEEK_CUR:', '+             if(o<0)', '+                 {', '+                     if(size_t(-o) >= streampos)', '+                         streampos = 0;', '+                     else', '+                         streampos += (size_t)o;', '+                 }', '+             else if (o>0)', '+                 {', '+                     if(o+streampos> streamsize)', '+                         streampos = streamsize;', '+                     else', '+                         streampos += (size_t)o;', '+                 }', '+             return 0;', '+         case SEEK_END:', '+             if(o>0)', '+                 streampos = streamsize;', '+             else if ( size_t(-o) > streamsize)', '+                 streampos = 0;', '+             else', '+                 streampos = streamsize+(size_t)o;', '+             return 0;', '+         default:', '+             return 0;', '+         }', '+ }', '+ ', '+ INT64 LibRaw_buffer_datastream::tell()', '+ {', '+     if(substream) return substream->tell();', '+     return INT64(streampos);', '+ }', '+ ', '+ char* LibRaw_buffer_datastream::gets(char *s, int sz)', '+ {', '+     if (substream) return substream->gets(s,sz);', '+     unsigned char *psrc,*pdest,*str;', '+     str = (unsigned char *)s;', '+     psrc = buf+streampos;', '+     pdest = str;', '+     while ( (size_t(psrc - buf) < streamsize)', '+             &&', '+             ((pdest-str)<sz)', '+         )', '+         {', '+             *pdest = *psrc;', ""+             if(*psrc == '\\n')"", '+                 break;', '+             psrc++;', '+             pdest++;', '+         }', '+     if(size_t(psrc-buf) < streamsize)', '+         psrc++;', '+     if((pdest-str)<sz)', '+         *(++pdest)=0;', '+     streampos = psrc - buf;', '+     return s;', '+ }', '+ ', '+ int LibRaw_buffer_datastream::scanf_one(const char *fmt, void* val)', '+ {', '+     if(substream) return substream->scanf_one(fmt,val);', '+     int scanf_res;', '+     if(streampos>streamsize) return 0;', '+ #ifndef WIN32SECURECALLS', '+     scanf_res = sscanf((char*)(buf+streampos),fmt,val);', '+ #else', '+     scanf_res = sscanf_s((char*)(buf+streampos),fmt,val);', '+ #endif', '+     if(scanf_res>0)', '+         {', '+             int xcnt=0;', '+             while(streampos<streamsize)', '+                 {', '+                     streampos++;', '+                     xcnt++;', '+                     if(buf[streampos] == 0', ""+                        || buf[streampos]==' '"", ""+                        || buf[streampos]=='\\t'"", ""+                        || buf[streampos]=='\\n'"", '+                        || xcnt>24)', '+                         break;', '+                 }', '+         }', '+     return scanf_res;', '+ }', '+ ', '+ LibRaw_byte_buffer *LibRaw_buffer_datastream::make_byte_buffer(unsigned int sz)', '+ {', '+     LibRaw_byte_buffer *ret = new LibRaw_byte_buffer(0);', '+     if(streampos + sz > streamsize)', '+         sz = streamsize - streampos;', '+     ret->set_buffer(buf+streampos,sz);', '+     return ret;', '+ }', '+ ', '+ int LibRaw_buffer_datastream::eof()', '+ {', '+     if(substream) return substream->eof();', '+     return streampos >= streamsize;', '+ }', '+  int LibRaw_buffer_datastream::valid()', '+ {', '+     return buf?1:0;', '+ }', '+ ', '+ ', '+ void * LibRaw_buffer_datastream::make_jas_stream()', '+ {', '+ #ifdef NO_JASPER', '+     return NULL;', '+ #else', '+     return jas_stream_memopen((char*)buf,streamsize);', '+ #endif', '+ }', '+ ', '+ LibRaw_bigfile_datastream::LibRaw_bigfile_datastream(const char *fname)', '+ {', '+     if(fname)', '+         {', '+             filename = fname;', '+ #ifndef WIN32SECURECALLS', '+             f = fopen(fname,""rb"");', '+ #else', '+             if(fopen_s(&f,fname,""rb""))', '+                 f = 0;', '+ #endif', '+         }', '+     else', '+         {filename=0;f=0;}', '+     sav=0;', '+ }', '+ ', '+ LibRaw_bigfile_datastream::~LibRaw_bigfile_datastream() {if(f)fclose(f); if(sav)fclose(sav);}', '+ int         LibRaw_bigfile_datastream::valid() { return f?1:0;}', '+ ', '+ #define LR_BF_CHK() do {if(!f) throw LIBRAW_EXCEPTION_IO_EOF;}while(0)', '+ ', '+ int LibRaw_bigfile_datastream::read(void * ptr,size_t size, size_t nmemb)', '+ {', '+     LR_BF_CHK();', '+     return substream?substream->read(ptr,size,nmemb):int(fread(ptr,size,nmemb,f));', '+ }', '+ ', '+ int LibRaw_bigfile_datastream::eof()', '+ {', '+     LR_BF_CHK();', '+     return substream?substream->eof():feof(f);', '+ }', '+ ', '+ int     LibRaw_bigfile_datastream:: seek(INT64 o, int whence)', '+ {', '+     LR_BF_CHK();', '+ #if defined (WIN32)', '+ #ifdef WIN32SECURECALLS', '+     return substream?substream->seek(o,whence):_fseeki64(f,o,whence);', '+ #else', '+     return substream?substream->seek(o,whence):fseek(f,(long)o,whence);', '+ #endif', '+ #else', '+     return substream?substream->seek(o,whence):fseeko(f,o,whence);', '+ #endif', '+ }', '+ ', '+ INT64 LibRaw_bigfile_datastream::tell()', '+ {', '+     LR_BF_CHK();', '+ #if defined (WIN32)', '+ #ifdef WIN32SECURECALLS', '+     return substream?substream->tell():_ftelli64(f);', '+ #else', '+     return substream?substream->tell():ftell(f);', '+ #endif', '+ #else', '+     return substream?substream->tell():ftello(f);', '+ #endif', '+ }', '+ ', '+ char* LibRaw_bigfile_datastream::gets(char *str, int sz)', '+ {', '+     LR_BF_CHK();', '+     return substream?substream->gets(str,sz):fgets(str,sz,f);', '+ }', '+ ', '+ int LibRaw_bigfile_datastream::scanf_one(const char *fmt, void*val)', '+ {', '+     LR_BF_CHK();', '+     return substream?substream->scanf_one(fmt,val):', '+ #ifndef WIN32SECURECALLS', '+         fscanf(f,fmt,val)', '+ #else', '+         fscanf_s(f,fmt,val)', '+ #endif', '+         ;', '+ }', '+ ', '+ const char *LibRaw_bigfile_datastream::fname()', '+ {', '+     return filename;', '+ }', '+ ', '+ int LibRaw_bigfile_datastream::subfile_open(const char *fn)', '+ {', '+     if(sav) return EBUSY;', '+     sav = f;', '+ #ifndef WIN32SECURECALLS', '+     f = fopen(fn,""rb"");', '+ #else', '+     fopen_s(&f,fn,""rb"");', '+ #endif', '+     if(!f)', '+         {', '+             f = sav;', '+             sav = NULL;', '+             return ENOENT;', '+         }', '+     else', '+         return 0;', '+ }', '+ ', '+ void LibRaw_bigfile_datastream::subfile_close()', '+ {', '+     if(!sav) return;', '+     fclose(f);', '+     f = sav;', '+     sav = 0;', '+ }', '+ ', '+ ', '+ void *LibRaw_bigfile_datastream::make_jas_stream()', '+ {', '+ #ifdef NO_JASPER', '+     return NULL;', '+ #else', '+     return jas_stream_freopen(fname(),""rb"",f);', '+ #endif', '+ }', '+ ', '+ #ifdef WIN32', '+ ', '+ LibRaw_windows_datastream::LibRaw_windows_datastream(const TCHAR* sFile)', '+     : LibRaw_buffer_datastream(NULL, 0)', '+     , hMap_(0)', '+     , pView_(NULL)', '+ {', '+     HANDLE hFile = CreateFile(sFile, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);', '+     if (hFile == INVALID_HANDLE_VALUE)', '+         throw std::runtime_error(""failed to open the file"");', '+ ', '+     try { Open(hFile); \t}\tcatch(...) { CloseHandle(hFile); throw; }', '+ ', '+     reconstruct_base();', '+ }', '+ ', '+ LibRaw_windows_datastream::LibRaw_windows_datastream(HANDLE hFile)', '+     : LibRaw_buffer_datastream(NULL, 0)', '+     , hMap_(0)', '+     , pView_(NULL)', '+ {', '+     Open(hFile);', '+     reconstruct_base();', '+ }', '+ ', '+ LibRaw_windows_datastream::~LibRaw_windows_datastream()', '+ {', '+     if (pView_ != NULL)', '+         ::UnmapViewOfFile(pView_);', '+ ', '+     if (hMap_ != 0)', '+         ::CloseHandle(hMap_);', '+ }', '+ ', '+ void LibRaw_windows_datastream::Open(HANDLE hFile)', '+ {', '+     hMap_ = ::CreateFileMapping(hFile, 0, PAGE_READONLY, 0, 0, 0);', '+     if (hMap_ == NULL)\tthrow std::runtime_error(""failed to create file mapping"");', '+ ', '+     if (!::GetFileSizeEx(hFile, (PLARGE_INTEGER)&cbView_))', '+         throw std::runtime_error(""failed to get the file size"");', '+ ', '+     pView_ = ::MapViewOfFile(hMap_, FILE_MAP_READ, 0, 0, (size_t)cbView_);', '+     if (pView_ == NULL)', '+         throw std::runtime_error(""failed to map the file"");', '+ }', '+ ', '+ ', '+ #endif', '+ ', '+ ', '+ ']]",[[]],501,0.0,501.0,d09696a3bccb31d45abc1375b4016dd299557e57LibRaw/LibRaw,['11909cc59e712e09b508dda729b99aeaac2b29ad']
589e5b52f634f6b2d307a167a19eef7e7328cb08,FFmpeg/FFmpeg,libavcodec/jpeg2000dec.c,train,C,1,"['@@ -940,12 +940,13 @@ static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,\n     int passno = cblk->npasses, pass_t = 2, bpno = cblk->nonzerobits - 1, y;\n \n     for (y = 0; y < height; y++)\n-        memset(t1->data[y], 0, width * sizeof(width));\n+        memset(t1->data[y], 0, width * sizeof(**t1->data));\n+\n     /* If code-block contains no compressed data: nothing to do. */\n     if (!cblk->length)\n         return 0;\n     for (y = 0; y < height + 2; y++)\n-        memset(t1->flags[y], 0, (width + 2) * sizeof(width));\n+        memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));\n \n     ff_mqc_initdec(&t1->mqc, cblk->data);\n     cblk->data[cblk->length]     = 0xff;\n']",2013-07-02 20:05:46+02:00,"jpeg2000: Use the correct sizeof in memset for T1 data

Signed-off-by: Luca Barbato <lu_zero@gentoo.org>","[['+         memset(t1->data[y], 0, width * sizeof(**t1->data));', '+ ', '+         memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));', '-         memset(t1->data[y], 0, width * sizeof(width));', '-         memset(t1->flags[y], 0, (width + 2) * sizeof(width));']]","[['+         memset(t1->data[y], 0, width * sizeof(**t1->data));', '+ ', '+         memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));', '-         memset(t1->data[y], 0, width * sizeof(width));', '-         memset(t1->flags[y], 0, (width + 2) * sizeof(width));']]","[['+         memset(t1->data[y], 0, width * sizeof(**t1->data));', '+ ', '+         memset(t1->flags[y], 0, (width + 2) * sizeof(**t1->flags));']]","[['-         memset(t1->data[y], 0, width * sizeof(width));', '-         memset(t1->flags[y], 0, (width + 2) * sizeof(width));']]",3,2.0,5.0,589e5b52f634f6b2d307a167a19eef7e7328cb08FFmpeg/FFmpeg,['9a271a9368eaabf99e6c2046103acb33957e63b7']
4beb0209a750c36bfe738e5b63378d3a2cc4d8cd,libarchive/libarchive,test_ustar_filenames.c,train,C,0,"['@@ -0,0 +1,183 @@\n+/*-\n+ * Copyright (c) 2003-2007 Tim Kientzle\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS\'\' AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n+ * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ */\n+#include ""test.h""\n+__FBSDID(""$FreeBSD$"");\n+\n+/*\n+ * Exercise various lengths of filenames in ustar archives.\n+ */\n+\n+static void\n+test_filename(const char *prefix, int dlen, int flen)\n+{\n+\tchar buff[8192];\n+\tchar filename[400];\n+\tchar dirname[400];\n+\tstruct archive_entry *ae;\n+\tstruct archive *a;\n+\tsize_t used;\n+\tint separator = 0;\n+\tint i = 0;\n+\n+\tif (prefix != NULL) {\n+\t\tstrcpy(filename, prefix);\n+\t\ti = strlen(prefix);\n+\t}\n+\tif (dlen > 0) {\n+\t\tfor (; i < dlen; i++)\n+\t\t\tfilename[i] = \'a\';\n+\t\tfilename[i++] = \'/\';\n+\t\tseparator = 1;\n+\t}\n+\tfor (; i < dlen + flen + separator; i++)\n+\t\tfilename[i] = \'b\';\n+\tfilename[i++] = \'\\0\';\n+\n+\tstrcpy(dirname, filename);\n+\n+\t/* Create a new archive in memory. */\n+\tassert((a = archive_write_new()) != NULL);\n+\tassertA(0 == archive_write_set_format_ustar(a));\n+\tassertA(0 == archive_write_set_compression_none(a));\n+\tassertA(0 == archive_write_set_bytes_per_block(a,0));\n+\tassertA(0 == archive_write_open_memory(a, buff, sizeof(buff), &used));\n+\n+\t/*\n+\t * Write a file to it.\n+\t */\n+\tassert((ae = archive_entry_new()) != NULL);\n+\tarchive_entry_copy_pathname(ae, filename);\n+\tarchive_entry_set_mode(ae, S_IFREG | 0755);\n+\tfailure(""dlen=%d, flen=%d"", dlen, flen);\n+\tif (flen > 100) {\n+\t\tassertEqualIntA(a, ARCHIVE_WARN, archive_write_header(a, ae));\n+\t} else {\n+\t\tassertEqualIntA(a, 0, archive_write_header(a, ae));\n+\t}\n+\tarchive_entry_free(ae);\n+\n+\t/*\n+\t * Write a dir to it (without trailing \'/\').\n+\t */\n+\tassert((ae = archive_entry_new()) != NULL);\n+\tarchive_entry_copy_pathname(ae, dirname);\n+\tarchive_entry_set_mode(ae, S_IFDIR | 0755);\n+\tfailure(""dlen=%d, flen=%d"", dlen, flen);\n+\tif (flen >= 100) {\n+\t\tassertEqualIntA(a, ARCHIVE_WARN, archive_write_header(a, ae));\n+\t} else {\n+\t\tassertEqualIntA(a, 0, archive_write_header(a, ae));\n+\t}\n+\tarchive_entry_free(ae);\n+\n+\t/* Tar adds a \'/\' to directory names. */\n+\tstrcat(dirname, ""/"");\n+\n+\t/*\n+\t * Write a dir to it (with trailing \'/\').\n+\t */\n+\tassert((ae = archive_entry_new()) != NULL);\n+\tarchive_entry_copy_pathname(ae, dirname);\n+\tarchive_entry_set_mode(ae, S_IFDIR | 0755);\n+\tfailure(""dlen=%d, flen=%d"", dlen, flen);\n+\tif (flen >= 100) {\n+\t\tassertEqualIntA(a, ARCHIVE_WARN, archive_write_header(a, ae));\n+\t} else {\n+\t\tassertEqualIntA(a, 0, archive_write_header(a, ae));\n+\t}\n+\tarchive_entry_free(ae);\n+\n+\t/* Close out the archive. */\n+\tassertA(0 == archive_write_close(a));\n+\tassertA(0 == archive_write_finish(a));\n+\n+\t/*\n+\t * Now, read the data back.\n+\t */\n+\tassert((a = archive_read_new()) != NULL);\n+\tassertA(0 == archive_read_support_format_all(a));\n+\tassertA(0 == archive_read_support_compression_all(a));\n+\tassertA(0 == archive_read_open_memory(a, buff, used));\n+\n+\tif (flen <= 100) {\n+\t\t/* Read the file and check the filename. */\n+\t\tassertA(0 == archive_read_next_header(a, &ae));\n+\t\tfailure(""dlen=%d, flen=%d"", dlen, flen);\n+\t\tassertEqualString(filename, archive_entry_pathname(ae));\n+\t\tassertEqualInt((S_IFREG | 0755), archive_entry_mode(ae));\n+\t}\n+\n+\t/*\n+\t * Read the two dirs and check the names.\n+\t *\n+\t * Both dirs should read back with the same name, since\n+\t * tar should add a trailing \'/\' to any dir that doesn\'t\n+\t * already have one.\n+\t */\n+\tif (flen <= 99) {\n+\t\tassertA(0 == archive_read_next_header(a, &ae));\n+\t\tassert((S_IFDIR | 0755) == archive_entry_mode(ae));\n+\t\tfailure(""dlen=%d, flen=%d"", dlen, flen);\n+\t\tassertEqualString(dirname, archive_entry_pathname(ae));\n+\t}\n+\n+\tif (flen <= 99) {\n+\t\tassertA(0 == archive_read_next_header(a, &ae));\n+\t\tassert((S_IFDIR | 0755) == archive_entry_mode(ae));\n+\t\tassertEqualString(dirname, archive_entry_pathname(ae));\n+\t}\n+\n+\t/* Verify the end of the archive. */\n+\tfailure(""This fails if entries were written that should not have been written.  dlen=%d, flen=%d"", dlen, flen);\n+\tassertEqualInt(1, archive_read_next_header(a, &ae));\n+\tassert(0 == archive_read_close(a));\n+\tassert(0 == archive_read_finish(a));\n+}\n+\n+DEFINE_TEST(test_ustar_filenames)\n+{\n+\tint dlen, flen;\n+\n+\t/* Try a bunch of different file/dir lengths that add up\n+\t * to just a little less or a little more than 100 bytes.\n+\t * This exercises the code that splits paths between ustar\n+\t * filename and prefix fields.\n+\t */\n+\tfor (dlen = 5; dlen < 70; dlen += 5) {\n+\t\tfor (flen = 100 - dlen - 5; flen < 100 - dlen + 5; flen++) {\n+\t\t\ttest_filename(NULL, dlen, flen);\n+\t\t\ttest_filename(""/"", dlen, flen);\n+\t\t}\n+\t}\n+\n+\t/* Probe the 100-char limit for paths with no \'/\'. */\n+\tfor (flen = 90; flen < 110; flen++) {\n+\t\ttest_filename(NULL, 0, flen);\n+\t\ttest_filename(""/"", dlen, flen);\n+\t}\n+\n+\t/* XXXX TODO Probe the 100-char limit with a dir prefix. */\n+\t/* XXXX TODO Probe the 255-char total limit. */\n+}\n']",,,"['+ #include ""test.h""', '+ __FBSDID(""$FreeBSD$"");', '+ static void', '+ test_filename(const char *prefix, int dlen, int flen)', '+ {', '+ \tchar buff[8192];', '+ \tchar filename[400];', '+ \tchar dirname[400];', '+ \tstruct archive_entry *ae;', '+ \tstruct archive *a;', '+ \tsize_t used;', '+ \tint separator = 0;', '+ \tint i = 0;', '+ \tif (prefix != NULL) {', '+ \t\tstrcpy(filename, prefix);', '+ \t\ti = strlen(prefix);', '+ \t}', '+ \tif (dlen > 0) {', '+ \t\tfor (; i < dlen; i++)', ""+ \t\t\tfilename[i] = 'a';"", ""+ \t\tfilename[i++] = '/';"", '+ \t\tseparator = 1;', '+ \t}', '+ \tfor (; i < dlen + flen + separator; i++)', ""+ \t\tfilename[i] = 'b';"", ""+ \tfilename[i++] = '\\0';"", '+ \tstrcpy(dirname, filename);', '+ \tassert((a = archive_write_new()) != NULL);', '+ \tassertA(0 == archive_write_set_format_ustar(a));', '+ \tassertA(0 == archive_write_set_compression_none(a));', '+ \tassertA(0 == archive_write_set_bytes_per_block(a,0));', '+ \tassertA(0 == archive_write_open_memory(a, buff, sizeof(buff), &used));', '+ \tassert((ae = archive_entry_new()) != NULL);', '+ \tarchive_entry_copy_pathname(ae, filename);', '+ \tarchive_entry_set_mode(ae, S_IFREG | 0755);', '+ \tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \tif (flen > 100) {', '+ \t\tassertEqualIntA(a, ARCHIVE_WARN, archive_write_header(a, ae));', '+ \t} else {', '+ \t\tassertEqualIntA(a, 0, archive_write_header(a, ae));', '+ \t}', '+ \tarchive_entry_free(ae);', '+ \tassert((ae = archive_entry_new()) != NULL);', '+ \tarchive_entry_copy_pathname(ae, dirname);', '+ \tarchive_entry_set_mode(ae, S_IFDIR | 0755);', '+ \tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \tif (flen >= 100) {', '+ \t\tassertEqualIntA(a, ARCHIVE_WARN, archive_write_header(a, ae));', '+ \t} else {', '+ \t\tassertEqualIntA(a, 0, archive_write_header(a, ae));', '+ \t}', '+ \tarchive_entry_free(ae);', '+ \tstrcat(dirname, ""/"");', '+ \tassert((ae = archive_entry_new()) != NULL);', '+ \tarchive_entry_copy_pathname(ae, dirname);', '+ \tarchive_entry_set_mode(ae, S_IFDIR | 0755);', '+ \tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \tif (flen >= 100) {', '+ \t\tassertEqualIntA(a, ARCHIVE_WARN, archive_write_header(a, ae));', '+ \t} else {', '+ \t\tassertEqualIntA(a, 0, archive_write_header(a, ae));', '+ \t}', '+ \tarchive_entry_free(ae);', '+ \tassertA(0 == archive_write_close(a));', '+ \tassertA(0 == archive_write_finish(a));', '+ \tassert((a = archive_read_new()) != NULL);', '+ \tassertA(0 == archive_read_support_format_all(a));', '+ \tassertA(0 == archive_read_support_compression_all(a));', '+ \tassertA(0 == archive_read_open_memory(a, buff, used));', '+ \tif (flen <= 100) {', '+ \t\tassertA(0 == archive_read_next_header(a, &ae));', '+ \t\tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \t\tassertEqualString(filename, archive_entry_pathname(ae));', '+ \t\tassertEqualInt((S_IFREG | 0755), archive_entry_mode(ae));', '+ \t}', '+ \tif (flen <= 99) {', '+ \t\tassertA(0 == archive_read_next_header(a, &ae));', '+ \t\tassert((S_IFDIR | 0755) == archive_entry_mode(ae));', '+ \t\tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \t\tassertEqualString(dirname, archive_entry_pathname(ae));', '+ \t}', '+ \tif (flen <= 99) {', '+ \t\tassertA(0 == archive_read_next_header(a, &ae));', '+ \t\tassert((S_IFDIR | 0755) == archive_entry_mode(ae));', '+ \t\tassertEqualString(dirname, archive_entry_pathname(ae));', '+ \t}', '+ \tfailure(""This fails if entries were written that should not have been written.  dlen=%d, flen=%d"", dlen, flen);', '+ \tassertEqualInt(1, archive_read_next_header(a, &ae));', '+ \tassert(0 == archive_read_close(a));', '+ \tassert(0 == archive_read_finish(a));', '+ }', '+ DEFINE_TEST(test_ustar_filenames)', '+ {', '+ \tint dlen, flen;', '+ \tfor (dlen = 5; dlen < 70; dlen += 5) {', '+ \t\tfor (flen = 100 - dlen - 5; flen < 100 - dlen + 5; flen++) {', '+ \t\t\ttest_filename(NULL, dlen, flen);', '+ \t\t\ttest_filename(""/"", dlen, flen);', '+ \t\t}', '+ \t}', '+ \tfor (flen = 90; flen < 110; flen++) {', '+ \t\ttest_filename(NULL, 0, flen);', '+ \t\ttest_filename(""/"", dlen, flen);', '+ \t}', '+ }']","['+ #include ""test.h""', '+ __fbsdid(""$freebsd$"");', '+ static void', '+ test_filename(const char *prefix, int dlen, int flen)', '+ {', '+ \tchar buff[8192];', '+ \tchar filename[400];', '+ \tchar dirname[400];', '+ \tstruct archive_entry *ae;', '+ \tstruct archive *a;', '+ \tsize_t used;', '+ \tint separator = 0;', '+ \tint i = 0;', '+ \tif (prefix != null) {', '+ \t\tstrcpy(filename, prefix);', '+ \t\ti = strlen(prefix);', '+ \t}', '+ \tif (dlen > 0) {', '+ \t\tfor (; i < dlen; i++)', ""+ \t\t\tfilename[i] = 'a';"", ""+ \t\tfilename[i++] = '/';"", '+ \t\tseparator = 1;', '+ \t}', '+ \tfor (; i < dlen + flen + separator; i++)', ""+ \t\tfilename[i] = 'b';"", ""+ \tfilename[i++] = '\\0';"", '+ \tstrcpy(dirname, filename);', '+ \tassert((a = archive_write_new()) != null);', '+ \tasserta(0 == archive_write_set_format_ustar(a));', '+ \tasserta(0 == archive_write_set_compression_none(a));', '+ \tasserta(0 == archive_write_set_bytes_per_block(a,0));', '+ \tasserta(0 == archive_write_open_memory(a, buff, sizeof(buff), &used));', '+ \tassert((ae = archive_entry_new()) != null);', '+ \tarchive_entry_copy_pathname(ae, filename);', '+ \tarchive_entry_set_mode(ae, s_ifreg | 0755);', '+ \tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \tif (flen > 100) {', '+ \t\tassertequalinta(a, archive_warn, archive_write_header(a, ae));', '+ \t} else {', '+ \t\tassertequalinta(a, 0, archive_write_header(a, ae));', '+ \t}', '+ \tarchive_entry_free(ae);', '+ \tassert((ae = archive_entry_new()) != null);', '+ \tarchive_entry_copy_pathname(ae, dirname);', '+ \tarchive_entry_set_mode(ae, s_ifdir | 0755);', '+ \tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \tif (flen >= 100) {', '+ \t\tassertequalinta(a, archive_warn, archive_write_header(a, ae));', '+ \t} else {', '+ \t\tassertequalinta(a, 0, archive_write_header(a, ae));', '+ \t}', '+ \tarchive_entry_free(ae);', '+ \tstrcat(dirname, ""/"");', '+ \tassert((ae = archive_entry_new()) != null);', '+ \tarchive_entry_copy_pathname(ae, dirname);', '+ \tarchive_entry_set_mode(ae, s_ifdir | 0755);', '+ \tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \tif (flen >= 100) {', '+ \t\tassertequalinta(a, archive_warn, archive_write_header(a, ae));', '+ \t} else {', '+ \t\tassertequalinta(a, 0, archive_write_header(a, ae));', '+ \t}', '+ \tarchive_entry_free(ae);', '+ \tasserta(0 == archive_write_close(a));', '+ \tasserta(0 == archive_write_finish(a));', '+ \tassert((a = archive_read_new()) != null);', '+ \tasserta(0 == archive_read_support_format_all(a));', '+ \tasserta(0 == archive_read_support_compression_all(a));', '+ \tasserta(0 == archive_read_open_memory(a, buff, used));', '+ \tif (flen <= 100) {', '+ \t\tasserta(0 == archive_read_next_header(a, &ae));', '+ \t\tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \t\tassertequalstring(filename, archive_entry_pathname(ae));', '+ \t\tassertequalint((s_ifreg | 0755), archive_entry_mode(ae));', '+ \t}', '+ \tif (flen <= 99) {', '+ \t\tasserta(0 == archive_read_next_header(a, &ae));', '+ \t\tassert((s_ifdir | 0755) == archive_entry_mode(ae));', '+ \t\tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \t\tassertequalstring(dirname, archive_entry_pathname(ae));', '+ \t}', '+ \tif (flen <= 99) {', '+ \t\tasserta(0 == archive_read_next_header(a, &ae));', '+ \t\tassert((s_ifdir | 0755) == archive_entry_mode(ae));', '+ \t\tassertequalstring(dirname, archive_entry_pathname(ae));', '+ \t}', '+ \tfailure(""this fails if entries were written that should not have been written.  dlen=%d, flen=%d"", dlen, flen);', '+ \tassertequalint(1, archive_read_next_header(a, &ae));', '+ \tassert(0 == archive_read_close(a));', '+ \tassert(0 == archive_read_finish(a));', '+ }', '+ define_test(test_ustar_filenames)', '+ {', '+ \tint dlen, flen;', '+ \tfor (dlen = 5; dlen < 70; dlen += 5) {', '+ \t\tfor (flen = 100 - dlen - 5; flen < 100 - dlen + 5; flen++) {', '+ \t\t\ttest_filename(null, dlen, flen);', '+ \t\t\ttest_filename(""/"", dlen, flen);', '+ \t\t}', '+ \t}', '+ \tfor (flen = 90; flen < 110; flen++) {', '+ \t\ttest_filename(null, 0, flen);', '+ \t\ttest_filename(""/"", dlen, flen);', '+ \t}', '+ }']","['+ #include ""test.h""', '+ __FBSDID(""$FreeBSD$"");', '+ static void', '+ test_filename(const char *prefix, int dlen, int flen)', '+ {', '+ \tchar buff[8192];', '+ \tchar filename[400];', '+ \tchar dirname[400];', '+ \tstruct archive_entry *ae;', '+ \tstruct archive *a;', '+ \tsize_t used;', '+ \tint separator = 0;', '+ \tint i = 0;', '+ \tif (prefix != NULL) {', '+ \t\tstrcpy(filename, prefix);', '+ \t\ti = strlen(prefix);', '+ \t}', '+ \tif (dlen > 0) {', '+ \t\tfor (; i < dlen; i++)', ""+ \t\t\tfilename[i] = 'a';"", ""+ \t\tfilename[i++] = '/';"", '+ \t\tseparator = 1;', '+ \t}', '+ \tfor (; i < dlen + flen + separator; i++)', ""+ \t\tfilename[i] = 'b';"", ""+ \tfilename[i++] = '\\0';"", '+ \tstrcpy(dirname, filename);', '+ \tassert((a = archive_write_new()) != NULL);', '+ \tassertA(0 == archive_write_set_format_ustar(a));', '+ \tassertA(0 == archive_write_set_compression_none(a));', '+ \tassertA(0 == archive_write_set_bytes_per_block(a,0));', '+ \tassertA(0 == archive_write_open_memory(a, buff, sizeof(buff), &used));', '+ \tassert((ae = archive_entry_new()) != NULL);', '+ \tarchive_entry_copy_pathname(ae, filename);', '+ \tarchive_entry_set_mode(ae, S_IFREG | 0755);', '+ \tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \tif (flen > 100) {', '+ \t\tassertEqualIntA(a, ARCHIVE_WARN, archive_write_header(a, ae));', '+ \t} else {', '+ \t\tassertEqualIntA(a, 0, archive_write_header(a, ae));', '+ \t}', '+ \tarchive_entry_free(ae);', '+ \tassert((ae = archive_entry_new()) != NULL);', '+ \tarchive_entry_copy_pathname(ae, dirname);', '+ \tarchive_entry_set_mode(ae, S_IFDIR | 0755);', '+ \tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \tif (flen >= 100) {', '+ \t\tassertEqualIntA(a, ARCHIVE_WARN, archive_write_header(a, ae));', '+ \t} else {', '+ \t\tassertEqualIntA(a, 0, archive_write_header(a, ae));', '+ \t}', '+ \tarchive_entry_free(ae);', '+ \tstrcat(dirname, ""/"");', '+ \tassert((ae = archive_entry_new()) != NULL);', '+ \tarchive_entry_copy_pathname(ae, dirname);', '+ \tarchive_entry_set_mode(ae, S_IFDIR | 0755);', '+ \tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \tif (flen >= 100) {', '+ \t\tassertEqualIntA(a, ARCHIVE_WARN, archive_write_header(a, ae));', '+ \t} else {', '+ \t\tassertEqualIntA(a, 0, archive_write_header(a, ae));', '+ \t}', '+ \tarchive_entry_free(ae);', '+ \tassertA(0 == archive_write_close(a));', '+ \tassertA(0 == archive_write_finish(a));', '+ \tassert((a = archive_read_new()) != NULL);', '+ \tassertA(0 == archive_read_support_format_all(a));', '+ \tassertA(0 == archive_read_support_compression_all(a));', '+ \tassertA(0 == archive_read_open_memory(a, buff, used));', '+ \tif (flen <= 100) {', '+ \t\tassertA(0 == archive_read_next_header(a, &ae));', '+ \t\tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \t\tassertEqualString(filename, archive_entry_pathname(ae));', '+ \t\tassertEqualInt((S_IFREG | 0755), archive_entry_mode(ae));', '+ \t}', '+ \tif (flen <= 99) {', '+ \t\tassertA(0 == archive_read_next_header(a, &ae));', '+ \t\tassert((S_IFDIR | 0755) == archive_entry_mode(ae));', '+ \t\tfailure(""dlen=%d, flen=%d"", dlen, flen);', '+ \t\tassertEqualString(dirname, archive_entry_pathname(ae));', '+ \t}', '+ \tif (flen <= 99) {', '+ \t\tassertA(0 == archive_read_next_header(a, &ae));', '+ \t\tassert((S_IFDIR | 0755) == archive_entry_mode(ae));', '+ \t\tassertEqualString(dirname, archive_entry_pathname(ae));', '+ \t}', '+ \tfailure(""This fails if entries were written that should not have been written.  dlen=%d, flen=%d"", dlen, flen);', '+ \tassertEqualInt(1, archive_read_next_header(a, &ae));', '+ \tassert(0 == archive_read_close(a));', '+ \tassert(0 == archive_read_finish(a));', '+ }', '+ DEFINE_TEST(test_ustar_filenames)', '+ {', '+ \tint dlen, flen;', '+ \tfor (dlen = 5; dlen < 70; dlen += 5) {', '+ \t\tfor (flen = 100 - dlen - 5; flen < 100 - dlen + 5; flen++) {', '+ \t\t\ttest_filename(NULL, dlen, flen);', '+ \t\t\ttest_filename(""/"", dlen, flen);', '+ \t\t}', '+ \t}', '+ \tfor (flen = 90; flen < 110; flen++) {', '+ \t\ttest_filename(NULL, 0, flen);', '+ \t\ttest_filename(""/"", dlen, flen);', '+ \t}', '+ }']",[],105,0.0,105.0,4beb0209a750c36bfe738e5b63378d3a2cc4d8cdlibarchive/libarchive,[]
0c78baa9853b26c72d7fcef31d743c23437329a5,dajobe/raptor,raptor_parse.c,train,C,0,"['@@ -372,12 +372,14 @@ struct rapier_ns_map_s {\n typedef struct {\n   /* Name - always present */\n   const char *qname;\n+  int qname_length;\n   /* Namespace or NULL if not in a namespace */\n-  const rapier_ns_map *namespace;\n+  const rapier_ns_map *nspace;\n   /* URI of namespace+qname or NULL if not defined */\n   rapier_uri *uri;\n   /* optional value - used when name is an attribute */\n   const char *value;\n+  int value_length;\n } rapier_ns_name;\n \n \n@@ -449,11 +451,11 @@ struct rapier_element_s {\n   struct rapier_element_s *parent;\n   rapier_ns_name *name;\n   rapier_ns_name **attributes;\n-  unsigned int attribute_count;\n+  int attribute_count;\n   /* attributes declared in M&S */\n   const char * rdf_attr[RDF_ATTR_LAST+1];\n   /* how many of above seen */\n-  unsigned int rdf_attr_count;\n+  int rdf_attr_count;\n \n   /* state that this production matches */\n   rapier_state state;\n@@ -660,9 +662,9 @@ static void rapier_parser_warning(rapier_parser* parser, const char *message, ..\n \n /* prototypes for namespace and name/qname functions */\n static void rapier_init_namespaces(rapier_parser *rdf_parser);\n-static void rapier_start_namespace(rapier_parser *rdf_parser, const char *prefix, const char *namespace, int depth);\n-static void rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* namespace);\n-static void rapier_end_namespace(rapier_parser *rdf_parser, const char *prefix, const char *namespace);\n+static void rapier_start_namespace(rapier_parser *rdf_parser, const char *prefix, const char *nspace, int depth);\n+static void rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map *nspace);\n+static void rapier_end_namespace(rapier_parser *rdf_parser, const char *prefix, const char *nspace);\n static void rapier_end_namespaces_for_depth(rapier_parser *rdf_parser);\n static rapier_ns_name* rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name, const char *value, int is_element);\n #ifdef RAPIER_DEBUG\n@@ -728,7 +730,7 @@ rapier_init_namespaces(rapier_parser *rdf_parser) {\n \n static void\n rapier_start_namespace(rapier_parser *rdf_parser, \n-                       const char *prefix, const char *namespace, int depth)\n+                       const char *prefix, const char *nspace, int depth)\n {\n   int prefix_length=0;\n #ifdef LIBRDF_INTERNAL\n@@ -737,21 +739,21 @@ rapier_start_namespace(rapier_parser *rdf_parser,\n #endif\n   int len;\n   rapier_ns_map *map;\n-  void *p;\n+  char *p;\n \n   LIBRDF_DEBUG4(rapier_start_namespace,\n                 ""namespace prefix %s uri %s depth %d\\n"",\n-                prefix ? prefix : ""(default)"", namespace, depth);\n+                prefix ? prefix : ""(default)"", nspace, depth);\n \n   /* Convert an empty namespace string """" to a NULL pointer */\n-  if(!*namespace)\n-    namespace=NULL;\n+  if(!*nspace)\n+    nspace=NULL;\n \n   len=sizeof(rapier_ns_map);\n #ifdef LIBRDF_INTERNAL\n #else\n-  if(namespace) {\n-    uri_length=strlen(namespace);\n+  if(nspace) {\n+    uri_length=strlen(nspace);\n     len+=uri_length+1;\n   }\n #endif\n@@ -767,7 +769,7 @@ rapier_start_namespace(rapier_parser *rdf_parser,\n     return;\n   }\n \n-  p=(void*)map+sizeof(rapier_ns_map);\n+  p=(char*)map+sizeof(rapier_ns_map);\n #ifdef LIBRDF_INTERNAL\n   map->uri=librdf_new_uri(namespace);\n   if(!map->uri) {\n@@ -776,8 +778,8 @@ rapier_start_namespace(rapier_parser *rdf_parser,\n     return;\n   }\n #else\n-  if(namespace) {\n-    map->uri=strcpy((char*)p, namespace);\n+  if(nspace) {\n+    map->uri=strcpy((char*)p, nspace);\n     map->uri_length=uri_length;\n     p+= uri_length+1;\n   }\n@@ -792,16 +794,16 @@ rapier_start_namespace(rapier_parser *rdf_parser,\n   map->depth=depth;\n \n   /* set convienience flags when there is a defined namespace URI */\n-  if(namespace) {\n+  if(nspace) {\n #ifdef LIBRDF_INTERNAL\n     if(librdf_uri_equals(map->uri, librdf_concept_ms_namespace_uri))\n       map->is_rdf_ms=1;\n     else if(librdf_uri_equals(map->uri, librdf_concept_schema_namespace_uri))\n       map->is_rdf_schema=1;\n #else\n-    if(!strcmp(namespace, rapier_rdf_ms_uri))\n+    if(!strcmp(nspace, rapier_rdf_ms_uri))\n       map->is_rdf_ms=1;\n-    else if(!strcmp(namespace, rapier_rdf_schema_uri))\n+    else if(!strcmp(nspace, rapier_rdf_schema_uri))\n       map->is_rdf_schema=1;\n #endif\n   }\n@@ -813,22 +815,22 @@ rapier_start_namespace(rapier_parser *rdf_parser,\n \n \n static void \n-rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* namespace)\n+rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* nspace)\n {\n #ifdef LIBRDF_INTERNAL\n   if(namespace->uri)\n     librdf_free_uri(namespace->uri);\n #endif\n-  LIBRDF_FREE(rapier_ns_map, namespace);\n+  LIBRDF_FREE(rapier_ns_map, nspace);\n }\n \n \n static void \n rapier_end_namespace(rapier_parser *rdf_parser, \n-                     const char *prefix, const char *namespace) \n+                     const char *prefix, const char *nspace)\n {\n   LIBRDF_DEBUG3(rapier_end_namespace, ""prefix %s uri \\""%s\\""\\n"", \n-                prefix ? prefix : ""(default)"", namespace);\n+                prefix ? prefix : ""(default)"", nspace);\n }\n \n \n@@ -894,7 +896,6 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n {\n   rapier_ns_name* ns_name;\n   const char *p;\n-  char *new_value=NULL;\n   rapier_ns_map* ns;\n   char* new_name;\n   int prefix_length;\n@@ -912,7 +913,9 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n   }\n \n   if(value) {\n-    new_value=(char*)LIBRDF_MALLOC(cstring, strlen(value)+1);\n+    int value_length=strlen(value);\n+    char* new_value=(char*)LIBRDF_MALLOC(cstring, value_length+1);\n+\n     if(!new_value) {\n       rapier_parser_fatal_error(rdf_parser, ""Out of memory"");\n       LIBRDF_FREE(rapier_ns_name, ns_name);\n@@ -920,6 +923,7 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n     } \n     strcpy(new_value, value);\n     ns_name->value=new_value;\n+    ns_name->value_length=value_length;\n   }\n \n   /* Find : */\n@@ -938,13 +942,14 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n     }\n     strcpy(new_name, name);\n     ns_name->qname=new_name;\n-\n+    ns_name->qname_length=qname_length;\n+    \n     /* Find a default namespace */\n     for(ns=rdf_parser->namespaces; ns && ns->prefix; ns=ns->next)\n       ;\n \n     if(ns) {\n-      ns_name->namespace=ns;\n+      ns_name->nspace=ns;\n #if RAPIER_DEBUG > 1\n     LIBRDF_DEBUG2(rapier_make_namespaced_name,\n                   ""Found default namespace %s\\n"", ns->uri);\n@@ -953,8 +958,8 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n       /* failed to find namespace - now what? FIXME */\n       /* rapier_parser_warning(rdf_parser, ""No default namespace defined - cannot expand %s"", name); */\n #if RAPIER_DEBUG > 1\n-    LIBRDF_DEBUG1(rapier_make_namespaced_name,\n-                  ""No default namespace defined\\n"");\n+      LIBRDF_DEBUG1(rapier_make_namespaced_name,\n+                    ""No default namespace defined\\n"");\n #endif\n     }\n \n@@ -974,6 +979,7 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n     }\n     strcpy(new_name, p);\n     ns_name->qname=new_name;\n+    ns_name->qname_length=qname_length;\n \n     /* Find the namespace */\n     for(ns=rdf_parser->namespaces; ns ; ns=ns->next)\n@@ -992,7 +998,7 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n     LIBRDF_DEBUG3(rapier_make_namespaced_name,\n                   ""Found namespace prefix %s URI %s\\n"", ns->prefix, ns->uri);\n #endif\n-    ns_name->namespace=ns;\n+    ns_name->nspace=ns;\n   }\n \n \n@@ -1000,9 +1006,9 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n   /* If namespace has a URI and a qname is defined, create the URI\n    * for this element \n    */\n-  if(ns_name->namespace && ns_name->namespace->uri && qname_length) {\n+  if(ns_name->nspace && ns_name->nspace->uri && qname_length) {\n #ifdef LIBRDF_INTERNAL\n-    librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->namespace->uri,\n+    librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->nspace->uri,\n                                                   new_name);\n     if(!uri) {\n       rapier_free_ns_name(ns_name);\n@@ -1011,14 +1017,14 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n     ns_name->uri=uri;\n #else\n     char *uri_string=(char*)LIBRDF_MALLOC(cstring, \n-                                          ns_name->namespace->uri_length + \n+                                          ns_name->nspace->uri_length + \n                                           qname_length + 1);\n     if(!uri_string) {\n       rapier_free_ns_name(ns_name);\n       return NULL;\n     }\n-    strcpy(uri_string, ns_name->namespace->uri);\n-    strcpy(uri_string+ns_name->namespace->uri_length, new_name);\n+    strcpy(uri_string, ns_name->nspace->uri);\n+    strcpy(uri_string + ns_name->nspace->uri_length, new_name);\n     ns_name->uri=uri_string;\n #endif\n   }\n@@ -1032,9 +1038,9 @@ rapier_make_namespaced_name(rapier_parser *rdf_parser, const char *name,\n static void\n rapier_print_ns_name(FILE *stream, rapier_ns_name* name) \n {\n-  if(name->namespace) {\n-    if(name->namespace->prefix)\n-      fprintf(stream, ""%s:%s"", name->namespace->prefix, name->qname);\n+  if(name->nspace) {\n+    if(name->nspace->prefix)\n+      fprintf(stream, ""%s:%s"", name->nspace->prefix, name->qname);\n     else\n       fprintf(stream, ""(default):%s"", name->qname);\n   } else\n@@ -1064,9 +1070,11 @@ rapier_ns_names_equal(rapier_ns_name *name1, rapier_ns_name *name2)\n   if(name1->uri && name2->uri)\n     return librdf_uri_equals(name1->uri, name2->uri);\n #else\n-  if(name1->namespace != name2->namespace)\n+  if(name1->nspace != name2->nspace)\n     return 0;\n #endif\n+  if(name1->qname_length != name2->qname_length)\n+    return 0;\n   if(strcmp(name1->qname, name2->qname))\n     return 0;\n   return 1;\n@@ -1141,12 +1149,12 @@ rapier_free_element(rapier_element *element)\n static void\n rapier_print_element(rapier_element *element, FILE* stream)\n {\n-  int i;\n-\n   rapier_print_ns_name(stream, element->name);\n   fputc(\'\\n\', stream);\n \n   if(element->attribute_count) {\n+    int i;\n+\n     fputs("" attributes: "", stream);\n     for (i = 0; i < element->attribute_count; i++) {\n       if(i)\n@@ -1164,15 +1172,14 @@ static char *\n rapier_format_element(rapier_element *element, int *length_p, int is_end)\n {\n   int length;\n-  int l;\n   char *buffer;\n   char *ptr;\n   int i;\n \n   /* get length of element name (and namespace-prefix: if there is one) */\n-  length=strlen(element->name->qname);\n-  if(element->name->namespace)\n-    length += element->name->namespace->prefix_length + 1;\n+  length=element->name->qname_length;\n+  if(element->name->nspace)\n+    length += element->name->nspace->prefix_length + 1;\n \n   if(is_end)\n     length++; /* / */\n@@ -1183,13 +1190,13 @@ rapier_format_element(rapier_element *element, int *length_p, int is_end)\n     \n     for(i=0; element->attributes[i];) {\n       if(!i)\n-        (length)++; /* \' \' between attributes */\n-      length += strlen(element->attributes[i]->qname) + 2; /* ="" */\n-      if(element->attributes[i]->namespace)\n-        length += element->attributes[i]->namespace->prefix_length + 1;\n+        length++; /* \' \' between attributes */\n+      length += element->attributes[i]->qname_length + 2; /* ="" */\n+      if(element->attributes[i]->nspace)\n+        length += element->attributes[i]->nspace->prefix_length + 1;\n \n       i++;\n-      length += strlen(element->attributes[i]->value) + 1; /* "" */\n+      length += element->attributes[i]->value_length + 1; /* "" */\n       i++;\n     }\n   }\n@@ -1209,14 +1216,14 @@ rapier_format_element(rapier_element *element, int *length_p, int is_end)\n   *ptr++ = \'<\';\n   if(is_end)\n     *ptr++ = \'/\';\n-  if(element->name->namespace) {\n-    strncpy(ptr, element->name->namespace->prefix,\n-            element->name->namespace->prefix_length);\n-    ptr+= element->name->namespace->prefix_length;\n+  if(element->name->nspace) {\n+    strncpy(ptr, element->name->nspace->prefix,\n+            element->name->nspace->prefix_length);\n+    ptr+= element->name->nspace->prefix_length;\n     *ptr++=\':\';\n   }\n   strcpy(ptr, element->name->qname);\n-  ptr += strlen(element->name->qname);\n+  ptr += element->name->qname_length;\n \n   if(!is_end && element->attributes) {\n     *ptr++ = \' \';\n@@ -1224,25 +1231,24 @@ rapier_format_element(rapier_element *element, int *length_p, int is_end)\n       if(!i)\n         *ptr++ =\' \';\n       \n-      if(element->attributes[i]->namespace) {\n-        length += element->attributes[i]->namespace->prefix_length + 1;\n-        strncpy(ptr, element->attributes[i]->namespace->prefix,\n-                element->attributes[i]->namespace->prefix_length);\n-        ptr+= element->attributes[i]->namespace->prefix_length;\n+      if(element->attributes[i]->nspace) {\n+        length += element->attributes[i]->nspace->prefix_length + 1;\n+        strncpy(ptr, element->attributes[i]->nspace->prefix,\n+                element->attributes[i]->nspace->prefix_length);\n+        ptr+= element->attributes[i]->nspace->prefix_length;\n         *ptr++=\':\';\n       }\n     \n       strcpy(ptr, element->attributes[i]->qname);\n-      ptr += strlen(element->attributes[i]->qname);\n+      ptr += element->attributes[i]->qname_length;\n       \n       *ptr++ =\'=\';\n       *ptr++ =\'""\';\n       \n       i++;\n       \n-      l=strlen(element->attributes[i]->value);\n       strcpy(ptr, element->attributes[i]->value);\n-      ptr += l;\n+      ptr += element->attributes[i]->value_length;\n       *ptr++ =\'""\';\n       \n       i++;\n@@ -1295,7 +1301,7 @@ rapier_xml_start_element_handler(void *user_data,\n         /* there is more i.e. xmlns:foo */\n         const char *prefix=atts[i][5] ? &atts[i][6] : NULL;\n \n-        rapier_start_namespace(user_data, prefix, atts[i+1],\n+        rapier_start_namespace(rdf_parser, prefix, atts[i+1],\n                                rdf_parser->depth);\n         /* Is it ok to zap XML parser array things? */\n         atts[i]=NULL; \n@@ -1374,7 +1380,7 @@ rapier_xml_start_element_handler(void *user_data,\n       /* Save pointers to some RDF M&S attributes */\n \n       /* If RDF M&S namespace-prefixed attributes */\n-      if(attribute->namespace && attribute->namespace->is_rdf_ms) {\n+      if(attribute->nspace && attribute->nspace->is_rdf_ms) {\n         const char *attr_name=attribute->qname;\n         int j;\n \n@@ -1876,7 +1882,7 @@ rapier_file_uri_to_filename(const char *uri)\n \n   /* FIXME: unix version of URI -> filename conversion */\n   length=strlen(uri) -5 +1;\n-  filename=LIBRDF_MALLOC(cstring, length);\n+  filename=(char*)LIBRDF_MALLOC(cstring, length);\n   if(!filename)\n     return NULL;\n \n@@ -1980,7 +1986,7 @@ rapier_new(rapier_uri *base_uri)\n   XML_Parser xp;\n #endif\n \n-  rdf_parser=LIBRDF_CALLOC(rapier_parser, 1, sizeof(rapier_parser));\n+  rdf_parser=(rapier_parser*)LIBRDF_CALLOC(rapier_parser, 1, sizeof(rapier_parser));\n \n   if(!rdf_parser)\n     return NULL;\n@@ -2513,7 +2519,7 @@ rapier_make_uri_from_id(rapier_uri *base_uri, const char *id)\n   return new_uri;\n #else\n   len=strlen(base_uri)+1+strlen(id)+1;\n-  new_uri=LIBRDF_MALLOC(cstring, len);\n+  new_uri=(char*)LIBRDF_MALLOC(cstring, len);\n   if(!new_uri)\n     return NULL;\n   sprintf(new_uri, ""%s#%s"", base_uri, id);\n@@ -2543,7 +2549,7 @@ rapier_make_uri(rapier_uri *base_uri, const char *uri_string)\n #else\n   /* If URI string is empty, just copy base URI */\n   if(!*uri_string) {\n-    new_uri=LIBRDF_MALLOC(cstring, base_uri_len+1);\n+    new_uri=(char*)LIBRDF_MALLOC(cstring, base_uri_len+1);\n     if(!new_uri)\n       return NULL;\n     strcpy(new_uri, base_uri);\n@@ -2552,7 +2558,7 @@ rapier_make_uri(rapier_uri *base_uri, const char *uri_string)\n \n   /* If URI string is a fragment #foo, append to base URI */\n   if(*uri_string == \'#\') {\n-    new_uri=LIBRDF_MALLOC(cstring, base_uri_len+1+strlen(uri_string)+1);\n+    new_uri=(char*)LIBRDF_MALLOC(cstring, base_uri_len+1+strlen(uri_string)+1);\n     if(!new_uri)\n       return NULL;\n     strncpy(new_uri, base_uri, base_uri_len);\n@@ -2568,7 +2574,7 @@ rapier_make_uri(rapier_uri *base_uri, const char *uri_string)\n    * Need to check URI spec - FIXME\n    */\n   if(*p && *p == \':\') {\n-    new_uri=LIBRDF_MALLOC(cstring, strlen(uri_string)+1);\n+    new_uri=(char*)LIBRDF_MALLOC(cstring, strlen(uri_string)+1);\n     if(!new_uri)\n       return NULL;\n     strcpy(new_uri, uri_string);\n@@ -2583,7 +2589,7 @@ rapier_make_uri(rapier_uri *base_uri, const char *uri_string)\n   for(p=base_uri+base_uri_len-1; p > base_uri && *p != \'/\' && *p != \':\'; p--)\n     ;\n \n-  new_uri=LIBRDF_MALLOC(cstring, (p-base_uri)+1+strlen(uri_string)+1);\n+  new_uri=(char*)LIBRDF_MALLOC(cstring, (p-base_uri)+1+strlen(uri_string)+1);\n   if(!new_uri)\n     return NULL;\n   strncpy(new_uri, base_uri, p-base_uri+1);\n@@ -2627,7 +2633,7 @@ rapier_process_property_attributes(rapier_parser *rdf_parser,\n      * (attribute has a URI) or non-namespaced predicate (attribute\n      * is just the XML name)\n      */\n-    if(attribute->namespace && attribute->namespace->is_rdf_ms && \n+    if(attribute->nspace && attribute->nspace->is_rdf_ms && \n        IS_RDF_MS_CONCEPT(attribute->qname, attribute->uri, li)) {\n       /* recognise rdf:li attribute */\n       element->last_ordinal++;\n@@ -2660,8 +2666,8 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n   rapier_state state;\n   int i;\n   const char *el_name=element->name->qname;\n-  int element_in_rdf_ns=(element->name->namespace && \n-                         element->name->namespace->is_rdf_ms);\n+  int element_in_rdf_ns=(element->name->nspace && \n+                         element->name->nspace->is_rdf_ms);\n \n \n   if(element->parent) {\n@@ -2988,7 +2994,7 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n           int ordinal = 0;\n           int attribute_problems=0;\n \n-          if(!attribute->namespace || !attribute->namespace->is_rdf_ms) {\n+          if(!attribute->nspace || !attribute->nspace->is_rdf_ms) {\n             /* No namespace or not rdf: namespace */\n             attribute_problems++;\n           } else if (*name != \'_\') {\n@@ -3009,7 +3015,7 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n             }\n           }\n \n-          if(attribute->namespace && attribute->namespace->is_rdf_ms &&\n+          if(attribute->nspace && attribute->nspace->is_rdf_ms &&\n              attribute_problems == 1)\n             /* Warn if unexpected or bad rdf: attributes seen and not\n              * already warned\n@@ -3110,7 +3116,7 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n             /* Append cdata content content */\n             if(element->content_cdata) {\n               /* Append */\n-              char *new_cdata=LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);\n+              char *new_cdata=(char*)LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);\n               if(new_cdata) {\n                 strncpy(new_cdata, element->content_cdata,\n                         element->content_cdata_length);\n@@ -3244,8 +3250,8 @@ rapier_end_element_grammar(rapier_parser *rdf_parser,\n   rapier_state state;\n   int finished;\n   const char *el_name=element->name->qname;\n-  int element_in_rdf_ns=(element->name->namespace && \n-                         element->name->namespace->is_rdf_ms);\n+  int element_in_rdf_ns=(element->name->nspace && \n+                         element->name->nspace->is_rdf_ms);\n \n \n   state=element->state;\n@@ -3365,7 +3371,7 @@ rapier_end_element_grammar(rapier_parser *rdf_parser,\n           fmt_buffer=rapier_format_element(element, &fmt_length,1);\n           if(fmt_buffer && fmt_length) {\n             /* Append cdata content content */\n-            char *new_cdata=LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);\n+            char *new_cdata=(char*)LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);\n             if(new_cdata) {\n               strncpy(new_cdata, element->content_cdata,\n                       element->content_cdata_length);\n@@ -3379,7 +3385,7 @@ rapier_end_element_grammar(rapier_parser *rdf_parser,\n         /* Append this cdata content to parent element cdata content */\n         if(element->parent->content_cdata) {\n           /* Append */\n-          char *new_cdata=LIBRDF_MALLOC(cstring, element->parent->content_cdata_length + element->content_cdata_length + 1);\n+          char *new_cdata=(char*)LIBRDF_MALLOC(cstring, element->parent->content_cdata_length + element->content_cdata_length + 1);\n           if(new_cdata) {\n             strncpy(new_cdata, element->parent->content_cdata,\n                     element->parent->content_cdata_length);\n']",,,"['+   int qname_length;', '+   const rapier_ns_map *nspace;', '+   int value_length;', '+   int attribute_count;', '+   int rdf_attr_count;', '+ static void rapier_start_namespace(rapier_parser *rdf_parser, const char *prefix, const char *nspace, int depth);', '+ static void rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map *nspace);', '+ static void rapier_end_namespace(rapier_parser *rdf_parser, const char *prefix, const char *nspace);', '+                        const char *prefix, const char *nspace, int depth)', '+   char *p;', '+                 prefix ? prefix : ""(default)"", nspace, depth);', '+   if(!*nspace)', '+     nspace=NULL;', '+   if(nspace) {', '+     uri_length=strlen(nspace);', '+   p=(char*)map+sizeof(rapier_ns_map);', '+   if(nspace) {', '+     map->uri=strcpy((char*)p, nspace);', '+   if(nspace) {', '+     if(!strcmp(nspace, rapier_rdf_ms_uri))', '+     else if(!strcmp(nspace, rapier_rdf_schema_uri))', '+ rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* nspace)', '+   LIBRDF_FREE(rapier_ns_map, nspace);', '+                      const char *prefix, const char *nspace)', '+                 prefix ? prefix : ""(default)"", nspace);', '+     int value_length=strlen(value);', '+     char* new_value=(char*)LIBRDF_MALLOC(cstring, value_length+1);', '+     ns_name->value_length=value_length;', '+     ns_name->qname_length=qname_length;', '+       ns_name->nspace=ns;', '+       LIBRDF_DEBUG1(rapier_make_namespaced_name,', '+                     ""No default namespace defined\\n"");', '+     ns_name->qname_length=qname_length;', '+     ns_name->nspace=ns;', '+   if(ns_name->nspace && ns_name->nspace->uri && qname_length) {', '+     librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->nspace->uri,', '+                                           ns_name->nspace->uri_length +', '+     strcpy(uri_string, ns_name->nspace->uri);', '+     strcpy(uri_string + ns_name->nspace->uri_length, new_name);', '+   if(name->nspace) {', '+     if(name->nspace->prefix)', '+       fprintf(stream, ""%s:%s"", name->nspace->prefix, name->qname);', '+   if(name1->nspace != name2->nspace)', '+   if(name1->qname_length != name2->qname_length)', '+     return 0;', '+     int i;', '+   length=element->name->qname_length;', '+   if(element->name->nspace)', '+     length += element->name->nspace->prefix_length + 1;', '+       if(element->attributes[i]->nspace)', '+         length += element->attributes[i]->nspace->prefix_length + 1;', '+   if(element->name->nspace) {', '+     strncpy(ptr, element->name->nspace->prefix,', '+             element->name->nspace->prefix_length);', '+     ptr+= element->name->nspace->prefix_length;', '+   ptr += element->name->qname_length;', '+       if(element->attributes[i]->nspace) {', '+         length += element->attributes[i]->nspace->prefix_length + 1;', '+         strncpy(ptr, element->attributes[i]->nspace->prefix,', '+                 element->attributes[i]->nspace->prefix_length);', '+         ptr+= element->attributes[i]->nspace->prefix_length;', '+       ptr += element->attributes[i]->qname_length;', '+       ptr += element->attributes[i]->value_length;', '+         rapier_start_namespace(rdf_parser, prefix, atts[i+1],', '+       if(attribute->nspace && attribute->nspace->is_rdf_ms) {', '+   filename=(char*)LIBRDF_MALLOC(cstring, length);', '+   rdf_parser=(rapier_parser*)LIBRDF_CALLOC(rapier_parser, 1, sizeof(rapier_parser));', '+   new_uri=(char*)LIBRDF_MALLOC(cstring, len);', '+     new_uri=(char*)LIBRDF_MALLOC(cstring, base_uri_len+1);', '+     new_uri=(char*)LIBRDF_MALLOC(cstring, base_uri_len+1+strlen(uri_string)+1);', '+     new_uri=(char*)LIBRDF_MALLOC(cstring, strlen(uri_string)+1);', '+   new_uri=(char*)LIBRDF_MALLOC(cstring, (p-base_uri)+1+strlen(uri_string)+1);', '+     if(attribute->nspace && attribute->nspace->is_rdf_ms &&', '+   int element_in_rdf_ns=(element->name->nspace &&', '+                          element->name->nspace->is_rdf_ms);', '+           if(!attribute->nspace || !attribute->nspace->is_rdf_ms) {', '+           if(attribute->nspace && attribute->nspace->is_rdf_ms &&', '+               char *new_cdata=(char*)LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);', '+   int element_in_rdf_ns=(element->name->nspace &&', '+                          element->name->nspace->is_rdf_ms);', '+             char *new_cdata=(char*)LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);', '+           char *new_cdata=(char*)LIBRDF_MALLOC(cstring, element->parent->content_cdata_length + element->content_cdata_length + 1);', '-   const rapier_ns_map *namespace;', '-   unsigned int attribute_count;', '-   unsigned int rdf_attr_count;', '- static void rapier_start_namespace(rapier_parser *rdf_parser, const char *prefix, const char *namespace, int depth);', '- static void rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* namespace);', '- static void rapier_end_namespace(rapier_parser *rdf_parser, const char *prefix, const char *namespace);', '-                        const char *prefix, const char *namespace, int depth)', '-   void *p;', '-                 prefix ? prefix : ""(default)"", namespace, depth);', '-   if(!*namespace)', '-     namespace=NULL;', '-   if(namespace) {', '-     uri_length=strlen(namespace);', '-   p=(void*)map+sizeof(rapier_ns_map);', '-   if(namespace) {', '-     map->uri=strcpy((char*)p, namespace);', '-   if(namespace) {', '-     if(!strcmp(namespace, rapier_rdf_ms_uri))', '-     else if(!strcmp(namespace, rapier_rdf_schema_uri))', '- rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* namespace)', '-   LIBRDF_FREE(rapier_ns_map, namespace);', '-                      const char *prefix, const char *namespace)', '-                 prefix ? prefix : ""(default)"", namespace);', '-   char *new_value=NULL;', '-     new_value=(char*)LIBRDF_MALLOC(cstring, strlen(value)+1);', '-       ns_name->namespace=ns;', '-     LIBRDF_DEBUG1(rapier_make_namespaced_name,', '-                   ""No default namespace defined\\n"");', '-     ns_name->namespace=ns;', '-   if(ns_name->namespace && ns_name->namespace->uri && qname_length) {', '-     librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->namespace->uri,', '-                                           ns_name->namespace->uri_length +', '-     strcpy(uri_string, ns_name->namespace->uri);', '-     strcpy(uri_string+ns_name->namespace->uri_length, new_name);', '-   if(name->namespace) {', '-     if(name->namespace->prefix)', '-       fprintf(stream, ""%s:%s"", name->namespace->prefix, name->qname);', '-   if(name1->namespace != name2->namespace)', '-   int i;', '-   int l;', '-   length=strlen(element->name->qname);', '-   if(element->name->namespace)', '-     length += element->name->namespace->prefix_length + 1;', '-       if(element->attributes[i]->namespace)', '-         length += element->attributes[i]->namespace->prefix_length + 1;', '-   if(element->name->namespace) {', '-     strncpy(ptr, element->name->namespace->prefix,', '-             element->name->namespace->prefix_length);', '-     ptr+= element->name->namespace->prefix_length;', '-   ptr += strlen(element->name->qname);', '-       if(element->attributes[i]->namespace) {', '-         length += element->attributes[i]->namespace->prefix_length + 1;', '-         strncpy(ptr, element->attributes[i]->namespace->prefix,', '-                 element->attributes[i]->namespace->prefix_length);', '-         ptr+= element->attributes[i]->namespace->prefix_length;', '-       ptr += strlen(element->attributes[i]->qname);', '-       l=strlen(element->attributes[i]->value);', '-       ptr += l;', '-         rapier_start_namespace(user_data, prefix, atts[i+1],', '-       if(attribute->namespace && attribute->namespace->is_rdf_ms) {', '-   filename=LIBRDF_MALLOC(cstring, length);', '-   rdf_parser=LIBRDF_CALLOC(rapier_parser, 1, sizeof(rapier_parser));', '-   new_uri=LIBRDF_MALLOC(cstring, len);', '-     new_uri=LIBRDF_MALLOC(cstring, base_uri_len+1);', '-     new_uri=LIBRDF_MALLOC(cstring, base_uri_len+1+strlen(uri_string)+1);', '-     new_uri=LIBRDF_MALLOC(cstring, strlen(uri_string)+1);', '-   new_uri=LIBRDF_MALLOC(cstring, (p-base_uri)+1+strlen(uri_string)+1);', '-     if(attribute->namespace && attribute->namespace->is_rdf_ms &&', '-   int element_in_rdf_ns=(element->name->namespace &&', '-                          element->name->namespace->is_rdf_ms);', '-           if(!attribute->namespace || !attribute->namespace->is_rdf_ms) {', '-           if(attribute->namespace && attribute->namespace->is_rdf_ms &&', '-               char *new_cdata=LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);', '-   int element_in_rdf_ns=(element->name->namespace &&', '-                          element->name->namespace->is_rdf_ms);', '-             char *new_cdata=LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);', '-           char *new_cdata=LIBRDF_MALLOC(cstring, element->parent->content_cdata_length + element->content_cdata_length + 1);']","['+   int qname_length;', '+   const rapier_ns_map *nspace;', '+   int value_length;', '+   int attribute_count;', '+   int rdf_attr_count;', '+ static void rapier_start_namespace(rapier_parser *rdf_parser, const char *prefix, const char *nspace, int depth);', '+ static void rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map *nspace);', '+ static void rapier_end_namespace(rapier_parser *rdf_parser, const char *prefix, const char *nspace);', '+                        const char *prefix, const char *nspace, int depth)', '+   char *p;', '+                 prefix ? prefix : ""(default)"", nspace, depth);', '+   if(!*nspace)', '+     nspace=null;', '+   if(nspace) {', '+     uri_length=strlen(nspace);', '+   p=(char*)map+sizeof(rapier_ns_map);', '+   if(nspace) {', '+     map->uri=strcpy((char*)p, nspace);', '+   if(nspace) {', '+     if(!strcmp(nspace, rapier_rdf_ms_uri))', '+     else if(!strcmp(nspace, rapier_rdf_schema_uri))', '+ rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* nspace)', '+   librdf_free(rapier_ns_map, nspace);', '+                      const char *prefix, const char *nspace)', '+                 prefix ? prefix : ""(default)"", nspace);', '+     int value_length=strlen(value);', '+     char* new_value=(char*)librdf_malloc(cstring, value_length+1);', '+     ns_name->value_length=value_length;', '+     ns_name->qname_length=qname_length;', '+       ns_name->nspace=ns;', '+       librdf_debug1(rapier_make_namespaced_name,', '+                     ""no default namespace defined\\n"");', '+     ns_name->qname_length=qname_length;', '+     ns_name->nspace=ns;', '+   if(ns_name->nspace && ns_name->nspace->uri && qname_length) {', '+     librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->nspace->uri,', '+                                           ns_name->nspace->uri_length +', '+     strcpy(uri_string, ns_name->nspace->uri);', '+     strcpy(uri_string + ns_name->nspace->uri_length, new_name);', '+   if(name->nspace) {', '+     if(name->nspace->prefix)', '+       fprintf(stream, ""%s:%s"", name->nspace->prefix, name->qname);', '+   if(name1->nspace != name2->nspace)', '+   if(name1->qname_length != name2->qname_length)', '+     return 0;', '+     int i;', '+   length=element->name->qname_length;', '+   if(element->name->nspace)', '+     length += element->name->nspace->prefix_length + 1;', '+       if(element->attributes[i]->nspace)', '+         length += element->attributes[i]->nspace->prefix_length + 1;', '+   if(element->name->nspace) {', '+     strncpy(ptr, element->name->nspace->prefix,', '+             element->name->nspace->prefix_length);', '+     ptr+= element->name->nspace->prefix_length;', '+   ptr += element->name->qname_length;', '+       if(element->attributes[i]->nspace) {', '+         length += element->attributes[i]->nspace->prefix_length + 1;', '+         strncpy(ptr, element->attributes[i]->nspace->prefix,', '+                 element->attributes[i]->nspace->prefix_length);', '+         ptr+= element->attributes[i]->nspace->prefix_length;', '+       ptr += element->attributes[i]->qname_length;', '+       ptr += element->attributes[i]->value_length;', '+         rapier_start_namespace(rdf_parser, prefix, atts[i+1],', '+       if(attribute->nspace && attribute->nspace->is_rdf_ms) {', '+   filename=(char*)librdf_malloc(cstring, length);', '+   rdf_parser=(rapier_parser*)librdf_calloc(rapier_parser, 1, sizeof(rapier_parser));', '+   new_uri=(char*)librdf_malloc(cstring, len);', '+     new_uri=(char*)librdf_malloc(cstring, base_uri_len+1);', '+     new_uri=(char*)librdf_malloc(cstring, base_uri_len+1+strlen(uri_string)+1);', '+     new_uri=(char*)librdf_malloc(cstring, strlen(uri_string)+1);', '+   new_uri=(char*)librdf_malloc(cstring, (p-base_uri)+1+strlen(uri_string)+1);', '+     if(attribute->nspace && attribute->nspace->is_rdf_ms &&', '+   int element_in_rdf_ns=(element->name->nspace &&', '+                          element->name->nspace->is_rdf_ms);', '+           if(!attribute->nspace || !attribute->nspace->is_rdf_ms) {', '+           if(attribute->nspace && attribute->nspace->is_rdf_ms &&', '+               char *new_cdata=(char*)librdf_malloc(cstring, element->content_cdata_length + fmt_length + 1);', '+   int element_in_rdf_ns=(element->name->nspace &&', '+                          element->name->nspace->is_rdf_ms);', '+             char *new_cdata=(char*)librdf_malloc(cstring, element->content_cdata_length + fmt_length + 1);', '+           char *new_cdata=(char*)librdf_malloc(cstring, element->parent->content_cdata_length + element->content_cdata_length + 1);', '-   const rapier_ns_map *namespace;', '-   unsigned int attribute_count;', '-   unsigned int rdf_attr_count;', '- static void rapier_start_namespace(rapier_parser *rdf_parser, const char *prefix, const char *namespace, int depth);', '- static void rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* namespace);', '- static void rapier_end_namespace(rapier_parser *rdf_parser, const char *prefix, const char *namespace);', '-                        const char *prefix, const char *namespace, int depth)', '-   void *p;', '-                 prefix ? prefix : ""(default)"", namespace, depth);', '-   if(!*namespace)', '-     namespace=null;', '-   if(namespace) {', '-     uri_length=strlen(namespace);', '-   p=(void*)map+sizeof(rapier_ns_map);', '-   if(namespace) {', '-     map->uri=strcpy((char*)p, namespace);', '-   if(namespace) {', '-     if(!strcmp(namespace, rapier_rdf_ms_uri))', '-     else if(!strcmp(namespace, rapier_rdf_schema_uri))', '- rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* namespace)', '-   librdf_free(rapier_ns_map, namespace);', '-                      const char *prefix, const char *namespace)', '-                 prefix ? prefix : ""(default)"", namespace);', '-   char *new_value=null;', '-     new_value=(char*)librdf_malloc(cstring, strlen(value)+1);', '-       ns_name->namespace=ns;', '-     librdf_debug1(rapier_make_namespaced_name,', '-                   ""no default namespace defined\\n"");', '-     ns_name->namespace=ns;', '-   if(ns_name->namespace && ns_name->namespace->uri && qname_length) {', '-     librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->namespace->uri,', '-                                           ns_name->namespace->uri_length +', '-     strcpy(uri_string, ns_name->namespace->uri);', '-     strcpy(uri_string+ns_name->namespace->uri_length, new_name);', '-   if(name->namespace) {', '-     if(name->namespace->prefix)', '-       fprintf(stream, ""%s:%s"", name->namespace->prefix, name->qname);', '-   if(name1->namespace != name2->namespace)', '-   int i;', '-   int l;', '-   length=strlen(element->name->qname);', '-   if(element->name->namespace)', '-     length += element->name->namespace->prefix_length + 1;', '-       if(element->attributes[i]->namespace)', '-         length += element->attributes[i]->namespace->prefix_length + 1;', '-   if(element->name->namespace) {', '-     strncpy(ptr, element->name->namespace->prefix,', '-             element->name->namespace->prefix_length);', '-     ptr+= element->name->namespace->prefix_length;', '-   ptr += strlen(element->name->qname);', '-       if(element->attributes[i]->namespace) {', '-         length += element->attributes[i]->namespace->prefix_length + 1;', '-         strncpy(ptr, element->attributes[i]->namespace->prefix,', '-                 element->attributes[i]->namespace->prefix_length);', '-         ptr+= element->attributes[i]->namespace->prefix_length;', '-       ptr += strlen(element->attributes[i]->qname);', '-       l=strlen(element->attributes[i]->value);', '-       ptr += l;', '-         rapier_start_namespace(user_data, prefix, atts[i+1],', '-       if(attribute->namespace && attribute->namespace->is_rdf_ms) {', '-   filename=librdf_malloc(cstring, length);', '-   rdf_parser=librdf_calloc(rapier_parser, 1, sizeof(rapier_parser));', '-   new_uri=librdf_malloc(cstring, len);', '-     new_uri=librdf_malloc(cstring, base_uri_len+1);', '-     new_uri=librdf_malloc(cstring, base_uri_len+1+strlen(uri_string)+1);', '-     new_uri=librdf_malloc(cstring, strlen(uri_string)+1);', '-   new_uri=librdf_malloc(cstring, (p-base_uri)+1+strlen(uri_string)+1);', '-     if(attribute->namespace && attribute->namespace->is_rdf_ms &&', '-   int element_in_rdf_ns=(element->name->namespace &&', '-                          element->name->namespace->is_rdf_ms);', '-           if(!attribute->namespace || !attribute->namespace->is_rdf_ms) {', '-           if(attribute->namespace && attribute->namespace->is_rdf_ms &&', '-               char *new_cdata=librdf_malloc(cstring, element->content_cdata_length + fmt_length + 1);', '-   int element_in_rdf_ns=(element->name->namespace &&', '-                          element->name->namespace->is_rdf_ms);', '-             char *new_cdata=librdf_malloc(cstring, element->content_cdata_length + fmt_length + 1);', '-           char *new_cdata=librdf_malloc(cstring, element->parent->content_cdata_length + element->content_cdata_length + 1);']","['+   int qname_length;', '+   const rapier_ns_map *nspace;', '+   int value_length;', '+   int attribute_count;', '+   int rdf_attr_count;', '+ static void rapier_start_namespace(rapier_parser *rdf_parser, const char *prefix, const char *nspace, int depth);', '+ static void rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map *nspace);', '+ static void rapier_end_namespace(rapier_parser *rdf_parser, const char *prefix, const char *nspace);', '+                        const char *prefix, const char *nspace, int depth)', '+   char *p;', '+                 prefix ? prefix : ""(default)"", nspace, depth);', '+   if(!*nspace)', '+     nspace=NULL;', '+   if(nspace) {', '+     uri_length=strlen(nspace);', '+   p=(char*)map+sizeof(rapier_ns_map);', '+   if(nspace) {', '+     map->uri=strcpy((char*)p, nspace);', '+   if(nspace) {', '+     if(!strcmp(nspace, rapier_rdf_ms_uri))', '+     else if(!strcmp(nspace, rapier_rdf_schema_uri))', '+ rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* nspace)', '+   LIBRDF_FREE(rapier_ns_map, nspace);', '+                      const char *prefix, const char *nspace)', '+                 prefix ? prefix : ""(default)"", nspace);', '+     int value_length=strlen(value);', '+     char* new_value=(char*)LIBRDF_MALLOC(cstring, value_length+1);', '+     ns_name->value_length=value_length;', '+     ns_name->qname_length=qname_length;', '+       ns_name->nspace=ns;', '+       LIBRDF_DEBUG1(rapier_make_namespaced_name,', '+                     ""No default namespace defined\\n"");', '+     ns_name->qname_length=qname_length;', '+     ns_name->nspace=ns;', '+   if(ns_name->nspace && ns_name->nspace->uri && qname_length) {', '+     librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->nspace->uri,', '+                                           ns_name->nspace->uri_length +', '+     strcpy(uri_string, ns_name->nspace->uri);', '+     strcpy(uri_string + ns_name->nspace->uri_length, new_name);', '+   if(name->nspace) {', '+     if(name->nspace->prefix)', '+       fprintf(stream, ""%s:%s"", name->nspace->prefix, name->qname);', '+   if(name1->nspace != name2->nspace)', '+   if(name1->qname_length != name2->qname_length)', '+     return 0;', '+     int i;', '+   length=element->name->qname_length;', '+   if(element->name->nspace)', '+     length += element->name->nspace->prefix_length + 1;', '+       if(element->attributes[i]->nspace)', '+         length += element->attributes[i]->nspace->prefix_length + 1;', '+   if(element->name->nspace) {', '+     strncpy(ptr, element->name->nspace->prefix,', '+             element->name->nspace->prefix_length);', '+     ptr+= element->name->nspace->prefix_length;', '+   ptr += element->name->qname_length;', '+       if(element->attributes[i]->nspace) {', '+         length += element->attributes[i]->nspace->prefix_length + 1;', '+         strncpy(ptr, element->attributes[i]->nspace->prefix,', '+                 element->attributes[i]->nspace->prefix_length);', '+         ptr+= element->attributes[i]->nspace->prefix_length;', '+       ptr += element->attributes[i]->qname_length;', '+       ptr += element->attributes[i]->value_length;', '+         rapier_start_namespace(rdf_parser, prefix, atts[i+1],', '+       if(attribute->nspace && attribute->nspace->is_rdf_ms) {', '+   filename=(char*)LIBRDF_MALLOC(cstring, length);', '+   rdf_parser=(rapier_parser*)LIBRDF_CALLOC(rapier_parser, 1, sizeof(rapier_parser));', '+   new_uri=(char*)LIBRDF_MALLOC(cstring, len);', '+     new_uri=(char*)LIBRDF_MALLOC(cstring, base_uri_len+1);', '+     new_uri=(char*)LIBRDF_MALLOC(cstring, base_uri_len+1+strlen(uri_string)+1);', '+     new_uri=(char*)LIBRDF_MALLOC(cstring, strlen(uri_string)+1);', '+   new_uri=(char*)LIBRDF_MALLOC(cstring, (p-base_uri)+1+strlen(uri_string)+1);', '+     if(attribute->nspace && attribute->nspace->is_rdf_ms &&', '+   int element_in_rdf_ns=(element->name->nspace &&', '+                          element->name->nspace->is_rdf_ms);', '+           if(!attribute->nspace || !attribute->nspace->is_rdf_ms) {', '+           if(attribute->nspace && attribute->nspace->is_rdf_ms &&', '+               char *new_cdata=(char*)LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);', '+   int element_in_rdf_ns=(element->name->nspace &&', '+                          element->name->nspace->is_rdf_ms);', '+             char *new_cdata=(char*)LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);', '+           char *new_cdata=(char*)LIBRDF_MALLOC(cstring, element->parent->content_cdata_length + element->content_cdata_length + 1);']","['-   const rapier_ns_map *namespace;', '-   unsigned int attribute_count;', '-   unsigned int rdf_attr_count;', '- static void rapier_start_namespace(rapier_parser *rdf_parser, const char *prefix, const char *namespace, int depth);', '- static void rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* namespace);', '- static void rapier_end_namespace(rapier_parser *rdf_parser, const char *prefix, const char *namespace);', '-                        const char *prefix, const char *namespace, int depth)', '-   void *p;', '-                 prefix ? prefix : ""(default)"", namespace, depth);', '-   if(!*namespace)', '-     namespace=NULL;', '-   if(namespace) {', '-     uri_length=strlen(namespace);', '-   p=(void*)map+sizeof(rapier_ns_map);', '-   if(namespace) {', '-     map->uri=strcpy((char*)p, namespace);', '-   if(namespace) {', '-     if(!strcmp(namespace, rapier_rdf_ms_uri))', '-     else if(!strcmp(namespace, rapier_rdf_schema_uri))', '- rapier_free_namespace(rapier_parser *rdf_parser,  rapier_ns_map* namespace)', '-   LIBRDF_FREE(rapier_ns_map, namespace);', '-                      const char *prefix, const char *namespace)', '-                 prefix ? prefix : ""(default)"", namespace);', '-   char *new_value=NULL;', '-     new_value=(char*)LIBRDF_MALLOC(cstring, strlen(value)+1);', '-       ns_name->namespace=ns;', '-     LIBRDF_DEBUG1(rapier_make_namespaced_name,', '-                   ""No default namespace defined\\n"");', '-     ns_name->namespace=ns;', '-   if(ns_name->namespace && ns_name->namespace->uri && qname_length) {', '-     librdf_uri* uri=librdf_new_uri_from_uri_qname(ns_name->namespace->uri,', '-                                           ns_name->namespace->uri_length +', '-     strcpy(uri_string, ns_name->namespace->uri);', '-     strcpy(uri_string+ns_name->namespace->uri_length, new_name);', '-   if(name->namespace) {', '-     if(name->namespace->prefix)', '-       fprintf(stream, ""%s:%s"", name->namespace->prefix, name->qname);', '-   if(name1->namespace != name2->namespace)', '-   int i;', '-   int l;', '-   length=strlen(element->name->qname);', '-   if(element->name->namespace)', '-     length += element->name->namespace->prefix_length + 1;', '-       if(element->attributes[i]->namespace)', '-         length += element->attributes[i]->namespace->prefix_length + 1;', '-   if(element->name->namespace) {', '-     strncpy(ptr, element->name->namespace->prefix,', '-             element->name->namespace->prefix_length);', '-     ptr+= element->name->namespace->prefix_length;', '-   ptr += strlen(element->name->qname);', '-       if(element->attributes[i]->namespace) {', '-         length += element->attributes[i]->namespace->prefix_length + 1;', '-         strncpy(ptr, element->attributes[i]->namespace->prefix,', '-                 element->attributes[i]->namespace->prefix_length);', '-         ptr+= element->attributes[i]->namespace->prefix_length;', '-       ptr += strlen(element->attributes[i]->qname);', '-       l=strlen(element->attributes[i]->value);', '-       ptr += l;', '-         rapier_start_namespace(user_data, prefix, atts[i+1],', '-       if(attribute->namespace && attribute->namespace->is_rdf_ms) {', '-   filename=LIBRDF_MALLOC(cstring, length);', '-   rdf_parser=LIBRDF_CALLOC(rapier_parser, 1, sizeof(rapier_parser));', '-   new_uri=LIBRDF_MALLOC(cstring, len);', '-     new_uri=LIBRDF_MALLOC(cstring, base_uri_len+1);', '-     new_uri=LIBRDF_MALLOC(cstring, base_uri_len+1+strlen(uri_string)+1);', '-     new_uri=LIBRDF_MALLOC(cstring, strlen(uri_string)+1);', '-   new_uri=LIBRDF_MALLOC(cstring, (p-base_uri)+1+strlen(uri_string)+1);', '-     if(attribute->namespace && attribute->namespace->is_rdf_ms &&', '-   int element_in_rdf_ns=(element->name->namespace &&', '-                          element->name->namespace->is_rdf_ms);', '-           if(!attribute->namespace || !attribute->namespace->is_rdf_ms) {', '-           if(attribute->namespace && attribute->namespace->is_rdf_ms &&', '-               char *new_cdata=LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);', '-   int element_in_rdf_ns=(element->name->namespace &&', '-                          element->name->namespace->is_rdf_ms);', '-             char *new_cdata=LIBRDF_MALLOC(cstring, element->content_cdata_length + fmt_length + 1);', '-           char *new_cdata=LIBRDF_MALLOC(cstring, element->parent->content_cdata_length + element->content_cdata_length + 1);']",82,77.0,159.0,0c78baa9853b26c72d7fcef31d743c23437329a5dajobe/raptor,[]
d40e88a0164bbeb8027e9321cd95107c81e09d63,php/php-src,mod_php3.c,train,C,0,"['@@ -49,6 +49,14 @@\n #include ""http_log.h""\n #endif\n \n+\n+/* These are taken out of php_ini.h\n+ * they must be updated if php_ini.h changes!\n+ */\n+#define PHP_INI_USER    (1<<0)\n+#define PHP_INI_PERDIR  (1<<1)\n+#define PHP_INI_SYSTEM  (1<<2)\n+\n #include ""util_script.h""\n \n #include ""php_version.h""\n@@ -384,6 +392,36 @@ char *php3flaghandler(cmd_parms * cmd, php3_ini_structure * conf, int val)\n \treturn NULL;\n }\n \n+\n+#if MODULE_MAGIC_NUMBER > 19961007\n+#define CONST_PREFIX const\n+#else\n+#define CONST_PREFIX\n+#endif\n+\n+CONST_PREFIX char *php_apache_value_handler(cmd_parms *cmd, php3_ini_structure *conf, char *arg1, char *arg2)\n+{\n+\tphp_alter_ini_entry(arg1, strlen(arg1)+1, arg2, strlen(arg2)+1, PHP_INI_PERDIR);\n+\treturn NULL;\n+}\n+\n+\n+CONST_PREFIX char *php_apache_flag_handler(cmd_parms *cmd, php3_ini_structure *conf, char *arg1, char *arg2)\n+{\n+\tchar bool_val[2];\n+\n+\tif (!strcmp(arg2, ""On"")) {\n+\t\tbool_val[0] = \'1\';\n+\t} else {\n+\t\tbool_val[0] = \'0\';\n+\t}\n+\tbool_val[1] = 0;\n+\t\n+\tphp_alter_ini_entry(arg1, strlen(arg1)+1, bool_val, 2, PHP_INI_PERDIR);\n+\treturn NULL;\n+}\n+\n+\n #if MODULE_MAGIC_NUMBER > 19961007\n const char *php3take1handler(cmd_parms * cmd, php3_ini_structure * conf, char *arg)\n {\n@@ -546,6 +584,8 @@ handler_rec php3_handlers[] =\n \n command_rec php3_commands[] =\n {\n+\t{""php4_directive"",\t\tphp_apache_value_handler, NULL, OR_OPTIONS, TAKE2, ""PHP Value Modifier""},\n+\t{""php4_flag"",\t\t\tphp_apache_flag_handler, NULL, OR_OPTIONS, TAKE2, ""PHP Flag Modifier""},\n \t{""php3_error_reporting"", php3take1handler, (void *)0, OR_OPTIONS, TAKE1, ""error reporting level""},\n \t{""php3_doc_root"", php3take1handler, (void *)1, ACCESS_CONF|RSRC_CONF, TAKE1, ""directory""}, /* not used yet */\n \t{""php3_user_dir"", php3take1handler, (void *)2, ACCESS_CONF|RSRC_CONF, TAKE1, ""user directory""}, /* not used yet */\n']",,,"['+ #define PHP_INI_USER    (1<<0)', '+ #define PHP_INI_PERDIR  (1<<1)', '+ #define PHP_INI_SYSTEM  (1<<2)', '+ #if MODULE_MAGIC_NUMBER > 19961007', '+ #define CONST_PREFIX const', '+ #else', '+ #define CONST_PREFIX', '+ #endif', '+ CONST_PREFIX char *php_apache_value_handler(cmd_parms *cmd, php3_ini_structure *conf, char *arg1, char *arg2)', '+ {', '+ \tphp_alter_ini_entry(arg1, strlen(arg1)+1, arg2, strlen(arg2)+1, PHP_INI_PERDIR);', '+ \treturn NULL;', '+ }', '+ CONST_PREFIX char *php_apache_flag_handler(cmd_parms *cmd, php3_ini_structure *conf, char *arg1, char *arg2)', '+ {', '+ \tchar bool_val[2];', '+ \tif (!strcmp(arg2, ""On"")) {', ""+ \t\tbool_val[0] = '1';"", '+ \t} else {', ""+ \t\tbool_val[0] = '0';"", '+ \t}', '+ \tbool_val[1] = 0;', '+ \tphp_alter_ini_entry(arg1, strlen(arg1)+1, bool_val, 2, PHP_INI_PERDIR);', '+ \treturn NULL;', '+ }', '+ \t{""php4_directive"",\t\tphp_apache_value_handler, NULL, OR_OPTIONS, TAKE2, ""PHP Value Modifier""},', '+ \t{""php4_flag"",\t\t\tphp_apache_flag_handler, NULL, OR_OPTIONS, TAKE2, ""PHP Flag Modifier""},']","['+ #define php_ini_user    (1<<0)', '+ #define php_ini_perdir  (1<<1)', '+ #define php_ini_system  (1<<2)', '+ #if module_magic_number > 19961007', '+ #define const_prefix const', '+ #else', '+ #define const_prefix', '+ #endif', '+ const_prefix char *php_apache_value_handler(cmd_parms *cmd, php3_ini_structure *conf, char *arg1, char *arg2)', '+ {', '+ \tphp_alter_ini_entry(arg1, strlen(arg1)+1, arg2, strlen(arg2)+1, php_ini_perdir);', '+ \treturn null;', '+ }', '+ const_prefix char *php_apache_flag_handler(cmd_parms *cmd, php3_ini_structure *conf, char *arg1, char *arg2)', '+ {', '+ \tchar bool_val[2];', '+ \tif (!strcmp(arg2, ""on"")) {', ""+ \t\tbool_val[0] = '1';"", '+ \t} else {', ""+ \t\tbool_val[0] = '0';"", '+ \t}', '+ \tbool_val[1] = 0;', '+ \tphp_alter_ini_entry(arg1, strlen(arg1)+1, bool_val, 2, php_ini_perdir);', '+ \treturn null;', '+ }', '+ \t{""php4_directive"",\t\tphp_apache_value_handler, null, or_options, take2, ""php value modifier""},', '+ \t{""php4_flag"",\t\t\tphp_apache_flag_handler, null, or_options, take2, ""php flag modifier""},']","['+ #define PHP_INI_USER    (1<<0)', '+ #define PHP_INI_PERDIR  (1<<1)', '+ #define PHP_INI_SYSTEM  (1<<2)', '+ #if MODULE_MAGIC_NUMBER > 19961007', '+ #define CONST_PREFIX const', '+ #else', '+ #define CONST_PREFIX', '+ #endif', '+ CONST_PREFIX char *php_apache_value_handler(cmd_parms *cmd, php3_ini_structure *conf, char *arg1, char *arg2)', '+ {', '+ \tphp_alter_ini_entry(arg1, strlen(arg1)+1, arg2, strlen(arg2)+1, PHP_INI_PERDIR);', '+ \treturn NULL;', '+ }', '+ CONST_PREFIX char *php_apache_flag_handler(cmd_parms *cmd, php3_ini_structure *conf, char *arg1, char *arg2)', '+ {', '+ \tchar bool_val[2];', '+ \tif (!strcmp(arg2, ""On"")) {', ""+ \t\tbool_val[0] = '1';"", '+ \t} else {', ""+ \t\tbool_val[0] = '0';"", '+ \t}', '+ \tbool_val[1] = 0;', '+ \tphp_alter_ini_entry(arg1, strlen(arg1)+1, bool_val, 2, PHP_INI_PERDIR);', '+ \treturn NULL;', '+ }', '+ \t{""php4_directive"",\t\tphp_apache_value_handler, NULL, OR_OPTIONS, TAKE2, ""PHP Value Modifier""},', '+ \t{""php4_flag"",\t\t\tphp_apache_flag_handler, NULL, OR_OPTIONS, TAKE2, ""PHP Flag Modifier""},']",[],27,0.0,27.0,d40e88a0164bbeb8027e9321cd95107c81e09d63php/php-src,[]
5349fe7e02b3d85550ee02afc88953e886fbcb3b,dajobe/raptor,src/raptor_rdfxml.c,train,C,1,"['@@ -655,7 +655,7 @@ raptor_rdfxml_start_element_handler(void *user_data,\n           continue;\n \n         /* If non namespace-prefixed RDF attributes found on an element */\n-        if(rdf_parser->options[RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES] &&\n+        if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES) &&\n            !attr->nspace) {\n           const unsigned char *attr_name = attr->local_name;\n           int j;\n@@ -996,13 +996,13 @@ raptor_rdfxml_parse_start(raptor_parser* rdf_parser)\n    * http://www.w3.org/TR/rdf-concepts/#dfn-language-identifier\n    */\n   raptor_sax2_set_option(rdf_xml_parser->sax2,\n-                          RAPTOR_OPTION_NORMALIZE_LANGUAGE, \n-                          rdf_parser->options[RAPTOR_OPTION_NORMALIZE_LANGUAGE]);\n+                         RAPTOR_OPTION_NORMALIZE_LANGUAGE,\n+                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NORMALIZE_LANGUAGE));\n \n   /* Optionally forbid network requests in the XML parser */\n   raptor_sax2_set_option(rdf_xml_parser->sax2, \n-                          RAPTOR_OPTION_NO_NET,\n-                          rdf_parser->options[RAPTOR_OPTION_NO_NET]);\n+                         RAPTOR_OPTION_NO_NET,\n+                         RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));\n   \n   raptor_sax2_parse_start(rdf_xml_parser->sax2, uri);\n \n@@ -1013,7 +1013,7 @@ raptor_rdfxml_parse_start(raptor_parser* rdf_parser)\n   }\n   \n   /* Create a new id_set if needed */\n-  if(rdf_parser->options[RAPTOR_OPTION_CHECK_RDF_ID]) {\n+  if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID)) {\n     rdf_xml_parser->id_set = raptor_new_id_set(rdf_parser->world);\n     if(!rdf_xml_parser->id_set)\n       return 1;\n@@ -1203,7 +1203,7 @@ raptor_rdfxml_generate_statement(raptor_parser *rdf_parser,\n \n \n   /* the bagID mess */\n-  if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID] &&\n+  if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID) &&\n      bag_element && bag_element->bag) {\n     raptor_term* bag = bag_element->bag;\n     raptor_uri* bag_predicate_uri = NULL;\n@@ -1370,7 +1370,7 @@ raptor_rdfxml_process_property_attributes(raptor_parser *rdf_parser,\n \n       message = ""Property attribute \'%s\' has a string not in Unicode Normal Form C: %s"";\n       raptor_rdfxml_update_document_locator(rdf_parser);\n-      if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])\n+      if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))\n         raptor_parser_error(rdf_parser, message, name, value);\n       else\n         raptor_parser_warning(rdf_parser, message, name, value);\n@@ -1477,7 +1477,7 @@ raptor_rdfxml_process_property_attributes(raptor_parser *rdf_parser,\n       const char *message;\n       message = ""Property attribute \'%s\' has a string not in Unicode Normal Form C: %s"";\n       raptor_rdfxml_update_document_locator(rdf_parser);\n-      if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])\n+      if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))\n         raptor_parser_error(rdf_parser, message,\n                             raptor_rdf_ns_terms_info[i].name, value);\n       else\n@@ -1600,7 +1600,7 @@ raptor_rdfxml_start_element_grammar(raptor_parser *rdf_parser,\n         }\n \n         /* If scanning for element, can continue */\n-        if(rdf_parser->options[RAPTOR_OPTION_SCANNING]) {\n+        if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_SCANNING)) {\n           finished = 1;\n           break;\n         }\n@@ -1811,7 +1811,7 @@ raptor_rdfxml_start_element_grammar(raptor_parser *rdf_parser,\n \n \n         if(element->rdf_attr[RDF_NS_bagID]) {\n-          if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID]) {\n+          if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID)) {\n             unsigned char* bag_id;\n             raptor_uri* bag_uri = NULL;\n \n@@ -1895,7 +1895,7 @@ raptor_rdfxml_start_element_grammar(raptor_parser *rdf_parser,\n             }\n \n             if((element->content_type == RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_DAML_COLLECTION) ||\n-               rdf_parser->options[RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST]) {\n+               RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST)) {\n               raptor_uri* class_uri = NULL;\n \n               if(element->content_type == RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_DAML_COLLECTION) {\n@@ -2128,7 +2128,7 @@ raptor_rdfxml_start_element_grammar(raptor_parser *rdf_parser,\n \n         if(element->rdf_attr[RDF_NS_bagID]) {\n \n-          if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID]) {\n+          if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID)) {\n \n             if(element->rdf_attr[RDF_NS_resource] ||\n                element->rdf_attr[RDF_NS_parseType]) {\n@@ -2247,14 +2247,14 @@ raptor_rdfxml_start_element_grammar(raptor_parser *rdf_parser,\n             element->child_state = RAPTOR_STATE_PARSETYPE_COLLECTION;\n             element->child_content_type = RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_COLLECTION;\n           } else {\n-            if(rdf_parser->options[RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES] &&\n+            if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES) &&\n                !raptor_strcasecmp((char*)parse_type, ""daml:collection"")) {\n                 /* A DAML collection appears as a single node */\n                 element->content_type = RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_RESOURCE;\n                 element->child_state = RAPTOR_STATE_PARSETYPE_COLLECTION;\n                 element->child_content_type = RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_DAML_COLLECTION;\n             } else {\n-              if(rdf_parser->options[RAPTOR_OPTION_WARN_OTHER_PARSETYPES]) {\n+              if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_WARN_OTHER_PARSETYPES)) {\n                 raptor_parser_warning(rdf_parser, ""Unknown rdf:parseType value \'%s\' taken as \'Literal\'"", parse_type);\n               }\n               is_parseType_Literal = 1;\n@@ -2416,7 +2416,7 @@ raptor_rdfxml_end_element_grammar(raptor_parser *rdf_parser,\n         /* When scanning, another element ending is outside the RDF\n          * world so this can happen without further work\n          */\n-        if(rdf_parser->options[RAPTOR_OPTION_SCANNING]) {\n+        if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_SCANNING)) {\n           state = RAPTOR_STATE_UNKNOWN;\n           finished = 1;\n           break;\n@@ -2665,7 +2665,7 @@ raptor_rdfxml_end_element_grammar(raptor_parser *rdf_parser,\n \n             if(element->content_type == RAPTOR_RDFXML_ELEMENT_CONTENT_TYPE_LITERAL) {\n \n-              if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID]) {\n+              if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID)) {\n                 /* Only an empty literal can have a rdf:bagID */\n                 if(element->bag) {\n                   if(xml_element->content_cdata_length > 0) {\n@@ -2766,7 +2766,7 @@ raptor_rdfxml_end_element_grammar(raptor_parser *rdf_parser,\n                   const char *message;\n                   message = ""Property element \'%s\' has a string not in Unicode Normal Form C: %s"";\n                   raptor_rdfxml_update_document_locator(rdf_parser);\n-                  if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])\n+                  if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))\n                     raptor_parser_error(rdf_parser, message, el_name, literal);\n                   else\n                     raptor_parser_warning(rdf_parser, message, el_name, literal);\n@@ -2819,7 +2819,7 @@ raptor_rdfxml_end_element_grammar(raptor_parser *rdf_parser,\n                 const char *message;\n                 message = ""Property element \'%s\' has XML literal content not in Unicode Normal Form C: %s"";\n                 raptor_rdfxml_update_document_locator(rdf_parser);\n-                if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])\n+                if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))\n                   raptor_parser_error(rdf_parser, message, el_name, buffer);\n                 else\n                   raptor_parser_warning(rdf_parser, message, el_name, buffer);\n@@ -2982,7 +2982,7 @@ raptor_rdfxml_cdata_grammar(raptor_parser *rdf_parser,\n \n   if(state == RAPTOR_STATE_UNKNOWN) {\n     /* Ignore all cdata if still looking for RDF */\n-    if(rdf_parser->options[RAPTOR_OPTION_SCANNING])\n+    if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_SCANNING))\n       return;\n \n     /* Ignore all whitespace cdata before first element */\n@@ -3108,7 +3108,7 @@ raptor_rdfxml_record_ID(raptor_parser *rdf_parser,\n   \n   rdf_xml_parser = (raptor_rdfxml_parser*)rdf_parser->context;\n \n-  if(!rdf_parser->options[RAPTOR_OPTION_CHECK_RDF_ID])\n+  if(!RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID))\n     return 0;\n \n   base_uri = raptor_rdfxml_inscope_base_uri(rdf_parser);\n']",2010-03-09 12:42:51-08:00,"Move per-parser-project options into a raptor_object_options type.

raptor_object_options typedef added.

raptor_parser_s: use above rather than array of int.

(RAPTOR_OPTIONS_GET_NUMERIC, RAPTOR_OPTIONS_SET_NUMERIC): Added and
used by parsers.","[['+         if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES) &&', '+                          RAPTOR_OPTION_NORMALIZE_LANGUAGE,', '+                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NORMALIZE_LANGUAGE));', '+                          RAPTOR_OPTION_NO_NET,', '+                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));', '+   if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID)) {', '+   if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID) &&', '+       if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))', '+       if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))', '+         if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_SCANNING)) {', '+           if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID)) {', '+                RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST)) {', '+           if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID)) {', '+             if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES) &&', '+               if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_WARN_OTHER_PARSETYPES)) {', '+         if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_SCANNING)) {', '+               if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID)) {', '+                   if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))', '+                 if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))', '+     if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_SCANNING))', '+   if(!RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID))', '-         if(rdf_parser->options[RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES] &&', '-                           RAPTOR_OPTION_NORMALIZE_LANGUAGE,', '-                           rdf_parser->options[RAPTOR_OPTION_NORMALIZE_LANGUAGE]);', '-                           RAPTOR_OPTION_NO_NET,', '-                           rdf_parser->options[RAPTOR_OPTION_NO_NET]);', '-   if(rdf_parser->options[RAPTOR_OPTION_CHECK_RDF_ID]) {', '-   if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID] &&', '-       if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])', '-       if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])', '-         if(rdf_parser->options[RAPTOR_OPTION_SCANNING]) {', '-           if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID]) {', '-                rdf_parser->options[RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST]) {', '-           if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID]) {', '-             if(rdf_parser->options[RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES] &&', '-               if(rdf_parser->options[RAPTOR_OPTION_WARN_OTHER_PARSETYPES]) {', '-         if(rdf_parser->options[RAPTOR_OPTION_SCANNING]) {', '-               if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID]) {', '-                   if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])', '-                 if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])', '-     if(rdf_parser->options[RAPTOR_OPTION_SCANNING])', '-   if(!rdf_parser->options[RAPTOR_OPTION_CHECK_RDF_ID])']]","[['+         if(raptor_options_get_numeric(rdf_parser, raptor_option_allow_non_ns_attributes) &&', '+                          raptor_option_normalize_language,', '+                          raptor_options_get_numeric(rdf_parser, raptor_option_normalize_language));', '+                          raptor_option_no_net,', '+                          raptor_options_get_numeric(rdf_parser, raptor_option_no_net));', '+   if(raptor_options_get_numeric(rdf_parser, raptor_option_check_rdf_id)) {', '+   if(raptor_options_get_numeric(rdf_parser, raptor_option_allow_bagid) &&', '+       if(raptor_options_get_numeric(rdf_parser, raptor_option_non_nfc_fatal))', '+       if(raptor_options_get_numeric(rdf_parser, raptor_option_non_nfc_fatal))', '+         if(raptor_options_get_numeric(rdf_parser, raptor_option_scanning)) {', '+           if(raptor_options_get_numeric(rdf_parser, raptor_option_allow_bagid)) {', '+                raptor_options_get_numeric(rdf_parser, raptor_option_allow_rdf_type_rdf_list)) {', '+           if(raptor_options_get_numeric(rdf_parser, raptor_option_allow_bagid)) {', '+             if(raptor_options_get_numeric(rdf_parser, raptor_option_allow_other_parsetypes) &&', '+               if(raptor_options_get_numeric(rdf_parser, raptor_option_warn_other_parsetypes)) {', '+         if(raptor_options_get_numeric(rdf_parser, raptor_option_scanning)) {', '+               if(raptor_options_get_numeric(rdf_parser, raptor_option_allow_bagid)) {', '+                   if(raptor_options_get_numeric(rdf_parser, raptor_option_non_nfc_fatal))', '+                 if(raptor_options_get_numeric(rdf_parser, raptor_option_non_nfc_fatal))', '+     if(raptor_options_get_numeric(rdf_parser, raptor_option_scanning))', '+   if(!raptor_options_get_numeric(rdf_parser, raptor_option_check_rdf_id))', '-         if(rdf_parser->options[raptor_option_allow_non_ns_attributes] &&', '-                           raptor_option_normalize_language,', '-                           rdf_parser->options[raptor_option_normalize_language]);', '-                           raptor_option_no_net,', '-                           rdf_parser->options[raptor_option_no_net]);', '-   if(rdf_parser->options[raptor_option_check_rdf_id]) {', '-   if(rdf_parser->options[raptor_option_allow_bagid] &&', '-       if(rdf_parser->options[raptor_option_non_nfc_fatal])', '-       if(rdf_parser->options[raptor_option_non_nfc_fatal])', '-         if(rdf_parser->options[raptor_option_scanning]) {', '-           if(rdf_parser->options[raptor_option_allow_bagid]) {', '-                rdf_parser->options[raptor_option_allow_rdf_type_rdf_list]) {', '-           if(rdf_parser->options[raptor_option_allow_bagid]) {', '-             if(rdf_parser->options[raptor_option_allow_other_parsetypes] &&', '-               if(rdf_parser->options[raptor_option_warn_other_parsetypes]) {', '-         if(rdf_parser->options[raptor_option_scanning]) {', '-               if(rdf_parser->options[raptor_option_allow_bagid]) {', '-                   if(rdf_parser->options[raptor_option_non_nfc_fatal])', '-                 if(rdf_parser->options[raptor_option_non_nfc_fatal])', '-     if(rdf_parser->options[raptor_option_scanning])', '-   if(!rdf_parser->options[raptor_option_check_rdf_id])']]","[['+         if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES) &&', '+                          RAPTOR_OPTION_NORMALIZE_LANGUAGE,', '+                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NORMALIZE_LANGUAGE));', '+                          RAPTOR_OPTION_NO_NET,', '+                          RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NO_NET));', '+   if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID)) {', '+   if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID) &&', '+       if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))', '+       if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))', '+         if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_SCANNING)) {', '+           if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID)) {', '+                RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST)) {', '+           if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID)) {', '+             if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES) &&', '+               if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_WARN_OTHER_PARSETYPES)) {', '+         if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_SCANNING)) {', '+               if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_ALLOW_BAGID)) {', '+                   if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))', '+                 if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_NON_NFC_FATAL))', '+     if(RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_SCANNING))', '+   if(!RAPTOR_OPTIONS_GET_NUMERIC(rdf_parser, RAPTOR_OPTION_CHECK_RDF_ID))']]","[['-         if(rdf_parser->options[RAPTOR_OPTION_ALLOW_NON_NS_ATTRIBUTES] &&', '-                           RAPTOR_OPTION_NORMALIZE_LANGUAGE,', '-                           rdf_parser->options[RAPTOR_OPTION_NORMALIZE_LANGUAGE]);', '-                           RAPTOR_OPTION_NO_NET,', '-                           rdf_parser->options[RAPTOR_OPTION_NO_NET]);', '-   if(rdf_parser->options[RAPTOR_OPTION_CHECK_RDF_ID]) {', '-   if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID] &&', '-       if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])', '-       if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])', '-         if(rdf_parser->options[RAPTOR_OPTION_SCANNING]) {', '-           if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID]) {', '-                rdf_parser->options[RAPTOR_OPTION_ALLOW_RDF_TYPE_RDF_LIST]) {', '-           if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID]) {', '-             if(rdf_parser->options[RAPTOR_OPTION_ALLOW_OTHER_PARSETYPES] &&', '-               if(rdf_parser->options[RAPTOR_OPTION_WARN_OTHER_PARSETYPES]) {', '-         if(rdf_parser->options[RAPTOR_OPTION_SCANNING]) {', '-               if(rdf_parser->options[RAPTOR_OPTION_ALLOW_BAGID]) {', '-                   if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])', '-                 if(rdf_parser->options[RAPTOR_OPTION_NON_NFC_FATAL])', '-     if(rdf_parser->options[RAPTOR_OPTION_SCANNING])', '-   if(!rdf_parser->options[RAPTOR_OPTION_CHECK_RDF_ID])']]",21,21.0,42.0,5349fe7e02b3d85550ee02afc88953e886fbcb3bdajobe/raptor,"['a676f235309a59d4aa78eeffd2574ae5d341fcb0', 'a676f235309a59d4aa78eeffd2574ae5d341fcb0']"
764eb0caaffbd0db6c38306eefb21115d6f7eb51,jabberd2/jabberd2,c2s/main.c,val,C,1,"['@@ -422,8 +422,8 @@ static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cb\n             /* make node a random string */\n             jid_random_part(&jid, jid_NODE);\n \n-            strcpy(buf, jid_full(&jid));\n-        \n+            strcpy(buf, jid.node);\n+\n             *res = (void *)buf;\n \n             return sx_sasl_ret_OK;\n']",2008-03-14 22:37:50+00:00,crash-recovery of repository files,"[['+             strcpy(buf, jid.node);', '+ ', '-             strcpy(buf, jid_full(&jid));', '- ']]","[['+             strcpy(buf, jid.node);', '+ ', '-             strcpy(buf, jid_full(&jid));', '- ']]","[['+             strcpy(buf, jid.node);', '+ ']]","[['-             strcpy(buf, jid_full(&jid));', '- ']]",2,2.0,4.0,764eb0caaffbd0db6c38306eefb21115d6f7eb51jabberd2/jabberd2,['8416ae54ecefa670534f27a31db71d048b9c7f16']
5c0645db483680f01bc5d9cd2a12f63e7afd0c44,file/file,src/readelf.c,test,C,1,"['@@ -38,7 +38,7 @@\n #include ""magic.h""\n \n #ifndef lint\n-FILE_RCSID(""@(#)$File: readelf.c,v 1.72 2008/02/19 15:53:09 christos Exp $"")\n+FILE_RCSID(""@(#)$File: readelf.c,v 1.73 2008/03/27 22:00:28 christos Exp $"")\n #endif\n \n #ifdef\tELFCORE\n@@ -47,7 +47,8 @@ private int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t,\n #endif\n private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,\n     off_t, int *);\n-private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *);\n+private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *,\n+    int);\n private size_t donote(struct magic_set *, unsigned char *, size_t, size_t, int,\n     int, size_t, int *);\n \n@@ -190,6 +191,18 @@ getu64(int swap, uint64_t value)\n #define prpsoffsets(i)\t(class == ELFCLASS32\t\t\t\\\n \t\t\t ? prpsoffsets32[i]\t\t\t\\\n \t\t\t : prpsoffsets64[i])\n+#define xcap_addr\t(class == ELFCLASS32\t\t\t\\\n+\t\t\t ? (void *) &cap32\t\t\t\\\n+\t\t\t : (void *) &cap64)\n+#define xcap_sizeof\t(class == ELFCLASS32\t\t\t\\\n+\t\t\t ? sizeof cap32\t\t\t\t\\\n+\t\t\t : sizeof cap64)\n+#define xcap_tag\t(class == ELFCLASS32\t\t\t\\\n+\t\t\t ? elf_getu32(swap, cap32.c_tag)\t\\\n+\t\t\t : elf_getu64(swap, cap64.c_tag))\n+#define xcap_val\t(class == ELFCLASS32\t\t\t\\\n+\t\t\t ? elf_getu32(swap, cap32.c_un.c_val)\t\\\n+\t\t\t : elf_getu64(swap, cap64.c_un.c_val))\n \n #ifdef ELFCORE\n /*\n@@ -750,15 +763,67 @@ core:\n \treturn offset;\n }\n \n+/* SunOS 5.x hardware capability descriptions */\n+typedef struct cap_desc {\n+\tuint64_t cd_mask;\n+\tconst char *cd_name;\n+} cap_desc_t;\n+\n+static const cap_desc_t cap_desc_sparc[] = {\n+\t{ AV_SPARC_MUL32,\t\t""MUL32"" },\n+\t{ AV_SPARC_DIV32,\t\t""DIV32"" },\n+\t{ AV_SPARC_FSMULD,\t\t""FSMULD"" },\n+\t{ AV_SPARC_V8PLUS,\t\t""V8PLUS"" },\n+\t{ AV_SPARC_POPC,\t\t""POPC"" },\n+\t{ AV_SPARC_VIS,\t\t\t""VIS"" },\n+\t{ AV_SPARC_VIS2,\t\t""VIS2"" },\n+\t{ AV_SPARC_ASI_BLK_INIT,\t""ASI_BLK_INIT"" },\n+\t{ AV_SPARC_FMAF,\t\t""FMAF"" },\n+\t{ AV_SPARC_FJFMAU,\t\t""FJFMAU"" },\n+\t{ AV_SPARC_IMA,\t\t\t""IMA"" },\n+\t{ 0, NULL }\n+};\n+\n+static const cap_desc_t cap_desc_386[] = {\n+\t{ AV_386_FPU,\t\t\t""FPU"" },\n+\t{ AV_386_TSC,\t\t\t""TSC"" },\n+\t{ AV_386_CX8,\t\t\t""CX8"" },\n+\t{ AV_386_SEP,\t\t\t""SEP"" },\n+\t{ AV_386_AMD_SYSC,\t\t""AMD_SYSC"" },\n+\t{ AV_386_CMOV,\t\t\t""CMOV"" },\n+\t{ AV_386_MMX,\t\t\t""MMX"" },\n+\t{ AV_386_AMD_MMX,\t\t""AMD_MMX"" },\n+\t{ AV_386_AMD_3DNow,\t\t""AMD_3DNow"" },\n+\t{ AV_386_AMD_3DNowx,\t\t""AMD_3DNowx"" },\n+\t{ AV_386_FXSR,\t\t\t""FXSR"" },\n+\t{ AV_386_SSE,\t\t\t""SSE"" },\n+\t{ AV_386_SSE2,\t\t\t""SSE2"" },\n+\t{ AV_386_PAUSE,\t\t\t""PAUSE"" },\n+\t{ AV_386_SSE3,\t\t\t""SSE3"" },\n+\t{ AV_386_MON,\t\t\t""MON"" },\n+\t{ AV_386_CX16,\t\t\t""CX16"" },\n+\t{ AV_386_AHF,\t\t\t""AHF"" },\n+\t{ AV_386_TSCP,\t\t\t""TSCP"" },\n+\t{ AV_386_AMD_SSE4A,\t\t""AMD_SSE4A"" },\n+\t{ AV_386_POPCNT,\t\t""POPCNT"" },\n+\t{ AV_386_AMD_LZCNT,\t\t""AMD_LZCNT"" },\n+\t{ AV_386_SSSE3,\t\t\t""SSSE3"" },\n+\t{ AV_386_SSE4_1,\t\t""SSE4.1"" },\n+\t{ AV_386_SSE4_2,\t\t""SSE4.2"" },\n+\t{ 0, NULL }\n+};\n+\n private int\n doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,\n-    size_t size, int *flags)\n+    size_t size, int *flags, int mach)\n {\n \tElf32_Shdr sh32;\n \tElf64_Shdr sh64;\n \tint stripped = 1;\n \tvoid *nbuf;\n \toff_t noff;\n+\tuint64_t cap_hw1 = 0;\t/* SunOS 5.x hardware capabilites */\n+\tuint64_t cap_sf1 = 0;\t/* SunOS 5.x software capabilites */\n \n \tif (size != xsh_sizeof) {\n \t\tif (file_printf(ms, "", corrupted section header size"") == -1)\n@@ -824,10 +889,115 @@ doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,\n \t\t\t}\n \t\t\tfree(nbuf);\n \t\t\tbreak;\n+\t\tcase SHT_SUNW_cap:\n+\t\t    {\n+\t\t\toff_t coff;\n+\t\t\tif ((off = lseek(fd, (off_t)0, SEEK_CUR)) ==\n+\t\t\t    (off_t)-1) {\n+\t\t\t\tfile_badread(ms);\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t\tif (lseek(fd, (off_t)xsh_offset, SEEK_SET) ==\n+\t\t\t    (off_t)-1) {\n+\t\t\t\tfile_badread(ms);\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t\tcoff = 0;\n+\t\t\tfor (;;) {\n+\t\t\t\tElf32_Cap cap32;\n+\t\t\t\tElf64_Cap cap64;\n+\t\t\t\tchar cbuf[MAX(sizeof cap32, sizeof cap64)];\n+\t\t\t\tif ((coff += xcap_sizeof) >= (size_t)xsh_size)\n+\t\t\t\t\tbreak;\n+\t\t\t\tif (read(fd, cbuf, (size_t)xcap_sizeof) !=\n+\t\t\t\t    (ssize_t)xcap_sizeof) {\n+\t\t\t\t\tfile_badread(ms);\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t\t(void)memcpy(xcap_addr, cbuf, xcap_sizeof);\n+\t\t\t\tswitch (xcap_tag) {\n+\t\t\t\tcase CA_SUNW_NULL:\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase CA_SUNW_HW_1:\n+\t\t\t\t\tcap_hw1 |= xcap_val;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase CA_SUNW_SF_1:\n+\t\t\t\t\tcap_sf1 |= xcap_val;\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\tif (file_printf(ms,\n+\t\t\t\t\t    "", with unknown capability ""\n+\t\t\t\t\t    ""0x%llx = 0x%llx"",\n+\t\t\t\t\t    xcap_tag, xcap_val) == -1)\n+\t\t\t\t\t\treturn -1;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (lseek(fd, off, SEEK_SET) == (off_t)-1) {\n+\t\t\t\tfile_badread(ms);\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t    }\n \t\t}\n \t}\n \tif (file_printf(ms, "", %sstripped"", stripped ? """" : ""not "") == -1)\n \t\treturn -1;\n+\tif (cap_hw1) {\n+\t\tconst cap_desc_t *cdp;\n+\t\tswitch (mach) {\n+\t\tcase EM_SPARC:\n+\t\tcase EM_SPARC32PLUS:\n+\t\tcase EM_SPARCV9:\n+\t\t\tcdp = cap_desc_sparc;\n+\t\t\tbreak;\n+\t\tcase EM_386:\n+\t\tcase EM_IA_64:\n+\t\tcase EM_AMD64:\n+\t\t\tcdp = cap_desc_386;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tcdp = NULL;\n+\t\t\tbreak;\n+\t\t}\n+\t\tif (file_printf(ms, "", uses"") == -1)\n+\t\t\treturn -1;\n+\t\tif (cdp) {\n+\t\t\twhile (cdp->cd_name) {\n+\t\t\t\tif (cap_hw1 & cdp->cd_mask) {\n+\t\t\t\t\tif (file_printf(ms,\n+\t\t\t\t\t    "" %s"", cdp->cd_name) == -1)\n+\t\t\t\t\t\treturn -1;\n+\t\t\t\t\tcap_hw1 &= ~cdp->cd_mask;\n+\t\t\t\t}\n+\t\t\t\t++cdp;\n+\t\t\t}\n+\t\t\tif (cap_hw1)\n+\t\t\t\tif (file_printf(ms,\n+\t\t\t\t    "" unknown hardware capability 0x%llx"",\n+\t\t\t\t    cap_hw1) == -1)\n+\t\t\t\t\treturn -1;\n+\t\t} else {\n+\t\t\tif (file_printf(ms,\n+\t\t\t    "" hardware capability 0x%llx"", cap_hw1) == -1)\n+\t\t\t\treturn -1;\n+\t\t}\n+\t}\n+\tif (cap_sf1) {\n+\t\tif (cap_sf1 & SF1_SUNW_FPUSED) {\n+\t\t\tif (file_printf(ms,\n+\t\t\t    (cap_sf1 & SF1_SUNW_FPKNWN)\n+\t\t\t    ? "", uses frame pointer""\n+\t\t\t    : "", not known to use frame pointer"") == -1)\n+\t\t\t\treturn -1;\n+\t\t}\n+\t\tcap_sf1 &= ~SF1_SUNW_MASK;\n+\t\tif (cap_sf1)\n+\t\t\tif (file_printf(ms,\n+\t\t\t    "", with unknown software capability 0x%llx"",\n+\t\t\t    cap_sf1) == -1)\n+\t\t\t\treturn -1;\n+\t}\n \treturn 0;\n }\n \n']",2008-05-28 21:02:28+00:00,Solaris enchancements from Bob Byrnes.,"[['+ FILE_RCSID(""@(#)$File: readelf.c,v 1.73 2008/03/27 22:00:28 christos Exp $"")', '+ private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *,', '+     int);', '+ #define xcap_addr\t(class == ELFCLASS32\t\t\t\\', '+ \t\t\t ? (void *) &cap32\t\t\t\\', '+ \t\t\t : (void *) &cap64)', '+ #define xcap_sizeof\t(class == ELFCLASS32\t\t\t\\', '+ \t\t\t ? sizeof cap32\t\t\t\t\\', '+ \t\t\t : sizeof cap64)', '+ #define xcap_tag\t(class == ELFCLASS32\t\t\t\\', '+ \t\t\t ? elf_getu32(swap, cap32.c_tag)\t\\', '+ \t\t\t : elf_getu64(swap, cap64.c_tag))', '+ #define xcap_val\t(class == ELFCLASS32\t\t\t\\', '+ \t\t\t ? elf_getu32(swap, cap32.c_un.c_val)\t\\', '+ \t\t\t : elf_getu64(swap, cap64.c_un.c_val))', '+ typedef struct cap_desc {', '+ \tuint64_t cd_mask;', '+ \tconst char *cd_name;', '+ } cap_desc_t;', '+ ', '+ static const cap_desc_t cap_desc_sparc[] = {', '+ \t{ AV_SPARC_MUL32,\t\t""MUL32"" },', '+ \t{ AV_SPARC_DIV32,\t\t""DIV32"" },', '+ \t{ AV_SPARC_FSMULD,\t\t""FSMULD"" },', '+ \t{ AV_SPARC_V8PLUS,\t\t""V8PLUS"" },', '+ \t{ AV_SPARC_POPC,\t\t""POPC"" },', '+ \t{ AV_SPARC_VIS,\t\t\t""VIS"" },', '+ \t{ AV_SPARC_VIS2,\t\t""VIS2"" },', '+ \t{ AV_SPARC_ASI_BLK_INIT,\t""ASI_BLK_INIT"" },', '+ \t{ AV_SPARC_FMAF,\t\t""FMAF"" },', '+ \t{ AV_SPARC_FJFMAU,\t\t""FJFMAU"" },', '+ \t{ AV_SPARC_IMA,\t\t\t""IMA"" },', '+ \t{ 0, NULL }', '+ };', '+ ', '+ static const cap_desc_t cap_desc_386[] = {', '+ \t{ AV_386_FPU,\t\t\t""FPU"" },', '+ \t{ AV_386_TSC,\t\t\t""TSC"" },', '+ \t{ AV_386_CX8,\t\t\t""CX8"" },', '+ \t{ AV_386_SEP,\t\t\t""SEP"" },', '+ \t{ AV_386_AMD_SYSC,\t\t""AMD_SYSC"" },', '+ \t{ AV_386_CMOV,\t\t\t""CMOV"" },', '+ \t{ AV_386_MMX,\t\t\t""MMX"" },', '+ \t{ AV_386_AMD_MMX,\t\t""AMD_MMX"" },', '+ \t{ AV_386_AMD_3DNow,\t\t""AMD_3DNow"" },', '+ \t{ AV_386_AMD_3DNowx,\t\t""AMD_3DNowx"" },', '+ \t{ AV_386_FXSR,\t\t\t""FXSR"" },', '+ \t{ AV_386_SSE,\t\t\t""SSE"" },', '+ \t{ AV_386_SSE2,\t\t\t""SSE2"" },', '+ \t{ AV_386_PAUSE,\t\t\t""PAUSE"" },', '+ \t{ AV_386_SSE3,\t\t\t""SSE3"" },', '+ \t{ AV_386_MON,\t\t\t""MON"" },', '+ \t{ AV_386_CX16,\t\t\t""CX16"" },', '+ \t{ AV_386_AHF,\t\t\t""AHF"" },', '+ \t{ AV_386_TSCP,\t\t\t""TSCP"" },', '+ \t{ AV_386_AMD_SSE4A,\t\t""AMD_SSE4A"" },', '+ \t{ AV_386_POPCNT,\t\t""POPCNT"" },', '+ \t{ AV_386_AMD_LZCNT,\t\t""AMD_LZCNT"" },', '+ \t{ AV_386_SSSE3,\t\t\t""SSSE3"" },', '+ \t{ AV_386_SSE4_1,\t\t""SSE4.1"" },', '+ \t{ AV_386_SSE4_2,\t\t""SSE4.2"" },', '+ \t{ 0, NULL }', '+ };', '+ ', '+     size_t size, int *flags, int mach)', '+ \t\tcase SHT_SUNW_cap:', '+ \t\t    {', '+ \t\t\toff_t coff;', '+ \t\t\tif ((off = lseek(fd, (off_t)0, SEEK_CUR)) ==', '+ \t\t\t    (off_t)-1) {', '+ \t\t\t\tfile_badread(ms);', '+ \t\t\t\treturn -1;', '+ \t\t\t}', '+ \t\t\tif (lseek(fd, (off_t)xsh_offset, SEEK_SET) ==', '+ \t\t\t    (off_t)-1) {', '+ \t\t\t\tfile_badread(ms);', '+ \t\t\t\treturn -1;', '+ \t\t\t}', '+ \t\t\tcoff = 0;', '+ \t\t\tfor (;;) {', '+ \t\t\t\tElf32_Cap cap32;', '+ \t\t\t\tElf64_Cap cap64;', '+ \t\t\t\tchar cbuf[MAX(sizeof cap32, sizeof cap64)];', '+ \t\t\t\tif ((coff += xcap_sizeof) >= (size_t)xsh_size)', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tif (read(fd, cbuf, (size_t)xcap_sizeof) !=', '+ \t\t\t\t    (ssize_t)xcap_sizeof) {', '+ \t\t\t\t\tfile_badread(ms);', '+ \t\t\t\t\treturn -1;', '+ \t\t\t\t}', '+ \t\t\t\t(void)memcpy(xcap_addr, cbuf, xcap_sizeof);', '+ \t\t\t\tswitch (xcap_tag) {', '+ \t\t\t\tcase CA_SUNW_NULL:', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase CA_SUNW_HW_1:', '+ \t\t\t\t\tcap_hw1 |= xcap_val;', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase CA_SUNW_SF_1:', '+ \t\t\t\t\tcap_sf1 |= xcap_val;', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tdefault:', '+ \t\t\t\t\tif (file_printf(ms,', '+ \t\t\t\t\t    "", with unknown capability ""', '+ \t\t\t\t\t    ""0x%llx = 0x%llx"",', '+ \t\t\t\t\t    xcap_tag, xcap_val) == -1)', '+ \t\t\t\t\t\treturn -1;', '+ \t\t\t\t\tbreak;', '+ \t\t\t\t}', '+ \t\t\t}', '+ \t\t\tif (lseek(fd, off, SEEK_SET) == (off_t)-1) {', '+ \t\t\t\tfile_badread(ms);', '+ \t\t\t\treturn -1;', '+ \t\t\t}', '+ \t\t\tbreak;', '+ \t\t    }', '+ \tif (cap_hw1) {', '+ \t\tconst cap_desc_t *cdp;', '+ \t\tswitch (mach) {', '+ \t\tcase EM_SPARC:', '+ \t\tcase EM_SPARC32PLUS:', '+ \t\tcase EM_SPARCV9:', '+ \t\t\tcdp = cap_desc_sparc;', '+ \t\t\tbreak;', '+ \t\tcase EM_386:', '+ \t\tcase EM_IA_64:', '+ \t\tcase EM_AMD64:', '+ \t\t\tcdp = cap_desc_386;', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\t\tcdp = NULL;', '+ \t\t\tbreak;', '+ \t\t}', '+ \t\tif (file_printf(ms, "", uses"") == -1)', '+ \t\t\treturn -1;', '+ \t\tif (cdp) {', '+ \t\t\twhile (cdp->cd_name) {', '+ \t\t\t\tif (cap_hw1 & cdp->cd_mask) {', '+ \t\t\t\t\tif (file_printf(ms,', '+ \t\t\t\t\t    "" %s"", cdp->cd_name) == -1)', '+ \t\t\t\t\t\treturn -1;', '+ \t\t\t\t\tcap_hw1 &= ~cdp->cd_mask;', '+ \t\t\t\t}', '+ \t\t\t\t++cdp;', '+ \t\t\t}', '+ \t\t\tif (cap_hw1)', '+ \t\t\t\tif (file_printf(ms,', '+ \t\t\t\t    "" unknown hardware capability 0x%llx"",', '+ \t\t\t\t    cap_hw1) == -1)', '+ \t\t\t\t\treturn -1;', '+ \t\t} else {', '+ \t\t\tif (file_printf(ms,', '+ \t\t\t    "" hardware capability 0x%llx"", cap_hw1) == -1)', '+ \t\t\t\treturn -1;', '+ \t\t}', '+ \t}', '+ \tif (cap_sf1) {', '+ \t\tif (cap_sf1 & SF1_SUNW_FPUSED) {', '+ \t\t\tif (file_printf(ms,', '+ \t\t\t    (cap_sf1 & SF1_SUNW_FPKNWN)', '+ \t\t\t    ? "", uses frame pointer""', '+ \t\t\t    : "", not known to use frame pointer"") == -1)', '+ \t\t\t\treturn -1;', '+ \t\t}', '+ \t\tcap_sf1 &= ~SF1_SUNW_MASK;', '+ \t\tif (cap_sf1)', '+ \t\t\tif (file_printf(ms,', '+ \t\t\t    "", with unknown software capability 0x%llx"",', '+ \t\t\t    cap_sf1) == -1)', '+ \t\t\t\treturn -1;', '+ \t}', '- FILE_RCSID(""@(#)$File: readelf.c,v 1.72 2008/02/19 15:53:09 christos Exp $"")', '- private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *);', '-     size_t size, int *flags)']]","[['+ file_rcsid(""@(#)$file: readelf.c,v 1.73 2008/03/27 22:00:28 christos exp $"")', '+ private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *,', '+     int);', '+ #define xcap_addr\t(class == elfclass32\t\t\t\\', '+ \t\t\t ? (void *) &cap32\t\t\t\\', '+ \t\t\t : (void *) &cap64)', '+ #define xcap_sizeof\t(class == elfclass32\t\t\t\\', '+ \t\t\t ? sizeof cap32\t\t\t\t\\', '+ \t\t\t : sizeof cap64)', '+ #define xcap_tag\t(class == elfclass32\t\t\t\\', '+ \t\t\t ? elf_getu32(swap, cap32.c_tag)\t\\', '+ \t\t\t : elf_getu64(swap, cap64.c_tag))', '+ #define xcap_val\t(class == elfclass32\t\t\t\\', '+ \t\t\t ? elf_getu32(swap, cap32.c_un.c_val)\t\\', '+ \t\t\t : elf_getu64(swap, cap64.c_un.c_val))', '+ typedef struct cap_desc {', '+ \tuint64_t cd_mask;', '+ \tconst char *cd_name;', '+ } cap_desc_t;', '+ ', '+ static const cap_desc_t cap_desc_sparc[] = {', '+ \t{ av_sparc_mul32,\t\t""mul32"" },', '+ \t{ av_sparc_div32,\t\t""div32"" },', '+ \t{ av_sparc_fsmuld,\t\t""fsmuld"" },', '+ \t{ av_sparc_v8plus,\t\t""v8plus"" },', '+ \t{ av_sparc_popc,\t\t""popc"" },', '+ \t{ av_sparc_vis,\t\t\t""vis"" },', '+ \t{ av_sparc_vis2,\t\t""vis2"" },', '+ \t{ av_sparc_asi_blk_init,\t""asi_blk_init"" },', '+ \t{ av_sparc_fmaf,\t\t""fmaf"" },', '+ \t{ av_sparc_fjfmau,\t\t""fjfmau"" },', '+ \t{ av_sparc_ima,\t\t\t""ima"" },', '+ \t{ 0, null }', '+ };', '+ ', '+ static const cap_desc_t cap_desc_386[] = {', '+ \t{ av_386_fpu,\t\t\t""fpu"" },', '+ \t{ av_386_tsc,\t\t\t""tsc"" },', '+ \t{ av_386_cx8,\t\t\t""cx8"" },', '+ \t{ av_386_sep,\t\t\t""sep"" },', '+ \t{ av_386_amd_sysc,\t\t""amd_sysc"" },', '+ \t{ av_386_cmov,\t\t\t""cmov"" },', '+ \t{ av_386_mmx,\t\t\t""mmx"" },', '+ \t{ av_386_amd_mmx,\t\t""amd_mmx"" },', '+ \t{ av_386_amd_3dnow,\t\t""amd_3dnow"" },', '+ \t{ av_386_amd_3dnowx,\t\t""amd_3dnowx"" },', '+ \t{ av_386_fxsr,\t\t\t""fxsr"" },', '+ \t{ av_386_sse,\t\t\t""sse"" },', '+ \t{ av_386_sse2,\t\t\t""sse2"" },', '+ \t{ av_386_pause,\t\t\t""pause"" },', '+ \t{ av_386_sse3,\t\t\t""sse3"" },', '+ \t{ av_386_mon,\t\t\t""mon"" },', '+ \t{ av_386_cx16,\t\t\t""cx16"" },', '+ \t{ av_386_ahf,\t\t\t""ahf"" },', '+ \t{ av_386_tscp,\t\t\t""tscp"" },', '+ \t{ av_386_amd_sse4a,\t\t""amd_sse4a"" },', '+ \t{ av_386_popcnt,\t\t""popcnt"" },', '+ \t{ av_386_amd_lzcnt,\t\t""amd_lzcnt"" },', '+ \t{ av_386_ssse3,\t\t\t""ssse3"" },', '+ \t{ av_386_sse4_1,\t\t""sse4.1"" },', '+ \t{ av_386_sse4_2,\t\t""sse4.2"" },', '+ \t{ 0, null }', '+ };', '+ ', '+     size_t size, int *flags, int mach)', '+ \t\tcase sht_sunw_cap:', '+ \t\t    {', '+ \t\t\toff_t coff;', '+ \t\t\tif ((off = lseek(fd, (off_t)0, seek_cur)) ==', '+ \t\t\t    (off_t)-1) {', '+ \t\t\t\tfile_badread(ms);', '+ \t\t\t\treturn -1;', '+ \t\t\t}', '+ \t\t\tif (lseek(fd, (off_t)xsh_offset, seek_set) ==', '+ \t\t\t    (off_t)-1) {', '+ \t\t\t\tfile_badread(ms);', '+ \t\t\t\treturn -1;', '+ \t\t\t}', '+ \t\t\tcoff = 0;', '+ \t\t\tfor (;;) {', '+ \t\t\t\telf32_cap cap32;', '+ \t\t\t\telf64_cap cap64;', '+ \t\t\t\tchar cbuf[max(sizeof cap32, sizeof cap64)];', '+ \t\t\t\tif ((coff += xcap_sizeof) >= (size_t)xsh_size)', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tif (read(fd, cbuf, (size_t)xcap_sizeof) !=', '+ \t\t\t\t    (ssize_t)xcap_sizeof) {', '+ \t\t\t\t\tfile_badread(ms);', '+ \t\t\t\t\treturn -1;', '+ \t\t\t\t}', '+ \t\t\t\t(void)memcpy(xcap_addr, cbuf, xcap_sizeof);', '+ \t\t\t\tswitch (xcap_tag) {', '+ \t\t\t\tcase ca_sunw_null:', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase ca_sunw_hw_1:', '+ \t\t\t\t\tcap_hw1 |= xcap_val;', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase ca_sunw_sf_1:', '+ \t\t\t\t\tcap_sf1 |= xcap_val;', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tdefault:', '+ \t\t\t\t\tif (file_printf(ms,', '+ \t\t\t\t\t    "", with unknown capability ""', '+ \t\t\t\t\t    ""0x%llx = 0x%llx"",', '+ \t\t\t\t\t    xcap_tag, xcap_val) == -1)', '+ \t\t\t\t\t\treturn -1;', '+ \t\t\t\t\tbreak;', '+ \t\t\t\t}', '+ \t\t\t}', '+ \t\t\tif (lseek(fd, off, seek_set) == (off_t)-1) {', '+ \t\t\t\tfile_badread(ms);', '+ \t\t\t\treturn -1;', '+ \t\t\t}', '+ \t\t\tbreak;', '+ \t\t    }', '+ \tif (cap_hw1) {', '+ \t\tconst cap_desc_t *cdp;', '+ \t\tswitch (mach) {', '+ \t\tcase em_sparc:', '+ \t\tcase em_sparc32plus:', '+ \t\tcase em_sparcv9:', '+ \t\t\tcdp = cap_desc_sparc;', '+ \t\t\tbreak;', '+ \t\tcase em_386:', '+ \t\tcase em_ia_64:', '+ \t\tcase em_amd64:', '+ \t\t\tcdp = cap_desc_386;', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\t\tcdp = null;', '+ \t\t\tbreak;', '+ \t\t}', '+ \t\tif (file_printf(ms, "", uses"") == -1)', '+ \t\t\treturn -1;', '+ \t\tif (cdp) {', '+ \t\t\twhile (cdp->cd_name) {', '+ \t\t\t\tif (cap_hw1 & cdp->cd_mask) {', '+ \t\t\t\t\tif (file_printf(ms,', '+ \t\t\t\t\t    "" %s"", cdp->cd_name) == -1)', '+ \t\t\t\t\t\treturn -1;', '+ \t\t\t\t\tcap_hw1 &= ~cdp->cd_mask;', '+ \t\t\t\t}', '+ \t\t\t\t++cdp;', '+ \t\t\t}', '+ \t\t\tif (cap_hw1)', '+ \t\t\t\tif (file_printf(ms,', '+ \t\t\t\t    "" unknown hardware capability 0x%llx"",', '+ \t\t\t\t    cap_hw1) == -1)', '+ \t\t\t\t\treturn -1;', '+ \t\t} else {', '+ \t\t\tif (file_printf(ms,', '+ \t\t\t    "" hardware capability 0x%llx"", cap_hw1) == -1)', '+ \t\t\t\treturn -1;', '+ \t\t}', '+ \t}', '+ \tif (cap_sf1) {', '+ \t\tif (cap_sf1 & sf1_sunw_fpused) {', '+ \t\t\tif (file_printf(ms,', '+ \t\t\t    (cap_sf1 & sf1_sunw_fpknwn)', '+ \t\t\t    ? "", uses frame pointer""', '+ \t\t\t    : "", not known to use frame pointer"") == -1)', '+ \t\t\t\treturn -1;', '+ \t\t}', '+ \t\tcap_sf1 &= ~sf1_sunw_mask;', '+ \t\tif (cap_sf1)', '+ \t\t\tif (file_printf(ms,', '+ \t\t\t    "", with unknown software capability 0x%llx"",', '+ \t\t\t    cap_sf1) == -1)', '+ \t\t\t\treturn -1;', '+ \t}', '- file_rcsid(""@(#)$file: readelf.c,v 1.72 2008/02/19 15:53:09 christos exp $"")', '- private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *);', '-     size_t size, int *flags)']]","[['+ FILE_RCSID(""@(#)$File: readelf.c,v 1.73 2008/03/27 22:00:28 christos Exp $"")', '+ private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *,', '+     int);', '+ #define xcap_addr\t(class == ELFCLASS32\t\t\t\\', '+ \t\t\t ? (void *) &cap32\t\t\t\\', '+ \t\t\t : (void *) &cap64)', '+ #define xcap_sizeof\t(class == ELFCLASS32\t\t\t\\', '+ \t\t\t ? sizeof cap32\t\t\t\t\\', '+ \t\t\t : sizeof cap64)', '+ #define xcap_tag\t(class == ELFCLASS32\t\t\t\\', '+ \t\t\t ? elf_getu32(swap, cap32.c_tag)\t\\', '+ \t\t\t : elf_getu64(swap, cap64.c_tag))', '+ #define xcap_val\t(class == ELFCLASS32\t\t\t\\', '+ \t\t\t ? elf_getu32(swap, cap32.c_un.c_val)\t\\', '+ \t\t\t : elf_getu64(swap, cap64.c_un.c_val))', '+ typedef struct cap_desc {', '+ \tuint64_t cd_mask;', '+ \tconst char *cd_name;', '+ } cap_desc_t;', '+ ', '+ static const cap_desc_t cap_desc_sparc[] = {', '+ \t{ AV_SPARC_MUL32,\t\t""MUL32"" },', '+ \t{ AV_SPARC_DIV32,\t\t""DIV32"" },', '+ \t{ AV_SPARC_FSMULD,\t\t""FSMULD"" },', '+ \t{ AV_SPARC_V8PLUS,\t\t""V8PLUS"" },', '+ \t{ AV_SPARC_POPC,\t\t""POPC"" },', '+ \t{ AV_SPARC_VIS,\t\t\t""VIS"" },', '+ \t{ AV_SPARC_VIS2,\t\t""VIS2"" },', '+ \t{ AV_SPARC_ASI_BLK_INIT,\t""ASI_BLK_INIT"" },', '+ \t{ AV_SPARC_FMAF,\t\t""FMAF"" },', '+ \t{ AV_SPARC_FJFMAU,\t\t""FJFMAU"" },', '+ \t{ AV_SPARC_IMA,\t\t\t""IMA"" },', '+ \t{ 0, NULL }', '+ };', '+ ', '+ static const cap_desc_t cap_desc_386[] = {', '+ \t{ AV_386_FPU,\t\t\t""FPU"" },', '+ \t{ AV_386_TSC,\t\t\t""TSC"" },', '+ \t{ AV_386_CX8,\t\t\t""CX8"" },', '+ \t{ AV_386_SEP,\t\t\t""SEP"" },', '+ \t{ AV_386_AMD_SYSC,\t\t""AMD_SYSC"" },', '+ \t{ AV_386_CMOV,\t\t\t""CMOV"" },', '+ \t{ AV_386_MMX,\t\t\t""MMX"" },', '+ \t{ AV_386_AMD_MMX,\t\t""AMD_MMX"" },', '+ \t{ AV_386_AMD_3DNow,\t\t""AMD_3DNow"" },', '+ \t{ AV_386_AMD_3DNowx,\t\t""AMD_3DNowx"" },', '+ \t{ AV_386_FXSR,\t\t\t""FXSR"" },', '+ \t{ AV_386_SSE,\t\t\t""SSE"" },', '+ \t{ AV_386_SSE2,\t\t\t""SSE2"" },', '+ \t{ AV_386_PAUSE,\t\t\t""PAUSE"" },', '+ \t{ AV_386_SSE3,\t\t\t""SSE3"" },', '+ \t{ AV_386_MON,\t\t\t""MON"" },', '+ \t{ AV_386_CX16,\t\t\t""CX16"" },', '+ \t{ AV_386_AHF,\t\t\t""AHF"" },', '+ \t{ AV_386_TSCP,\t\t\t""TSCP"" },', '+ \t{ AV_386_AMD_SSE4A,\t\t""AMD_SSE4A"" },', '+ \t{ AV_386_POPCNT,\t\t""POPCNT"" },', '+ \t{ AV_386_AMD_LZCNT,\t\t""AMD_LZCNT"" },', '+ \t{ AV_386_SSSE3,\t\t\t""SSSE3"" },', '+ \t{ AV_386_SSE4_1,\t\t""SSE4.1"" },', '+ \t{ AV_386_SSE4_2,\t\t""SSE4.2"" },', '+ \t{ 0, NULL }', '+ };', '+ ', '+     size_t size, int *flags, int mach)', '+ \t\tcase SHT_SUNW_cap:', '+ \t\t    {', '+ \t\t\toff_t coff;', '+ \t\t\tif ((off = lseek(fd, (off_t)0, SEEK_CUR)) ==', '+ \t\t\t    (off_t)-1) {', '+ \t\t\t\tfile_badread(ms);', '+ \t\t\t\treturn -1;', '+ \t\t\t}', '+ \t\t\tif (lseek(fd, (off_t)xsh_offset, SEEK_SET) ==', '+ \t\t\t    (off_t)-1) {', '+ \t\t\t\tfile_badread(ms);', '+ \t\t\t\treturn -1;', '+ \t\t\t}', '+ \t\t\tcoff = 0;', '+ \t\t\tfor (;;) {', '+ \t\t\t\tElf32_Cap cap32;', '+ \t\t\t\tElf64_Cap cap64;', '+ \t\t\t\tchar cbuf[MAX(sizeof cap32, sizeof cap64)];', '+ \t\t\t\tif ((coff += xcap_sizeof) >= (size_t)xsh_size)', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tif (read(fd, cbuf, (size_t)xcap_sizeof) !=', '+ \t\t\t\t    (ssize_t)xcap_sizeof) {', '+ \t\t\t\t\tfile_badread(ms);', '+ \t\t\t\t\treturn -1;', '+ \t\t\t\t}', '+ \t\t\t\t(void)memcpy(xcap_addr, cbuf, xcap_sizeof);', '+ \t\t\t\tswitch (xcap_tag) {', '+ \t\t\t\tcase CA_SUNW_NULL:', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase CA_SUNW_HW_1:', '+ \t\t\t\t\tcap_hw1 |= xcap_val;', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tcase CA_SUNW_SF_1:', '+ \t\t\t\t\tcap_sf1 |= xcap_val;', '+ \t\t\t\t\tbreak;', '+ \t\t\t\tdefault:', '+ \t\t\t\t\tif (file_printf(ms,', '+ \t\t\t\t\t    "", with unknown capability ""', '+ \t\t\t\t\t    ""0x%llx = 0x%llx"",', '+ \t\t\t\t\t    xcap_tag, xcap_val) == -1)', '+ \t\t\t\t\t\treturn -1;', '+ \t\t\t\t\tbreak;', '+ \t\t\t\t}', '+ \t\t\t}', '+ \t\t\tif (lseek(fd, off, SEEK_SET) == (off_t)-1) {', '+ \t\t\t\tfile_badread(ms);', '+ \t\t\t\treturn -1;', '+ \t\t\t}', '+ \t\t\tbreak;', '+ \t\t    }', '+ \tif (cap_hw1) {', '+ \t\tconst cap_desc_t *cdp;', '+ \t\tswitch (mach) {', '+ \t\tcase EM_SPARC:', '+ \t\tcase EM_SPARC32PLUS:', '+ \t\tcase EM_SPARCV9:', '+ \t\t\tcdp = cap_desc_sparc;', '+ \t\t\tbreak;', '+ \t\tcase EM_386:', '+ \t\tcase EM_IA_64:', '+ \t\tcase EM_AMD64:', '+ \t\t\tcdp = cap_desc_386;', '+ \t\t\tbreak;', '+ \t\tdefault:', '+ \t\t\tcdp = NULL;', '+ \t\t\tbreak;', '+ \t\t}', '+ \t\tif (file_printf(ms, "", uses"") == -1)', '+ \t\t\treturn -1;', '+ \t\tif (cdp) {', '+ \t\t\twhile (cdp->cd_name) {', '+ \t\t\t\tif (cap_hw1 & cdp->cd_mask) {', '+ \t\t\t\t\tif (file_printf(ms,', '+ \t\t\t\t\t    "" %s"", cdp->cd_name) == -1)', '+ \t\t\t\t\t\treturn -1;', '+ \t\t\t\t\tcap_hw1 &= ~cdp->cd_mask;', '+ \t\t\t\t}', '+ \t\t\t\t++cdp;', '+ \t\t\t}', '+ \t\t\tif (cap_hw1)', '+ \t\t\t\tif (file_printf(ms,', '+ \t\t\t\t    "" unknown hardware capability 0x%llx"",', '+ \t\t\t\t    cap_hw1) == -1)', '+ \t\t\t\t\treturn -1;', '+ \t\t} else {', '+ \t\t\tif (file_printf(ms,', '+ \t\t\t    "" hardware capability 0x%llx"", cap_hw1) == -1)', '+ \t\t\t\treturn -1;', '+ \t\t}', '+ \t}', '+ \tif (cap_sf1) {', '+ \t\tif (cap_sf1 & SF1_SUNW_FPUSED) {', '+ \t\t\tif (file_printf(ms,', '+ \t\t\t    (cap_sf1 & SF1_SUNW_FPKNWN)', '+ \t\t\t    ? "", uses frame pointer""', '+ \t\t\t    : "", not known to use frame pointer"") == -1)', '+ \t\t\t\treturn -1;', '+ \t\t}', '+ \t\tcap_sf1 &= ~SF1_SUNW_MASK;', '+ \t\tif (cap_sf1)', '+ \t\t\tif (file_printf(ms,', '+ \t\t\t    "", with unknown software capability 0x%llx"",', '+ \t\t\t    cap_sf1) == -1)', '+ \t\t\t\treturn -1;', '+ \t}']]","[['- FILE_RCSID(""@(#)$File: readelf.c,v 1.72 2008/02/19 15:53:09 christos Exp $"")', '- private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *);', '-     size_t size, int *flags)']]",170,3.0,173.0,5c0645db483680f01bc5d9cd2a12f63e7afd0c44file/file,['d7cdad007c507e6c79f51f058dd77fab70ceb9f6']
3bb4e23a8aa15fc93b91b92d8c6437358fd71113,FFmpeg/FFmpeg,msmpeg4.c,train,C,0,"['@@ -694,6 +694,7 @@ int msmpeg4_decode_mb(MpegEncContext *s,\n                 s->mv_type = MV_TYPE_16X16;\n                 s->mv[0][0][0] = 0;\n                 s->mv[0][0][1] = 0;\n+                s->mb_skiped = 1;\n                 return 0;\n             }\n         }\n']",,,['+                 s->mb_skiped = 1;'],['+                 s->mb_skiped = 1;'],['+                 s->mb_skiped = 1;'],[],1,0.0,1.0,3bb4e23a8aa15fc93b91b92d8c6437358fd71113FFmpeg/FFmpeg,[]
3edb99e8acc3f2c720f7f8d490b9535b6e6b67a5,php/php-src,php_ini.c,test,C,0,"['@@ -73,8 +73,11 @@ int php_register_ini_entries(php_ini_entry *ini_entry, int module_number)\n \t\t\treturn FAILURE;\n \t\t}\n \t\tif ((default_value=cfg_get_entry(p->name, p->name_length))) {\n-\t\t\thashed_ini_entry->value = default_value->value.str.val;\n-\t\t\thashed_ini_entry->value_length = default_value->value.str.len;\n+\t\t\tif (!hashed_ini_entry->on_modify\n+\t\t\t\t|| hashed_ini_entry->on_modify(hashed_ini_entry, default_value->value.str.val, default_value->value.str.len)==SUCCESS) {\n+\t\t\t\thashed_ini_entry->value = default_value->value.str.val;\n+\t\t\t\thashed_ini_entry->value_length = default_value->value.str.len;\n+\t\t\t}\n \t\t}\n \t\thashed_ini_entry->modified = 0;\n \t\tp++;\n']",,,"['+ \t\t\tif (!hashed_ini_entry->on_modify', '+ \t\t\t\t|| hashed_ini_entry->on_modify(hashed_ini_entry, default_value->value.str.val, default_value->value.str.len)==SUCCESS) {', '+ \t\t\t\thashed_ini_entry->value = default_value->value.str.val;', '+ \t\t\t\thashed_ini_entry->value_length = default_value->value.str.len;', '+ \t\t\t}', '- \t\t\thashed_ini_entry->value = default_value->value.str.val;', '- \t\t\thashed_ini_entry->value_length = default_value->value.str.len;']","['+ \t\t\tif (!hashed_ini_entry->on_modify', '+ \t\t\t\t|| hashed_ini_entry->on_modify(hashed_ini_entry, default_value->value.str.val, default_value->value.str.len)==success) {', '+ \t\t\t\thashed_ini_entry->value = default_value->value.str.val;', '+ \t\t\t\thashed_ini_entry->value_length = default_value->value.str.len;', '+ \t\t\t}', '- \t\t\thashed_ini_entry->value = default_value->value.str.val;', '- \t\t\thashed_ini_entry->value_length = default_value->value.str.len;']","['+ \t\t\tif (!hashed_ini_entry->on_modify', '+ \t\t\t\t|| hashed_ini_entry->on_modify(hashed_ini_entry, default_value->value.str.val, default_value->value.str.len)==SUCCESS) {', '+ \t\t\t\thashed_ini_entry->value = default_value->value.str.val;', '+ \t\t\t\thashed_ini_entry->value_length = default_value->value.str.len;', '+ \t\t\t}']","['- \t\t\thashed_ini_entry->value = default_value->value.str.val;', '- \t\t\thashed_ini_entry->value_length = default_value->value.str.len;']",5,2.0,7.0,3edb99e8acc3f2c720f7f8d490b9535b6e6b67a5php/php-src,[]
bf9f5fbc176681b561a4c2819b301ad908d64dd8,libarchive/libarchive,test_option_T.c,train,C,0,"['@@ -118,6 +118,25 @@ DEFINE_TEST(test_option_T)\n \tassertFileExists(""test2/d1/d2/f4"");\n \tassertFileNotExists(""test2/d1/d2/f5"");\n \n+\tassertEqualInt(0, mkdir(""test4"", 0755));\n+\tassertEqualInt(0, mkdir(""test4_out"", 0755));\n+\tassertEqualInt(0, mkdir(""test4_out2"", 0755));\n+\tassertEqualInt(0, mkdir(""test4/d1"", 0755));\n+\tassertEqualInt(1, touch(""test4/d1/foo""));\n+\n+\tsystemf(""%s -cf - -s /foo/bar/ test4/d1/foo | %s -xf - -C test4_out"",\n+\t    testprog, testprog);\n+\tassertEmptyFile(""test4_out/test4/d1/bar"");\n+\tsystemf(""%s -cf - -s /d1/d2/ test4/d1/foo | %s -xf - -C test4_out"",\n+\t    testprog, testprog);\n+\tassertEmptyFile(""test4_out/test4/d2/foo"");\n+\tsystemf(""%s -cf - -s ,test4/d1/foo,, test4/d1/foo | %s -tvf - > test4.lst"",\n+\t    testprog, testprog);\n+\tassertEmptyFile(""test4.lst"");\n+\tsystemf(""%s -cf - test4/d1/foo | %s -xf - -s /foo/bar/ -C test4_out2"",\n+\t    testprog, testprog);\n+\tassertEmptyFile(""test4_out2/test4/d1/bar"");\n+\n \t/* TODO: Include some use of -C directory-changing within the filelist. */\n \t/* I\'m pretty sure -C within the filelist is broken on extract. */\n }\n']",,,"['+ \tassertEqualInt(0, mkdir(""test4"", 0755));', '+ \tassertEqualInt(0, mkdir(""test4_out"", 0755));', '+ \tassertEqualInt(0, mkdir(""test4_out2"", 0755));', '+ \tassertEqualInt(0, mkdir(""test4/d1"", 0755));', '+ \tassertEqualInt(1, touch(""test4/d1/foo""));', '+ \tsystemf(""%s -cf - -s /foo/bar/ test4/d1/foo | %s -xf - -C test4_out"",', '+ \t    testprog, testprog);', '+ \tassertEmptyFile(""test4_out/test4/d1/bar"");', '+ \tsystemf(""%s -cf - -s /d1/d2/ test4/d1/foo | %s -xf - -C test4_out"",', '+ \t    testprog, testprog);', '+ \tassertEmptyFile(""test4_out/test4/d2/foo"");', '+ \tsystemf(""%s -cf - -s ,test4/d1/foo,, test4/d1/foo | %s -tvf - > test4.lst"",', '+ \t    testprog, testprog);', '+ \tassertEmptyFile(""test4.lst"");', '+ \tsystemf(""%s -cf - test4/d1/foo | %s -xf - -s /foo/bar/ -C test4_out2"",', '+ \t    testprog, testprog);', '+ \tassertEmptyFile(""test4_out2/test4/d1/bar"");']","['+ \tassertequalint(0, mkdir(""test4"", 0755));', '+ \tassertequalint(0, mkdir(""test4_out"", 0755));', '+ \tassertequalint(0, mkdir(""test4_out2"", 0755));', '+ \tassertequalint(0, mkdir(""test4/d1"", 0755));', '+ \tassertequalint(1, touch(""test4/d1/foo""));', '+ \tsystemf(""%s -cf - -s /foo/bar/ test4/d1/foo | %s -xf - -c test4_out"",', '+ \t    testprog, testprog);', '+ \tassertemptyfile(""test4_out/test4/d1/bar"");', '+ \tsystemf(""%s -cf - -s /d1/d2/ test4/d1/foo | %s -xf - -c test4_out"",', '+ \t    testprog, testprog);', '+ \tassertemptyfile(""test4_out/test4/d2/foo"");', '+ \tsystemf(""%s -cf - -s ,test4/d1/foo,, test4/d1/foo | %s -tvf - > test4.lst"",', '+ \t    testprog, testprog);', '+ \tassertemptyfile(""test4.lst"");', '+ \tsystemf(""%s -cf - test4/d1/foo | %s -xf - -s /foo/bar/ -c test4_out2"",', '+ \t    testprog, testprog);', '+ \tassertemptyfile(""test4_out2/test4/d1/bar"");']","['+ \tassertEqualInt(0, mkdir(""test4"", 0755));', '+ \tassertEqualInt(0, mkdir(""test4_out"", 0755));', '+ \tassertEqualInt(0, mkdir(""test4_out2"", 0755));', '+ \tassertEqualInt(0, mkdir(""test4/d1"", 0755));', '+ \tassertEqualInt(1, touch(""test4/d1/foo""));', '+ \tsystemf(""%s -cf - -s /foo/bar/ test4/d1/foo | %s -xf - -C test4_out"",', '+ \t    testprog, testprog);', '+ \tassertEmptyFile(""test4_out/test4/d1/bar"");', '+ \tsystemf(""%s -cf - -s /d1/d2/ test4/d1/foo | %s -xf - -C test4_out"",', '+ \t    testprog, testprog);', '+ \tassertEmptyFile(""test4_out/test4/d2/foo"");', '+ \tsystemf(""%s -cf - -s ,test4/d1/foo,, test4/d1/foo | %s -tvf - > test4.lst"",', '+ \t    testprog, testprog);', '+ \tassertEmptyFile(""test4.lst"");', '+ \tsystemf(""%s -cf - test4/d1/foo | %s -xf - -s /foo/bar/ -C test4_out2"",', '+ \t    testprog, testprog);', '+ \tassertEmptyFile(""test4_out2/test4/d1/bar"");']",[],17,0.0,17.0,bf9f5fbc176681b561a4c2819b301ad908d64dd8libarchive/libarchive,[]
629947e3ba4cc631a9439d5b9ede8f235da1da08,libarchive/libarchive,archive_read_support_format_mtree.c,test,C,0,"['@@ -483,6 +483,18 @@ parse_keyword(struct archive_read *a, struct mtree *mtree,\n \t\t\tarchive_strcpy(&mtree->contents_name, val);\n \t\t\tbreak;\n \t\t}\n+\t\tif (strcmp(key, ""cksum"") == 0)\n+\t\t\tbreak;\n+\tcase \'d\':\n+#if 0\n+\t\tif (strcmp(key, ""device"") == 0)\n+\t\t\tbreak;\n+#endif\n+\tcase \'f\':\n+\t\tif (strcmp(key, ""flags"") == 0) {\n+\t\t\tarchive_entry_copy_fflags_text(entry, val);\n+\t\t\tbreak;\n+\t\t}\n \tcase \'g\':\n \t\tif (strcmp(key, ""gid"") == 0) {\n \t\t\tarchive_entry_set_gid(entry, mtree_atol10(&val));\n@@ -492,12 +504,20 @@ parse_keyword(struct archive_read *a, struct mtree *mtree,\n \t\t\tarchive_entry_copy_gname(entry, val);\n \t\t\tbreak;\n \t\t}\n+\tcase \'i\':\n+#if 0\n+\t\tif (strcmp(key, ""ignore"") == 0) {\n+\t\t\t/* Ignore under this. */\n+\t\t\tbreak;\n+#endif\n \tcase \'l\':\n \t\tif (strcmp(key, ""link"") == 0) {\n \t\t\tarchive_entry_set_link(entry, val);\n \t\t\tbreak;\n \t\t}\n \tcase \'m\':\n+\t\tif (strcmp(key, ""md5"") == 0 || strcmp(key, ""md5digest"") == 0)\n+\t\t\tbreak;\n \t\tif (strcmp(key, ""mode"") == 0) {\n \t\t\tif (val[0] == \'0\') {\n \t\t\t\tarchive_entry_set_perm(entry,\n@@ -508,12 +528,53 @@ parse_keyword(struct archive_read *a, struct mtree *mtree,\n \t\t\t\t    ""Symbolic mode \\""%s\\"" unsupported"", val);\n \t\t\tbreak;\n \t\t}\n+\tcase \'n\':\n+\t\tif (strcmp(key, ""nlink"") == 0) {\n+\t\t\tarchive_entry_set_nlink(entry, mtree_atol10(&val));\n+\t\t\tbreak;\n+\t\t}\n+\tcase \'o\':\n+#if 0\n+\t\tif (strcmp(key, ""optional"") == 0) {\n+\t\t\t/*\n+\t\t\t * This file may or may not exist.\n+\t\t\t * Just ignore the keyword?\n+\t\t\t */\n+\t\t\tbreak;\n+#endif\n+\tcase \'r\':\n+\t\tif (strcmp(key, ""rmd160"") == 0 ||\n+\t\t    strcmp(key, ""rmd160digest"") == 0)\n+\t\t\tbreak;\n \tcase \'s\':\n+\t\tif (strcmp(key, ""sha1"") == 0 || strcmp(key, ""sha1digest"") == 0)\n+\t\t\tbreak;\n+\t\tif (strcmp(key, ""sha256"") == 0 ||\n+\t\t    strcmp(key, ""sha256digest"") == 0)\n+\t\t\tbreak;\n+\t\tif (strcmp(key, ""sha384"") == 0 ||\n+\t\t    strcmp(key, ""sha384digest"") == 0)\n+\t\t\tbreak;\n+\t\tif (strcmp(key, ""sha512"") == 0 ||\n+\t\t    strcmp(key, ""sha512digest"") == 0)\n+\t\t\tbreak;\n \t\tif (strcmp(key, ""size"") == 0) {\n \t\t\tarchive_entry_set_size(entry, mtree_atol10(&val));\n \t\t\tbreak;\n \t\t}\n \tcase \'t\':\n+\t\tif (strcmp(key, ""tags"") == 0) {\n+\t\t\t/*\n+\t\t\t * Comma delimited list of tags.\n+\t\t\t * Ignore the tags for now, but the interface\n+\t\t\t * should be extended to allow inclusion/exclusion.\n+\t\t\t */\n+\t\t\tbreak;\n+\t\t}\n+\t\tif (strcmp(key, ""time"") == 0) {\n+\t\t\tarchive_entry_set_mtime(entry, mtree_atol10(&val), 0);\n+\t\t\tbreak;\n+\t\t}\n \t\tif (strcmp(key, ""type"") == 0) {\n \t\t\tswitch (val[0]) {\n \t\t\tcase \'b\':\n@@ -554,10 +615,6 @@ parse_keyword(struct archive_read *a, struct mtree *mtree,\n \t\t\tarchive_entry_set_filetype(entry, mtree->filetype);\n \t\t\tbreak;\n \t\t}\n-\t\tif (strcmp(key, ""time"") == 0) {\n-\t\t\tarchive_entry_set_mtime(entry, mtree_atol10(&val), 0);\n-\t\t\tbreak;\n-\t\t}\n \tcase \'u\':\n \t\tif (strcmp(key, ""uid"") == 0) {\n \t\t\tarchive_entry_set_uid(entry, mtree_atol10(&val));\n']",,,"['+ \t\tif (strcmp(key, ""cksum"") == 0)', '+ \t\t\tbreak;', ""+ \tcase 'd':"", '+ #if 0', '+ \t\tif (strcmp(key, ""device"") == 0)', '+ \t\t\tbreak;', '+ #endif', ""+ \tcase 'f':"", '+ \t\tif (strcmp(key, ""flags"") == 0) {', '+ \t\t\tarchive_entry_copy_fflags_text(entry, val);', '+ \t\t\tbreak;', '+ \t\t}', ""+ \tcase 'i':"", '+ #if 0', '+ \t\tif (strcmp(key, ""ignore"") == 0) {', '+ \t\t\tbreak;', '+ #endif', '+ \t\tif (strcmp(key, ""md5"") == 0 || strcmp(key, ""md5digest"") == 0)', '+ \t\t\tbreak;', ""+ \tcase 'n':"", '+ \t\tif (strcmp(key, ""nlink"") == 0) {', '+ \t\t\tarchive_entry_set_nlink(entry, mtree_atol10(&val));', '+ \t\t\tbreak;', '+ \t\t}', ""+ \tcase 'o':"", '+ #if 0', '+ \t\tif (strcmp(key, ""optional"") == 0) {', '+ \t\t\tbreak;', '+ #endif', ""+ \tcase 'r':"", '+ \t\tif (strcmp(key, ""rmd160"") == 0 ||', '+ \t\t    strcmp(key, ""rmd160digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha1"") == 0 || strcmp(key, ""sha1digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha256"") == 0 ||', '+ \t\t    strcmp(key, ""sha256digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha384"") == 0 ||', '+ \t\t    strcmp(key, ""sha384digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha512"") == 0 ||', '+ \t\t    strcmp(key, ""sha512digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""tags"") == 0) {', '+ \t\t\tbreak;', '+ \t\t}', '+ \t\tif (strcmp(key, ""time"") == 0) {', '+ \t\t\tarchive_entry_set_mtime(entry, mtree_atol10(&val), 0);', '+ \t\t\tbreak;', '+ \t\t}', '- \t\tif (strcmp(key, ""time"") == 0) {', '- \t\t\tarchive_entry_set_mtime(entry, mtree_atol10(&val), 0);', '- \t\t\tbreak;', '- \t\t}']","['+ \t\tif (strcmp(key, ""cksum"") == 0)', '+ \t\t\tbreak;', ""+ \tcase 'd':"", '+ #if 0', '+ \t\tif (strcmp(key, ""device"") == 0)', '+ \t\t\tbreak;', '+ #endif', ""+ \tcase 'f':"", '+ \t\tif (strcmp(key, ""flags"") == 0) {', '+ \t\t\tarchive_entry_copy_fflags_text(entry, val);', '+ \t\t\tbreak;', '+ \t\t}', ""+ \tcase 'i':"", '+ #if 0', '+ \t\tif (strcmp(key, ""ignore"") == 0) {', '+ \t\t\tbreak;', '+ #endif', '+ \t\tif (strcmp(key, ""md5"") == 0 || strcmp(key, ""md5digest"") == 0)', '+ \t\t\tbreak;', ""+ \tcase 'n':"", '+ \t\tif (strcmp(key, ""nlink"") == 0) {', '+ \t\t\tarchive_entry_set_nlink(entry, mtree_atol10(&val));', '+ \t\t\tbreak;', '+ \t\t}', ""+ \tcase 'o':"", '+ #if 0', '+ \t\tif (strcmp(key, ""optional"") == 0) {', '+ \t\t\tbreak;', '+ #endif', ""+ \tcase 'r':"", '+ \t\tif (strcmp(key, ""rmd160"") == 0 ||', '+ \t\t    strcmp(key, ""rmd160digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha1"") == 0 || strcmp(key, ""sha1digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha256"") == 0 ||', '+ \t\t    strcmp(key, ""sha256digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha384"") == 0 ||', '+ \t\t    strcmp(key, ""sha384digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha512"") == 0 ||', '+ \t\t    strcmp(key, ""sha512digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""tags"") == 0) {', '+ \t\t\tbreak;', '+ \t\t}', '+ \t\tif (strcmp(key, ""time"") == 0) {', '+ \t\t\tarchive_entry_set_mtime(entry, mtree_atol10(&val), 0);', '+ \t\t\tbreak;', '+ \t\t}', '- \t\tif (strcmp(key, ""time"") == 0) {', '- \t\t\tarchive_entry_set_mtime(entry, mtree_atol10(&val), 0);', '- \t\t\tbreak;', '- \t\t}']","['+ \t\tif (strcmp(key, ""cksum"") == 0)', '+ \t\t\tbreak;', ""+ \tcase 'd':"", '+ #if 0', '+ \t\tif (strcmp(key, ""device"") == 0)', '+ \t\t\tbreak;', '+ #endif', ""+ \tcase 'f':"", '+ \t\tif (strcmp(key, ""flags"") == 0) {', '+ \t\t\tarchive_entry_copy_fflags_text(entry, val);', '+ \t\t\tbreak;', '+ \t\t}', ""+ \tcase 'i':"", '+ #if 0', '+ \t\tif (strcmp(key, ""ignore"") == 0) {', '+ \t\t\tbreak;', '+ #endif', '+ \t\tif (strcmp(key, ""md5"") == 0 || strcmp(key, ""md5digest"") == 0)', '+ \t\t\tbreak;', ""+ \tcase 'n':"", '+ \t\tif (strcmp(key, ""nlink"") == 0) {', '+ \t\t\tarchive_entry_set_nlink(entry, mtree_atol10(&val));', '+ \t\t\tbreak;', '+ \t\t}', ""+ \tcase 'o':"", '+ #if 0', '+ \t\tif (strcmp(key, ""optional"") == 0) {', '+ \t\t\tbreak;', '+ #endif', ""+ \tcase 'r':"", '+ \t\tif (strcmp(key, ""rmd160"") == 0 ||', '+ \t\t    strcmp(key, ""rmd160digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha1"") == 0 || strcmp(key, ""sha1digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha256"") == 0 ||', '+ \t\t    strcmp(key, ""sha256digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha384"") == 0 ||', '+ \t\t    strcmp(key, ""sha384digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""sha512"") == 0 ||', '+ \t\t    strcmp(key, ""sha512digest"") == 0)', '+ \t\t\tbreak;', '+ \t\tif (strcmp(key, ""tags"") == 0) {', '+ \t\t\tbreak;', '+ \t\t}', '+ \t\tif (strcmp(key, ""time"") == 0) {', '+ \t\t\tarchive_entry_set_mtime(entry, mtree_atol10(&val), 0);', '+ \t\t\tbreak;', '+ \t\t}']","['- \t\tif (strcmp(key, ""time"") == 0) {', '- \t\t\tarchive_entry_set_mtime(entry, mtree_atol10(&val), 0);', '- \t\t\tbreak;', '- \t\t}']",51,4.0,55.0,629947e3ba4cc631a9439d5b9ede8f235da1da08libarchive/libarchive,[]
8e78a7eeb7266329891971090d2666f5c6a13ad0,krb5/krb5,src/lib/kadm5/srv/svr_principal.c,train,C,1,"['@@ -224,9 +224,10 @@ kadm5_create_principal_3(void *server_handle,\n                          int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n                          char *password)\n {\n-    krb5_db_entry               kdb;\n+    krb5_db_entry               *kdb;\n     osa_princ_ent_rec           adb;\n     kadm5_policy_ent_rec        polent;\n+    krb5_boolean                have_polent = FALSE;\n     krb5_int32                  now;\n     krb5_tl_data                *tl_data_orig, *tl_data_tail;\n     unsigned int                ret;\n@@ -264,13 +265,16 @@ kadm5_create_principal_3(void *server_handle,\n     case KADM5_UNK_PRINC:\n         break;\n     case 0:\n-        kdb_free_entry(handle, &kdb, &adb);\n+        kdb_free_entry(handle, kdb, &adb);\n         return KADM5_DUP;\n     default:\n         return ret;\n     }\n \n-    memset(&kdb, 0, sizeof(krb5_db_entry));\n+    kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb));\n+    if (kdb == NULL)\n+        return ENOMEM;\n+    memset(kdb, 0, sizeof(*kdb));\n     memset(&adb, 0, sizeof(osa_princ_ent_rec));\n \n     /*\n@@ -280,101 +284,84 @@ kadm5_create_principal_3(void *server_handle,\n     if ((mask & KADM5_POLICY)) {\n         if ((ret = kadm5_get_policy(handle->lhandle, entry->policy,\n                                     &polent)) != KADM5_OK) {\n-            if(ret == EINVAL)\n-                return KADM5_BAD_POLICY;\n-            else\n-                return ret;\n+            if (ret == EINVAL)\n+                ret = KADM5_BAD_POLICY;\n+            if (ret)\n+                goto cleanup;\n         }\n+        have_polent = TRUE;\n     }\n     if (password) {\n-        ret = passwd_check(handle, password, (mask & KADM5_POLICY),\n-                           &polent, entry->principal);\n-        if (ret) {\n-            if (mask & KADM5_POLICY)\n-                (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-            return ret;\n-        }\n+        ret = passwd_check(handle, password, have_polent, &polent,\n+                           entry->principal);\n+        if (ret)\n+            goto cleanup;\n     }\n     /*\n      * Start populating the various DB fields, using the\n      * ""defaults"" for fields that were not specified by the\n      * mask.\n      */\n-    if ((ret = krb5_timeofday(handle->context, &now))) {\n-        if (mask & KADM5_POLICY)\n-            (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-        return ret;\n-    }\n+    if ((ret = krb5_timeofday(handle->context, &now)))\n+        goto cleanup;\n \n-    kdb.magic = KRB5_KDB_MAGIC_NUMBER;\n-    kdb.len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n+    kdb->magic = KRB5_KDB_MAGIC_NUMBER;\n+    kdb->len = KRB5_KDB_V1_BASE_LENGTH; /* gag me with a chainsaw */\n \n     if ((mask & KADM5_ATTRIBUTES))\n-        kdb.attributes = entry->attributes;\n+        kdb->attributes = entry->attributes;\n     else\n-        kdb.attributes = handle->params.flags;\n+        kdb->attributes = handle->params.flags;\n \n     if ((mask & KADM5_MAX_LIFE))\n-        kdb.max_life = entry->max_life;\n+        kdb->max_life = entry->max_life;\n     else\n-        kdb.max_life = handle->params.max_life;\n+        kdb->max_life = handle->params.max_life;\n \n     if (mask & KADM5_MAX_RLIFE)\n-        kdb.max_renewable_life = entry->max_renewable_life;\n+        kdb->max_renewable_life = entry->max_renewable_life;\n     else\n-        kdb.max_renewable_life = handle->params.max_rlife;\n+        kdb->max_renewable_life = handle->params.max_rlife;\n \n     if ((mask & KADM5_PRINC_EXPIRE_TIME))\n-        kdb.expiration = entry->princ_expire_time;\n+        kdb->expiration = entry->princ_expire_time;\n     else\n-        kdb.expiration = handle->params.expiration;\n+        kdb->expiration = handle->params.expiration;\n \n-    kdb.pw_expiration = 0;\n-    if ((mask & KADM5_POLICY)) {\n+    kdb->pw_expiration = 0;\n+    if (have_polent) {\n         if(polent.pw_max_life)\n-            kdb.pw_expiration = now + polent.pw_max_life;\n+            kdb->pw_expiration = now + polent.pw_max_life;\n         else\n-            kdb.pw_expiration = 0;\n+            kdb->pw_expiration = 0;\n     }\n     if ((mask & KADM5_PW_EXPIRATION))\n-        kdb.pw_expiration = entry->pw_expiration;\n+        kdb->pw_expiration = entry->pw_expiration;\n \n-    kdb.last_success = 0;\n-    kdb.last_failed = 0;\n-    kdb.fail_auth_count = 0;\n+    kdb->last_success = 0;\n+    kdb->last_failed = 0;\n+    kdb->fail_auth_count = 0;\n \n     /* this is kind of gross, but in order to free the tl data, I need\n        to free the entire kdb entry, and that will try to free the\n        principal. */\n \n     if ((ret = kadm5_copy_principal(handle->context,\n-                                    entry->principal, &(kdb.princ)))) {\n-        if (mask & KADM5_POLICY)\n-            (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-        return(ret);\n-    }\n+                                    entry->principal, &(kdb->princ))))\n+        goto cleanup;\n \n-    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now))) {\n-        krb5_db_free_principal(handle->context, &kdb, 1);\n-        if (mask & KADM5_POLICY)\n-            (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-        return(ret);\n-    }\n+    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n+        goto cleanup;\n \n     if (mask & KADM5_TL_DATA) {\n-        /* splice entry->tl_data onto the front of kdb.tl_data */\n-        tl_data_orig = kdb.tl_data;\n+        /* splice entry->tl_data onto the front of kdb->tl_data */\n+        tl_data_orig = kdb->tl_data;\n         for (tl_data_tail = entry->tl_data; tl_data_tail;\n              tl_data_tail = tl_data_tail->tl_data_next)\n         {\n-            ret = krb5_dbe_update_tl_data(handle->context, &kdb, tl_data_tail);\n+            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);\n             if( ret )\n-            {\n-                krb5_db_free_principal(handle->context, &kdb, 1);\n-                if (mask & KADM5_POLICY)\n-                    (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-                return ret;\n-            }\n+                goto cleanup;\n         }\n     }\n \n@@ -382,42 +369,29 @@ kadm5_create_principal_3(void *server_handle,\n \n     ret = krb5_dbe_find_act_mkey(handle->context, master_keylist,\n                                  active_mkey_list, &act_kvno, &act_mkey);\n-    if (ret) {\n-        krb5_db_free_principal(handle->context, &kdb, 1);\n-        if (mask & KADM5_POLICY)\n-            (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-        return (ret);\n-    }\n+    if (ret)\n+        goto cleanup;\n \n     if (password) {\n         ret = krb5_dbe_cpw(handle->context, act_mkey,\n                            n_ks_tuple?ks_tuple:handle->params.keysalts,\n                            n_ks_tuple?n_ks_tuple:handle->params.num_keysalts,\n                            password, (mask & KADM5_KVNO)?entry->kvno:1,\n-                           FALSE, &kdb);\n+                           FALSE, kdb);\n     } else {\n         /* Null password means create with random key (new in 1.8). */\n         ret = krb5_dbe_crk(handle->context, &master_keyblock,\n                            n_ks_tuple?ks_tuple:handle->params.keysalts,\n                            n_ks_tuple?n_ks_tuple:handle->params.num_keysalts,\n-                           FALSE, &kdb);\n-    }\n-    if (ret) {\n-        krb5_db_free_principal(handle->context, &kdb, 1);\n-        if (mask & KADM5_POLICY)\n-            (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-        return(ret);\n+                           FALSE, kdb);\n     }\n+    if (ret)\n+        goto cleanup;\n \n     /* Record the master key VNO used to encrypt this entry\'s keys */\n-    ret = krb5_dbe_update_mkvno(handle->context, &kdb, act_kvno);\n+    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n     if (ret)\n-    {\n-        krb5_db_free_principal(handle->context, &kdb, 1);\n-        if (mask & KADM5_POLICY)\n-            (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-        return ret;\n-    }\n+        goto cleanup;\n \n     /* populate the admin-server-specific fields.  In the OV server,\n        this used to be in a separate database.  Since there\'s already\n@@ -426,7 +400,7 @@ kadm5_create_principal_3(void *server_handle,\n        single tl_data record, */\n \n     adb.admin_history_kvno = INITIAL_HIST_KVNO;\n-    if ((mask & KADM5_POLICY)) {\n+    if (have_polent) {\n         adb.aux_attributes = KADM5_POLICY;\n \n         /* this does *not* need to be strdup\'ed, because adb is xdr */\n@@ -437,28 +411,23 @@ kadm5_create_principal_3(void *server_handle,\n \n     /* increment the policy ref count, if any */\n \n-    if ((mask & KADM5_POLICY)) {\n+    if (have_polent) {\n         polent.policy_refcnt++;\n         if ((ret = kadm5_modify_policy_internal(handle->lhandle, &polent,\n                                                 KADM5_REF_COUNT))\n-            != KADM5_OK) {\n-            krb5_db_free_principal(handle->context, &kdb, 1);\n-            if (mask & KADM5_POLICY)\n-                (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-            return(ret);\n-        }\n+            != KADM5_OK)\n+            goto cleanup;\n     }\n \n     /* In all cases key and the principal data is set, let the database provider know */\n-    kdb.mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n+    kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;\n \n     /* store the new db entry */\n-    ret = kdb_put_entry(handle, &kdb, &adb);\n+    ret = kdb_put_entry(handle, kdb, &adb);\n \n-    krb5_db_free_principal(handle->context, &kdb, 1);\n \n     if (ret) {\n-        if ((mask & KADM5_POLICY)) {\n+        if (have_polent) {\n             /* decrement the policy ref count */\n \n             polent.policy_refcnt--;\n@@ -469,16 +438,13 @@ kadm5_create_principal_3(void *server_handle,\n             (void) kadm5_modify_policy_internal(handle->lhandle, &polent,\n                                                 KADM5_REF_COUNT);\n         }\n-\n-        if (mask & KADM5_POLICY)\n-            (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-        return(ret);\n     }\n \n-    if (mask & KADM5_POLICY)\n+cleanup:\n+    krb5_db_free_principal(handle->context, kdb);\n+    if (have_polent)\n         (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-\n-    return KADM5_OK;\n+    return ret;\n }\n \n \n@@ -487,7 +453,7 @@ kadm5_delete_principal(void *server_handle, krb5_principal principal)\n {\n     unsigned int                ret;\n     kadm5_policy_ent_rec        polent;\n-    krb5_db_entry               kdb;\n+    krb5_db_entry               *kdb;\n     osa_princ_ent_rec           adb;\n     kadm5_server_handle_t handle = server_handle;\n \n@@ -510,19 +476,19 @@ kadm5_delete_principal(void *server_handle, krb5_principal principal)\n                                                     KADM5_REF_COUNT))\n                 != KADM5_OK) {\n                 (void) kadm5_free_policy_ent(handle->lhandle, &polent);\n-                kdb_free_entry(handle, &kdb, &adb);\n+                kdb_free_entry(handle, kdb, &adb);\n                 return(ret);\n             }\n         }\n         if ((ret = kadm5_free_policy_ent(handle->lhandle, &polent))) {\n-            kdb_free_entry(handle, &kdb, &adb);\n+            kdb_free_entry(handle, kdb, &adb);\n             return ret;\n         }\n     }\n \n     ret = kdb_delete_entry(handle, principal);\n \n-    kdb_free_entry(handle, &kdb, &adb);\n+    kdb_free_entry(handle, kdb, &adb);\n \n     return ret;\n }\n@@ -534,7 +500,7 @@ kadm5_modify_principal(void *server_handle,\n     int                     ret, ret2, i;\n     kadm5_policy_ent_rec    npol, opol;\n     int                     have_npol = 0, have_opol = 0;\n-    krb5_db_entry           kdb;\n+    krb5_db_entry           *kdb;\n     krb5_tl_data            *tl_data_orig;\n     osa_princ_ent_rec       adb;\n     kadm5_server_handle_t handle = server_handle;\n@@ -620,13 +586,13 @@ kadm5_modify_principal(void *server_handle,\n \n         /* set pw_max_life based on new policy */\n         if (npol.pw_max_life) {\n-            ret = krb5_dbe_lookup_last_pwd_change(handle->context, &kdb,\n-                                                  &(kdb.pw_expiration));\n+            ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n+                                                  &(kdb->pw_expiration));\n             if (ret)\n                 goto done;\n-            kdb.pw_expiration += npol.pw_max_life;\n+            kdb->pw_expiration += npol.pw_max_life;\n         } else {\n-            kdb.pw_expiration = 0;\n+            kdb->pw_expiration = 0;\n         }\n     }\n \n@@ -646,7 +612,7 @@ kadm5_modify_principal(void *server_handle,\n                 free(adb.policy);\n             adb.policy = NULL;\n             adb.aux_attributes &= ~KADM5_POLICY;\n-            kdb.pw_expiration = 0;\n+            kdb->pw_expiration = 0;\n             opol.policy_refcnt--;\n             break;\n         default:\n@@ -667,19 +633,19 @@ kadm5_modify_principal(void *server_handle,\n         goto done;\n \n     if ((mask & KADM5_ATTRIBUTES))\n-        kdb.attributes = entry->attributes;\n+        kdb->attributes = entry->attributes;\n     if ((mask & KADM5_MAX_LIFE))\n-        kdb.max_life = entry->max_life;\n+        kdb->max_life = entry->max_life;\n     if ((mask & KADM5_PRINC_EXPIRE_TIME))\n-        kdb.expiration = entry->princ_expire_time;\n+        kdb->expiration = entry->princ_expire_time;\n     if (mask & KADM5_PW_EXPIRATION)\n-        kdb.pw_expiration = entry->pw_expiration;\n+        kdb->pw_expiration = entry->pw_expiration;\n     if (mask & KADM5_MAX_RLIFE)\n-        kdb.max_renewable_life = entry->max_renewable_life;\n+        kdb->max_renewable_life = entry->max_renewable_life;\n \n     if((mask & KADM5_KVNO)) {\n-        for (i = 0; i < kdb.n_key_data; i++)\n-            kdb.key_data[i].key_data_kvno = entry->kvno;\n+        for (i = 0; i < kdb->n_key_data; i++)\n+            kdb->key_data[i].key_data_kvno = entry->kvno;\n     }\n \n     if (mask & KADM5_TL_DATA) {\n@@ -690,7 +656,7 @@ kadm5_modify_principal(void *server_handle,\n         for (tl = entry->tl_data; tl;\n              tl = tl->tl_data_next)\n         {\n-            ret = krb5_dbe_update_tl_data(handle->context, &kdb, tl);\n+            ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);\n             if( ret )\n             {\n                 goto done;\n@@ -709,13 +675,13 @@ kadm5_modify_principal(void *server_handle,\n             goto done;\n         }\n \n-        kdb.fail_auth_count = 0;\n+        kdb->fail_auth_count = 0;\n     }\n \n     /* let the mask propagate to the database provider */\n-    kdb.mask = mask;\n+    kdb->mask = mask;\n \n-    ret = kdb_put_entry(handle, &kdb, &adb);\n+    ret = kdb_put_entry(handle, kdb, &adb);\n     if (ret) goto done;\n \n     ret = KADM5_OK;\n@@ -728,7 +694,7 @@ done:\n         ret2 = kadm5_free_policy_ent(handle->lhandle, &npol);\n         ret = ret ? ret : ret2;\n     }\n-    kdb_free_entry(handle, &kdb, &adb);\n+    kdb_free_entry(handle, kdb, &adb);\n     return ret;\n }\n \n@@ -736,7 +702,7 @@ kadm5_ret_t\n kadm5_rename_principal(void *server_handle,\n                        krb5_principal source, krb5_principal target)\n {\n-    krb5_db_entry       kdb;\n+    krb5_db_entry       *kdb;\n     osa_princ_ent_rec   adb;\n     int                 ret, i;\n     kadm5_server_handle_t handle = server_handle;\n@@ -749,7 +715,7 @@ kadm5_rename_principal(void *server_handle,\n         return EINVAL;\n \n     if ((ret = kdb_get_entry(handle, target, &kdb, &adb)) == 0) {\n-        kdb_free_entry(handle, &kdb, &adb);\n+        kdb_free_entry(handle, kdb, &adb);\n         return(KADM5_DUP);\n     }\n \n@@ -758,28 +724,28 @@ kadm5_rename_principal(void *server_handle,\n \n     /* this is kinda gross, but unavoidable */\n \n-    for (i=0; i<kdb.n_key_data; i++) {\n-        if ((kdb.key_data[i].key_data_ver == 1) ||\n-            (kdb.key_data[i].key_data_type[1] == KRB5_KDB_SALTTYPE_NORMAL)) {\n+    for (i=0; i<kdb->n_key_data; i++) {\n+        if ((kdb->key_data[i].key_data_ver == 1) ||\n+            (kdb->key_data[i].key_data_type[1] == KRB5_KDB_SALTTYPE_NORMAL)) {\n             ret = KADM5_NO_RENAME_SALT;\n             goto done;\n         }\n     }\n \n-    kadm5_free_principal(handle->context, kdb.princ);\n-    ret = kadm5_copy_principal(handle->context, target, &kdb.princ);\n+    kadm5_free_principal(handle->context, kdb->princ);\n+    ret = kadm5_copy_principal(handle->context, target, &kdb->princ);\n     if (ret) {\n-        kdb.princ = NULL; /* so freeing the dbe doesn\'t lose */\n+        kdb->princ = NULL; /* so freeing the dbe doesn\'t lose */\n         goto done;\n     }\n \n-    if ((ret = kdb_put_entry(handle, &kdb, &adb)))\n+    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n         goto done;\n \n     ret = kdb_delete_entry(handle, source);\n \n done:\n-    kdb_free_entry(handle, &kdb, &adb);\n+    kdb_free_entry(handle, kdb, &adb);\n     return ret;\n }\n \n@@ -788,7 +754,7 @@ kadm5_get_principal(void *server_handle, krb5_principal principal,\n                     kadm5_principal_ent_t entry,\n                     long in_mask)\n {\n-    krb5_db_entry               kdb;\n+    krb5_db_entry               *kdb;\n     osa_princ_ent_rec           adb;\n     krb5_error_code             ret = 0;\n     long                        mask;\n@@ -826,29 +792,29 @@ kadm5_get_principal(void *server_handle, krb5_principal principal,\n         entry->aux_attributes = adb.aux_attributes;\n \n     if ((mask & KADM5_PRINCIPAL) &&\n-        (ret = krb5_copy_principal(handle->context, kdb.princ,\n+        (ret = krb5_copy_principal(handle->context, kdb->princ,\n                                    &entry->principal))) {\n         goto done;\n     }\n \n     if (mask & KADM5_PRINC_EXPIRE_TIME)\n-        entry->princ_expire_time = kdb.expiration;\n+        entry->princ_expire_time = kdb->expiration;\n \n     if ((mask & KADM5_LAST_PWD_CHANGE) &&\n-        (ret = krb5_dbe_lookup_last_pwd_change(handle->context, &kdb,\n+        (ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                                &(entry->last_pwd_change)))) {\n         goto done;\n     }\n \n     if (mask & KADM5_PW_EXPIRATION)\n-        entry->pw_expiration = kdb.pw_expiration;\n+        entry->pw_expiration = kdb->pw_expiration;\n     if (mask & KADM5_MAX_LIFE)\n-        entry->max_life = kdb.max_life;\n+        entry->max_life = kdb->max_life;\n \n     /* this is a little non-sensical because the function returns two */\n     /* values that must be checked separately against the mask */\n     if ((mask & KADM5_MOD_NAME) || (mask & KADM5_MOD_TIME)) {\n-        ret = krb5_dbe_lookup_mod_princ_data(handle->context, &kdb,\n+        ret = krb5_dbe_lookup_mod_princ_data(handle->context, kdb,\n                                              &(entry->mod_date),\n                                              &(entry->mod_name));\n         if (ret) {\n@@ -864,34 +830,34 @@ kadm5_get_principal(void *server_handle, krb5_principal principal,\n     }\n \n     if (mask & KADM5_ATTRIBUTES)\n-        entry->attributes = kdb.attributes;\n+        entry->attributes = kdb->attributes;\n \n     if (mask & KADM5_KVNO)\n-        for (entry->kvno = 0, i=0; i<kdb.n_key_data; i++)\n-            if (kdb.key_data[i].key_data_kvno > entry->kvno)\n-                entry->kvno = kdb.key_data[i].key_data_kvno;\n+        for (entry->kvno = 0, i=0; i<kdb->n_key_data; i++)\n+            if (kdb->key_data[i].key_data_kvno > entry->kvno)\n+                entry->kvno = kdb->key_data[i].key_data_kvno;\n \n     if (mask & KADM5_MKVNO) {\n-        ret = krb5_dbe_get_mkvno(handle->context, &kdb, master_keylist,\n+        ret = krb5_dbe_get_mkvno(handle->context, kdb, master_keylist,\n                                  &entry->mkvno);\n         if (ret)\n             goto done;\n     }\n \n     if (mask & KADM5_MAX_RLIFE)\n-        entry->max_renewable_life = kdb.max_renewable_life;\n+        entry->max_renewable_life = kdb->max_renewable_life;\n     if (mask & KADM5_LAST_SUCCESS)\n-        entry->last_success = kdb.last_success;\n+        entry->last_success = kdb->last_success;\n     if (mask & KADM5_LAST_FAILED)\n-        entry->last_failed = kdb.last_failed;\n+        entry->last_failed = kdb->last_failed;\n     if (mask & KADM5_FAIL_AUTH_COUNT)\n-        entry->fail_auth_count = kdb.fail_auth_count;\n+        entry->fail_auth_count = kdb->fail_auth_count;\n     if (mask & KADM5_TL_DATA) {\n         krb5_tl_data *tl, *tl2;\n \n         entry->tl_data = NULL;\n \n-        tl = kdb.tl_data;\n+        tl = kdb->tl_data;\n         while (tl) {\n             if (tl->tl_data_type > 255) {\n                 if ((tl2 = dup_tl_data(tl)) == NULL) {\n@@ -907,7 +873,7 @@ kadm5_get_principal(void *server_handle, krb5_principal principal,\n         }\n     }\n     if (mask & KADM5_KEY_DATA) {\n-        entry->n_key_data = kdb.n_key_data;\n+        entry->n_key_data = kdb->n_key_data;\n         if(entry->n_key_data) {\n             entry->key_data = malloc(entry->n_key_data*sizeof(krb5_key_data));\n             if (entry->key_data == NULL) {\n@@ -919,7 +885,7 @@ kadm5_get_principal(void *server_handle, krb5_principal principal,\n \n         for (i = 0; i < entry->n_key_data; i++)\n             ret = krb5_copy_key_data_contents(handle->context,\n-                                              &kdb.key_data[i],\n+                                              &kdb->key_data[i],\n                                               &entry->key_data[i]);\n         if (ret)\n             goto done;\n@@ -932,7 +898,7 @@ done:\n         krb5_free_principal(handle->context, entry->principal);\n         entry->principal = NULL;\n     }\n-    kdb_free_entry(handle, &kdb, &adb);\n+    kdb_free_entry(handle, kdb, &adb);\n \n     return ret;\n }\n@@ -1338,7 +1304,7 @@ kadm5_chpass_principal_3(void *server_handle,\n     krb5_int32                  now;\n     kadm5_policy_ent_rec        pol;\n     osa_princ_ent_rec           adb;\n-    krb5_db_entry               kdb, kdb_save;\n+    krb5_db_entry               *kdb, *kdb_save;\n     int                         ret, ret2, last_pwd, hist_added;\n     int                         have_pol = 0;\n     kadm5_server_handle_t       handle = server_handle;\n@@ -1365,7 +1331,7 @@ kadm5_chpass_principal_3(void *server_handle,\n \n     /* we are going to need the current keys after the new keys are set */\n     if ((ret = kdb_get_entry(handle, principal, &kdb_save, NULL))) {\n-        kdb_free_entry(handle, &kdb, &adb);\n+        kdb_free_entry(handle, kdb, &adb);\n         return(ret);\n     }\n \n@@ -1388,15 +1354,15 @@ kadm5_chpass_principal_3(void *server_handle,\n                        n_ks_tuple?ks_tuple:handle->params.keysalts,\n                        n_ks_tuple?n_ks_tuple:handle->params.num_keysalts,\n                        password, 0 /* increment kvno */,\n-                       keepold, &kdb);\n+                       keepold, kdb);\n     if (ret)\n         goto done;\n \n-    ret = krb5_dbe_update_mkvno(handle->context, &kdb, act_kvno);\n+    ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);\n     if (ret)\n         goto done;\n \n-    kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n+    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n \n     ret = krb5_timeofday(handle->context, &now);\n     if (ret)\n@@ -1405,8 +1371,7 @@ kadm5_chpass_principal_3(void *server_handle,\n     if ((adb.aux_attributes & KADM5_POLICY)) {\n         /* the policy was loaded before */\n \n-        ret = krb5_dbe_lookup_last_pwd_change(handle->context,\n-                                              &kdb, &last_pwd);\n+        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n         if (ret)\n             goto done;\n \n@@ -1418,7 +1383,7 @@ kadm5_chpass_principal_3(void *server_handle,\n          * local caller implicitly has all authorization bits.\n          */\n         if ((now - last_pwd) < pol.pw_min_life &&\n-            !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n+            !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n             ret = KADM5_PASS_TOOSOON;\n             goto done;\n         }\n@@ -1430,13 +1395,13 @@ kadm5_chpass_principal_3(void *server_handle,\n \n         ret = create_history_entry(handle->context,\n                                    act_mkey, &hist_keyblock,\n-                                   kdb_save.n_key_data,\n-                                   kdb_save.key_data, &hist);\n+                                   kdb_save->n_key_data,\n+                                   kdb_save->key_data, &hist);\n         if (ret)\n             goto done;\n \n         ret = check_pw_reuse(handle->context, act_mkey, &hist_keyblock,\n-                             kdb.n_key_data, kdb.key_data,\n+                             kdb->n_key_data, kdb->key_data,\n                              1, &hist);\n         if (ret)\n             goto done;\n@@ -1446,7 +1411,7 @@ kadm5_chpass_principal_3(void *server_handle,\n              * can\'t check the history. */\n             if (adb.admin_history_kvno == hist_kvno) {\n                 ret = check_pw_reuse(handle->context, act_mkey, &hist_keyblock,\n-                                     kdb.n_key_data, kdb.key_data,\n+                                     kdb->n_key_data, kdb->key_data,\n                                      adb.old_key_len, adb.old_keys);\n                 if (ret)\n                     goto done;\n@@ -1460,11 +1425,11 @@ kadm5_chpass_principal_3(void *server_handle,\n         }\n \n         if (pol.pw_max_life)\n-            kdb.pw_expiration = now + pol.pw_max_life;\n+            kdb->pw_expiration = now + pol.pw_max_life;\n         else\n-            kdb.pw_expiration = 0;\n+            kdb->pw_expiration = 0;\n     } else {\n-        kdb.pw_expiration = 0;\n+        kdb->pw_expiration = 0;\n     }\n \n #ifdef USE_PASSWORD_SERVER\n@@ -1496,28 +1461,27 @@ kadm5_chpass_principal_3(void *server_handle,\n     }\n #endif\n \n-    ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);\n+    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n     if (ret)\n         goto done;\n \n     /* unlock principal on this KDC */\n-    kdb.fail_auth_count = 0;\n+    kdb->fail_auth_count = 0;\n \n     /* key data and attributes changed, let the database provider know */\n-    kdb.mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |\n+    kdb->mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |\n         KADM5_FAIL_AUTH_COUNT;\n     /* | KADM5_CPW_FUNCTION */\n \n-    if ((ret = kdb_put_entry(handle, &kdb, &adb)))\n+    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n         goto done;\n \n     ret = KADM5_OK;\n done:\n     if (!hist_added && hist.key_data)\n         free_history_entry(handle->context, &hist);\n-    kdb_free_entry(handle, &kdb, &adb);\n-    kdb_free_entry(handle, &kdb_save, NULL);\n-    krb5_db_free_principal(handle->context, &kdb, 1);\n+    kdb_free_entry(handle, kdb, &adb);\n+    kdb_free_entry(handle, kdb_save, NULL);\n     krb5_free_keyblock_contents(handle->context, &hist_keyblock);\n \n     if (have_pol && (ret2 = kadm5_free_policy_ent(handle->lhandle, &pol))\n@@ -1546,7 +1510,7 @@ kadm5_randkey_principal_3(void *server_handle,\n                           krb5_keyblock **keyblocks,\n                           int *n_keys)\n {\n-    krb5_db_entry               kdb;\n+    krb5_db_entry               *kdb;\n     osa_princ_ent_rec           adb;\n     krb5_int32                  now;\n     kadm5_policy_ent_rec        pol;\n@@ -1584,11 +1548,11 @@ kadm5_randkey_principal_3(void *server_handle,\n                        n_ks_tuple?ks_tuple:handle->params.keysalts,\n                        n_ks_tuple?n_ks_tuple:handle->params.num_keysalts,\n                        keepold,\n-                       &kdb);\n+                       kdb);\n     if (ret)\n         goto done;\n \n-    kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n+    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n \n     ret = krb5_timeofday(handle->context, &now);\n     if (ret)\n@@ -1600,8 +1564,7 @@ kadm5_randkey_principal_3(void *server_handle,\n             goto done;\n         have_pol = 1;\n \n-        ret = krb5_dbe_lookup_last_pwd_change(handle->context,\n-                                              &kdb, &last_pwd);\n+        ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);\n         if (ret)\n             goto done;\n \n@@ -1613,45 +1576,45 @@ kadm5_randkey_principal_3(void *server_handle,\n          * local caller implicitly has all authorization bits.\n          */\n         if((now - last_pwd) < pol.pw_min_life &&\n-           !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n+           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n             ret = KADM5_PASS_TOOSOON;\n             goto done;\n         }\n #endif\n \n         if (pol.pw_max_life)\n-            kdb.pw_expiration = now + pol.pw_max_life;\n+            kdb->pw_expiration = now + pol.pw_max_life;\n         else\n-            kdb.pw_expiration = 0;\n+            kdb->pw_expiration = 0;\n     } else {\n-        kdb.pw_expiration = 0;\n+        kdb->pw_expiration = 0;\n     }\n \n-    ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);\n+    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n     if (ret)\n         goto done;\n \n     /* unlock principal on this KDC */\n-    kdb.fail_auth_count = 0;\n+    kdb->fail_auth_count = 0;\n \n     if (keyblocks) {\n         ret = decrypt_key_data(handle->context, act_mkey,\n-                               kdb.n_key_data, kdb.key_data,\n+                               kdb->n_key_data, kdb->key_data,\n                                keyblocks, n_keys);\n         if (ret)\n             goto done;\n     }\n \n     /* key data changed, let the database provider know */\n-    kdb.mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n+    kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;\n     /* | KADM5_RANDKEY_USED */;\n \n-    if ((ret = kdb_put_entry(handle, &kdb, &adb)))\n+    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n         goto done;\n \n     ret = KADM5_OK;\n done:\n-    kdb_free_entry(handle, &kdb, &adb);\n+    kdb_free_entry(handle, kdb, &adb);\n     if (have_pol)\n         kadm5_free_policy_ent(handle->lhandle, &pol);\n \n@@ -1670,7 +1633,7 @@ kadm5_setv4key_principal(void *server_handle,\n                          krb5_principal principal,\n                          krb5_keyblock *keyblock)\n {\n-    krb5_db_entry               kdb;\n+    krb5_db_entry               *kdb;\n     osa_princ_ent_rec           adb;\n     krb5_int32                  now;\n     kadm5_policy_ent_rec        pol;\n@@ -1702,18 +1665,18 @@ kadm5_setv4key_principal(void *server_handle,\n     if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n         return(ret);\n \n-    for (kvno = 0, i=0; i<kdb.n_key_data; i++)\n-        if (kdb.key_data[i].key_data_kvno > kvno)\n-            kvno = kdb.key_data[i].key_data_kvno;\n+    for (kvno = 0, i=0; i<kdb->n_key_data; i++)\n+        if (kdb->key_data[i].key_data_kvno > kvno)\n+            kvno = kdb->key_data[i].key_data_kvno;\n \n-    if (kdb.key_data != NULL)\n-        cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);\n+    if (kdb->key_data != NULL)\n+        cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n \n-    kdb.key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, sizeof(krb5_key_data));\n-    if (kdb.key_data == NULL)\n+    kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, sizeof(krb5_key_data));\n+    if (kdb->key_data == NULL)\n         return ENOMEM;\n-    memset(kdb.key_data, 0, sizeof(krb5_key_data));\n-    kdb.n_key_data = 1;\n+    memset(kdb->key_data, 0, sizeof(krb5_key_data));\n+    kdb->n_key_data = 1;\n     keysalt.type = KRB5_KDB_SALTTYPE_V4;\n     /* XXX data.magic? */\n     keysalt.data.length = 0;\n@@ -1732,18 +1695,18 @@ kadm5_setv4key_principal(void *server_handle,\n     }\n \n     for (k = 0; k < tmp_key_data.key_data_ver; k++) {\n-        kdb.key_data->key_data_type[k] = tmp_key_data.key_data_type[k];\n-        kdb.key_data->key_data_length[k] = tmp_key_data.key_data_length[k];\n+        kdb->key_data->key_data_type[k] = tmp_key_data.key_data_type[k];\n+        kdb->key_data->key_data_length[k] = tmp_key_data.key_data_length[k];\n         if (tmp_key_data.key_data_contents[k]) {\n-            kdb.key_data->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);\n-            if (kdb.key_data->key_data_contents[k] == NULL) {\n-                cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);\n-                kdb.key_data = NULL;\n-                kdb.n_key_data = 0;\n+            kdb->key_data->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);\n+            if (kdb->key_data->key_data_contents[k] == NULL) {\n+                cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n+                kdb->key_data = NULL;\n+                kdb->n_key_data = 0;\n                 ret = ENOMEM;\n                 goto done;\n             }\n-            memcpy (kdb.key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);\n+            memcpy (kdb->key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);\n \n             memset (tmp_key_data.key_data_contents[k], 0, tmp_key_data.key_data_length[k]);\n             free (tmp_key_data.key_data_contents[k]);\n@@ -1753,7 +1716,7 @@ kadm5_setv4key_principal(void *server_handle,\n \n \n \n-    kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n+    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n \n     ret = krb5_timeofday(handle->context, &now);\n     if (ret)\n@@ -1773,31 +1736,31 @@ kadm5_setv4key_principal(void *server_handle,\n          * local caller implicitly has all authorization bits.\n          */\n         if (ret = krb5_dbe_lookup_last_pwd_change(handle->context,\n-                                                  &kdb, &last_pwd))\n+                                                  kdb, &last_pwd))\n             goto done;\n         if((now - last_pwd) < pol.pw_min_life &&\n-           !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n+           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n             ret = KADM5_PASS_TOOSOON;\n             goto done;\n         }\n #endif\n \n         if (pol.pw_max_life)\n-            kdb.pw_expiration = now + pol.pw_max_life;\n+            kdb->pw_expiration = now + pol.pw_max_life;\n         else\n-            kdb.pw_expiration = 0;\n+            kdb->pw_expiration = 0;\n     } else {\n-        kdb.pw_expiration = 0;\n+        kdb->pw_expiration = 0;\n     }\n \n-    ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);\n+    ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);\n     if (ret)\n         goto done;\n \n     /* unlock principal on this KDC */\n-    kdb.fail_auth_count = 0;\n+    kdb->fail_auth_count = 0;\n \n-    if ((ret = kdb_put_entry(handle, &kdb, &adb)))\n+    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n         goto done;\n \n     ret = KADM5_OK;\n@@ -1809,7 +1772,7 @@ done:\n         }\n     }\n \n-    kdb_free_entry(handle, &kdb, &adb);\n+    kdb_free_entry(handle, kdb, &adb);\n     if (have_pol)\n         kadm5_free_policy_ent(handle->lhandle, &pol);\n \n@@ -1836,7 +1799,7 @@ kadm5_setkey_principal_3(void *server_handle,\n                          krb5_keyblock *keyblocks,\n                          int n_keys)\n {\n-    krb5_db_entry               kdb;\n+    krb5_db_entry               *kdb;\n     osa_princ_ent_rec           adb;\n     krb5_int32                  now;\n     kadm5_policy_ent_rec        pol;\n@@ -1887,29 +1850,29 @@ kadm5_setkey_principal_3(void *server_handle,\n     if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n         return(ret);\n \n-    for (kvno = 0, i=0; i<kdb.n_key_data; i++)\n-        if (kdb.key_data[i].key_data_kvno > kvno)\n-            kvno = kdb.key_data[i].key_data_kvno;\n+    for (kvno = 0, i=0; i<kdb->n_key_data; i++)\n+        if (kdb->key_data[i].key_data_kvno > kvno)\n+            kvno = kdb->key_data[i].key_data_kvno;\n \n     if (keepold) {\n-        old_key_data = kdb.key_data;\n-        n_old_keys = kdb.n_key_data;\n+        old_key_data = kdb->key_data;\n+        n_old_keys = kdb->n_key_data;\n     } else {\n-        if (kdb.key_data != NULL)\n-            cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);\n+        if (kdb->key_data != NULL)\n+            cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);\n         n_old_keys = 0;\n         old_key_data = NULL;\n     }\n \n-    kdb.key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, (n_keys+n_old_keys)\n-                                                 *sizeof(krb5_key_data));\n-    if (kdb.key_data == NULL) {\n+    kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, (n_keys+n_old_keys)\n+                                                  *sizeof(krb5_key_data));\n+    if (kdb->key_data == NULL) {\n         ret = ENOMEM;\n         goto done;\n     }\n \n-    memset(kdb.key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));\n-    kdb.n_key_data = 0;\n+    memset(kdb->key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));\n+    kdb->n_key_data = 0;\n \n     for (i = 0; i < n_keys; i++) {\n         if (n_ks_tuple) {\n@@ -1935,7 +1898,7 @@ kadm5_setkey_principal_3(void *server_handle,\n         if (ret)\n             goto done;\n \n-        tptr = &kdb.key_data[i];\n+        tptr = &kdb->key_data[i];\n         tptr->key_data_ver = tmp_key_data.key_data_ver;\n         tptr->key_data_kvno = tmp_key_data.key_data_kvno;\n         for (k = 0; k < tmp_key_data.key_data_ver; k++) {\n@@ -1962,21 +1925,21 @@ kadm5_setkey_principal_3(void *server_handle,\n                 tmp_key_data.key_data_contents[k] = NULL;\n             }\n         }\n-        kdb.n_key_data++;\n+        kdb->n_key_data++;\n     }\n \n     /* copy old key data if necessary */\n     for (i = 0; i < n_old_keys; i++) {\n-        kdb.key_data[i+n_keys] = old_key_data[i];\n+        kdb->key_data[i+n_keys] = old_key_data[i];\n         memset(&old_key_data[i], 0, sizeof (krb5_key_data));\n-        kdb.n_key_data++;\n+        kdb->n_key_data++;\n     }\n \n     if (old_key_data)\n         krb5_db_free(handle->context, old_key_data);\n \n-    /* assert(kdb.n_key_data == n_keys + n_old_keys) */\n-    kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n+    /* assert(kdb->n_key_data == n_keys + n_old_keys) */\n+    kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;\n \n     if ((ret = krb5_timeofday(handle->context, &now)))\n         goto done;\n@@ -1995,35 +1958,35 @@ kadm5_setkey_principal_3(void *server_handle,\n          * local caller implicitly has all authorization bits.\n          */\n         if (ret = krb5_dbe_lookup_last_pwd_change(handle->context,\n-                                                  &kdb, &last_pwd))\n+                                                  kdb, &last_pwd))\n             goto done;\n         if((now - last_pwd) < pol.pw_min_life &&\n-           !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n+           !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {\n             ret = KADM5_PASS_TOOSOON;\n             goto done;\n         }\n #endif\n \n         if (pol.pw_max_life)\n-            kdb.pw_expiration = now + pol.pw_max_life;\n+            kdb->pw_expiration = now + pol.pw_max_life;\n         else\n-            kdb.pw_expiration = 0;\n+            kdb->pw_expiration = 0;\n     } else {\n-        kdb.pw_expiration = 0;\n+        kdb->pw_expiration = 0;\n     }\n \n-    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now)))\n+    if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))\n         goto done;\n \n     /* unlock principal on this KDC */\n-    kdb.fail_auth_count = 0;\n+    kdb->fail_auth_count = 0;\n \n-    if ((ret = kdb_put_entry(handle, &kdb, &adb)))\n+    if ((ret = kdb_put_entry(handle, kdb, &adb)))\n         goto done;\n \n     ret = KADM5_OK;\n done:\n-    kdb_free_entry(handle, &kdb, &adb);\n+    kdb_free_entry(handle, kdb, &adb);\n     if (have_pol)\n         kadm5_free_policy_ent(handle->lhandle, &pol);\n \n@@ -2040,7 +2003,7 @@ kadm5_get_principal_keys(void *server_handle /* IN */,\n                          krb5_keyblock **keyblocks /* OUT */,\n                          int *n_keys /* OUT */)\n {\n-    krb5_db_entry               kdb;\n+    krb5_db_entry               *kdb;\n     osa_princ_ent_rec           adb;\n     kadm5_ret_t                 ret;\n     kadm5_server_handle_t       handle = server_handle;\n@@ -2058,7 +2021,7 @@ kadm5_get_principal_keys(void *server_handle /* IN */,\n         return(ret);\n \n     if (keyblocks) {\n-        if ((ret = krb5_dbe_find_mkey(handle->context, master_keylist, &kdb,\n+        if ((ret = krb5_dbe_find_mkey(handle->context, master_keylist, kdb,\n                                       &mkey_ptr))) {\n             krb5_keylist_node *tmp_mkey_list;\n             /* try refreshing master key list */\n@@ -2069,7 +2032,7 @@ kadm5_get_principal_keys(void *server_handle /* IN */,\n                 krb5_dbe_free_key_list(handle->context, master_keylist);\n                 master_keylist = tmp_mkey_list;\n                 if ((ret = krb5_dbe_find_mkey(handle->context, master_keylist,\n-                                              &kdb, &mkey_ptr))) {\n+                                              kdb, &mkey_ptr))) {\n                     goto done;\n                 }\n             } else {\n@@ -2078,7 +2041,7 @@ kadm5_get_principal_keys(void *server_handle /* IN */,\n         }\n \n         ret = decrypt_key_data(handle->context, mkey_ptr,\n-                               kdb.n_key_data, kdb.key_data,\n+                               kdb->n_key_data, kdb->key_data,\n                                keyblocks, n_keys);\n         if (ret)\n             goto done;\n@@ -2086,7 +2049,7 @@ kadm5_get_principal_keys(void *server_handle /* IN */,\n \n     ret = KADM5_OK;\n done:\n-    kdb_free_entry(handle, &kdb, &adb);\n+    kdb_free_entry(handle, kdb, &adb);\n \n     return ret;\n }\n']",2010-07-06 21:53:23+00:00,"Remove count parameters from get_principal, put_principal,
free_principal, delete_principal, and get_policy.  Make get_principal
allocate the DB entry container.  Fold krb5_db_get_principal_ext into
krb5_db_get_principal.

ticket: 6749
status: open

git-svn-id: svn://anonsvn.mit.edu/krb5/trunk@24175 dc483132-0cff-0310-8789-dd5450dbe970","[['+     krb5_db_entry               *kdb;', '+     krb5_boolean                have_polent = FALSE;', '+         kdb_free_entry(handle, kdb, &adb);', '+     kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb));', '+     if (kdb == NULL)', '+         return ENOMEM;', '+     memset(kdb, 0, sizeof(*kdb));', '+             if (ret == EINVAL)', '+                 ret = KADM5_BAD_POLICY;', '+             if (ret)', '+                 goto cleanup;', '+         have_polent = TRUE;', '+         ret = passwd_check(handle, password, have_polent, &polent,', '+                            entry->principal);', '+         if (ret)', '+             goto cleanup;', '+     if ((ret = krb5_timeofday(handle->context, &now)))', '+         goto cleanup;', '+     kdb->magic = KRB5_KDB_MAGIC_NUMBER;', '+         kdb->attributes = entry->attributes;', '+         kdb->attributes = handle->params.flags;', '+         kdb->max_life = entry->max_life;', '+         kdb->max_life = handle->params.max_life;', '+         kdb->max_renewable_life = entry->max_renewable_life;', '+         kdb->max_renewable_life = handle->params.max_rlife;', '+         kdb->expiration = entry->princ_expire_time;', '+         kdb->expiration = handle->params.expiration;', '+     kdb->pw_expiration = 0;', '+     if (have_polent) {', '+             kdb->pw_expiration = now + polent.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = entry->pw_expiration;', '+     kdb->last_success = 0;', '+     kdb->last_failed = 0;', '+     kdb->fail_auth_count = 0;', '+                                     entry->principal, &(kdb->princ))))', '+         goto cleanup;', '+     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))', '+         goto cleanup;', '+         tl_data_orig = kdb->tl_data;', '+             ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);', '+                 goto cleanup;', '+     if (ret)', '+         goto cleanup;', '+                            FALSE, kdb);', '+                            FALSE, kdb);', '+     if (ret)', '+         goto cleanup;', '+     ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);', '+         goto cleanup;', '+     if (have_polent) {', '+     if (have_polent) {', '+             != KADM5_OK)', '+             goto cleanup;', '+     kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;', '+     ret = kdb_put_entry(handle, kdb, &adb);', '+         if (have_polent) {', '+ cleanup:', '+     krb5_db_free_principal(handle->context, kdb);', '+     if (have_polent)', '+     return ret;', '+     krb5_db_entry               *kdb;', '+                 kdb_free_entry(handle, kdb, &adb);', '+             kdb_free_entry(handle, kdb, &adb);', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry           *kdb;', '+             ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,', '+                                                   &(kdb->pw_expiration));', '+             kdb->pw_expiration += npol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+             kdb->pw_expiration = 0;', '+         kdb->attributes = entry->attributes;', '+         kdb->max_life = entry->max_life;', '+         kdb->expiration = entry->princ_expire_time;', '+         kdb->pw_expiration = entry->pw_expiration;', '+         kdb->max_renewable_life = entry->max_renewable_life;', '+         for (i = 0; i < kdb->n_key_data; i++)', '+             kdb->key_data[i].key_data_kvno = entry->kvno;', '+             ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);', '+         kdb->fail_auth_count = 0;', '+     kdb->mask = mask;', '+     ret = kdb_put_entry(handle, kdb, &adb);', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry       *kdb;', '+         kdb_free_entry(handle, kdb, &adb);', '+     for (i=0; i<kdb->n_key_data; i++) {', '+         if ((kdb->key_data[i].key_data_ver == 1) ||', '+             (kdb->key_data[i].key_data_type[1] == KRB5_KDB_SALTTYPE_NORMAL)) {', '+     kadm5_free_principal(handle->context, kdb->princ);', '+     ret = kadm5_copy_principal(handle->context, target, &kdb->princ);', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+         (ret = krb5_copy_principal(handle->context, kdb->princ,', '+         entry->princ_expire_time = kdb->expiration;', '+         (ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,', '+         entry->pw_expiration = kdb->pw_expiration;', '+         entry->max_life = kdb->max_life;', '+         ret = krb5_dbe_lookup_mod_princ_data(handle->context, kdb,', '+         entry->attributes = kdb->attributes;', '+         for (entry->kvno = 0, i=0; i<kdb->n_key_data; i++)', '+             if (kdb->key_data[i].key_data_kvno > entry->kvno)', '+                 entry->kvno = kdb->key_data[i].key_data_kvno;', '+         ret = krb5_dbe_get_mkvno(handle->context, kdb, master_keylist,', '+         entry->max_renewable_life = kdb->max_renewable_life;', '+         entry->last_success = kdb->last_success;', '+         entry->last_failed = kdb->last_failed;', '+         entry->fail_auth_count = kdb->fail_auth_count;', '+         tl = kdb->tl_data;', '+         entry->n_key_data = kdb->n_key_data;', '+                                               &kdb->key_data[i],', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb, *kdb_save;', '+         kdb_free_entry(handle, kdb, &adb);', '+                        keepold, kdb);', '+     ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);', '+     kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '+         ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);', '+             !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '+                                    kdb_save->n_key_data,', '+                                    kdb_save->key_data, &hist);', '+                              kdb->n_key_data, kdb->key_data,', '+                                      kdb->n_key_data, kdb->key_data,', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);', '+     kdb->fail_auth_count = 0;', '+     kdb->mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     kdb_free_entry(handle, kdb_save, NULL);', '+     krb5_db_entry               *kdb;', '+                        kdb);', '+     kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '+         ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);', '+            !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);', '+     kdb->fail_auth_count = 0;', '+                                kdb->n_key_data, kdb->key_data,', '+     kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+     for (kvno = 0, i=0; i<kdb->n_key_data; i++)', '+         if (kdb->key_data[i].key_data_kvno > kvno)', '+             kvno = kdb->key_data[i].key_data_kvno;', '+     if (kdb->key_data != NULL)', '+         cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);', '+     kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, sizeof(krb5_key_data));', '+     if (kdb->key_data == NULL)', '+     memset(kdb->key_data, 0, sizeof(krb5_key_data));', '+     kdb->n_key_data = 1;', '+         kdb->key_data->key_data_type[k] = tmp_key_data.key_data_type[k];', '+         kdb->key_data->key_data_length[k] = tmp_key_data.key_data_length[k];', '+             kdb->key_data->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);', '+             if (kdb->key_data->key_data_contents[k] == NULL) {', '+                 cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);', '+                 kdb->key_data = NULL;', '+                 kdb->n_key_data = 0;', '+             memcpy (kdb->key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);', '+     kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '+                                                   kdb, &last_pwd))', '+            !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);', '+     kdb->fail_auth_count = 0;', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+     for (kvno = 0, i=0; i<kdb->n_key_data; i++)', '+         if (kdb->key_data[i].key_data_kvno > kvno)', '+             kvno = kdb->key_data[i].key_data_kvno;', '+         old_key_data = kdb->key_data;', '+         n_old_keys = kdb->n_key_data;', '+         if (kdb->key_data != NULL)', '+             cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);', '+     kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, (n_keys+n_old_keys)', '+                                                   *sizeof(krb5_key_data));', '+     if (kdb->key_data == NULL) {', '+     memset(kdb->key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));', '+     kdb->n_key_data = 0;', '+         tptr = &kdb->key_data[i];', '+         kdb->n_key_data++;', '+         kdb->key_data[i+n_keys] = old_key_data[i];', '+         kdb->n_key_data++;', '+     kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '+                                                   kdb, &last_pwd))', '+            !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))', '+     kdb->fail_auth_count = 0;', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+         if ((ret = krb5_dbe_find_mkey(handle->context, master_keylist, kdb,', '+                                               kdb, &mkey_ptr))) {', '+                                kdb->n_key_data, kdb->key_data,', '+     kdb_free_entry(handle, kdb, &adb);', '-     krb5_db_entry               kdb;', '-         kdb_free_entry(handle, &kdb, &adb);', '-     memset(&kdb, 0, sizeof(krb5_db_entry));', '-             if(ret == EINVAL)', '-                 return KADM5_BAD_POLICY;', '-             else', '-                 return ret;', '-         ret = passwd_check(handle, password, (mask & KADM5_POLICY),', '-                            &polent, entry->principal);', '-         if (ret) {', '-             if (mask & KADM5_POLICY)', '-                 (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-             return ret;', '-         }', '-     if ((ret = krb5_timeofday(handle->context, &now))) {', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return ret;', '-     }', '-     kdb.magic = KRB5_KDB_MAGIC_NUMBER;', '-         kdb.attributes = entry->attributes;', '-         kdb.attributes = handle->params.flags;', '-         kdb.max_life = entry->max_life;', '-         kdb.max_life = handle->params.max_life;', '-         kdb.max_renewable_life = entry->max_renewable_life;', '-         kdb.max_renewable_life = handle->params.max_rlife;', '-         kdb.expiration = entry->princ_expire_time;', '-         kdb.expiration = handle->params.expiration;', '-     kdb.pw_expiration = 0;', '-     if ((mask & KADM5_POLICY)) {', '-             kdb.pw_expiration = now + polent.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = entry->pw_expiration;', '-     kdb.last_success = 0;', '-     kdb.last_failed = 0;', '-     kdb.fail_auth_count = 0;', '-                                     entry->principal, &(kdb.princ)))) {', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     }', '-     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now))) {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     }', '-         tl_data_orig = kdb.tl_data;', '-             ret = krb5_dbe_update_tl_data(handle->context, &kdb, tl_data_tail);', '-             {', '-                 krb5_db_free_principal(handle->context, &kdb, 1);', '-                 if (mask & KADM5_POLICY)', '-                     (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-                 return ret;', '-             }', '-     if (ret) {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return (ret);', '-     }', '-                            FALSE, &kdb);', '-                            FALSE, &kdb);', '-     }', '-     if (ret) {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     ret = krb5_dbe_update_mkvno(handle->context, &kdb, act_kvno);', '-     {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return ret;', '-     }', '-     if ((mask & KADM5_POLICY)) {', '-     if ((mask & KADM5_POLICY)) {', '-             != KADM5_OK) {', '-             krb5_db_free_principal(handle->context, &kdb, 1);', '-             if (mask & KADM5_POLICY)', '-                 (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-             return(ret);', '-         }', '-     kdb.mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;', '-     ret = kdb_put_entry(handle, &kdb, &adb);', '-     krb5_db_free_principal(handle->context, &kdb, 1);', '-         if ((mask & KADM5_POLICY)) {', '- ', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     if (mask & KADM5_POLICY)', '- ', '-     return KADM5_OK;', '-     krb5_db_entry               kdb;', '-                 kdb_free_entry(handle, &kdb, &adb);', '-             kdb_free_entry(handle, &kdb, &adb);', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry           kdb;', '-             ret = krb5_dbe_lookup_last_pwd_change(handle->context, &kdb,', '-                                                   &(kdb.pw_expiration));', '-             kdb.pw_expiration += npol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-             kdb.pw_expiration = 0;', '-         kdb.attributes = entry->attributes;', '-         kdb.max_life = entry->max_life;', '-         kdb.expiration = entry->princ_expire_time;', '-         kdb.pw_expiration = entry->pw_expiration;', '-         kdb.max_renewable_life = entry->max_renewable_life;', '-         for (i = 0; i < kdb.n_key_data; i++)', '-             kdb.key_data[i].key_data_kvno = entry->kvno;', '-             ret = krb5_dbe_update_tl_data(handle->context, &kdb, tl);', '-         kdb.fail_auth_count = 0;', '-     kdb.mask = mask;', '-     ret = kdb_put_entry(handle, &kdb, &adb);', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry       kdb;', '-         kdb_free_entry(handle, &kdb, &adb);', '-     for (i=0; i<kdb.n_key_data; i++) {', '-         if ((kdb.key_data[i].key_data_ver == 1) ||', '-             (kdb.key_data[i].key_data_type[1] == KRB5_KDB_SALTTYPE_NORMAL)) {', '-     kadm5_free_principal(handle->context, kdb.princ);', '-     ret = kadm5_copy_principal(handle->context, target, &kdb.princ);', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-         (ret = krb5_copy_principal(handle->context, kdb.princ,', '-         entry->princ_expire_time = kdb.expiration;', '-         (ret = krb5_dbe_lookup_last_pwd_change(handle->context, &kdb,', '-         entry->pw_expiration = kdb.pw_expiration;', '-         entry->max_life = kdb.max_life;', '-         ret = krb5_dbe_lookup_mod_princ_data(handle->context, &kdb,', '-         entry->attributes = kdb.attributes;', '-         for (entry->kvno = 0, i=0; i<kdb.n_key_data; i++)', '-             if (kdb.key_data[i].key_data_kvno > entry->kvno)', '-                 entry->kvno = kdb.key_data[i].key_data_kvno;', '-         ret = krb5_dbe_get_mkvno(handle->context, &kdb, master_keylist,', '-         entry->max_renewable_life = kdb.max_renewable_life;', '-         entry->last_success = kdb.last_success;', '-         entry->last_failed = kdb.last_failed;', '-         entry->fail_auth_count = kdb.fail_auth_count;', '-         tl = kdb.tl_data;', '-         entry->n_key_data = kdb.n_key_data;', '-                                               &kdb.key_data[i],', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb, kdb_save;', '-         kdb_free_entry(handle, &kdb, &adb);', '-                        keepold, &kdb);', '-     ret = krb5_dbe_update_mkvno(handle->context, &kdb, act_kvno);', '-     kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '-         ret = krb5_dbe_lookup_last_pwd_change(handle->context,', '-                                               &kdb, &last_pwd);', '-             !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '-                                    kdb_save.n_key_data,', '-                                    kdb_save.key_data, &hist);', '-                              kdb.n_key_data, kdb.key_data,', '-                                      kdb.n_key_data, kdb.key_data,', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);', '-     kdb.fail_auth_count = 0;', '-     kdb.mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     kdb_free_entry(handle, &kdb_save, NULL);', '-     krb5_db_free_principal(handle->context, &kdb, 1);', '-     krb5_db_entry               kdb;', '-                        &kdb);', '-     kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '-         ret = krb5_dbe_lookup_last_pwd_change(handle->context,', '-                                               &kdb, &last_pwd);', '-            !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);', '-     kdb.fail_auth_count = 0;', '-                                kdb.n_key_data, kdb.key_data,', '-     kdb.mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-     for (kvno = 0, i=0; i<kdb.n_key_data; i++)', '-         if (kdb.key_data[i].key_data_kvno > kvno)', '-             kvno = kdb.key_data[i].key_data_kvno;', '-     if (kdb.key_data != NULL)', '-         cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);', '-     kdb.key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, sizeof(krb5_key_data));', '-     if (kdb.key_data == NULL)', '-     memset(kdb.key_data, 0, sizeof(krb5_key_data));', '-     kdb.n_key_data = 1;', '-         kdb.key_data->key_data_type[k] = tmp_key_data.key_data_type[k];', '-         kdb.key_data->key_data_length[k] = tmp_key_data.key_data_length[k];', '-             kdb.key_data->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);', '-             if (kdb.key_data->key_data_contents[k] == NULL) {', '-                 cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);', '-                 kdb.key_data = NULL;', '-                 kdb.n_key_data = 0;', '-             memcpy (kdb.key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);', '-     kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '-                                                   &kdb, &last_pwd))', '-            !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);', '-     kdb.fail_auth_count = 0;', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-     for (kvno = 0, i=0; i<kdb.n_key_data; i++)', '-         if (kdb.key_data[i].key_data_kvno > kvno)', '-             kvno = kdb.key_data[i].key_data_kvno;', '-         old_key_data = kdb.key_data;', '-         n_old_keys = kdb.n_key_data;', '-         if (kdb.key_data != NULL)', '-             cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);', '-     kdb.key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, (n_keys+n_old_keys)', '-                                                  *sizeof(krb5_key_data));', '-     if (kdb.key_data == NULL) {', '-     memset(kdb.key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));', '-     kdb.n_key_data = 0;', '-         tptr = &kdb.key_data[i];', '-         kdb.n_key_data++;', '-         kdb.key_data[i+n_keys] = old_key_data[i];', '-         kdb.n_key_data++;', '-     kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '-                                                   &kdb, &last_pwd))', '-            !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now)))', '-     kdb.fail_auth_count = 0;', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-         if ((ret = krb5_dbe_find_mkey(handle->context, master_keylist, &kdb,', '-                                               &kdb, &mkey_ptr))) {', '-                                kdb.n_key_data, kdb.key_data,', '-     kdb_free_entry(handle, &kdb, &adb);']]","[['+     krb5_db_entry               *kdb;', '+     krb5_boolean                have_polent = false;', '+         kdb_free_entry(handle, kdb, &adb);', '+     kdb = krb5_db_alloc(handle->context, null, sizeof(*kdb));', '+     if (kdb == null)', '+         return enomem;', '+     memset(kdb, 0, sizeof(*kdb));', '+             if (ret == einval)', '+                 ret = kadm5_bad_policy;', '+             if (ret)', '+                 goto cleanup;', '+         have_polent = true;', '+         ret = passwd_check(handle, password, have_polent, &polent,', '+                            entry->principal);', '+         if (ret)', '+             goto cleanup;', '+     if ((ret = krb5_timeofday(handle->context, &now)))', '+         goto cleanup;', '+     kdb->magic = krb5_kdb_magic_number;', '+         kdb->attributes = entry->attributes;', '+         kdb->attributes = handle->params.flags;', '+         kdb->max_life = entry->max_life;', '+         kdb->max_life = handle->params.max_life;', '+         kdb->max_renewable_life = entry->max_renewable_life;', '+         kdb->max_renewable_life = handle->params.max_rlife;', '+         kdb->expiration = entry->princ_expire_time;', '+         kdb->expiration = handle->params.expiration;', '+     kdb->pw_expiration = 0;', '+     if (have_polent) {', '+             kdb->pw_expiration = now + polent.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = entry->pw_expiration;', '+     kdb->last_success = 0;', '+     kdb->last_failed = 0;', '+     kdb->fail_auth_count = 0;', '+                                     entry->principal, &(kdb->princ))))', '+         goto cleanup;', '+     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))', '+         goto cleanup;', '+         tl_data_orig = kdb->tl_data;', '+             ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);', '+                 goto cleanup;', '+     if (ret)', '+         goto cleanup;', '+                            false, kdb);', '+                            false, kdb);', '+     if (ret)', '+         goto cleanup;', '+     ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);', '+         goto cleanup;', '+     if (have_polent) {', '+     if (have_polent) {', '+             != kadm5_ok)', '+             goto cleanup;', '+     kdb->mask = mask | kadm5_key_data | kadm5_principal ;', '+     ret = kdb_put_entry(handle, kdb, &adb);', '+         if (have_polent) {', '+ cleanup:', '+     krb5_db_free_principal(handle->context, kdb);', '+     if (have_polent)', '+     return ret;', '+     krb5_db_entry               *kdb;', '+                 kdb_free_entry(handle, kdb, &adb);', '+             kdb_free_entry(handle, kdb, &adb);', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry           *kdb;', '+             ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,', '+                                                   &(kdb->pw_expiration));', '+             kdb->pw_expiration += npol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+             kdb->pw_expiration = 0;', '+         kdb->attributes = entry->attributes;', '+         kdb->max_life = entry->max_life;', '+         kdb->expiration = entry->princ_expire_time;', '+         kdb->pw_expiration = entry->pw_expiration;', '+         kdb->max_renewable_life = entry->max_renewable_life;', '+         for (i = 0; i < kdb->n_key_data; i++)', '+             kdb->key_data[i].key_data_kvno = entry->kvno;', '+             ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);', '+         kdb->fail_auth_count = 0;', '+     kdb->mask = mask;', '+     ret = kdb_put_entry(handle, kdb, &adb);', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry       *kdb;', '+         kdb_free_entry(handle, kdb, &adb);', '+     for (i=0; i<kdb->n_key_data; i++) {', '+         if ((kdb->key_data[i].key_data_ver == 1) ||', '+             (kdb->key_data[i].key_data_type[1] == krb5_kdb_salttype_normal)) {', '+     kadm5_free_principal(handle->context, kdb->princ);', '+     ret = kadm5_copy_principal(handle->context, target, &kdb->princ);', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+         (ret = krb5_copy_principal(handle->context, kdb->princ,', '+         entry->princ_expire_time = kdb->expiration;', '+         (ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,', '+         entry->pw_expiration = kdb->pw_expiration;', '+         entry->max_life = kdb->max_life;', '+         ret = krb5_dbe_lookup_mod_princ_data(handle->context, kdb,', '+         entry->attributes = kdb->attributes;', '+         for (entry->kvno = 0, i=0; i<kdb->n_key_data; i++)', '+             if (kdb->key_data[i].key_data_kvno > entry->kvno)', '+                 entry->kvno = kdb->key_data[i].key_data_kvno;', '+         ret = krb5_dbe_get_mkvno(handle->context, kdb, master_keylist,', '+         entry->max_renewable_life = kdb->max_renewable_life;', '+         entry->last_success = kdb->last_success;', '+         entry->last_failed = kdb->last_failed;', '+         entry->fail_auth_count = kdb->fail_auth_count;', '+         tl = kdb->tl_data;', '+         entry->n_key_data = kdb->n_key_data;', '+                                               &kdb->key_data[i],', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb, *kdb_save;', '+         kdb_free_entry(handle, kdb, &adb);', '+                        keepold, kdb);', '+     ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);', '+     kdb->attributes &= ~krb5_kdb_requires_pwchange;', '+         ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);', '+             !(kdb->attributes & krb5_kdb_requires_pwchange)) {', '+                                    kdb_save->n_key_data,', '+                                    kdb_save->key_data, &hist);', '+                              kdb->n_key_data, kdb->key_data,', '+                                      kdb->n_key_data, kdb->key_data,', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);', '+     kdb->fail_auth_count = 0;', '+     kdb->mask = kadm5_key_data | kadm5_attributes |', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     kdb_free_entry(handle, kdb_save, null);', '+     krb5_db_entry               *kdb;', '+                        kdb);', '+     kdb->attributes &= ~krb5_kdb_requires_pwchange;', '+         ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);', '+            !(kdb->attributes & krb5_kdb_requires_pwchange)) {', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);', '+     kdb->fail_auth_count = 0;', '+                                kdb->n_key_data, kdb->key_data,', '+     kdb->mask = kadm5_key_data | kadm5_fail_auth_count;', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+     for (kvno = 0, i=0; i<kdb->n_key_data; i++)', '+         if (kdb->key_data[i].key_data_kvno > kvno)', '+             kvno = kdb->key_data[i].key_data_kvno;', '+     if (kdb->key_data != null)', '+         cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);', '+     kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, null, sizeof(krb5_key_data));', '+     if (kdb->key_data == null)', '+     memset(kdb->key_data, 0, sizeof(krb5_key_data));', '+     kdb->n_key_data = 1;', '+         kdb->key_data->key_data_type[k] = tmp_key_data.key_data_type[k];', '+         kdb->key_data->key_data_length[k] = tmp_key_data.key_data_length[k];', '+             kdb->key_data->key_data_contents[k] = krb5_db_alloc(handle->context, null, tmp_key_data.key_data_length[k]);', '+             if (kdb->key_data->key_data_contents[k] == null) {', '+                 cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);', '+                 kdb->key_data = null;', '+                 kdb->n_key_data = 0;', '+             memcpy (kdb->key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);', '+     kdb->attributes &= ~krb5_kdb_requires_pwchange;', '+                                                   kdb, &last_pwd))', '+            !(kdb->attributes & krb5_kdb_requires_pwchange)) {', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);', '+     kdb->fail_auth_count = 0;', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+     for (kvno = 0, i=0; i<kdb->n_key_data; i++)', '+         if (kdb->key_data[i].key_data_kvno > kvno)', '+             kvno = kdb->key_data[i].key_data_kvno;', '+         old_key_data = kdb->key_data;', '+         n_old_keys = kdb->n_key_data;', '+         if (kdb->key_data != null)', '+             cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);', '+     kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, null, (n_keys+n_old_keys)', '+                                                   *sizeof(krb5_key_data));', '+     if (kdb->key_data == null) {', '+     memset(kdb->key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));', '+     kdb->n_key_data = 0;', '+         tptr = &kdb->key_data[i];', '+         kdb->n_key_data++;', '+         kdb->key_data[i+n_keys] = old_key_data[i];', '+         kdb->n_key_data++;', '+     kdb->attributes &= ~krb5_kdb_requires_pwchange;', '+                                                   kdb, &last_pwd))', '+            !(kdb->attributes & krb5_kdb_requires_pwchange)) {', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))', '+     kdb->fail_auth_count = 0;', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+         if ((ret = krb5_dbe_find_mkey(handle->context, master_keylist, kdb,', '+                                               kdb, &mkey_ptr))) {', '+                                kdb->n_key_data, kdb->key_data,', '+     kdb_free_entry(handle, kdb, &adb);', '-     krb5_db_entry               kdb;', '-         kdb_free_entry(handle, &kdb, &adb);', '-     memset(&kdb, 0, sizeof(krb5_db_entry));', '-             if(ret == einval)', '-                 return kadm5_bad_policy;', '-             else', '-                 return ret;', '-         ret = passwd_check(handle, password, (mask & kadm5_policy),', '-                            &polent, entry->principal);', '-         if (ret) {', '-             if (mask & kadm5_policy)', '-                 (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-             return ret;', '-         }', '-     if ((ret = krb5_timeofday(handle->context, &now))) {', '-         if (mask & kadm5_policy)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return ret;', '-     }', '-     kdb.magic = krb5_kdb_magic_number;', '-         kdb.attributes = entry->attributes;', '-         kdb.attributes = handle->params.flags;', '-         kdb.max_life = entry->max_life;', '-         kdb.max_life = handle->params.max_life;', '-         kdb.max_renewable_life = entry->max_renewable_life;', '-         kdb.max_renewable_life = handle->params.max_rlife;', '-         kdb.expiration = entry->princ_expire_time;', '-         kdb.expiration = handle->params.expiration;', '-     kdb.pw_expiration = 0;', '-     if ((mask & kadm5_policy)) {', '-             kdb.pw_expiration = now + polent.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = entry->pw_expiration;', '-     kdb.last_success = 0;', '-     kdb.last_failed = 0;', '-     kdb.fail_auth_count = 0;', '-                                     entry->principal, &(kdb.princ)))) {', '-         if (mask & kadm5_policy)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     }', '-     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now))) {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & kadm5_policy)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     }', '-         tl_data_orig = kdb.tl_data;', '-             ret = krb5_dbe_update_tl_data(handle->context, &kdb, tl_data_tail);', '-             {', '-                 krb5_db_free_principal(handle->context, &kdb, 1);', '-                 if (mask & kadm5_policy)', '-                     (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-                 return ret;', '-             }', '-     if (ret) {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & kadm5_policy)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return (ret);', '-     }', '-                            false, &kdb);', '-                            false, &kdb);', '-     }', '-     if (ret) {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & kadm5_policy)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     ret = krb5_dbe_update_mkvno(handle->context, &kdb, act_kvno);', '-     {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & kadm5_policy)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return ret;', '-     }', '-     if ((mask & kadm5_policy)) {', '-     if ((mask & kadm5_policy)) {', '-             != kadm5_ok) {', '-             krb5_db_free_principal(handle->context, &kdb, 1);', '-             if (mask & kadm5_policy)', '-                 (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-             return(ret);', '-         }', '-     kdb.mask = mask | kadm5_key_data | kadm5_principal ;', '-     ret = kdb_put_entry(handle, &kdb, &adb);', '-     krb5_db_free_principal(handle->context, &kdb, 1);', '-         if ((mask & kadm5_policy)) {', '- ', '-         if (mask & kadm5_policy)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     if (mask & kadm5_policy)', '- ', '-     return kadm5_ok;', '-     krb5_db_entry               kdb;', '-                 kdb_free_entry(handle, &kdb, &adb);', '-             kdb_free_entry(handle, &kdb, &adb);', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry           kdb;', '-             ret = krb5_dbe_lookup_last_pwd_change(handle->context, &kdb,', '-                                                   &(kdb.pw_expiration));', '-             kdb.pw_expiration += npol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-             kdb.pw_expiration = 0;', '-         kdb.attributes = entry->attributes;', '-         kdb.max_life = entry->max_life;', '-         kdb.expiration = entry->princ_expire_time;', '-         kdb.pw_expiration = entry->pw_expiration;', '-         kdb.max_renewable_life = entry->max_renewable_life;', '-         for (i = 0; i < kdb.n_key_data; i++)', '-             kdb.key_data[i].key_data_kvno = entry->kvno;', '-             ret = krb5_dbe_update_tl_data(handle->context, &kdb, tl);', '-         kdb.fail_auth_count = 0;', '-     kdb.mask = mask;', '-     ret = kdb_put_entry(handle, &kdb, &adb);', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry       kdb;', '-         kdb_free_entry(handle, &kdb, &adb);', '-     for (i=0; i<kdb.n_key_data; i++) {', '-         if ((kdb.key_data[i].key_data_ver == 1) ||', '-             (kdb.key_data[i].key_data_type[1] == krb5_kdb_salttype_normal)) {', '-     kadm5_free_principal(handle->context, kdb.princ);', '-     ret = kadm5_copy_principal(handle->context, target, &kdb.princ);', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-         (ret = krb5_copy_principal(handle->context, kdb.princ,', '-         entry->princ_expire_time = kdb.expiration;', '-         (ret = krb5_dbe_lookup_last_pwd_change(handle->context, &kdb,', '-         entry->pw_expiration = kdb.pw_expiration;', '-         entry->max_life = kdb.max_life;', '-         ret = krb5_dbe_lookup_mod_princ_data(handle->context, &kdb,', '-         entry->attributes = kdb.attributes;', '-         for (entry->kvno = 0, i=0; i<kdb.n_key_data; i++)', '-             if (kdb.key_data[i].key_data_kvno > entry->kvno)', '-                 entry->kvno = kdb.key_data[i].key_data_kvno;', '-         ret = krb5_dbe_get_mkvno(handle->context, &kdb, master_keylist,', '-         entry->max_renewable_life = kdb.max_renewable_life;', '-         entry->last_success = kdb.last_success;', '-         entry->last_failed = kdb.last_failed;', '-         entry->fail_auth_count = kdb.fail_auth_count;', '-         tl = kdb.tl_data;', '-         entry->n_key_data = kdb.n_key_data;', '-                                               &kdb.key_data[i],', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb, kdb_save;', '-         kdb_free_entry(handle, &kdb, &adb);', '-                        keepold, &kdb);', '-     ret = krb5_dbe_update_mkvno(handle->context, &kdb, act_kvno);', '-     kdb.attributes &= ~krb5_kdb_requires_pwchange;', '-         ret = krb5_dbe_lookup_last_pwd_change(handle->context,', '-                                               &kdb, &last_pwd);', '-             !(kdb.attributes & krb5_kdb_requires_pwchange)) {', '-                                    kdb_save.n_key_data,', '-                                    kdb_save.key_data, &hist);', '-                              kdb.n_key_data, kdb.key_data,', '-                                      kdb.n_key_data, kdb.key_data,', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);', '-     kdb.fail_auth_count = 0;', '-     kdb.mask = kadm5_key_data | kadm5_attributes |', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     kdb_free_entry(handle, &kdb_save, null);', '-     krb5_db_free_principal(handle->context, &kdb, 1);', '-     krb5_db_entry               kdb;', '-                        &kdb);', '-     kdb.attributes &= ~krb5_kdb_requires_pwchange;', '-         ret = krb5_dbe_lookup_last_pwd_change(handle->context,', '-                                               &kdb, &last_pwd);', '-            !(kdb.attributes & krb5_kdb_requires_pwchange)) {', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);', '-     kdb.fail_auth_count = 0;', '-                                kdb.n_key_data, kdb.key_data,', '-     kdb.mask = kadm5_key_data | kadm5_fail_auth_count;', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-     for (kvno = 0, i=0; i<kdb.n_key_data; i++)', '-         if (kdb.key_data[i].key_data_kvno > kvno)', '-             kvno = kdb.key_data[i].key_data_kvno;', '-     if (kdb.key_data != null)', '-         cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);', '-     kdb.key_data = (krb5_key_data*)krb5_db_alloc(handle->context, null, sizeof(krb5_key_data));', '-     if (kdb.key_data == null)', '-     memset(kdb.key_data, 0, sizeof(krb5_key_data));', '-     kdb.n_key_data = 1;', '-         kdb.key_data->key_data_type[k] = tmp_key_data.key_data_type[k];', '-         kdb.key_data->key_data_length[k] = tmp_key_data.key_data_length[k];', '-             kdb.key_data->key_data_contents[k] = krb5_db_alloc(handle->context, null, tmp_key_data.key_data_length[k]);', '-             if (kdb.key_data->key_data_contents[k] == null) {', '-                 cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);', '-                 kdb.key_data = null;', '-                 kdb.n_key_data = 0;', '-             memcpy (kdb.key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);', '-     kdb.attributes &= ~krb5_kdb_requires_pwchange;', '-                                                   &kdb, &last_pwd))', '-            !(kdb.attributes & krb5_kdb_requires_pwchange)) {', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);', '-     kdb.fail_auth_count = 0;', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-     for (kvno = 0, i=0; i<kdb.n_key_data; i++)', '-         if (kdb.key_data[i].key_data_kvno > kvno)', '-             kvno = kdb.key_data[i].key_data_kvno;', '-         old_key_data = kdb.key_data;', '-         n_old_keys = kdb.n_key_data;', '-         if (kdb.key_data != null)', '-             cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);', '-     kdb.key_data = (krb5_key_data*)krb5_db_alloc(handle->context, null, (n_keys+n_old_keys)', '-                                                  *sizeof(krb5_key_data));', '-     if (kdb.key_data == null) {', '-     memset(kdb.key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));', '-     kdb.n_key_data = 0;', '-         tptr = &kdb.key_data[i];', '-         kdb.n_key_data++;', '-         kdb.key_data[i+n_keys] = old_key_data[i];', '-         kdb.n_key_data++;', '-     kdb.attributes &= ~krb5_kdb_requires_pwchange;', '-                                                   &kdb, &last_pwd))', '-            !(kdb.attributes & krb5_kdb_requires_pwchange)) {', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now)))', '-     kdb.fail_auth_count = 0;', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-         if ((ret = krb5_dbe_find_mkey(handle->context, master_keylist, &kdb,', '-                                               &kdb, &mkey_ptr))) {', '-                                kdb.n_key_data, kdb.key_data,', '-     kdb_free_entry(handle, &kdb, &adb);']]","[['+     krb5_db_entry               *kdb;', '+     krb5_boolean                have_polent = FALSE;', '+         kdb_free_entry(handle, kdb, &adb);', '+     kdb = krb5_db_alloc(handle->context, NULL, sizeof(*kdb));', '+     if (kdb == NULL)', '+         return ENOMEM;', '+     memset(kdb, 0, sizeof(*kdb));', '+             if (ret == EINVAL)', '+                 ret = KADM5_BAD_POLICY;', '+             if (ret)', '+                 goto cleanup;', '+         have_polent = TRUE;', '+         ret = passwd_check(handle, password, have_polent, &polent,', '+                            entry->principal);', '+         if (ret)', '+             goto cleanup;', '+     if ((ret = krb5_timeofday(handle->context, &now)))', '+         goto cleanup;', '+     kdb->magic = KRB5_KDB_MAGIC_NUMBER;', '+         kdb->attributes = entry->attributes;', '+         kdb->attributes = handle->params.flags;', '+         kdb->max_life = entry->max_life;', '+         kdb->max_life = handle->params.max_life;', '+         kdb->max_renewable_life = entry->max_renewable_life;', '+         kdb->max_renewable_life = handle->params.max_rlife;', '+         kdb->expiration = entry->princ_expire_time;', '+         kdb->expiration = handle->params.expiration;', '+     kdb->pw_expiration = 0;', '+     if (have_polent) {', '+             kdb->pw_expiration = now + polent.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = entry->pw_expiration;', '+     kdb->last_success = 0;', '+     kdb->last_failed = 0;', '+     kdb->fail_auth_count = 0;', '+                                     entry->principal, &(kdb->princ))))', '+         goto cleanup;', '+     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))', '+         goto cleanup;', '+         tl_data_orig = kdb->tl_data;', '+             ret = krb5_dbe_update_tl_data(handle->context, kdb, tl_data_tail);', '+                 goto cleanup;', '+     if (ret)', '+         goto cleanup;', '+                            FALSE, kdb);', '+                            FALSE, kdb);', '+     if (ret)', '+         goto cleanup;', '+     ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);', '+         goto cleanup;', '+     if (have_polent) {', '+     if (have_polent) {', '+             != KADM5_OK)', '+             goto cleanup;', '+     kdb->mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;', '+     ret = kdb_put_entry(handle, kdb, &adb);', '+         if (have_polent) {', '+ cleanup:', '+     krb5_db_free_principal(handle->context, kdb);', '+     if (have_polent)', '+     return ret;', '+     krb5_db_entry               *kdb;', '+                 kdb_free_entry(handle, kdb, &adb);', '+             kdb_free_entry(handle, kdb, &adb);', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry           *kdb;', '+             ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,', '+                                                   &(kdb->pw_expiration));', '+             kdb->pw_expiration += npol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+             kdb->pw_expiration = 0;', '+         kdb->attributes = entry->attributes;', '+         kdb->max_life = entry->max_life;', '+         kdb->expiration = entry->princ_expire_time;', '+         kdb->pw_expiration = entry->pw_expiration;', '+         kdb->max_renewable_life = entry->max_renewable_life;', '+         for (i = 0; i < kdb->n_key_data; i++)', '+             kdb->key_data[i].key_data_kvno = entry->kvno;', '+             ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);', '+         kdb->fail_auth_count = 0;', '+     kdb->mask = mask;', '+     ret = kdb_put_entry(handle, kdb, &adb);', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry       *kdb;', '+         kdb_free_entry(handle, kdb, &adb);', '+     for (i=0; i<kdb->n_key_data; i++) {', '+         if ((kdb->key_data[i].key_data_ver == 1) ||', '+             (kdb->key_data[i].key_data_type[1] == KRB5_KDB_SALTTYPE_NORMAL)) {', '+     kadm5_free_principal(handle->context, kdb->princ);', '+     ret = kadm5_copy_principal(handle->context, target, &kdb->princ);', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+         (ret = krb5_copy_principal(handle->context, kdb->princ,', '+         entry->princ_expire_time = kdb->expiration;', '+         (ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,', '+         entry->pw_expiration = kdb->pw_expiration;', '+         entry->max_life = kdb->max_life;', '+         ret = krb5_dbe_lookup_mod_princ_data(handle->context, kdb,', '+         entry->attributes = kdb->attributes;', '+         for (entry->kvno = 0, i=0; i<kdb->n_key_data; i++)', '+             if (kdb->key_data[i].key_data_kvno > entry->kvno)', '+                 entry->kvno = kdb->key_data[i].key_data_kvno;', '+         ret = krb5_dbe_get_mkvno(handle->context, kdb, master_keylist,', '+         entry->max_renewable_life = kdb->max_renewable_life;', '+         entry->last_success = kdb->last_success;', '+         entry->last_failed = kdb->last_failed;', '+         entry->fail_auth_count = kdb->fail_auth_count;', '+         tl = kdb->tl_data;', '+         entry->n_key_data = kdb->n_key_data;', '+                                               &kdb->key_data[i],', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb, *kdb_save;', '+         kdb_free_entry(handle, kdb, &adb);', '+                        keepold, kdb);', '+     ret = krb5_dbe_update_mkvno(handle->context, kdb, act_kvno);', '+     kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '+         ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);', '+             !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '+                                    kdb_save->n_key_data,', '+                                    kdb_save->key_data, &hist);', '+                              kdb->n_key_data, kdb->key_data,', '+                                      kdb->n_key_data, kdb->key_data,', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);', '+     kdb->fail_auth_count = 0;', '+     kdb->mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     kdb_free_entry(handle, kdb_save, NULL);', '+     krb5_db_entry               *kdb;', '+                        kdb);', '+     kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '+         ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &last_pwd);', '+            !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);', '+     kdb->fail_auth_count = 0;', '+                                kdb->n_key_data, kdb->key_data,', '+     kdb->mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+     for (kvno = 0, i=0; i<kdb->n_key_data; i++)', '+         if (kdb->key_data[i].key_data_kvno > kvno)', '+             kvno = kdb->key_data[i].key_data_kvno;', '+     if (kdb->key_data != NULL)', '+         cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);', '+     kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, sizeof(krb5_key_data));', '+     if (kdb->key_data == NULL)', '+     memset(kdb->key_data, 0, sizeof(krb5_key_data));', '+     kdb->n_key_data = 1;', '+         kdb->key_data->key_data_type[k] = tmp_key_data.key_data_type[k];', '+         kdb->key_data->key_data_length[k] = tmp_key_data.key_data_length[k];', '+             kdb->key_data->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);', '+             if (kdb->key_data->key_data_contents[k] == NULL) {', '+                 cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);', '+                 kdb->key_data = NULL;', '+                 kdb->n_key_data = 0;', '+             memcpy (kdb->key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);', '+     kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '+                                                   kdb, &last_pwd))', '+            !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now);', '+     kdb->fail_auth_count = 0;', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+     for (kvno = 0, i=0; i<kdb->n_key_data; i++)', '+         if (kdb->key_data[i].key_data_kvno > kvno)', '+             kvno = kdb->key_data[i].key_data_kvno;', '+         old_key_data = kdb->key_data;', '+         n_old_keys = kdb->n_key_data;', '+         if (kdb->key_data != NULL)', '+             cleanup_key_data(handle->context, kdb->n_key_data, kdb->key_data);', '+     kdb->key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, (n_keys+n_old_keys)', '+                                                   *sizeof(krb5_key_data));', '+     if (kdb->key_data == NULL) {', '+     memset(kdb->key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));', '+     kdb->n_key_data = 0;', '+         tptr = &kdb->key_data[i];', '+         kdb->n_key_data++;', '+         kdb->key_data[i+n_keys] = old_key_data[i];', '+         kdb->n_key_data++;', '+     kdb->attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '+                                                   kdb, &last_pwd))', '+            !(kdb->attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '+             kdb->pw_expiration = now + pol.pw_max_life;', '+             kdb->pw_expiration = 0;', '+         kdb->pw_expiration = 0;', '+     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, kdb, now)))', '+     kdb->fail_auth_count = 0;', '+     if ((ret = kdb_put_entry(handle, kdb, &adb)))', '+     kdb_free_entry(handle, kdb, &adb);', '+     krb5_db_entry               *kdb;', '+         if ((ret = krb5_dbe_find_mkey(handle->context, master_keylist, kdb,', '+                                               kdb, &mkey_ptr))) {', '+                                kdb->n_key_data, kdb->key_data,', '+     kdb_free_entry(handle, kdb, &adb);']]","[['-     krb5_db_entry               kdb;', '-         kdb_free_entry(handle, &kdb, &adb);', '-     memset(&kdb, 0, sizeof(krb5_db_entry));', '-             if(ret == EINVAL)', '-                 return KADM5_BAD_POLICY;', '-             else', '-                 return ret;', '-         ret = passwd_check(handle, password, (mask & KADM5_POLICY),', '-                            &polent, entry->principal);', '-         if (ret) {', '-             if (mask & KADM5_POLICY)', '-                 (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-             return ret;', '-         }', '-     if ((ret = krb5_timeofday(handle->context, &now))) {', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return ret;', '-     }', '-     kdb.magic = KRB5_KDB_MAGIC_NUMBER;', '-         kdb.attributes = entry->attributes;', '-         kdb.attributes = handle->params.flags;', '-         kdb.max_life = entry->max_life;', '-         kdb.max_life = handle->params.max_life;', '-         kdb.max_renewable_life = entry->max_renewable_life;', '-         kdb.max_renewable_life = handle->params.max_rlife;', '-         kdb.expiration = entry->princ_expire_time;', '-         kdb.expiration = handle->params.expiration;', '-     kdb.pw_expiration = 0;', '-     if ((mask & KADM5_POLICY)) {', '-             kdb.pw_expiration = now + polent.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = entry->pw_expiration;', '-     kdb.last_success = 0;', '-     kdb.last_failed = 0;', '-     kdb.fail_auth_count = 0;', '-                                     entry->principal, &(kdb.princ)))) {', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     }', '-     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now))) {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     }', '-         tl_data_orig = kdb.tl_data;', '-             ret = krb5_dbe_update_tl_data(handle->context, &kdb, tl_data_tail);', '-             {', '-                 krb5_db_free_principal(handle->context, &kdb, 1);', '-                 if (mask & KADM5_POLICY)', '-                     (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-                 return ret;', '-             }', '-     if (ret) {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return (ret);', '-     }', '-                            FALSE, &kdb);', '-                            FALSE, &kdb);', '-     }', '-     if (ret) {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     ret = krb5_dbe_update_mkvno(handle->context, &kdb, act_kvno);', '-     {', '-         krb5_db_free_principal(handle->context, &kdb, 1);', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return ret;', '-     }', '-     if ((mask & KADM5_POLICY)) {', '-     if ((mask & KADM5_POLICY)) {', '-             != KADM5_OK) {', '-             krb5_db_free_principal(handle->context, &kdb, 1);', '-             if (mask & KADM5_POLICY)', '-                 (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-             return(ret);', '-         }', '-     kdb.mask = mask | KADM5_KEY_DATA | KADM5_PRINCIPAL ;', '-     ret = kdb_put_entry(handle, &kdb, &adb);', '-     krb5_db_free_principal(handle->context, &kdb, 1);', '-         if ((mask & KADM5_POLICY)) {', '- ', '-         if (mask & KADM5_POLICY)', '-             (void) kadm5_free_policy_ent(handle->lhandle, &polent);', '-         return(ret);', '-     if (mask & KADM5_POLICY)', '- ', '-     return KADM5_OK;', '-     krb5_db_entry               kdb;', '-                 kdb_free_entry(handle, &kdb, &adb);', '-             kdb_free_entry(handle, &kdb, &adb);', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry           kdb;', '-             ret = krb5_dbe_lookup_last_pwd_change(handle->context, &kdb,', '-                                                   &(kdb.pw_expiration));', '-             kdb.pw_expiration += npol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-             kdb.pw_expiration = 0;', '-         kdb.attributes = entry->attributes;', '-         kdb.max_life = entry->max_life;', '-         kdb.expiration = entry->princ_expire_time;', '-         kdb.pw_expiration = entry->pw_expiration;', '-         kdb.max_renewable_life = entry->max_renewable_life;', '-         for (i = 0; i < kdb.n_key_data; i++)', '-             kdb.key_data[i].key_data_kvno = entry->kvno;', '-             ret = krb5_dbe_update_tl_data(handle->context, &kdb, tl);', '-         kdb.fail_auth_count = 0;', '-     kdb.mask = mask;', '-     ret = kdb_put_entry(handle, &kdb, &adb);', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry       kdb;', '-         kdb_free_entry(handle, &kdb, &adb);', '-     for (i=0; i<kdb.n_key_data; i++) {', '-         if ((kdb.key_data[i].key_data_ver == 1) ||', '-             (kdb.key_data[i].key_data_type[1] == KRB5_KDB_SALTTYPE_NORMAL)) {', '-     kadm5_free_principal(handle->context, kdb.princ);', '-     ret = kadm5_copy_principal(handle->context, target, &kdb.princ);', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-         (ret = krb5_copy_principal(handle->context, kdb.princ,', '-         entry->princ_expire_time = kdb.expiration;', '-         (ret = krb5_dbe_lookup_last_pwd_change(handle->context, &kdb,', '-         entry->pw_expiration = kdb.pw_expiration;', '-         entry->max_life = kdb.max_life;', '-         ret = krb5_dbe_lookup_mod_princ_data(handle->context, &kdb,', '-         entry->attributes = kdb.attributes;', '-         for (entry->kvno = 0, i=0; i<kdb.n_key_data; i++)', '-             if (kdb.key_data[i].key_data_kvno > entry->kvno)', '-                 entry->kvno = kdb.key_data[i].key_data_kvno;', '-         ret = krb5_dbe_get_mkvno(handle->context, &kdb, master_keylist,', '-         entry->max_renewable_life = kdb.max_renewable_life;', '-         entry->last_success = kdb.last_success;', '-         entry->last_failed = kdb.last_failed;', '-         entry->fail_auth_count = kdb.fail_auth_count;', '-         tl = kdb.tl_data;', '-         entry->n_key_data = kdb.n_key_data;', '-                                               &kdb.key_data[i],', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb, kdb_save;', '-         kdb_free_entry(handle, &kdb, &adb);', '-                        keepold, &kdb);', '-     ret = krb5_dbe_update_mkvno(handle->context, &kdb, act_kvno);', '-     kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '-         ret = krb5_dbe_lookup_last_pwd_change(handle->context,', '-                                               &kdb, &last_pwd);', '-             !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '-                                    kdb_save.n_key_data,', '-                                    kdb_save.key_data, &hist);', '-                              kdb.n_key_data, kdb.key_data,', '-                                      kdb.n_key_data, kdb.key_data,', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);', '-     kdb.fail_auth_count = 0;', '-     kdb.mask = KADM5_KEY_DATA | KADM5_ATTRIBUTES |', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     kdb_free_entry(handle, &kdb_save, NULL);', '-     krb5_db_free_principal(handle->context, &kdb, 1);', '-     krb5_db_entry               kdb;', '-                        &kdb);', '-     kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '-         ret = krb5_dbe_lookup_last_pwd_change(handle->context,', '-                                               &kdb, &last_pwd);', '-            !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);', '-     kdb.fail_auth_count = 0;', '-                                kdb.n_key_data, kdb.key_data,', '-     kdb.mask = KADM5_KEY_DATA | KADM5_FAIL_AUTH_COUNT;', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-     for (kvno = 0, i=0; i<kdb.n_key_data; i++)', '-         if (kdb.key_data[i].key_data_kvno > kvno)', '-             kvno = kdb.key_data[i].key_data_kvno;', '-     if (kdb.key_data != NULL)', '-         cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);', '-     kdb.key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, sizeof(krb5_key_data));', '-     if (kdb.key_data == NULL)', '-     memset(kdb.key_data, 0, sizeof(krb5_key_data));', '-     kdb.n_key_data = 1;', '-         kdb.key_data->key_data_type[k] = tmp_key_data.key_data_type[k];', '-         kdb.key_data->key_data_length[k] = tmp_key_data.key_data_length[k];', '-             kdb.key_data->key_data_contents[k] = krb5_db_alloc(handle->context, NULL, tmp_key_data.key_data_length[k]);', '-             if (kdb.key_data->key_data_contents[k] == NULL) {', '-                 cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);', '-                 kdb.key_data = NULL;', '-                 kdb.n_key_data = 0;', '-             memcpy (kdb.key_data->key_data_contents[k], tmp_key_data.key_data_contents[k], tmp_key_data.key_data_length[k]);', '-     kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '-                                                   &kdb, &last_pwd))', '-            !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now);', '-     kdb.fail_auth_count = 0;', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-     for (kvno = 0, i=0; i<kdb.n_key_data; i++)', '-         if (kdb.key_data[i].key_data_kvno > kvno)', '-             kvno = kdb.key_data[i].key_data_kvno;', '-         old_key_data = kdb.key_data;', '-         n_old_keys = kdb.n_key_data;', '-         if (kdb.key_data != NULL)', '-             cleanup_key_data(handle->context, kdb.n_key_data, kdb.key_data);', '-     kdb.key_data = (krb5_key_data*)krb5_db_alloc(handle->context, NULL, (n_keys+n_old_keys)', '-                                                  *sizeof(krb5_key_data));', '-     if (kdb.key_data == NULL) {', '-     memset(kdb.key_data, 0, (n_keys+n_old_keys)*sizeof(krb5_key_data));', '-     kdb.n_key_data = 0;', '-         tptr = &kdb.key_data[i];', '-         kdb.n_key_data++;', '-         kdb.key_data[i+n_keys] = old_key_data[i];', '-         kdb.n_key_data++;', '-     kdb.attributes &= ~KRB5_KDB_REQUIRES_PWCHANGE;', '-                                                   &kdb, &last_pwd))', '-            !(kdb.attributes & KRB5_KDB_REQUIRES_PWCHANGE)) {', '-             kdb.pw_expiration = now + pol.pw_max_life;', '-             kdb.pw_expiration = 0;', '-         kdb.pw_expiration = 0;', '-     if ((ret = krb5_dbe_update_last_pwd_change(handle->context, &kdb, now)))', '-     kdb.fail_auth_count = 0;', '-     if ((ret = kdb_put_entry(handle, &kdb, &adb)))', '-     kdb_free_entry(handle, &kdb, &adb);', '-     krb5_db_entry               kdb;', '-         if ((ret = krb5_dbe_find_mkey(handle->context, master_keylist, &kdb,', '-                                               &kdb, &mkey_ptr))) {', '-                                kdb.n_key_data, kdb.key_data,', '-     kdb_free_entry(handle, &kdb, &adb);']]",206,243.0,449.0,8e78a7eeb7266329891971090d2666f5c6a13ad0krb5/krb5,"['4c023ba43c16396f0d199e2df1cfa59b88b62acc', '04038bf3633c4b909b5ded3072dc88c8c419bf16', 'af0ed4df4dfae762ab5fb605f5a0c8f59cb4f6ca']"
4e058ee0b010abd2eab53f5ddd13ba5dca2c354a,jabberd2/jabberd2,c2s/main.c,train,C,1,"['@@ -0,0 +1,715 @@\n+/*\n+ * jabberd - Jabber Open Source Server\n+ * Copyright (c) 2002 Jeremie Miller, Thomas Muldowney,\n+ *                    Ryan Eatmon, Robert Norris\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation; either version 2 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program; if not, write to the Free Software\n+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA\n+ */\n+\n+#include ""c2s.h""\n+\n+#ifdef HAVE_IDN\n+#include <stringprep.h>\n+#endif\n+\n+static sig_atomic_t c2s_shutdown = 0;\n+sig_atomic_t c2s_lost_router = 0;\n+static sig_atomic_t c2s_logrotate = 0;\n+\n+static void _c2s_signal(int signum)\n+{\n+    c2s_shutdown = 1;\n+    c2s_lost_router = 0;\n+}\n+\n+static void _c2s_signal_hup(int signum)\n+{\n+    c2s_logrotate = 1;\n+}\n+\n+/** store the process id */\n+static void _c2s_pidfile(c2s_t c2s) {\n+    char *pidfile;\n+    FILE *f;\n+    pid_t pid;\n+\n+    pidfile = config_get_one(c2s->config, ""pidfile"", 0);\n+    if(pidfile == NULL)\n+        return;\n+\n+    pid = getpid();\n+\n+    if((f = fopen(pidfile, ""w+"")) == NULL) {\n+        log_write(c2s->log, LOG_ERR, ""couldn\'t open %s for writing: %s"", pidfile, strerror(errno));\n+        return;\n+    }\n+\n+    if(fprintf(f, ""%d"", pid) < 0) {\n+        log_write(c2s->log, LOG_ERR, ""couldn\'t write to %s: %s"", pidfile, strerror(errno));\n+        return;\n+    }\n+\n+    fclose(f);\n+\n+    log_write(c2s->log, LOG_INFO, ""process id is %d, written to %s"", pid, pidfile);\n+}\n+/** pull values out of the config file */\n+static void _c2s_config_expand(c2s_t c2s)\n+{\n+    char *str, *ip, *mask;\n+    config_elem_t elem;\n+    int i;\n+\n+    c2s->id = config_get_one(c2s->config, ""id"", 0);\n+    if(c2s->id == NULL)\n+        c2s->id = ""c2s"";\n+\n+    c2s->router_ip = config_get_one(c2s->config, ""router.ip"", 0);\n+    if(c2s->router_ip == NULL)\n+        c2s->router_ip = ""127.0.0.1"";\n+\n+    c2s->router_port = j_atoi(config_get_one(c2s->config, ""router.port"", 0), 5347);\n+\n+    c2s->router_user = config_get_one(c2s->config, ""router.user"", 0);\n+    if(c2s->router_user == NULL)\n+        c2s->router_user = ""jabberd"";\n+    c2s->router_pass = config_get_one(c2s->config, ""router.pass"", 0);\n+    if(c2s->router_pass == NULL)\n+        c2s->router_pass = ""secret"";\n+\n+    c2s->router_pemfile = config_get_one(c2s->config, ""router.pemfile"", 0);\n+\n+    c2s->retry_init = j_atoi(config_get_one(c2s->config, ""router.retry.init"", 0), 3);\n+    c2s->retry_lost = j_atoi(config_get_one(c2s->config, ""router.retry.lost"", 0), 3);\n+    if((c2s->retry_sleep = j_atoi(config_get_one(c2s->config, ""router.retry.sleep"", 0), 2)) < 1)\n+        c2s->retry_sleep = 1;\n+\n+    c2s->log_type = log_STDOUT;\n+    if(config_get(c2s->config, ""log"") != NULL) {\n+        if((str = config_get_attr(c2s->config, ""log"", 0, ""type"")) != NULL) {\n+            if(strcmp(str, ""file"") == 0)\n+                c2s->log_type = log_FILE;\n+            else if(strcmp(str, ""syslog"") == 0)\n+                c2s->log_type = log_SYSLOG;\n+        }\n+    }\n+\n+    if(c2s->log_type == log_SYSLOG) {\n+        c2s->log_facility = config_get_one(c2s->config, ""log.facility"", 0);\n+        c2s->log_ident = config_get_one(c2s->config, ""log.ident"", 0);\n+        if(c2s->log_ident == NULL)\n+            c2s->log_ident = ""jabberd/c2s"";\n+    } else if(c2s->log_type == log_FILE)\n+        c2s->log_ident = config_get_one(c2s->config, ""log.file"", 0);\n+\n+    c2s->local_ip = config_get_one(c2s->config, ""local.ip"", 0);\n+    if(c2s->local_ip == NULL)\n+        c2s->local_ip = ""0.0.0.0"";\n+\n+    c2s->local_port = j_atoi(config_get_one(c2s->config, ""local.port"", 0), 0);\n+\n+    c2s->local_pemfile = config_get_one(c2s->config, ""local.pemfile"", 0);\n+\n+    if(config_get(c2s->config, ""local.require-starttls"") != NULL)\n+        c2s->local_require_starttls = 1;\n+\n+    c2s->local_cachain = config_get_one(c2s->config, ""local.cachain"", 0);\n+\n+    c2s->local_verify_mode = j_atoi(config_get_one(c2s->config, ""local.verify-mode"", 0), 0);\n+\n+    c2s->local_ssl_port = j_atoi(config_get_one(c2s->config, ""local.ssl-port"", 0), 0);\n+\n+    c2s->io_max_fds = j_atoi(config_get_one(c2s->config, ""io.max_fds"", 0), 1024);\n+\n+    c2s->io_check_interval = j_atoi(config_get_one(c2s->config, ""io.check.interval"", 0), 0);\n+    c2s->io_check_idle = j_atoi(config_get_one(c2s->config, ""io.check.idle"", 0), 0);\n+    c2s->io_check_keepalive = j_atoi(config_get_one(c2s->config, ""io.check.keepalive"", 0), 0);\n+\n+    c2s->ar_module_name = config_get_one(c2s->config, ""authreg.module"", 0);\n+\n+    c2s->ar_register_enable = (config_get(c2s->config, ""authreg.register.enable"") != NULL);\n+    if(c2s->ar_register_enable) {\n+        c2s->ar_register_instructions = config_get_one(c2s->config, ""authreg.register.instructions"", 0);\n+        if(c2s->ar_register_instructions == NULL)\n+            c2s->ar_register_instructions = ""Enter a username and password to register with this server."";\n+    } else\n+        c2s->ar_register_password = (config_get(c2s->config, ""authreg.register.password"") != NULL);\n+\n+    if(config_get(c2s->config, ""authreg.mechanisms.traditional.plain"") != NULL) c2s->ar_mechanisms |= AR_MECH_TRAD_PLAIN;\n+    if(config_get(c2s->config, ""authreg.mechanisms.traditional.digest"") != NULL) c2s->ar_mechanisms |= AR_MECH_TRAD_DIGEST;\n+    if(config_get(c2s->config, ""authreg.mechanisms.traditional.zerok"") != NULL) c2s->ar_mechanisms |= AR_MECH_TRAD_ZEROK;\n+\n+    elem = config_get(c2s->config, ""io.limits.bytes"");\n+    if(elem != NULL)\n+    {\n+        c2s->byte_rate_total = j_atoi(elem->values[0], 0);\n+        if(c2s->byte_rate_total != 0)\n+        {\n+            c2s->byte_rate_seconds = j_atoi(j_attr((const char **) elem->attrs[0], ""seconds""), 1);\n+            c2s->byte_rate_wait = j_atoi(j_attr((const char **) elem->attrs[0], ""throttle""), 5);\n+        }\n+    }\n+\n+    elem = config_get(c2s->config, ""io.limits.connects"");\n+    if(elem != NULL)\n+    {\n+        c2s->conn_rate_total = j_atoi(elem->values[0], 0);\n+        if(c2s->conn_rate_total != 0)\n+        {\n+            c2s->conn_rate_seconds = j_atoi(j_attr((const char **) elem->attrs[0], ""seconds""), 5);\n+            c2s->conn_rate_wait = j_atoi(j_attr((const char **) elem->attrs[0], ""throttle""), 5);\n+        }\n+    }\n+\n+    str = config_get_one(c2s->config, ""io.access.order"", 0);\n+    if(str == NULL || strcmp(str, ""deny,allow"") != 0)\n+        c2s->access = access_new(0);\n+    else\n+        c2s->access = access_new(1);\n+\n+    elem = config_get(c2s->config, ""io.access.allow"");\n+    if(elem != NULL)\n+    {\n+        for(i = 0; i < elem->nvalues; i++)\n+        {\n+            ip = j_attr((const char **) elem->attrs[i], ""ip"");\n+            mask = j_attr((const char **) elem->attrs[i], ""mask"");\n+\n+            if(ip == NULL)\n+                continue;\n+\n+            if(mask == NULL)\n+                mask = ""255.255.255.255"";\n+\n+            access_allow(c2s->access, ip, mask);\n+        }\n+    }\n+\n+    elem = config_get(c2s->config, ""io.access.deny"");\n+    if(elem != NULL)\n+    {\n+        for(i = 0; i < elem->nvalues; i++)\n+        {\n+            ip = j_attr((const char **) elem->attrs[i], ""ip"");\n+            mask = j_attr((const char **) elem->attrs[i], ""mask"");\n+\n+            if(ip == NULL)\n+                continue;\n+\n+            if(mask == NULL)\n+                mask = ""255.255.255.255"";\n+\n+            access_deny(c2s->access, ip, mask);\n+        }\n+    }\n+}\n+\n+static int _c2s_router_connect(c2s_t c2s) {\n+    log_write(c2s->log, LOG_NOTICE, ""attempting connection to router at %s, port=%d"", c2s->router_ip, c2s->router_port);\n+\n+    c2s->fd = mio_connect(c2s->mio, c2s->router_port, c2s->router_ip, c2s_router_mio_callback, (void *) c2s);\n+    if(c2s->fd < 0) {\n+        if(errno == ECONNREFUSED)\n+            c2s_lost_router = 1;\n+        log_write(c2s->log, LOG_NOTICE, ""connection attempt to router failed: %s (%d)"", strerror(errno), errno);\n+        return 1;\n+    }\n+\n+    c2s->router = sx_new(c2s->sx_env, c2s->fd, c2s_router_sx_callback, (void *) c2s);\n+    sx_client_init(c2s->router, 0, NULL, NULL, NULL, ""1.0"");\n+\n+    return 0;\n+}\n+\n+static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {\n+    c2s_t c2s = (c2s_t) cbarg;\n+    char *my_realm, *mech;\n+    sx_sasl_creds_t creds;\n+    static char buf[3072];\n+    char mechbuf[256];\n+    struct jid_st jid;\n+    jid_static_buf jid_buf;\n+    int i, r;\n+\n+    /* init static jid */\n+    jid_static(&jid,&jid_buf);\n+\n+    switch(cb) {\n+        case sx_sasl_cb_GET_REALM:\n+            \n+            if(s->req_to == NULL)   /* this shouldn\'t happen */\n+                my_realm = """";\n+\n+            else {\n+                my_realm = xhash_get(c2s->realms, s->req_to);\n+                if(my_realm == NULL)\n+                    my_realm = s->req_to;\n+            }\n+\n+            strncpy(buf, my_realm, 256);\n+            *res = buf;\n+\n+            log_debug(ZONE, ""sx sasl callback: get realm: realm is \'%s\'"", buf);\n+            return sx_sasl_ret_OK;\n+            break;\n+\n+        case sx_sasl_cb_GET_PASS:\n+            creds = (sx_sasl_creds_t) arg;\n+\n+            log_debug(ZONE, ""sx sasl callback: get pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);\n+\n+            if(c2s->ar->get_password && (c2s->ar->get_password)(c2s->ar, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm: """", buf) == 0) {\n+                *res = buf;\n+                return sx_sasl_ret_OK;\n+\t    }\n+\n+            return sx_sasl_ret_FAIL;\n+\n+        case sx_sasl_cb_CHECK_PASS:\n+            creds = (sx_sasl_creds_t) arg;\n+\n+            log_debug(ZONE, ""sx sasl callback: check pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);\n+\n+            if(c2s->ar->check_password != NULL) {\n+                if ((c2s->ar->check_password)(c2s->ar, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", (char *)creds->pass) == 0)\n+                    return sx_sasl_ret_OK;\n+                else\n+                    return sx_sasl_ret_FAIL;\n+            }\n+\n+            if(c2s->ar->get_password != NULL) {\n+                if ((c2s->ar->get_password)(c2s->ar, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", buf) != 0)\n+                    return sx_sasl_ret_FAIL;\n+\n+                if (strcmp(creds->pass, buf)==0)\n+                    return sx_sasl_ret_OK;\n+            }\n+\n+            return sx_sasl_ret_FAIL;\n+            break;\n+\t\n+        case sx_sasl_cb_CHECK_AUTHZID:\n+            creds = (sx_sasl_creds_t) arg;\n+\n+            /* no authzid, we should build one */\n+            if(creds->authzid == NULL || creds->authzid[0] == \'\\0\') {\n+                snprintf(buf, 3072, ""%s@%s"", creds->authnid, s->req_to);\n+                creds->authzid = (void *)buf;\n+            }\n+\n+            /* authzid must be a valid jid */\n+            jid.pc = c2s->pc;\n+            if(jid_reset(&jid, creds->authzid, -1) == NULL)\n+                return sx_sasl_ret_FAIL;\n+\n+            /* and have domain == stream to addr */\n+            if(strcmp(jid.domain, s->req_to) != 0)\n+                return sx_sasl_ret_FAIL;\n+\n+            /* and have no resource */\n+            if(jid.resource[0] != \'\\0\')\n+                return sx_sasl_ret_FAIL;\n+\n+            /* and exist ! */\n+\n+            if((c2s->ar->user_exists)(c2s->ar, (char *)creds->authnid, (char *)creds->realm))\n+                return sx_sasl_ret_OK;\n+\n+            return sx_sasl_ret_FAIL;\n+\n+        case sx_sasl_cb_GEN_AUTHZID:\n+\t  /* generate a jid for SASL ANONYMOUS */\n+            jid.pc = c2s->pc;\n+            jid_reset(&jid, s->req_to, -1);\n+\n+            /* make resource a random string */\n+            jid_random_part(&jid, jid_NODE);\n+\n+            strcpy(buf, jid_full(&jid));\n+\t\n+            *res = (void *)buf;\n+\n+            return sx_sasl_ret_OK;\n+            break;\n+\n+        case sx_sasl_cb_CHECK_MECH:\n+            mech = (char *)arg;\n+\n+            i=0;\n+            while(i<sizeof(mechbuf) && mech[i]!=\'\\0\') {\n+                mechbuf[i]=tolower(mech[i]);\n+                i++;\n+            }\n+            mechbuf[i]=\'\\0\';\n+\n+            r = snprintf(buf, sizeof(buf), ""authreg.mechanisms.sasl.%s"",mechbuf);\n+            if (r < -1 || r > sizeof(buf))\n+                return sx_sasl_ret_FAIL;\n+\n+            /* Work out if our configuration will let us use this mechanism */\n+            if(config_get(c2s->config,buf) != NULL)\n+                return sx_sasl_ret_OK;\n+            else\n+                return sx_sasl_ret_FAIL;\n+        default:\n+            break;\n+    }\n+\n+    return sx_sasl_ret_FAIL;\n+}\n+static void _c2s_time_checks(c2s_t c2s) {\n+    sess_t sess;\n+    time_t now;\n+    union xhashv xhv;\n+\n+    now = time(NULL);\n+\n+    if(xhash_iter_first(c2s->sessions))\n+        do {\n+            xhv.sess_val = &sess;\n+            xhash_iter_get(c2s->sessions, NULL, xhv.val);\n+\n+            if(c2s->io_check_idle > 0 && now > sess->last_activity + c2s->io_check_idle) {\n+                log_write(c2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] timed out"", sess->fd, sess->ip, sess->port);\n+\n+                sx_error(sess->s, stream_err_HOST_GONE, ""connection timed out"");\n+                sx_close(sess->s);\n+\n+                continue;\n+            }\n+\n+            if(c2s->io_check_keepalive > 0 && now > sess->last_activity + c2s->io_check_keepalive && sess->s->state >= state_STREAM) {\n+                log_debug(ZONE, ""sending keepalive for %d"", sess->fd);\n+\n+                sx_raw_write(sess->s, "" "", 1);\n+            }\n+\n+        } while(xhash_iter_next(c2s->sessions));\n+}\n+\n+int main(int argc, char **argv)\n+{\n+    c2s_t c2s;\n+    char *config_file, *realm;\n+    char id[1024];\n+    int i, sd_flags, optchar;\n+    config_elem_t elem;\n+    sess_t sess;\n+    union xhashv xhv;\n+#ifdef POOL_DEBUG\n+    time_t pool_time = 0;\n+#endif\n+    \n+#ifdef HAVE_UMASK\n+    umask((mode_t) 0027);\n+#endif\n+\n+    srand(time(NULL));\n+\n+#ifdef HAVE_WINSOCK2_H\n+/* get winsock running */\n+\t{\n+\t\tWORD wVersionRequested;\n+\t\tWSADATA wsaData;\n+\t\tint err;\n+\t\t\n+\t\twVersionRequested = MAKEWORD( 2, 2 );\n+\t\t\n+\t\terr = WSAStartup( wVersionRequested, &wsaData );\n+\t\tif ( err != 0 ) {\n+            /* !!! tell user that we couldn\'t find a usable winsock dll */\n+\t\t\treturn 0;\n+\t\t}\n+\t}\n+#endif\n+\n+    jabber_signal(SIGINT, _c2s_signal);\n+    jabber_signal(SIGTERM, _c2s_signal);\n+#ifdef SIGHUP\n+    jabber_signal(SIGHUP, _c2s_signal_hup);\n+#endif\n+#ifdef SIGPIPE\n+    jabber_signal(SIGPIPE, SIG_IGN);\n+#endif\n+\n+    c2s = (c2s_t) malloc(sizeof(struct c2s_st));\n+    memset(c2s, 0, sizeof(struct c2s_st));\n+\n+    /* load our config */\n+    c2s->config = config_new();\n+\n+    config_file = CONFIG_DIR ""/c2s.xml"";\n+\n+    /* cmdline parsing */\n+    while((optchar = getopt(argc, argv, ""Dc:h?"")) >= 0)\n+    {\n+        switch(optchar)\n+        {\n+            case \'c\':\n+                config_file = optarg;\n+                break;\n+            case \'D\':\n+#ifdef DEBUG\n+                set_debug_flag(1);\n+#else\n+                printf(""WARN: Debugging not enabled.  Ignoring -D.\\n"");\n+#endif\n+                break;\n+            case \'h\': case \'?\': default:\n+                fputs(\n+                    ""c2s - jabberd client-to-server connector ("" VERSION "")\\n""\n+                    ""Usage: c2s <options>\\n""\n+                    ""Options are:\\n""\n+                    ""   -c <config>     config file to use [default: "" CONFIG_DIR ""/c2s.xml]\\n""\n+#ifdef DEBUG\n+                    ""   -D              Show debug output\\n""\n+#endif\n+                    ,\n+                    stdout);\n+                config_free(c2s->config);\n+                free(c2s);\n+                return 1;\n+        }\n+    }\n+\n+    if(config_load(c2s->config, config_file) != 0)\n+    {\n+        fputs(""c2s: couldn\'t load config, aborting\\n"", stderr);\n+        config_free(c2s->config);\n+        free(c2s);\n+        return 2;\n+    }\n+\n+    _c2s_config_expand(c2s);\n+\n+    c2s->log = log_new(c2s->log_type, c2s->log_ident, c2s->log_facility);\n+    log_write(c2s->log, LOG_NOTICE, ""starting up"");\n+\n+    _c2s_pidfile(c2s);\n+\n+    if(c2s->ar_module_name == NULL)\n+    {\n+        log_write(c2s->log, LOG_ERR, ""no authreg module specified in config file"");\n+        exit(1);\n+    }\n+\n+    if((c2s->ar = authreg_init(c2s, c2s->ar_module_name)) == NULL)\n+        exit(1);\n+\n+    c2s->pc = prep_cache_new();\n+\n+    c2s->sessions = xhash_new(1023);\n+\n+    c2s->conn_rates = xhash_new(101);\n+\n+    c2s->dead = jqueue_new();\n+\n+    c2s->dead_sess = jqueue_new();\n+\n+    c2s->sx_env = sx_env_new();\n+\n+#ifdef HAVE_SSL\n+    /* get the ssl context up and running */\n+    if(c2s->local_pemfile != NULL) {\n+        c2s->sx_ssl = sx_env_plugin(c2s->sx_env, sx_ssl_init, c2s->local_pemfile, c2s->local_cachain, c2s->local_verify_mode);\n+        if(c2s->sx_ssl == NULL) {\n+            log_write(c2s->log, LOG_ERR, ""failed to load local SSL pemfile, SSL will not be available to clients"");\n+            c2s->local_pemfile = NULL;\n+        }\n+    }\n+\n+    /* try and get something online, so at least we can encrypt to the router */\n+    if(c2s->sx_ssl == NULL && c2s->router_pemfile != NULL) {\n+        c2s->sx_ssl = sx_env_plugin(c2s->sx_env, sx_ssl_init, c2s->router_pemfile, NULL);\n+        if(c2s->sx_ssl == NULL) {\n+            log_write(c2s->log, LOG_ERR, ""failed to load router SSL pemfile, channel to router will not be SSL encrypted"");\n+            c2s->router_pemfile = NULL;\n+        }\n+    }\n+#endif\n+            \n+    /* get sasl online */\n+    sd_flags = 0;\n+\n+    c2s->sx_sasl = sx_env_plugin(c2s->sx_env, sx_sasl_init, ""xmpp"", sd_flags, _c2s_sx_sasl_callback, (void *) c2s, sd_flags);\n+    if(c2s->sx_sasl == NULL) {\n+        log_write(c2s->log, LOG_ERR, ""failed to initialise SASL context, aborting"");\n+        exit(1);\n+    }\n+\n+    sx_env_plugin(c2s->sx_env, bind_init);\n+\n+    c2s->mio = mio_new(c2s->io_max_fds);\n+\n+    /* realm mapping */\n+    c2s->realms = xhash_new(51);\n+\n+    elem = config_get(c2s->config, ""local.id"");\n+    for(i = 0; i < elem->nvalues; i++) {\n+        realm = j_attr((const char **) elem->attrs[i], ""realm"");\n+\n+        /* stringprep ids (domain names) so that they are in canonical form */\n+        strncpy(id, elem->values[i], 1024);\n+        id[1023] = \'\\0\';\n+#ifdef HAVE_IDN\n+        if (stringprep_nameprep(id, 1024) != 0) {\n+           log_write(c2s->log, LOG_ERR, ""cannot stringprep id %s, aborting"", id);\n+           exit(1);\n+        }\n+#endif\n+        xhash_put(c2s->realms, pstrdup(xhash_pool(c2s->realms), id), (realm != NULL) ? realm : pstrdup(xhash_pool(c2s->realms), id));\n+\n+        log_write(c2s->log, LOG_NOTICE, ""[%s] configured; realm=%s"", id, realm);\n+    }\n+\n+    c2s->sm_avail = xhash_new(51);\n+\n+    c2s->retry_left = c2s->retry_init;\n+    _c2s_router_connect(c2s);\n+\n+    while(!c2s_shutdown) {\n+        mio_run(c2s->mio, 5);\n+\n+        if(c2s_logrotate) {\n+            log_write(c2s->log, LOG_NOTICE, ""reopening log ..."");\n+            log_free(c2s->log);\n+            c2s->log = log_new(c2s->log_type, c2s->log_ident, c2s->log_facility);\n+            log_write(c2s->log, LOG_NOTICE, ""log started"");\n+\n+            c2s_logrotate = 0;\n+        }\n+\n+        if(c2s_lost_router) {\n+            if(c2s->retry_left < 0) {\n+                log_write(c2s->log, LOG_NOTICE, ""attempting reconnect"");\n+                sleep(c2s->retry_sleep);\n+                c2s_lost_router = 0;\n+                _c2s_router_connect(c2s);\n+            }\n+\n+            else if(c2s->retry_left == 0) {\n+                c2s_shutdown = 1;\n+            }\n+\n+            else {\n+                log_write(c2s->log, LOG_NOTICE, ""attempting reconnect (%d left)"", c2s->retry_left);\n+                c2s->retry_left--;\n+                sleep(c2s->retry_sleep);\n+                c2s_lost_router = 0;\n+                _c2s_router_connect(c2s);\n+            }\n+        }\n+            \n+        /* cleanup dead sess (before sx_t as sess->result uses sx_t nad cache) */\n+        while(jqueue_size(c2s->dead_sess) > 0) {\n+            sess = (sess_t) jqueue_pull(c2s->dead_sess);\n+\n+            /* free sess data */\n+            if(sess->ip != NULL) free(sess->ip);\n+            if(sess->result != NULL) nad_free(sess->result);\n+            if(sess->jid != NULL) jid_free(sess->jid);\n+\n+            free(sess);\n+        }\n+\n+        /* cleanup dead sx_ts */\n+        while(jqueue_size(c2s->dead) > 0)\n+            sx_free((sx_t) jqueue_pull(c2s->dead));\n+\n+        /* time checks */\n+        if(c2s->io_check_interval > 0 && time(NULL) >= c2s->next_check) {\n+            log_debug(ZONE, ""running time checks"");\n+\n+            _c2s_time_checks(c2s);\n+\n+            c2s->next_check = time(NULL) + c2s->io_check_interval;\n+            log_debug(ZONE, ""next time check at %d"", c2s->next_check);\n+        }\n+\n+#ifdef POOL_DEBUG\n+        if(time(NULL) > pool_time + 60) {\n+            pool_stat(1);\n+            pool_time = time(NULL);\n+        }\n+#endif\n+    }\n+\n+    log_write(c2s->log, LOG_NOTICE, ""shutting down"");\n+    \n+    if(xhash_iter_first(c2s->sessions))\n+        do {\n+            xhv.sess_val = &sess;\n+            xhash_iter_get(c2s->sessions, NULL, xhv.val);\n+\n+            if(sess->active)\n+                sx_close(sess->s);\n+\n+        } while(xhash_iter_next(c2s->sessions));\n+\n+    /* cleanup dead sess */\n+    while(jqueue_size(c2s->dead_sess) > 0) {\n+        sess = (sess_t) jqueue_pull(c2s->dead_sess);\n+\n+        /* free sess data */\n+        if(sess->ip != NULL) free(sess->ip);\n+        if(sess->result != NULL) nad_free(sess->result);\n+        if(sess->jid != NULL) jid_free(sess->jid);\n+\n+        free(sess);\n+    }\n+\n+    while(jqueue_size(c2s->dead) > 0)\n+        sx_free((sx_t) jqueue_pull(c2s->dead));\n+\n+    sx_free(c2s->router);\n+\n+    sx_env_free(c2s->sx_env);\n+\n+    mio_free(c2s->mio);\n+\n+    xhash_free(c2s->sessions);\n+\n+    prep_cache_free(c2s->pc);\n+\n+    authreg_free(c2s->ar);\n+\n+    xhash_free(c2s->conn_rates);\n+\n+    xhash_free(c2s->sm_avail);\n+\n+    xhash_free(c2s->realms);\n+\n+    jqueue_free(c2s->dead);\n+\n+    jqueue_free(c2s->dead_sess);\n+\n+    access_free(c2s->access);\n+\n+    log_free(c2s->log);\n+\n+    config_free(c2s->config);\n+\n+    free(c2s);\n+\n+#ifdef POOL_DEBUG\n+    pool_stat(1);\n+#endif\n+\n+#ifdef HAVE_WINSOCK2_H\n+    WSACleanup();\n+#endif\n+\n+    return 0;\n+}\n']",2006-04-16 20:42:32+00:00,jabberstudio CVS import,"[['+ ', '+ #include ""c2s.h""', '+ ', '+ #ifdef HAVE_IDN', '+ #include <stringprep.h>', '+ #endif', '+ ', '+ static sig_atomic_t c2s_shutdown = 0;', '+ sig_atomic_t c2s_lost_router = 0;', '+ static sig_atomic_t c2s_logrotate = 0;', '+ ', '+ static void _c2s_signal(int signum)', '+ {', '+     c2s_shutdown = 1;', '+     c2s_lost_router = 0;', '+ }', '+ ', '+ static void _c2s_signal_hup(int signum)', '+ {', '+     c2s_logrotate = 1;', '+ }', '+ ', '+ static void _c2s_pidfile(c2s_t c2s) {', '+     char *pidfile;', '+     FILE *f;', '+     pid_t pid;', '+ ', '+     pidfile = config_get_one(c2s->config, ""pidfile"", 0);', '+     if(pidfile == NULL)', '+         return;', '+ ', '+     pid = getpid();', '+ ', '+     if((f = fopen(pidfile, ""w+"")) == NULL) {', '+         log_write(c2s->log, LOG_ERR, ""couldn\'t open %s for writing: %s"", pidfile, strerror(errno));', '+         return;', '+     }', '+ ', '+     if(fprintf(f, ""%d"", pid) < 0) {', '+         log_write(c2s->log, LOG_ERR, ""couldn\'t write to %s: %s"", pidfile, strerror(errno));', '+         return;', '+     }', '+ ', '+     fclose(f);', '+ ', '+     log_write(c2s->log, LOG_INFO, ""process id is %d, written to %s"", pid, pidfile);', '+ }', '+ static void _c2s_config_expand(c2s_t c2s)', '+ {', '+     char *str, *ip, *mask;', '+     config_elem_t elem;', '+     int i;', '+ ', '+     c2s->id = config_get_one(c2s->config, ""id"", 0);', '+     if(c2s->id == NULL)', '+         c2s->id = ""c2s"";', '+ ', '+     c2s->router_ip = config_get_one(c2s->config, ""router.ip"", 0);', '+     if(c2s->router_ip == NULL)', '+         c2s->router_ip = ""127.0.0.1"";', '+ ', '+     c2s->router_port = j_atoi(config_get_one(c2s->config, ""router.port"", 0), 5347);', '+ ', '+     c2s->router_user = config_get_one(c2s->config, ""router.user"", 0);', '+     if(c2s->router_user == NULL)', '+         c2s->router_user = ""jabberd"";', '+     c2s->router_pass = config_get_one(c2s->config, ""router.pass"", 0);', '+     if(c2s->router_pass == NULL)', '+         c2s->router_pass = ""secret"";', '+ ', '+     c2s->router_pemfile = config_get_one(c2s->config, ""router.pemfile"", 0);', '+ ', '+     c2s->retry_init = j_atoi(config_get_one(c2s->config, ""router.retry.init"", 0), 3);', '+     c2s->retry_lost = j_atoi(config_get_one(c2s->config, ""router.retry.lost"", 0), 3);', '+     if((c2s->retry_sleep = j_atoi(config_get_one(c2s->config, ""router.retry.sleep"", 0), 2)) < 1)', '+         c2s->retry_sleep = 1;', '+ ', '+     c2s->log_type = log_STDOUT;', '+     if(config_get(c2s->config, ""log"") != NULL) {', '+         if((str = config_get_attr(c2s->config, ""log"", 0, ""type"")) != NULL) {', '+             if(strcmp(str, ""file"") == 0)', '+                 c2s->log_type = log_FILE;', '+             else if(strcmp(str, ""syslog"") == 0)', '+                 c2s->log_type = log_SYSLOG;', '+         }', '+     }', '+ ', '+     if(c2s->log_type == log_SYSLOG) {', '+         c2s->log_facility = config_get_one(c2s->config, ""log.facility"", 0);', '+         c2s->log_ident = config_get_one(c2s->config, ""log.ident"", 0);', '+         if(c2s->log_ident == NULL)', '+             c2s->log_ident = ""jabberd/c2s"";', '+     } else if(c2s->log_type == log_FILE)', '+         c2s->log_ident = config_get_one(c2s->config, ""log.file"", 0);', '+ ', '+     c2s->local_ip = config_get_one(c2s->config, ""local.ip"", 0);', '+     if(c2s->local_ip == NULL)', '+         c2s->local_ip = ""0.0.0.0"";', '+ ', '+     c2s->local_port = j_atoi(config_get_one(c2s->config, ""local.port"", 0), 0);', '+ ', '+     c2s->local_pemfile = config_get_one(c2s->config, ""local.pemfile"", 0);', '+ ', '+     if(config_get(c2s->config, ""local.require-starttls"") != NULL)', '+         c2s->local_require_starttls = 1;', '+ ', '+     c2s->local_cachain = config_get_one(c2s->config, ""local.cachain"", 0);', '+ ', '+     c2s->local_verify_mode = j_atoi(config_get_one(c2s->config, ""local.verify-mode"", 0), 0);', '+ ', '+     c2s->local_ssl_port = j_atoi(config_get_one(c2s->config, ""local.ssl-port"", 0), 0);', '+ ', '+     c2s->io_max_fds = j_atoi(config_get_one(c2s->config, ""io.max_fds"", 0), 1024);', '+ ', '+     c2s->io_check_interval = j_atoi(config_get_one(c2s->config, ""io.check.interval"", 0), 0);', '+     c2s->io_check_idle = j_atoi(config_get_one(c2s->config, ""io.check.idle"", 0), 0);', '+     c2s->io_check_keepalive = j_atoi(config_get_one(c2s->config, ""io.check.keepalive"", 0), 0);', '+ ', '+     c2s->ar_module_name = config_get_one(c2s->config, ""authreg.module"", 0);', '+ ', '+     c2s->ar_register_enable = (config_get(c2s->config, ""authreg.register.enable"") != NULL);', '+     if(c2s->ar_register_enable) {', '+         c2s->ar_register_instructions = config_get_one(c2s->config, ""authreg.register.instructions"", 0);', '+         if(c2s->ar_register_instructions == NULL)', '+             c2s->ar_register_instructions = ""Enter a username and password to register with this server."";', '+     } else', '+         c2s->ar_register_password = (config_get(c2s->config, ""authreg.register.password"") != NULL);', '+ ', '+     if(config_get(c2s->config, ""authreg.mechanisms.traditional.plain"") != NULL) c2s->ar_mechanisms |= AR_MECH_TRAD_PLAIN;', '+     if(config_get(c2s->config, ""authreg.mechanisms.traditional.digest"") != NULL) c2s->ar_mechanisms |= AR_MECH_TRAD_DIGEST;', '+     if(config_get(c2s->config, ""authreg.mechanisms.traditional.zerok"") != NULL) c2s->ar_mechanisms |= AR_MECH_TRAD_ZEROK;', '+ ', '+     elem = config_get(c2s->config, ""io.limits.bytes"");', '+     if(elem != NULL)', '+     {', '+         c2s->byte_rate_total = j_atoi(elem->values[0], 0);', '+         if(c2s->byte_rate_total != 0)', '+         {', '+             c2s->byte_rate_seconds = j_atoi(j_attr((const char **) elem->attrs[0], ""seconds""), 1);', '+             c2s->byte_rate_wait = j_atoi(j_attr((const char **) elem->attrs[0], ""throttle""), 5);', '+         }', '+     }', '+ ', '+     elem = config_get(c2s->config, ""io.limits.connects"");', '+     if(elem != NULL)', '+     {', '+         c2s->conn_rate_total = j_atoi(elem->values[0], 0);', '+         if(c2s->conn_rate_total != 0)', '+         {', '+             c2s->conn_rate_seconds = j_atoi(j_attr((const char **) elem->attrs[0], ""seconds""), 5);', '+             c2s->conn_rate_wait = j_atoi(j_attr((const char **) elem->attrs[0], ""throttle""), 5);', '+         }', '+     }', '+ ', '+     str = config_get_one(c2s->config, ""io.access.order"", 0);', '+     if(str == NULL || strcmp(str, ""deny,allow"") != 0)', '+         c2s->access = access_new(0);', '+     else', '+         c2s->access = access_new(1);', '+ ', '+     elem = config_get(c2s->config, ""io.access.allow"");', '+     if(elem != NULL)', '+     {', '+         for(i = 0; i < elem->nvalues; i++)', '+         {', '+             ip = j_attr((const char **) elem->attrs[i], ""ip"");', '+             mask = j_attr((const char **) elem->attrs[i], ""mask"");', '+ ', '+             if(ip == NULL)', '+                 continue;', '+ ', '+             if(mask == NULL)', '+                 mask = ""255.255.255.255"";', '+ ', '+             access_allow(c2s->access, ip, mask);', '+         }', '+     }', '+ ', '+     elem = config_get(c2s->config, ""io.access.deny"");', '+     if(elem != NULL)', '+     {', '+         for(i = 0; i < elem->nvalues; i++)', '+         {', '+             ip = j_attr((const char **) elem->attrs[i], ""ip"");', '+             mask = j_attr((const char **) elem->attrs[i], ""mask"");', '+ ', '+             if(ip == NULL)', '+                 continue;', '+ ', '+             if(mask == NULL)', '+                 mask = ""255.255.255.255"";', '+ ', '+             access_deny(c2s->access, ip, mask);', '+         }', '+     }', '+ }', '+ ', '+ static int _c2s_router_connect(c2s_t c2s) {', '+     log_write(c2s->log, LOG_NOTICE, ""attempting connection to router at %s, port=%d"", c2s->router_ip, c2s->router_port);', '+ ', '+     c2s->fd = mio_connect(c2s->mio, c2s->router_port, c2s->router_ip, c2s_router_mio_callback, (void *) c2s);', '+     if(c2s->fd < 0) {', '+         if(errno == ECONNREFUSED)', '+             c2s_lost_router = 1;', '+         log_write(c2s->log, LOG_NOTICE, ""connection attempt to router failed: %s (%d)"", strerror(errno), errno);', '+         return 1;', '+     }', '+ ', '+     c2s->router = sx_new(c2s->sx_env, c2s->fd, c2s_router_sx_callback, (void *) c2s);', '+     sx_client_init(c2s->router, 0, NULL, NULL, NULL, ""1.0"");', '+ ', '+     return 0;', '+ }', '+ ', '+ static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {', '+     c2s_t c2s = (c2s_t) cbarg;', '+     char *my_realm, *mech;', '+     sx_sasl_creds_t creds;', '+     static char buf[3072];', '+     char mechbuf[256];', '+     struct jid_st jid;', '+     jid_static_buf jid_buf;', '+     int i, r;', '+ ', '+     jid_static(&jid,&jid_buf);', '+ ', '+     switch(cb) {', '+         case sx_sasl_cb_GET_REALM:', '+ ', '+ ', '+             strncpy(buf, my_realm, 256);', '+             *res = buf;', '+ ', '+             log_debug(ZONE, ""sx sasl callback: get realm: realm is \'%s\'"", buf);', '+             return sx_sasl_ret_OK;', '+             break;', '+ ', '+         case sx_sasl_cb_GET_PASS:', '+             creds = (sx_sasl_creds_t) arg;', '+ ', '+             log_debug(ZONE, ""sx sasl callback: get pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);', '+ ', '+             if(c2s->ar->get_password && (c2s->ar->get_password)(c2s->ar, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm: """", buf) == 0) {', '+                 *res = buf;', '+                 return sx_sasl_ret_OK;', '+ \t    }', '+ ', '+             return sx_sasl_ret_FAIL;', '+ ', '+         case sx_sasl_cb_CHECK_PASS:', '+             creds = (sx_sasl_creds_t) arg;', '+ ', '+             log_debug(ZONE, ""sx sasl callback: check pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);', '+ ', '+             if(c2s->ar->check_password != NULL) {', '+                 if ((c2s->ar->check_password)(c2s->ar, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", (char *)creds->pass) == 0)', '+                     return sx_sasl_ret_OK;', '+                 else', '+                     return sx_sasl_ret_FAIL;', '+             }', '+ ', '+             if(c2s->ar->get_password != NULL) {', '+                 if ((c2s->ar->get_password)(c2s->ar, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", buf) != 0)', '+                     return sx_sasl_ret_FAIL;', '+ ', '+                 if (strcmp(creds->pass, buf)==0)', '+                     return sx_sasl_ret_OK;', '+             }', '+ ', '+             return sx_sasl_ret_FAIL;', '+             break;', '+ ', '+         case sx_sasl_cb_CHECK_AUTHZID:', '+             creds = (sx_sasl_creds_t) arg;', '+ ', ""+             if(creds->authzid == NULL || creds->authzid[0] == '\\0') {"", '+                 snprintf(buf, 3072, ""%s@%s"", creds->authnid, s->req_to);', '+                 creds->authzid = (void *)buf;', '+             }', '+ ', '+             jid.pc = c2s->pc;', '+             if(jid_reset(&jid, creds->authzid, -1) == NULL)', '+                 return sx_sasl_ret_FAIL;', '+ ', '+             if(strcmp(jid.domain, s->req_to) != 0)', '+                 return sx_sasl_ret_FAIL;', '+ ', ""+             if(jid.resource[0] != '\\0')"", '+                 return sx_sasl_ret_FAIL;', '+ ', '+ ', '+             if((c2s->ar->user_exists)(c2s->ar, (char *)creds->authnid, (char *)creds->realm))', '+                 return sx_sasl_ret_OK;', '+ ', '+             return sx_sasl_ret_FAIL;', '+ ', '+         case sx_sasl_cb_GEN_AUTHZID:', '+             jid.pc = c2s->pc;', '+             jid_reset(&jid, s->req_to, -1);', '+ ', '+             jid_random_part(&jid, jid_NODE);', '+ ', '+             strcpy(buf, jid_full(&jid));', '+ ', '+             *res = (void *)buf;', '+ ', '+             return sx_sasl_ret_OK;', '+             break;', '+ ', '+         case sx_sasl_cb_CHECK_MECH:', '+             mech = (char *)arg;', '+ ', '+             i=0;', ""+             while(i<sizeof(mechbuf) && mech[i]!='\\0') {"", '+                 mechbuf[i]=tolower(mech[i]);', '+                 i++;', '+             }', ""+             mechbuf[i]='\\0';"", '+ ', '+             r = snprintf(buf, sizeof(buf), ""authreg.mechanisms.sasl.%s"",mechbuf);', '+             if (r < -1 || r > sizeof(buf))', '+                 return sx_sasl_ret_FAIL;', '+ ', '+             if(config_get(c2s->config,buf) != NULL)', '+                 return sx_sasl_ret_OK;', '+             else', '+                 return sx_sasl_ret_FAIL;', '+         default:', '+             break;', '+     }', '+ ', '+     return sx_sasl_ret_FAIL;', '+ }', '+ static void _c2s_time_checks(c2s_t c2s) {', '+     sess_t sess;', '+     time_t now;', '+     union xhashv xhv;', '+ ', '+     now = time(NULL);', '+ ', '+     if(xhash_iter_first(c2s->sessions))', '+         do {', '+             xhv.sess_val = &sess;', '+             xhash_iter_get(c2s->sessions, NULL, xhv.val);', '+ ', '+             if(c2s->io_check_idle > 0 && now > sess->last_activity + c2s->io_check_idle) {', '+                 log_write(c2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] timed out"", sess->fd, sess->ip, sess->port);', '+ ', '+                 sx_error(sess->s, stream_err_HOST_GONE, ""connection timed out"");', '+                 sx_close(sess->s);', '+ ', '+                 continue;', '+             }', '+ ', '+             if(c2s->io_check_keepalive > 0 && now > sess->last_activity + c2s->io_check_keepalive && sess->s->state >= state_STREAM) {', '+                 log_debug(ZONE, ""sending keepalive for %d"", sess->fd);', '+ ', '+                 sx_raw_write(sess->s, "" "", 1);', '+             }', '+ ', '+         } while(xhash_iter_next(c2s->sessions));', '+ }', '+ ', '+ int main(int argc, char **argv)', '+ {', '+     c2s_t c2s;', '+     char *config_file, *realm;', '+     char id[1024];', '+     int i, sd_flags, optchar;', '+     config_elem_t elem;', '+     sess_t sess;', '+     union xhashv xhv;', '+ #ifdef POOL_DEBUG', '+     time_t pool_time = 0;', '+ #endif', '+ ', '+ #ifdef HAVE_UMASK', '+     umask((mode_t) 0027);', '+ #endif', '+ ', '+     srand(time(NULL));', '+ ', '+ #ifdef HAVE_WINSOCK2_H', '+ \t{', '+ \t\tWORD wVersionRequested;', '+ \t\tWSADATA wsaData;', '+ \t\tint err;', '+ ', '+ \t\twVersionRequested = MAKEWORD( 2, 2 );', '+ ', '+ \t\terr = WSAStartup( wVersionRequested, &wsaData );', '+ \t\tif ( err != 0 ) {', '+ \t\t\treturn 0;', '+ \t\t}', '+ \t}', '+ #endif', '+ ', '+     jabber_signal(SIGINT, _c2s_signal);', '+     jabber_signal(SIGTERM, _c2s_signal);', '+ #ifdef SIGHUP', '+     jabber_signal(SIGHUP, _c2s_signal_hup);', '+ #endif', '+ #ifdef SIGPIPE', '+     jabber_signal(SIGPIPE, SIG_IGN);', '+ #endif', '+ ', '+     c2s = (c2s_t) malloc(sizeof(struct c2s_st));', '+     memset(c2s, 0, sizeof(struct c2s_st));', '+ ', '+     c2s->config = config_new();', '+ ', '+     config_file = CONFIG_DIR ""/c2s.xml"";', '+ ', '+     while((optchar = getopt(argc, argv, ""Dc:h?"")) >= 0)', '+     {', '+         switch(optchar)', '+         {', ""+             case 'c':"", '+                 config_file = optarg;', '+                 break;', ""+             case 'D':"", '+ #ifdef DEBUG', '+                 set_debug_flag(1);', '+ #else', '+                 printf(""WARN: Debugging not enabled.  Ignoring -D.\\n"");', '+ #endif', '+                 break;', ""+             case 'h': case '?': default:"", '+                 fputs(', '+                     ""c2s - jabberd client-to-server connector ("" VERSION "")\\n""', '+                     ""Usage: c2s <options>\\n""', '+                     ""Options are:\\n""', '+                     ""   -c <config>     config file to use [default: "" CONFIG_DIR ""/c2s.xml]\\n""', '+ #ifdef DEBUG', '+                     ""   -D              Show debug output\\n""', '+ #endif', '+                     ,', '+                     stdout);', '+                 config_free(c2s->config);', '+                 free(c2s);', '+                 return 1;', '+         }', '+     }', '+ ', '+     if(config_load(c2s->config, config_file) != 0)', '+     {', '+         fputs(""c2s: couldn\'t load config, aborting\\n"", stderr);', '+         config_free(c2s->config);', '+         free(c2s);', '+         return 2;', '+     }', '+ ', '+     _c2s_config_expand(c2s);', '+ ', '+     c2s->log = log_new(c2s->log_type, c2s->log_ident, c2s->log_facility);', '+     log_write(c2s->log, LOG_NOTICE, ""starting up"");', '+ ', '+     _c2s_pidfile(c2s);', '+ ', '+     if(c2s->ar_module_name == NULL)', '+     {', '+         log_write(c2s->log, LOG_ERR, ""no authreg module specified in config file"");', '+         exit(1);', '+     }', '+ ', '+     if((c2s->ar = authreg_init(c2s, c2s->ar_module_name)) == NULL)', '+         exit(1);', '+ ', '+     c2s->pc = prep_cache_new();', '+ ', '+     c2s->sessions = xhash_new(1023);', '+ ', '+     c2s->conn_rates = xhash_new(101);', '+ ', '+     c2s->dead = jqueue_new();', '+ ', '+     c2s->dead_sess = jqueue_new();', '+ ', '+     c2s->sx_env = sx_env_new();', '+ ', '+ #ifdef HAVE_SSL', '+     if(c2s->local_pemfile != NULL) {', '+         c2s->sx_ssl = sx_env_plugin(c2s->sx_env, sx_ssl_init, c2s->local_pemfile, c2s->local_cachain, c2s->local_verify_mode);', '+         if(c2s->sx_ssl == NULL) {', '+             log_write(c2s->log, LOG_ERR, ""failed to load local SSL pemfile, SSL will not be available to clients"");', '+             c2s->local_pemfile = NULL;', '+         }', '+     }', '+ ', '+     if(c2s->sx_ssl == NULL && c2s->router_pemfile != NULL) {', '+         c2s->sx_ssl = sx_env_plugin(c2s->sx_env, sx_ssl_init, c2s->router_pemfile, NULL);', '+         if(c2s->sx_ssl == NULL) {', '+             log_write(c2s->log, LOG_ERR, ""failed to load router SSL pemfile, channel to router will not be SSL encrypted"");', '+             c2s->router_pemfile = NULL;', '+         }', '+     }', '+ #endif', '+ ', '+     sd_flags = 0;', '+ ', '+     c2s->sx_sasl = sx_env_plugin(c2s->sx_env, sx_sasl_init, ""xmpp"", sd_flags, _c2s_sx_sasl_callback, (void *) c2s, sd_flags);', '+     if(c2s->sx_sasl == NULL) {', '+         log_write(c2s->log, LOG_ERR, ""failed to initialise SASL context, aborting"");', '+         exit(1);', '+     }', '+ ', '+     sx_env_plugin(c2s->sx_env, bind_init);', '+ ', '+     c2s->mio = mio_new(c2s->io_max_fds);', '+ ', '+     c2s->realms = xhash_new(51);', '+ ', '+     elem = config_get(c2s->config, ""local.id"");', '+     for(i = 0; i < elem->nvalues; i++) {', '+         realm = j_attr((const char **) elem->attrs[i], ""realm"");', '+ ', '+         strncpy(id, elem->values[i], 1024);', ""+         id[1023] = '\\0';"", '+ #ifdef HAVE_IDN', '+         if (stringprep_nameprep(id, 1024) != 0) {', '+            log_write(c2s->log, LOG_ERR, ""cannot stringprep id %s, aborting"", id);', '+            exit(1);', '+         }', '+ #endif', '+         xhash_put(c2s->realms, pstrdup(xhash_pool(c2s->realms), id), (realm != NULL) ? realm : pstrdup(xhash_pool(c2s->realms), id));', '+ ', '+         log_write(c2s->log, LOG_NOTICE, ""[%s] configured; realm=%s"", id, realm);', '+     }', '+ ', '+     c2s->sm_avail = xhash_new(51);', '+ ', '+     c2s->retry_left = c2s->retry_init;', '+     _c2s_router_connect(c2s);', '+ ', '+     while(!c2s_shutdown) {', '+         mio_run(c2s->mio, 5);', '+ ', '+         if(c2s_logrotate) {', '+             log_write(c2s->log, LOG_NOTICE, ""reopening log ..."");', '+             log_free(c2s->log);', '+             c2s->log = log_new(c2s->log_type, c2s->log_ident, c2s->log_facility);', '+             log_write(c2s->log, LOG_NOTICE, ""log started"");', '+ ', '+             c2s_logrotate = 0;', '+         }', '+ ', '+         if(c2s_lost_router) {', '+             if(c2s->retry_left < 0) {', '+                 log_write(c2s->log, LOG_NOTICE, ""attempting reconnect"");', '+                 sleep(c2s->retry_sleep);', '+                 c2s_lost_router = 0;', '+                 _c2s_router_connect(c2s);', '+             }', '+ ', '+             else if(c2s->retry_left == 0) {', '+                 c2s_shutdown = 1;', '+             }', '+ ', '+             else {', '+                 log_write(c2s->log, LOG_NOTICE, ""attempting reconnect (%d left)"", c2s->retry_left);', '+                 c2s->retry_left--;', '+                 sleep(c2s->retry_sleep);', '+                 c2s_lost_router = 0;', '+                 _c2s_router_connect(c2s);', '+             }', '+         }', '+ ', '+         while(jqueue_size(c2s->dead_sess) > 0) {', '+             sess = (sess_t) jqueue_pull(c2s->dead_sess);', '+ ', '+             if(sess->ip != NULL) free(sess->ip);', '+             if(sess->result != NULL) nad_free(sess->result);', '+             if(sess->jid != NULL) jid_free(sess->jid);', '+ ', '+             free(sess);', '+         }', '+ ', '+         while(jqueue_size(c2s->dead) > 0)', '+             sx_free((sx_t) jqueue_pull(c2s->dead));', '+ ', '+         if(c2s->io_check_interval > 0 && time(NULL) >= c2s->next_check) {', '+             log_debug(ZONE, ""running time checks"");', '+ ', '+             _c2s_time_checks(c2s);', '+ ', '+             c2s->next_check = time(NULL) + c2s->io_check_interval;', '+             log_debug(ZONE, ""next time check at %d"", c2s->next_check);', '+         }', '+ ', '+ #ifdef POOL_DEBUG', '+         if(time(NULL) > pool_time + 60) {', '+             pool_stat(1);', '+             pool_time = time(NULL);', '+         }', '+ #endif', '+     }', '+ ', '+     log_write(c2s->log, LOG_NOTICE, ""shutting down"");', '+ ', '+     if(xhash_iter_first(c2s->sessions))', '+         do {', '+             xhv.sess_val = &sess;', '+             xhash_iter_get(c2s->sessions, NULL, xhv.val);', '+ ', '+             if(sess->active)', '+                 sx_close(sess->s);', '+ ', '+         } while(xhash_iter_next(c2s->sessions));', '+ ', '+     while(jqueue_size(c2s->dead_sess) > 0) {', '+         sess = (sess_t) jqueue_pull(c2s->dead_sess);', '+ ', '+         if(sess->ip != NULL) free(sess->ip);', '+         if(sess->result != NULL) nad_free(sess->result);', '+         if(sess->jid != NULL) jid_free(sess->jid);', '+ ', '+         free(sess);', '+     }', '+ ', '+     while(jqueue_size(c2s->dead) > 0)', '+         sx_free((sx_t) jqueue_pull(c2s->dead));', '+ ', '+     sx_free(c2s->router);', '+ ', '+     sx_env_free(c2s->sx_env);', '+ ', '+     mio_free(c2s->mio);', '+ ', '+     xhash_free(c2s->sessions);', '+ ', '+     prep_cache_free(c2s->pc);', '+ ', '+     authreg_free(c2s->ar);', '+ ', '+     xhash_free(c2s->conn_rates);', '+ ', '+     xhash_free(c2s->sm_avail);', '+ ', '+     xhash_free(c2s->realms);', '+ ', '+     jqueue_free(c2s->dead);', '+ ', '+     jqueue_free(c2s->dead_sess);', '+ ', '+     access_free(c2s->access);', '+ ', '+     log_free(c2s->log);', '+ ', '+     config_free(c2s->config);', '+ ', '+     free(c2s);', '+ ', '+ #ifdef POOL_DEBUG', '+     pool_stat(1);', '+ #endif', '+ ', '+ #ifdef HAVE_WINSOCK2_H', '+     WSACleanup();', '+ #endif', '+ ', '+     return 0;', '+ }']]","[['+ ', '+ #include ""c2s.h""', '+ ', '+ #ifdef have_idn', '+ #include <stringprep.h>', '+ #endif', '+ ', '+ static sig_atomic_t c2s_shutdown = 0;', '+ sig_atomic_t c2s_lost_router = 0;', '+ static sig_atomic_t c2s_logrotate = 0;', '+ ', '+ static void _c2s_signal(int signum)', '+ {', '+     c2s_shutdown = 1;', '+     c2s_lost_router = 0;', '+ }', '+ ', '+ static void _c2s_signal_hup(int signum)', '+ {', '+     c2s_logrotate = 1;', '+ }', '+ ', '+ static void _c2s_pidfile(c2s_t c2s) {', '+     char *pidfile;', '+     file *f;', '+     pid_t pid;', '+ ', '+     pidfile = config_get_one(c2s->config, ""pidfile"", 0);', '+     if(pidfile == null)', '+         return;', '+ ', '+     pid = getpid();', '+ ', '+     if((f = fopen(pidfile, ""w+"")) == null) {', '+         log_write(c2s->log, log_err, ""couldn\'t open %s for writing: %s"", pidfile, strerror(errno));', '+         return;', '+     }', '+ ', '+     if(fprintf(f, ""%d"", pid) < 0) {', '+         log_write(c2s->log, log_err, ""couldn\'t write to %s: %s"", pidfile, strerror(errno));', '+         return;', '+     }', '+ ', '+     fclose(f);', '+ ', '+     log_write(c2s->log, log_info, ""process id is %d, written to %s"", pid, pidfile);', '+ }', '+ static void _c2s_config_expand(c2s_t c2s)', '+ {', '+     char *str, *ip, *mask;', '+     config_elem_t elem;', '+     int i;', '+ ', '+     c2s->id = config_get_one(c2s->config, ""id"", 0);', '+     if(c2s->id == null)', '+         c2s->id = ""c2s"";', '+ ', '+     c2s->router_ip = config_get_one(c2s->config, ""router.ip"", 0);', '+     if(c2s->router_ip == null)', '+         c2s->router_ip = ""127.0.0.1"";', '+ ', '+     c2s->router_port = j_atoi(config_get_one(c2s->config, ""router.port"", 0), 5347);', '+ ', '+     c2s->router_user = config_get_one(c2s->config, ""router.user"", 0);', '+     if(c2s->router_user == null)', '+         c2s->router_user = ""jabberd"";', '+     c2s->router_pass = config_get_one(c2s->config, ""router.pass"", 0);', '+     if(c2s->router_pass == null)', '+         c2s->router_pass = ""secret"";', '+ ', '+     c2s->router_pemfile = config_get_one(c2s->config, ""router.pemfile"", 0);', '+ ', '+     c2s->retry_init = j_atoi(config_get_one(c2s->config, ""router.retry.init"", 0), 3);', '+     c2s->retry_lost = j_atoi(config_get_one(c2s->config, ""router.retry.lost"", 0), 3);', '+     if((c2s->retry_sleep = j_atoi(config_get_one(c2s->config, ""router.retry.sleep"", 0), 2)) < 1)', '+         c2s->retry_sleep = 1;', '+ ', '+     c2s->log_type = log_stdout;', '+     if(config_get(c2s->config, ""log"") != null) {', '+         if((str = config_get_attr(c2s->config, ""log"", 0, ""type"")) != null) {', '+             if(strcmp(str, ""file"") == 0)', '+                 c2s->log_type = log_file;', '+             else if(strcmp(str, ""syslog"") == 0)', '+                 c2s->log_type = log_syslog;', '+         }', '+     }', '+ ', '+     if(c2s->log_type == log_syslog) {', '+         c2s->log_facility = config_get_one(c2s->config, ""log.facility"", 0);', '+         c2s->log_ident = config_get_one(c2s->config, ""log.ident"", 0);', '+         if(c2s->log_ident == null)', '+             c2s->log_ident = ""jabberd/c2s"";', '+     } else if(c2s->log_type == log_file)', '+         c2s->log_ident = config_get_one(c2s->config, ""log.file"", 0);', '+ ', '+     c2s->local_ip = config_get_one(c2s->config, ""local.ip"", 0);', '+     if(c2s->local_ip == null)', '+         c2s->local_ip = ""0.0.0.0"";', '+ ', '+     c2s->local_port = j_atoi(config_get_one(c2s->config, ""local.port"", 0), 0);', '+ ', '+     c2s->local_pemfile = config_get_one(c2s->config, ""local.pemfile"", 0);', '+ ', '+     if(config_get(c2s->config, ""local.require-starttls"") != null)', '+         c2s->local_require_starttls = 1;', '+ ', '+     c2s->local_cachain = config_get_one(c2s->config, ""local.cachain"", 0);', '+ ', '+     c2s->local_verify_mode = j_atoi(config_get_one(c2s->config, ""local.verify-mode"", 0), 0);', '+ ', '+     c2s->local_ssl_port = j_atoi(config_get_one(c2s->config, ""local.ssl-port"", 0), 0);', '+ ', '+     c2s->io_max_fds = j_atoi(config_get_one(c2s->config, ""io.max_fds"", 0), 1024);', '+ ', '+     c2s->io_check_interval = j_atoi(config_get_one(c2s->config, ""io.check.interval"", 0), 0);', '+     c2s->io_check_idle = j_atoi(config_get_one(c2s->config, ""io.check.idle"", 0), 0);', '+     c2s->io_check_keepalive = j_atoi(config_get_one(c2s->config, ""io.check.keepalive"", 0), 0);', '+ ', '+     c2s->ar_module_name = config_get_one(c2s->config, ""authreg.module"", 0);', '+ ', '+     c2s->ar_register_enable = (config_get(c2s->config, ""authreg.register.enable"") != null);', '+     if(c2s->ar_register_enable) {', '+         c2s->ar_register_instructions = config_get_one(c2s->config, ""authreg.register.instructions"", 0);', '+         if(c2s->ar_register_instructions == null)', '+             c2s->ar_register_instructions = ""enter a username and password to register with this server."";', '+     } else', '+         c2s->ar_register_password = (config_get(c2s->config, ""authreg.register.password"") != null);', '+ ', '+     if(config_get(c2s->config, ""authreg.mechanisms.traditional.plain"") != null) c2s->ar_mechanisms |= ar_mech_trad_plain;', '+     if(config_get(c2s->config, ""authreg.mechanisms.traditional.digest"") != null) c2s->ar_mechanisms |= ar_mech_trad_digest;', '+     if(config_get(c2s->config, ""authreg.mechanisms.traditional.zerok"") != null) c2s->ar_mechanisms |= ar_mech_trad_zerok;', '+ ', '+     elem = config_get(c2s->config, ""io.limits.bytes"");', '+     if(elem != null)', '+     {', '+         c2s->byte_rate_total = j_atoi(elem->values[0], 0);', '+         if(c2s->byte_rate_total != 0)', '+         {', '+             c2s->byte_rate_seconds = j_atoi(j_attr((const char **) elem->attrs[0], ""seconds""), 1);', '+             c2s->byte_rate_wait = j_atoi(j_attr((const char **) elem->attrs[0], ""throttle""), 5);', '+         }', '+     }', '+ ', '+     elem = config_get(c2s->config, ""io.limits.connects"");', '+     if(elem != null)', '+     {', '+         c2s->conn_rate_total = j_atoi(elem->values[0], 0);', '+         if(c2s->conn_rate_total != 0)', '+         {', '+             c2s->conn_rate_seconds = j_atoi(j_attr((const char **) elem->attrs[0], ""seconds""), 5);', '+             c2s->conn_rate_wait = j_atoi(j_attr((const char **) elem->attrs[0], ""throttle""), 5);', '+         }', '+     }', '+ ', '+     str = config_get_one(c2s->config, ""io.access.order"", 0);', '+     if(str == null || strcmp(str, ""deny,allow"") != 0)', '+         c2s->access = access_new(0);', '+     else', '+         c2s->access = access_new(1);', '+ ', '+     elem = config_get(c2s->config, ""io.access.allow"");', '+     if(elem != null)', '+     {', '+         for(i = 0; i < elem->nvalues; i++)', '+         {', '+             ip = j_attr((const char **) elem->attrs[i], ""ip"");', '+             mask = j_attr((const char **) elem->attrs[i], ""mask"");', '+ ', '+             if(ip == null)', '+                 continue;', '+ ', '+             if(mask == null)', '+                 mask = ""255.255.255.255"";', '+ ', '+             access_allow(c2s->access, ip, mask);', '+         }', '+     }', '+ ', '+     elem = config_get(c2s->config, ""io.access.deny"");', '+     if(elem != null)', '+     {', '+         for(i = 0; i < elem->nvalues; i++)', '+         {', '+             ip = j_attr((const char **) elem->attrs[i], ""ip"");', '+             mask = j_attr((const char **) elem->attrs[i], ""mask"");', '+ ', '+             if(ip == null)', '+                 continue;', '+ ', '+             if(mask == null)', '+                 mask = ""255.255.255.255"";', '+ ', '+             access_deny(c2s->access, ip, mask);', '+         }', '+     }', '+ }', '+ ', '+ static int _c2s_router_connect(c2s_t c2s) {', '+     log_write(c2s->log, log_notice, ""attempting connection to router at %s, port=%d"", c2s->router_ip, c2s->router_port);', '+ ', '+     c2s->fd = mio_connect(c2s->mio, c2s->router_port, c2s->router_ip, c2s_router_mio_callback, (void *) c2s);', '+     if(c2s->fd < 0) {', '+         if(errno == econnrefused)', '+             c2s_lost_router = 1;', '+         log_write(c2s->log, log_notice, ""connection attempt to router failed: %s (%d)"", strerror(errno), errno);', '+         return 1;', '+     }', '+ ', '+     c2s->router = sx_new(c2s->sx_env, c2s->fd, c2s_router_sx_callback, (void *) c2s);', '+     sx_client_init(c2s->router, 0, null, null, null, ""1.0"");', '+ ', '+     return 0;', '+ }', '+ ', '+ static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {', '+     c2s_t c2s = (c2s_t) cbarg;', '+     char *my_realm, *mech;', '+     sx_sasl_creds_t creds;', '+     static char buf[3072];', '+     char mechbuf[256];', '+     struct jid_st jid;', '+     jid_static_buf jid_buf;', '+     int i, r;', '+ ', '+     jid_static(&jid,&jid_buf);', '+ ', '+     switch(cb) {', '+         case sx_sasl_cb_get_realm:', '+ ', '+ ', '+             strncpy(buf, my_realm, 256);', '+             *res = buf;', '+ ', '+             log_debug(zone, ""sx sasl callback: get realm: realm is \'%s\'"", buf);', '+             return sx_sasl_ret_ok;', '+             break;', '+ ', '+         case sx_sasl_cb_get_pass:', '+             creds = (sx_sasl_creds_t) arg;', '+ ', '+             log_debug(zone, ""sx sasl callback: get pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);', '+ ', '+             if(c2s->ar->get_password && (c2s->ar->get_password)(c2s->ar, (char *)creds->authnid, (creds->realm != null) ? (char *)creds->realm: """", buf) == 0) {', '+                 *res = buf;', '+                 return sx_sasl_ret_ok;', '+ \t    }', '+ ', '+             return sx_sasl_ret_fail;', '+ ', '+         case sx_sasl_cb_check_pass:', '+             creds = (sx_sasl_creds_t) arg;', '+ ', '+             log_debug(zone, ""sx sasl callback: check pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);', '+ ', '+             if(c2s->ar->check_password != null) {', '+                 if ((c2s->ar->check_password)(c2s->ar, (char *)creds->authnid, (creds->realm != null) ? (char *)creds->realm : """", (char *)creds->pass) == 0)', '+                     return sx_sasl_ret_ok;', '+                 else', '+                     return sx_sasl_ret_fail;', '+             }', '+ ', '+             if(c2s->ar->get_password != null) {', '+                 if ((c2s->ar->get_password)(c2s->ar, (char *)creds->authnid, (creds->realm != null) ? (char *)creds->realm : """", buf) != 0)', '+                     return sx_sasl_ret_fail;', '+ ', '+                 if (strcmp(creds->pass, buf)==0)', '+                     return sx_sasl_ret_ok;', '+             }', '+ ', '+             return sx_sasl_ret_fail;', '+             break;', '+ ', '+         case sx_sasl_cb_check_authzid:', '+             creds = (sx_sasl_creds_t) arg;', '+ ', ""+             if(creds->authzid == null || creds->authzid[0] == '\\0') {"", '+                 snprintf(buf, 3072, ""%s@%s"", creds->authnid, s->req_to);', '+                 creds->authzid = (void *)buf;', '+             }', '+ ', '+             jid.pc = c2s->pc;', '+             if(jid_reset(&jid, creds->authzid, -1) == null)', '+                 return sx_sasl_ret_fail;', '+ ', '+             if(strcmp(jid.domain, s->req_to) != 0)', '+                 return sx_sasl_ret_fail;', '+ ', ""+             if(jid.resource[0] != '\\0')"", '+                 return sx_sasl_ret_fail;', '+ ', '+ ', '+             if((c2s->ar->user_exists)(c2s->ar, (char *)creds->authnid, (char *)creds->realm))', '+                 return sx_sasl_ret_ok;', '+ ', '+             return sx_sasl_ret_fail;', '+ ', '+         case sx_sasl_cb_gen_authzid:', '+             jid.pc = c2s->pc;', '+             jid_reset(&jid, s->req_to, -1);', '+ ', '+             jid_random_part(&jid, jid_node);', '+ ', '+             strcpy(buf, jid_full(&jid));', '+ ', '+             *res = (void *)buf;', '+ ', '+             return sx_sasl_ret_ok;', '+             break;', '+ ', '+         case sx_sasl_cb_check_mech:', '+             mech = (char *)arg;', '+ ', '+             i=0;', ""+             while(i<sizeof(mechbuf) && mech[i]!='\\0') {"", '+                 mechbuf[i]=tolower(mech[i]);', '+                 i++;', '+             }', ""+             mechbuf[i]='\\0';"", '+ ', '+             r = snprintf(buf, sizeof(buf), ""authreg.mechanisms.sasl.%s"",mechbuf);', '+             if (r < -1 || r > sizeof(buf))', '+                 return sx_sasl_ret_fail;', '+ ', '+             if(config_get(c2s->config,buf) != null)', '+                 return sx_sasl_ret_ok;', '+             else', '+                 return sx_sasl_ret_fail;', '+         default:', '+             break;', '+     }', '+ ', '+     return sx_sasl_ret_fail;', '+ }', '+ static void _c2s_time_checks(c2s_t c2s) {', '+     sess_t sess;', '+     time_t now;', '+     union xhashv xhv;', '+ ', '+     now = time(null);', '+ ', '+     if(xhash_iter_first(c2s->sessions))', '+         do {', '+             xhv.sess_val = &sess;', '+             xhash_iter_get(c2s->sessions, null, xhv.val);', '+ ', '+             if(c2s->io_check_idle > 0 && now > sess->last_activity + c2s->io_check_idle) {', '+                 log_write(c2s->log, log_notice, ""[%d] [%s, port=%d] timed out"", sess->fd, sess->ip, sess->port);', '+ ', '+                 sx_error(sess->s, stream_err_host_gone, ""connection timed out"");', '+                 sx_close(sess->s);', '+ ', '+                 continue;', '+             }', '+ ', '+             if(c2s->io_check_keepalive > 0 && now > sess->last_activity + c2s->io_check_keepalive && sess->s->state >= state_stream) {', '+                 log_debug(zone, ""sending keepalive for %d"", sess->fd);', '+ ', '+                 sx_raw_write(sess->s, "" "", 1);', '+             }', '+ ', '+         } while(xhash_iter_next(c2s->sessions));', '+ }', '+ ', '+ int main(int argc, char **argv)', '+ {', '+     c2s_t c2s;', '+     char *config_file, *realm;', '+     char id[1024];', '+     int i, sd_flags, optchar;', '+     config_elem_t elem;', '+     sess_t sess;', '+     union xhashv xhv;', '+ #ifdef pool_debug', '+     time_t pool_time = 0;', '+ #endif', '+ ', '+ #ifdef have_umask', '+     umask((mode_t) 0027);', '+ #endif', '+ ', '+     srand(time(null));', '+ ', '+ #ifdef have_winsock2_h', '+ \t{', '+ \t\tword wversionrequested;', '+ \t\twsadata wsadata;', '+ \t\tint err;', '+ ', '+ \t\twversionrequested = makeword( 2, 2 );', '+ ', '+ \t\terr = wsastartup( wversionrequested, &wsadata );', '+ \t\tif ( err != 0 ) {', '+ \t\t\treturn 0;', '+ \t\t}', '+ \t}', '+ #endif', '+ ', '+     jabber_signal(sigint, _c2s_signal);', '+     jabber_signal(sigterm, _c2s_signal);', '+ #ifdef sighup', '+     jabber_signal(sighup, _c2s_signal_hup);', '+ #endif', '+ #ifdef sigpipe', '+     jabber_signal(sigpipe, sig_ign);', '+ #endif', '+ ', '+     c2s = (c2s_t) malloc(sizeof(struct c2s_st));', '+     memset(c2s, 0, sizeof(struct c2s_st));', '+ ', '+     c2s->config = config_new();', '+ ', '+     config_file = config_dir ""/c2s.xml"";', '+ ', '+     while((optchar = getopt(argc, argv, ""dc:h?"")) >= 0)', '+     {', '+         switch(optchar)', '+         {', ""+             case 'c':"", '+                 config_file = optarg;', '+                 break;', ""+             case 'd':"", '+ #ifdef debug', '+                 set_debug_flag(1);', '+ #else', '+                 printf(""warn: debugging not enabled.  ignoring -d.\\n"");', '+ #endif', '+                 break;', ""+             case 'h': case '?': default:"", '+                 fputs(', '+                     ""c2s - jabberd client-to-server connector ("" version "")\\n""', '+                     ""usage: c2s <options>\\n""', '+                     ""options are:\\n""', '+                     ""   -c <config>     config file to use [default: "" config_dir ""/c2s.xml]\\n""', '+ #ifdef debug', '+                     ""   -d              show debug output\\n""', '+ #endif', '+                     ,', '+                     stdout);', '+                 config_free(c2s->config);', '+                 free(c2s);', '+                 return 1;', '+         }', '+     }', '+ ', '+     if(config_load(c2s->config, config_file) != 0)', '+     {', '+         fputs(""c2s: couldn\'t load config, aborting\\n"", stderr);', '+         config_free(c2s->config);', '+         free(c2s);', '+         return 2;', '+     }', '+ ', '+     _c2s_config_expand(c2s);', '+ ', '+     c2s->log = log_new(c2s->log_type, c2s->log_ident, c2s->log_facility);', '+     log_write(c2s->log, log_notice, ""starting up"");', '+ ', '+     _c2s_pidfile(c2s);', '+ ', '+     if(c2s->ar_module_name == null)', '+     {', '+         log_write(c2s->log, log_err, ""no authreg module specified in config file"");', '+         exit(1);', '+     }', '+ ', '+     if((c2s->ar = authreg_init(c2s, c2s->ar_module_name)) == null)', '+         exit(1);', '+ ', '+     c2s->pc = prep_cache_new();', '+ ', '+     c2s->sessions = xhash_new(1023);', '+ ', '+     c2s->conn_rates = xhash_new(101);', '+ ', '+     c2s->dead = jqueue_new();', '+ ', '+     c2s->dead_sess = jqueue_new();', '+ ', '+     c2s->sx_env = sx_env_new();', '+ ', '+ #ifdef have_ssl', '+     if(c2s->local_pemfile != null) {', '+         c2s->sx_ssl = sx_env_plugin(c2s->sx_env, sx_ssl_init, c2s->local_pemfile, c2s->local_cachain, c2s->local_verify_mode);', '+         if(c2s->sx_ssl == null) {', '+             log_write(c2s->log, log_err, ""failed to load local ssl pemfile, ssl will not be available to clients"");', '+             c2s->local_pemfile = null;', '+         }', '+     }', '+ ', '+     if(c2s->sx_ssl == null && c2s->router_pemfile != null) {', '+         c2s->sx_ssl = sx_env_plugin(c2s->sx_env, sx_ssl_init, c2s->router_pemfile, null);', '+         if(c2s->sx_ssl == null) {', '+             log_write(c2s->log, log_err, ""failed to load router ssl pemfile, channel to router will not be ssl encrypted"");', '+             c2s->router_pemfile = null;', '+         }', '+     }', '+ #endif', '+ ', '+     sd_flags = 0;', '+ ', '+     c2s->sx_sasl = sx_env_plugin(c2s->sx_env, sx_sasl_init, ""xmpp"", sd_flags, _c2s_sx_sasl_callback, (void *) c2s, sd_flags);', '+     if(c2s->sx_sasl == null) {', '+         log_write(c2s->log, log_err, ""failed to initialise sasl context, aborting"");', '+         exit(1);', '+     }', '+ ', '+     sx_env_plugin(c2s->sx_env, bind_init);', '+ ', '+     c2s->mio = mio_new(c2s->io_max_fds);', '+ ', '+     c2s->realms = xhash_new(51);', '+ ', '+     elem = config_get(c2s->config, ""local.id"");', '+     for(i = 0; i < elem->nvalues; i++) {', '+         realm = j_attr((const char **) elem->attrs[i], ""realm"");', '+ ', '+         strncpy(id, elem->values[i], 1024);', ""+         id[1023] = '\\0';"", '+ #ifdef have_idn', '+         if (stringprep_nameprep(id, 1024) != 0) {', '+            log_write(c2s->log, log_err, ""cannot stringprep id %s, aborting"", id);', '+            exit(1);', '+         }', '+ #endif', '+         xhash_put(c2s->realms, pstrdup(xhash_pool(c2s->realms), id), (realm != null) ? realm : pstrdup(xhash_pool(c2s->realms), id));', '+ ', '+         log_write(c2s->log, log_notice, ""[%s] configured; realm=%s"", id, realm);', '+     }', '+ ', '+     c2s->sm_avail = xhash_new(51);', '+ ', '+     c2s->retry_left = c2s->retry_init;', '+     _c2s_router_connect(c2s);', '+ ', '+     while(!c2s_shutdown) {', '+         mio_run(c2s->mio, 5);', '+ ', '+         if(c2s_logrotate) {', '+             log_write(c2s->log, log_notice, ""reopening log ..."");', '+             log_free(c2s->log);', '+             c2s->log = log_new(c2s->log_type, c2s->log_ident, c2s->log_facility);', '+             log_write(c2s->log, log_notice, ""log started"");', '+ ', '+             c2s_logrotate = 0;', '+         }', '+ ', '+         if(c2s_lost_router) {', '+             if(c2s->retry_left < 0) {', '+                 log_write(c2s->log, log_notice, ""attempting reconnect"");', '+                 sleep(c2s->retry_sleep);', '+                 c2s_lost_router = 0;', '+                 _c2s_router_connect(c2s);', '+             }', '+ ', '+             else if(c2s->retry_left == 0) {', '+                 c2s_shutdown = 1;', '+             }', '+ ', '+             else {', '+                 log_write(c2s->log, log_notice, ""attempting reconnect (%d left)"", c2s->retry_left);', '+                 c2s->retry_left--;', '+                 sleep(c2s->retry_sleep);', '+                 c2s_lost_router = 0;', '+                 _c2s_router_connect(c2s);', '+             }', '+         }', '+ ', '+         while(jqueue_size(c2s->dead_sess) > 0) {', '+             sess = (sess_t) jqueue_pull(c2s->dead_sess);', '+ ', '+             if(sess->ip != null) free(sess->ip);', '+             if(sess->result != null) nad_free(sess->result);', '+             if(sess->jid != null) jid_free(sess->jid);', '+ ', '+             free(sess);', '+         }', '+ ', '+         while(jqueue_size(c2s->dead) > 0)', '+             sx_free((sx_t) jqueue_pull(c2s->dead));', '+ ', '+         if(c2s->io_check_interval > 0 && time(null) >= c2s->next_check) {', '+             log_debug(zone, ""running time checks"");', '+ ', '+             _c2s_time_checks(c2s);', '+ ', '+             c2s->next_check = time(null) + c2s->io_check_interval;', '+             log_debug(zone, ""next time check at %d"", c2s->next_check);', '+         }', '+ ', '+ #ifdef pool_debug', '+         if(time(null) > pool_time + 60) {', '+             pool_stat(1);', '+             pool_time = time(null);', '+         }', '+ #endif', '+     }', '+ ', '+     log_write(c2s->log, log_notice, ""shutting down"");', '+ ', '+     if(xhash_iter_first(c2s->sessions))', '+         do {', '+             xhv.sess_val = &sess;', '+             xhash_iter_get(c2s->sessions, null, xhv.val);', '+ ', '+             if(sess->active)', '+                 sx_close(sess->s);', '+ ', '+         } while(xhash_iter_next(c2s->sessions));', '+ ', '+     while(jqueue_size(c2s->dead_sess) > 0) {', '+         sess = (sess_t) jqueue_pull(c2s->dead_sess);', '+ ', '+         if(sess->ip != null) free(sess->ip);', '+         if(sess->result != null) nad_free(sess->result);', '+         if(sess->jid != null) jid_free(sess->jid);', '+ ', '+         free(sess);', '+     }', '+ ', '+     while(jqueue_size(c2s->dead) > 0)', '+         sx_free((sx_t) jqueue_pull(c2s->dead));', '+ ', '+     sx_free(c2s->router);', '+ ', '+     sx_env_free(c2s->sx_env);', '+ ', '+     mio_free(c2s->mio);', '+ ', '+     xhash_free(c2s->sessions);', '+ ', '+     prep_cache_free(c2s->pc);', '+ ', '+     authreg_free(c2s->ar);', '+ ', '+     xhash_free(c2s->conn_rates);', '+ ', '+     xhash_free(c2s->sm_avail);', '+ ', '+     xhash_free(c2s->realms);', '+ ', '+     jqueue_free(c2s->dead);', '+ ', '+     jqueue_free(c2s->dead_sess);', '+ ', '+     access_free(c2s->access);', '+ ', '+     log_free(c2s->log);', '+ ', '+     config_free(c2s->config);', '+ ', '+     free(c2s);', '+ ', '+ #ifdef pool_debug', '+     pool_stat(1);', '+ #endif', '+ ', '+ #ifdef have_winsock2_h', '+     wsacleanup();', '+ #endif', '+ ', '+     return 0;', '+ }']]","[['+ ', '+ #include ""c2s.h""', '+ ', '+ #ifdef HAVE_IDN', '+ #include <stringprep.h>', '+ #endif', '+ ', '+ static sig_atomic_t c2s_shutdown = 0;', '+ sig_atomic_t c2s_lost_router = 0;', '+ static sig_atomic_t c2s_logrotate = 0;', '+ ', '+ static void _c2s_signal(int signum)', '+ {', '+     c2s_shutdown = 1;', '+     c2s_lost_router = 0;', '+ }', '+ ', '+ static void _c2s_signal_hup(int signum)', '+ {', '+     c2s_logrotate = 1;', '+ }', '+ ', '+ static void _c2s_pidfile(c2s_t c2s) {', '+     char *pidfile;', '+     FILE *f;', '+     pid_t pid;', '+ ', '+     pidfile = config_get_one(c2s->config, ""pidfile"", 0);', '+     if(pidfile == NULL)', '+         return;', '+ ', '+     pid = getpid();', '+ ', '+     if((f = fopen(pidfile, ""w+"")) == NULL) {', '+         log_write(c2s->log, LOG_ERR, ""couldn\'t open %s for writing: %s"", pidfile, strerror(errno));', '+         return;', '+     }', '+ ', '+     if(fprintf(f, ""%d"", pid) < 0) {', '+         log_write(c2s->log, LOG_ERR, ""couldn\'t write to %s: %s"", pidfile, strerror(errno));', '+         return;', '+     }', '+ ', '+     fclose(f);', '+ ', '+     log_write(c2s->log, LOG_INFO, ""process id is %d, written to %s"", pid, pidfile);', '+ }', '+ static void _c2s_config_expand(c2s_t c2s)', '+ {', '+     char *str, *ip, *mask;', '+     config_elem_t elem;', '+     int i;', '+ ', '+     c2s->id = config_get_one(c2s->config, ""id"", 0);', '+     if(c2s->id == NULL)', '+         c2s->id = ""c2s"";', '+ ', '+     c2s->router_ip = config_get_one(c2s->config, ""router.ip"", 0);', '+     if(c2s->router_ip == NULL)', '+         c2s->router_ip = ""127.0.0.1"";', '+ ', '+     c2s->router_port = j_atoi(config_get_one(c2s->config, ""router.port"", 0), 5347);', '+ ', '+     c2s->router_user = config_get_one(c2s->config, ""router.user"", 0);', '+     if(c2s->router_user == NULL)', '+         c2s->router_user = ""jabberd"";', '+     c2s->router_pass = config_get_one(c2s->config, ""router.pass"", 0);', '+     if(c2s->router_pass == NULL)', '+         c2s->router_pass = ""secret"";', '+ ', '+     c2s->router_pemfile = config_get_one(c2s->config, ""router.pemfile"", 0);', '+ ', '+     c2s->retry_init = j_atoi(config_get_one(c2s->config, ""router.retry.init"", 0), 3);', '+     c2s->retry_lost = j_atoi(config_get_one(c2s->config, ""router.retry.lost"", 0), 3);', '+     if((c2s->retry_sleep = j_atoi(config_get_one(c2s->config, ""router.retry.sleep"", 0), 2)) < 1)', '+         c2s->retry_sleep = 1;', '+ ', '+     c2s->log_type = log_STDOUT;', '+     if(config_get(c2s->config, ""log"") != NULL) {', '+         if((str = config_get_attr(c2s->config, ""log"", 0, ""type"")) != NULL) {', '+             if(strcmp(str, ""file"") == 0)', '+                 c2s->log_type = log_FILE;', '+             else if(strcmp(str, ""syslog"") == 0)', '+                 c2s->log_type = log_SYSLOG;', '+         }', '+     }', '+ ', '+     if(c2s->log_type == log_SYSLOG) {', '+         c2s->log_facility = config_get_one(c2s->config, ""log.facility"", 0);', '+         c2s->log_ident = config_get_one(c2s->config, ""log.ident"", 0);', '+         if(c2s->log_ident == NULL)', '+             c2s->log_ident = ""jabberd/c2s"";', '+     } else if(c2s->log_type == log_FILE)', '+         c2s->log_ident = config_get_one(c2s->config, ""log.file"", 0);', '+ ', '+     c2s->local_ip = config_get_one(c2s->config, ""local.ip"", 0);', '+     if(c2s->local_ip == NULL)', '+         c2s->local_ip = ""0.0.0.0"";', '+ ', '+     c2s->local_port = j_atoi(config_get_one(c2s->config, ""local.port"", 0), 0);', '+ ', '+     c2s->local_pemfile = config_get_one(c2s->config, ""local.pemfile"", 0);', '+ ', '+     if(config_get(c2s->config, ""local.require-starttls"") != NULL)', '+         c2s->local_require_starttls = 1;', '+ ', '+     c2s->local_cachain = config_get_one(c2s->config, ""local.cachain"", 0);', '+ ', '+     c2s->local_verify_mode = j_atoi(config_get_one(c2s->config, ""local.verify-mode"", 0), 0);', '+ ', '+     c2s->local_ssl_port = j_atoi(config_get_one(c2s->config, ""local.ssl-port"", 0), 0);', '+ ', '+     c2s->io_max_fds = j_atoi(config_get_one(c2s->config, ""io.max_fds"", 0), 1024);', '+ ', '+     c2s->io_check_interval = j_atoi(config_get_one(c2s->config, ""io.check.interval"", 0), 0);', '+     c2s->io_check_idle = j_atoi(config_get_one(c2s->config, ""io.check.idle"", 0), 0);', '+     c2s->io_check_keepalive = j_atoi(config_get_one(c2s->config, ""io.check.keepalive"", 0), 0);', '+ ', '+     c2s->ar_module_name = config_get_one(c2s->config, ""authreg.module"", 0);', '+ ', '+     c2s->ar_register_enable = (config_get(c2s->config, ""authreg.register.enable"") != NULL);', '+     if(c2s->ar_register_enable) {', '+         c2s->ar_register_instructions = config_get_one(c2s->config, ""authreg.register.instructions"", 0);', '+         if(c2s->ar_register_instructions == NULL)', '+             c2s->ar_register_instructions = ""Enter a username and password to register with this server."";', '+     } else', '+         c2s->ar_register_password = (config_get(c2s->config, ""authreg.register.password"") != NULL);', '+ ', '+     if(config_get(c2s->config, ""authreg.mechanisms.traditional.plain"") != NULL) c2s->ar_mechanisms |= AR_MECH_TRAD_PLAIN;', '+     if(config_get(c2s->config, ""authreg.mechanisms.traditional.digest"") != NULL) c2s->ar_mechanisms |= AR_MECH_TRAD_DIGEST;', '+     if(config_get(c2s->config, ""authreg.mechanisms.traditional.zerok"") != NULL) c2s->ar_mechanisms |= AR_MECH_TRAD_ZEROK;', '+ ', '+     elem = config_get(c2s->config, ""io.limits.bytes"");', '+     if(elem != NULL)', '+     {', '+         c2s->byte_rate_total = j_atoi(elem->values[0], 0);', '+         if(c2s->byte_rate_total != 0)', '+         {', '+             c2s->byte_rate_seconds = j_atoi(j_attr((const char **) elem->attrs[0], ""seconds""), 1);', '+             c2s->byte_rate_wait = j_atoi(j_attr((const char **) elem->attrs[0], ""throttle""), 5);', '+         }', '+     }', '+ ', '+     elem = config_get(c2s->config, ""io.limits.connects"");', '+     if(elem != NULL)', '+     {', '+         c2s->conn_rate_total = j_atoi(elem->values[0], 0);', '+         if(c2s->conn_rate_total != 0)', '+         {', '+             c2s->conn_rate_seconds = j_atoi(j_attr((const char **) elem->attrs[0], ""seconds""), 5);', '+             c2s->conn_rate_wait = j_atoi(j_attr((const char **) elem->attrs[0], ""throttle""), 5);', '+         }', '+     }', '+ ', '+     str = config_get_one(c2s->config, ""io.access.order"", 0);', '+     if(str == NULL || strcmp(str, ""deny,allow"") != 0)', '+         c2s->access = access_new(0);', '+     else', '+         c2s->access = access_new(1);', '+ ', '+     elem = config_get(c2s->config, ""io.access.allow"");', '+     if(elem != NULL)', '+     {', '+         for(i = 0; i < elem->nvalues; i++)', '+         {', '+             ip = j_attr((const char **) elem->attrs[i], ""ip"");', '+             mask = j_attr((const char **) elem->attrs[i], ""mask"");', '+ ', '+             if(ip == NULL)', '+                 continue;', '+ ', '+             if(mask == NULL)', '+                 mask = ""255.255.255.255"";', '+ ', '+             access_allow(c2s->access, ip, mask);', '+         }', '+     }', '+ ', '+     elem = config_get(c2s->config, ""io.access.deny"");', '+     if(elem != NULL)', '+     {', '+         for(i = 0; i < elem->nvalues; i++)', '+         {', '+             ip = j_attr((const char **) elem->attrs[i], ""ip"");', '+             mask = j_attr((const char **) elem->attrs[i], ""mask"");', '+ ', '+             if(ip == NULL)', '+                 continue;', '+ ', '+             if(mask == NULL)', '+                 mask = ""255.255.255.255"";', '+ ', '+             access_deny(c2s->access, ip, mask);', '+         }', '+     }', '+ }', '+ ', '+ static int _c2s_router_connect(c2s_t c2s) {', '+     log_write(c2s->log, LOG_NOTICE, ""attempting connection to router at %s, port=%d"", c2s->router_ip, c2s->router_port);', '+ ', '+     c2s->fd = mio_connect(c2s->mio, c2s->router_port, c2s->router_ip, c2s_router_mio_callback, (void *) c2s);', '+     if(c2s->fd < 0) {', '+         if(errno == ECONNREFUSED)', '+             c2s_lost_router = 1;', '+         log_write(c2s->log, LOG_NOTICE, ""connection attempt to router failed: %s (%d)"", strerror(errno), errno);', '+         return 1;', '+     }', '+ ', '+     c2s->router = sx_new(c2s->sx_env, c2s->fd, c2s_router_sx_callback, (void *) c2s);', '+     sx_client_init(c2s->router, 0, NULL, NULL, NULL, ""1.0"");', '+ ', '+     return 0;', '+ }', '+ ', '+ static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {', '+     c2s_t c2s = (c2s_t) cbarg;', '+     char *my_realm, *mech;', '+     sx_sasl_creds_t creds;', '+     static char buf[3072];', '+     char mechbuf[256];', '+     struct jid_st jid;', '+     jid_static_buf jid_buf;', '+     int i, r;', '+ ', '+     jid_static(&jid,&jid_buf);', '+ ', '+     switch(cb) {', '+         case sx_sasl_cb_GET_REALM:', '+ ', '+ ', '+             strncpy(buf, my_realm, 256);', '+             *res = buf;', '+ ', '+             log_debug(ZONE, ""sx sasl callback: get realm: realm is \'%s\'"", buf);', '+             return sx_sasl_ret_OK;', '+             break;', '+ ', '+         case sx_sasl_cb_GET_PASS:', '+             creds = (sx_sasl_creds_t) arg;', '+ ', '+             log_debug(ZONE, ""sx sasl callback: get pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);', '+ ', '+             if(c2s->ar->get_password && (c2s->ar->get_password)(c2s->ar, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm: """", buf) == 0) {', '+                 *res = buf;', '+                 return sx_sasl_ret_OK;', '+ \t    }', '+ ', '+             return sx_sasl_ret_FAIL;', '+ ', '+         case sx_sasl_cb_CHECK_PASS:', '+             creds = (sx_sasl_creds_t) arg;', '+ ', '+             log_debug(ZONE, ""sx sasl callback: check pass (authnid=%s, realm=%s)"", creds->authnid, creds->realm);', '+ ', '+             if(c2s->ar->check_password != NULL) {', '+                 if ((c2s->ar->check_password)(c2s->ar, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", (char *)creds->pass) == 0)', '+                     return sx_sasl_ret_OK;', '+                 else', '+                     return sx_sasl_ret_FAIL;', '+             }', '+ ', '+             if(c2s->ar->get_password != NULL) {', '+                 if ((c2s->ar->get_password)(c2s->ar, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : """", buf) != 0)', '+                     return sx_sasl_ret_FAIL;', '+ ', '+                 if (strcmp(creds->pass, buf)==0)', '+                     return sx_sasl_ret_OK;', '+             }', '+ ', '+             return sx_sasl_ret_FAIL;', '+             break;', '+ ', '+         case sx_sasl_cb_CHECK_AUTHZID:', '+             creds = (sx_sasl_creds_t) arg;', '+ ', ""+             if(creds->authzid == NULL || creds->authzid[0] == '\\0') {"", '+                 snprintf(buf, 3072, ""%s@%s"", creds->authnid, s->req_to);', '+                 creds->authzid = (void *)buf;', '+             }', '+ ', '+             jid.pc = c2s->pc;', '+             if(jid_reset(&jid, creds->authzid, -1) == NULL)', '+                 return sx_sasl_ret_FAIL;', '+ ', '+             if(strcmp(jid.domain, s->req_to) != 0)', '+                 return sx_sasl_ret_FAIL;', '+ ', ""+             if(jid.resource[0] != '\\0')"", '+                 return sx_sasl_ret_FAIL;', '+ ', '+ ', '+             if((c2s->ar->user_exists)(c2s->ar, (char *)creds->authnid, (char *)creds->realm))', '+                 return sx_sasl_ret_OK;', '+ ', '+             return sx_sasl_ret_FAIL;', '+ ', '+         case sx_sasl_cb_GEN_AUTHZID:', '+             jid.pc = c2s->pc;', '+             jid_reset(&jid, s->req_to, -1);', '+ ', '+             jid_random_part(&jid, jid_NODE);', '+ ', '+             strcpy(buf, jid_full(&jid));', '+ ', '+             *res = (void *)buf;', '+ ', '+             return sx_sasl_ret_OK;', '+             break;', '+ ', '+         case sx_sasl_cb_CHECK_MECH:', '+             mech = (char *)arg;', '+ ', '+             i=0;', ""+             while(i<sizeof(mechbuf) && mech[i]!='\\0') {"", '+                 mechbuf[i]=tolower(mech[i]);', '+                 i++;', '+             }', ""+             mechbuf[i]='\\0';"", '+ ', '+             r = snprintf(buf, sizeof(buf), ""authreg.mechanisms.sasl.%s"",mechbuf);', '+             if (r < -1 || r > sizeof(buf))', '+                 return sx_sasl_ret_FAIL;', '+ ', '+             if(config_get(c2s->config,buf) != NULL)', '+                 return sx_sasl_ret_OK;', '+             else', '+                 return sx_sasl_ret_FAIL;', '+         default:', '+             break;', '+     }', '+ ', '+     return sx_sasl_ret_FAIL;', '+ }', '+ static void _c2s_time_checks(c2s_t c2s) {', '+     sess_t sess;', '+     time_t now;', '+     union xhashv xhv;', '+ ', '+     now = time(NULL);', '+ ', '+     if(xhash_iter_first(c2s->sessions))', '+         do {', '+             xhv.sess_val = &sess;', '+             xhash_iter_get(c2s->sessions, NULL, xhv.val);', '+ ', '+             if(c2s->io_check_idle > 0 && now > sess->last_activity + c2s->io_check_idle) {', '+                 log_write(c2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] timed out"", sess->fd, sess->ip, sess->port);', '+ ', '+                 sx_error(sess->s, stream_err_HOST_GONE, ""connection timed out"");', '+                 sx_close(sess->s);', '+ ', '+                 continue;', '+             }', '+ ', '+             if(c2s->io_check_keepalive > 0 && now > sess->last_activity + c2s->io_check_keepalive && sess->s->state >= state_STREAM) {', '+                 log_debug(ZONE, ""sending keepalive for %d"", sess->fd);', '+ ', '+                 sx_raw_write(sess->s, "" "", 1);', '+             }', '+ ', '+         } while(xhash_iter_next(c2s->sessions));', '+ }', '+ ', '+ int main(int argc, char **argv)', '+ {', '+     c2s_t c2s;', '+     char *config_file, *realm;', '+     char id[1024];', '+     int i, sd_flags, optchar;', '+     config_elem_t elem;', '+     sess_t sess;', '+     union xhashv xhv;', '+ #ifdef POOL_DEBUG', '+     time_t pool_time = 0;', '+ #endif', '+ ', '+ #ifdef HAVE_UMASK', '+     umask((mode_t) 0027);', '+ #endif', '+ ', '+     srand(time(NULL));', '+ ', '+ #ifdef HAVE_WINSOCK2_H', '+ \t{', '+ \t\tWORD wVersionRequested;', '+ \t\tWSADATA wsaData;', '+ \t\tint err;', '+ ', '+ \t\twVersionRequested = MAKEWORD( 2, 2 );', '+ ', '+ \t\terr = WSAStartup( wVersionRequested, &wsaData );', '+ \t\tif ( err != 0 ) {', '+ \t\t\treturn 0;', '+ \t\t}', '+ \t}', '+ #endif', '+ ', '+     jabber_signal(SIGINT, _c2s_signal);', '+     jabber_signal(SIGTERM, _c2s_signal);', '+ #ifdef SIGHUP', '+     jabber_signal(SIGHUP, _c2s_signal_hup);', '+ #endif', '+ #ifdef SIGPIPE', '+     jabber_signal(SIGPIPE, SIG_IGN);', '+ #endif', '+ ', '+     c2s = (c2s_t) malloc(sizeof(struct c2s_st));', '+     memset(c2s, 0, sizeof(struct c2s_st));', '+ ', '+     c2s->config = config_new();', '+ ', '+     config_file = CONFIG_DIR ""/c2s.xml"";', '+ ', '+     while((optchar = getopt(argc, argv, ""Dc:h?"")) >= 0)', '+     {', '+         switch(optchar)', '+         {', ""+             case 'c':"", '+                 config_file = optarg;', '+                 break;', ""+             case 'D':"", '+ #ifdef DEBUG', '+                 set_debug_flag(1);', '+ #else', '+                 printf(""WARN: Debugging not enabled.  Ignoring -D.\\n"");', '+ #endif', '+                 break;', ""+             case 'h': case '?': default:"", '+                 fputs(', '+                     ""c2s - jabberd client-to-server connector ("" VERSION "")\\n""', '+                     ""Usage: c2s <options>\\n""', '+                     ""Options are:\\n""', '+                     ""   -c <config>     config file to use [default: "" CONFIG_DIR ""/c2s.xml]\\n""', '+ #ifdef DEBUG', '+                     ""   -D              Show debug output\\n""', '+ #endif', '+                     ,', '+                     stdout);', '+                 config_free(c2s->config);', '+                 free(c2s);', '+                 return 1;', '+         }', '+     }', '+ ', '+     if(config_load(c2s->config, config_file) != 0)', '+     {', '+         fputs(""c2s: couldn\'t load config, aborting\\n"", stderr);', '+         config_free(c2s->config);', '+         free(c2s);', '+         return 2;', '+     }', '+ ', '+     _c2s_config_expand(c2s);', '+ ', '+     c2s->log = log_new(c2s->log_type, c2s->log_ident, c2s->log_facility);', '+     log_write(c2s->log, LOG_NOTICE, ""starting up"");', '+ ', '+     _c2s_pidfile(c2s);', '+ ', '+     if(c2s->ar_module_name == NULL)', '+     {', '+         log_write(c2s->log, LOG_ERR, ""no authreg module specified in config file"");', '+         exit(1);', '+     }', '+ ', '+     if((c2s->ar = authreg_init(c2s, c2s->ar_module_name)) == NULL)', '+         exit(1);', '+ ', '+     c2s->pc = prep_cache_new();', '+ ', '+     c2s->sessions = xhash_new(1023);', '+ ', '+     c2s->conn_rates = xhash_new(101);', '+ ', '+     c2s->dead = jqueue_new();', '+ ', '+     c2s->dead_sess = jqueue_new();', '+ ', '+     c2s->sx_env = sx_env_new();', '+ ', '+ #ifdef HAVE_SSL', '+     if(c2s->local_pemfile != NULL) {', '+         c2s->sx_ssl = sx_env_plugin(c2s->sx_env, sx_ssl_init, c2s->local_pemfile, c2s->local_cachain, c2s->local_verify_mode);', '+         if(c2s->sx_ssl == NULL) {', '+             log_write(c2s->log, LOG_ERR, ""failed to load local SSL pemfile, SSL will not be available to clients"");', '+             c2s->local_pemfile = NULL;', '+         }', '+     }', '+ ', '+     if(c2s->sx_ssl == NULL && c2s->router_pemfile != NULL) {', '+         c2s->sx_ssl = sx_env_plugin(c2s->sx_env, sx_ssl_init, c2s->router_pemfile, NULL);', '+         if(c2s->sx_ssl == NULL) {', '+             log_write(c2s->log, LOG_ERR, ""failed to load router SSL pemfile, channel to router will not be SSL encrypted"");', '+             c2s->router_pemfile = NULL;', '+         }', '+     }', '+ #endif', '+ ', '+     sd_flags = 0;', '+ ', '+     c2s->sx_sasl = sx_env_plugin(c2s->sx_env, sx_sasl_init, ""xmpp"", sd_flags, _c2s_sx_sasl_callback, (void *) c2s, sd_flags);', '+     if(c2s->sx_sasl == NULL) {', '+         log_write(c2s->log, LOG_ERR, ""failed to initialise SASL context, aborting"");', '+         exit(1);', '+     }', '+ ', '+     sx_env_plugin(c2s->sx_env, bind_init);', '+ ', '+     c2s->mio = mio_new(c2s->io_max_fds);', '+ ', '+     c2s->realms = xhash_new(51);', '+ ', '+     elem = config_get(c2s->config, ""local.id"");', '+     for(i = 0; i < elem->nvalues; i++) {', '+         realm = j_attr((const char **) elem->attrs[i], ""realm"");', '+ ', '+         strncpy(id, elem->values[i], 1024);', ""+         id[1023] = '\\0';"", '+ #ifdef HAVE_IDN', '+         if (stringprep_nameprep(id, 1024) != 0) {', '+            log_write(c2s->log, LOG_ERR, ""cannot stringprep id %s, aborting"", id);', '+            exit(1);', '+         }', '+ #endif', '+         xhash_put(c2s->realms, pstrdup(xhash_pool(c2s->realms), id), (realm != NULL) ? realm : pstrdup(xhash_pool(c2s->realms), id));', '+ ', '+         log_write(c2s->log, LOG_NOTICE, ""[%s] configured; realm=%s"", id, realm);', '+     }', '+ ', '+     c2s->sm_avail = xhash_new(51);', '+ ', '+     c2s->retry_left = c2s->retry_init;', '+     _c2s_router_connect(c2s);', '+ ', '+     while(!c2s_shutdown) {', '+         mio_run(c2s->mio, 5);', '+ ', '+         if(c2s_logrotate) {', '+             log_write(c2s->log, LOG_NOTICE, ""reopening log ..."");', '+             log_free(c2s->log);', '+             c2s->log = log_new(c2s->log_type, c2s->log_ident, c2s->log_facility);', '+             log_write(c2s->log, LOG_NOTICE, ""log started"");', '+ ', '+             c2s_logrotate = 0;', '+         }', '+ ', '+         if(c2s_lost_router) {', '+             if(c2s->retry_left < 0) {', '+                 log_write(c2s->log, LOG_NOTICE, ""attempting reconnect"");', '+                 sleep(c2s->retry_sleep);', '+                 c2s_lost_router = 0;', '+                 _c2s_router_connect(c2s);', '+             }', '+ ', '+             else if(c2s->retry_left == 0) {', '+                 c2s_shutdown = 1;', '+             }', '+ ', '+             else {', '+                 log_write(c2s->log, LOG_NOTICE, ""attempting reconnect (%d left)"", c2s->retry_left);', '+                 c2s->retry_left--;', '+                 sleep(c2s->retry_sleep);', '+                 c2s_lost_router = 0;', '+                 _c2s_router_connect(c2s);', '+             }', '+         }', '+ ', '+         while(jqueue_size(c2s->dead_sess) > 0) {', '+             sess = (sess_t) jqueue_pull(c2s->dead_sess);', '+ ', '+             if(sess->ip != NULL) free(sess->ip);', '+             if(sess->result != NULL) nad_free(sess->result);', '+             if(sess->jid != NULL) jid_free(sess->jid);', '+ ', '+             free(sess);', '+         }', '+ ', '+         while(jqueue_size(c2s->dead) > 0)', '+             sx_free((sx_t) jqueue_pull(c2s->dead));', '+ ', '+         if(c2s->io_check_interval > 0 && time(NULL) >= c2s->next_check) {', '+             log_debug(ZONE, ""running time checks"");', '+ ', '+             _c2s_time_checks(c2s);', '+ ', '+             c2s->next_check = time(NULL) + c2s->io_check_interval;', '+             log_debug(ZONE, ""next time check at %d"", c2s->next_check);', '+         }', '+ ', '+ #ifdef POOL_DEBUG', '+         if(time(NULL) > pool_time + 60) {', '+             pool_stat(1);', '+             pool_time = time(NULL);', '+         }', '+ #endif', '+     }', '+ ', '+     log_write(c2s->log, LOG_NOTICE, ""shutting down"");', '+ ', '+     if(xhash_iter_first(c2s->sessions))', '+         do {', '+             xhv.sess_val = &sess;', '+             xhash_iter_get(c2s->sessions, NULL, xhv.val);', '+ ', '+             if(sess->active)', '+                 sx_close(sess->s);', '+ ', '+         } while(xhash_iter_next(c2s->sessions));', '+ ', '+     while(jqueue_size(c2s->dead_sess) > 0) {', '+         sess = (sess_t) jqueue_pull(c2s->dead_sess);', '+ ', '+         if(sess->ip != NULL) free(sess->ip);', '+         if(sess->result != NULL) nad_free(sess->result);', '+         if(sess->jid != NULL) jid_free(sess->jid);', '+ ', '+         free(sess);', '+     }', '+ ', '+     while(jqueue_size(c2s->dead) > 0)', '+         sx_free((sx_t) jqueue_pull(c2s->dead));', '+ ', '+     sx_free(c2s->router);', '+ ', '+     sx_env_free(c2s->sx_env);', '+ ', '+     mio_free(c2s->mio);', '+ ', '+     xhash_free(c2s->sessions);', '+ ', '+     prep_cache_free(c2s->pc);', '+ ', '+     authreg_free(c2s->ar);', '+ ', '+     xhash_free(c2s->conn_rates);', '+ ', '+     xhash_free(c2s->sm_avail);', '+ ', '+     xhash_free(c2s->realms);', '+ ', '+     jqueue_free(c2s->dead);', '+ ', '+     jqueue_free(c2s->dead_sess);', '+ ', '+     access_free(c2s->access);', '+ ', '+     log_free(c2s->log);', '+ ', '+     config_free(c2s->config);', '+ ', '+     free(c2s);', '+ ', '+ #ifdef POOL_DEBUG', '+     pool_stat(1);', '+ #endif', '+ ', '+ #ifdef HAVE_WINSOCK2_H', '+     WSACleanup();', '+ #endif', '+ ', '+     return 0;', '+ }']]",[[]],662,0.0,662.0,4e058ee0b010abd2eab53f5ddd13ba5dca2c354ajabberd2/jabberd2,['8416ae54ecefa670534f27a31db71d048b9c7f16']
6d04d9655f29085945526bc4f9921c4724895aa2,libarchive/libarchive,untar.c,train,C,0,"['@@ -0,0 +1,211 @@\n+/*\n+ * This file is in the public domain.\n+ * Use it as you wish.\n+ */\n+\n+/*\n+ * This is a compact tar extraction program whose primary goal is\n+ * small size.  Statically linked, it can be under 64k, depending on\n+ * how cleanly factored your system libraries are.  Note that this\n+ * uses the standard libarchive, without any special recompilation.\n+ * The only functional concession is that this program uses the\n+ * uid/gid from the archive instead of doing uname/gname lookups.\n+ * (Call archive_write_disk_set_standard_lookup() to enable\n+ * uname/gname lookups, but be aware that this can add 500k or more to\n+ * a static executable, depending on the system libraries.)\n+ *\n+ * To build:\n+ * gcc -static -Wall -o untar untar.c -larchive\n+ * strip untar\n+ *\n+ * For fun, statically compile the following simple hello.c program\n+ * and compare the size.  (On my system, the result is 89k, untar is\n+ * 69k.)\n+ *\n+ * #include <stdio.h>\n+ * int main(int argc, char **argv) {\n+ *    printf(""hello, world\\n"");\n+ *    return(0);\n+ * }\n+ */\n+\n+#include <sys/types.h>\n+__FBSDID(""$FreeBSD$"");\n+\n+#include <sys/stat.h>\n+\n+#include <archive.h>\n+#include <archive_entry.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+static void\terrmsg(const char *);\n+static void\textract(const char *filename, int do_extract, int flags);\n+static int\tcopy_data(struct archive *, struct archive *);\n+static void\tmsg(const char *);\n+static void\tusage(void);\n+\n+static int verbose = 0;\n+\n+int\n+main(int argc, const char **argv)\n+{\n+\tconst char *filename = NULL;\n+\tint compress, flags, mode, opt;\n+\n+\t(void)argc;\n+\tmode = \'x\';\n+\tverbose = 0;\n+\tcompress = \'\\0\';\n+\tflags = ARCHIVE_EXTRACT_TIME;\n+\n+\t/* Among other sins, getopt(3) pulls in printf(3). */\n+\twhile (*++argv != NULL && **argv == \'-\') {\n+\t\tconst char *p = *argv + 1;\n+\n+\t\twhile ((opt = *p++) != \'\\0\') {\n+\t\t\tswitch (opt) {\n+\t\t\tcase \'f\':\n+\t\t\t\tif (*p != \'\\0\')\n+\t\t\t\t\tfilename = p;\n+\t\t\t\telse\n+\t\t\t\t\tfilename = *++argv;\n+\t\t\t\tp += strlen(p);\n+\t\t\t\tbreak;\n+\t\t\tcase \'p\':\n+\t\t\t\tflags |= ARCHIVE_EXTRACT_PERM;\n+\t\t\t\tflags |= ARCHIVE_EXTRACT_ACL;\n+\t\t\t\tflags |= ARCHIVE_EXTRACT_FFLAGS;\n+\t\t\t\tbreak;\n+\t\t\tcase \'t\':\n+\t\t\t\tmode = opt;\n+\t\t\t\tbreak;\n+\t\t\tcase \'v\':\n+\t\t\t\tverbose++;\n+\t\t\t\tbreak;\n+\t\t\tcase \'x\':\n+\t\t\t\tmode = opt;\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tusage();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tswitch (mode) {\n+\tcase \'t\':\n+\t\textract(filename, 0, flags);\n+\t\tbreak;\n+\tcase \'x\':\n+\t\textract(filename, 1, flags);\n+\t\tbreak;\n+\t}\n+\n+\treturn (0);\n+}\n+\n+\n+static void\n+extract(const char *filename, int do_extract, int flags)\n+{\n+\tstruct archive *a;\n+\tstruct archive *ext;\n+\tstruct archive_entry *entry;\n+\tint r;\n+\n+\ta = archive_read_new();\n+\text = archive_write_disk_new();\n+\tarchive_write_disk_set_options(ext, flags);\n+\t/*\n+\t * Note: archive_write_disk_set_standard_lookup() is useful\n+\t * here, but it requires library routines that can add 500k or\n+\t * more to a static executable.\n+\t */\n+\tarchive_read_support_format_tar(a);\n+\t/*\n+\t * On my system, enabling other archive formats adds 20k-30k\n+\t * each.  Enabling gzip decompression adds about 20k.\n+\t * Enabling bzip2 is more expensive because the libbz2 library\n+\t * isn\'t very well factored.\n+\t */\n+\tif (filename != NULL && strcmp(filename, ""-"") == 0)\n+\t\tfilename = NULL;\n+\tif ((r = archive_read_open_file(a, filename, 10240))) {\n+\t\terrmsg(archive_error_string(a));\n+\t\terrmsg(""\\n"");\n+\t\texit(r);\n+\t}\n+\tfor (;;) {\n+\t\tr = archive_read_next_header(a, &entry);\n+\t\tif (r == ARCHIVE_EOF)\n+\t\t\tbreak;\n+\t\tif (r != ARCHIVE_OK) {\n+\t\t\terrmsg(archive_error_string(a));\n+\t\t\terrmsg(""\\n"");\n+\t\t\texit(1);\n+\t\t}\n+\t\tif (verbose && do_extract)\n+\t\t\tmsg(""x "");\n+\t\tif (verbose || !do_extract)\n+\t\t\tmsg(archive_entry_pathname(entry));\n+\t\tif (do_extract) {\n+\t\t\tr = archive_write_header(ext, entry);\n+\t\t\tif (r != ARCHIVE_OK)\n+\t\t\t\terrmsg(archive_error_string(a));\n+\t\t\telse\n+\t\t\t\tcopy_data(a, ext);\n+\t\t}\n+\t\tif (verbose || !do_extract)\n+\t\t\tmsg(""\\n"");\n+\t}\n+\tarchive_read_close(a);\n+\tarchive_read_finish(a);\n+\texit(0);\n+}\n+\n+static int\n+copy_data(struct archive *ar, struct archive *aw)\n+{\n+\tint r;\n+\tconst void *buff;\n+\tsize_t size;\n+\toff_t offset;\n+\n+\tfor (;;) {\n+\t\tr = archive_read_data_block(ar, &buff, &size, &offset);\n+\t\tif (r == ARCHIVE_EOF) {\n+\t\t\terrmsg(archive_error_string(ar));\n+\t\t\treturn (ARCHIVE_OK);\n+\t\t}\n+\t\tif (r != ARCHIVE_OK)\n+\t\t\treturn (r);\n+\t\tr = archive_write_data_block(aw, buff, size, offset);\n+\t\tif (r != ARCHIVE_OK) {\n+\t\t\terrmsg(archive_error_string(ar));\n+\t\t\treturn (r);\n+\t\t}\n+\t}\n+}\n+\n+static void\n+msg(const char *m)\n+{\n+\twrite(1, m, strlen(m));\n+}\n+\n+static void\n+errmsg(const char *m)\n+{\n+\twrite(2, m, strlen(m));\n+}\n+\n+static void\n+usage(void)\n+{\n+\tconst char *m = ""Usage: untar [-tvx] [-f file] [file]\\n"";\n+\terrmsg(m);\n+\texit(1);\n+}\n']",,,"['+ #include <sys/types.h>', '+ __FBSDID(""$FreeBSD$"");', '+ #include <sys/stat.h>', '+ #include <archive.h>', '+ #include <archive_entry.h>', '+ #include <fcntl.h>', '+ #include <stdio.h>', '+ #include <stdlib.h>', '+ #include <string.h>', '+ #include <unistd.h>', '+ static void\terrmsg(const char *);', '+ static void\textract(const char *filename, int do_extract, int flags);', '+ static int\tcopy_data(struct archive *, struct archive *);', '+ static void\tmsg(const char *);', '+ static void\tusage(void);', '+ static int verbose = 0;', '+ int', '+ main(int argc, const char **argv)', '+ {', '+ \tconst char *filename = NULL;', '+ \tint compress, flags, mode, opt;', '+ \t(void)argc;', ""+ \tmode = 'x';"", '+ \tverbose = 0;', ""+ \tcompress = '\\0';"", '+ \tflags = ARCHIVE_EXTRACT_TIME;', ""+ \twhile (*++argv != NULL && **argv == '-') {"", '+ \t\tconst char *p = *argv + 1;', ""+ \t\twhile ((opt = *p++) != '\\0') {"", '+ \t\t\tswitch (opt) {', ""+ \t\t\tcase 'f':"", ""+ \t\t\t\tif (*p != '\\0')"", '+ \t\t\t\t\tfilename = p;', '+ \t\t\t\telse', '+ \t\t\t\t\tfilename = *++argv;', '+ \t\t\t\tp += strlen(p);', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 'p':"", '+ \t\t\t\tflags |= ARCHIVE_EXTRACT_PERM;', '+ \t\t\t\tflags |= ARCHIVE_EXTRACT_ACL;', '+ \t\t\t\tflags |= ARCHIVE_EXTRACT_FFLAGS;', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 't':"", '+ \t\t\t\tmode = opt;', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 'v':"", '+ \t\t\t\tverbose++;', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 'x':"", '+ \t\t\t\tmode = opt;', '+ \t\t\t\tbreak;', '+ \t\t\tdefault:', '+ \t\t\t\tusage();', '+ \t\t\t}', '+ \t\t}', '+ \t}', '+ \tswitch (mode) {', ""+ \tcase 't':"", '+ \t\textract(filename, 0, flags);', '+ \t\tbreak;', ""+ \tcase 'x':"", '+ \t\textract(filename, 1, flags);', '+ \t\tbreak;', '+ \t}', '+ \treturn (0);', '+ }', '+ static void', '+ extract(const char *filename, int do_extract, int flags)', '+ {', '+ \tstruct archive *a;', '+ \tstruct archive *ext;', '+ \tstruct archive_entry *entry;', '+ \tint r;', '+ \ta = archive_read_new();', '+ \text = archive_write_disk_new();', '+ \tarchive_write_disk_set_options(ext, flags);', '+ \tarchive_read_support_format_tar(a);', '+ \tif (filename != NULL && strcmp(filename, ""-"") == 0)', '+ \t\tfilename = NULL;', '+ \tif ((r = archive_read_open_file(a, filename, 10240))) {', '+ \t\terrmsg(archive_error_string(a));', '+ \t\terrmsg(""\\n"");', '+ \t\texit(r);', '+ \t}', '+ \tfor (;;) {', '+ \t\tr = archive_read_next_header(a, &entry);', '+ \t\tif (r == ARCHIVE_EOF)', '+ \t\t\tbreak;', '+ \t\tif (r != ARCHIVE_OK) {', '+ \t\t\terrmsg(archive_error_string(a));', '+ \t\t\terrmsg(""\\n"");', '+ \t\t\texit(1);', '+ \t\t}', '+ \t\tif (verbose && do_extract)', '+ \t\t\tmsg(""x "");', '+ \t\tif (verbose || !do_extract)', '+ \t\t\tmsg(archive_entry_pathname(entry));', '+ \t\tif (do_extract) {', '+ \t\t\tr = archive_write_header(ext, entry);', '+ \t\t\tif (r != ARCHIVE_OK)', '+ \t\t\t\terrmsg(archive_error_string(a));', '+ \t\t\telse', '+ \t\t\t\tcopy_data(a, ext);', '+ \t\t}', '+ \t\tif (verbose || !do_extract)', '+ \t\t\tmsg(""\\n"");', '+ \t}', '+ \tarchive_read_close(a);', '+ \tarchive_read_finish(a);', '+ \texit(0);', '+ }', '+ static int', '+ copy_data(struct archive *ar, struct archive *aw)', '+ {', '+ \tint r;', '+ \tconst void *buff;', '+ \tsize_t size;', '+ \toff_t offset;', '+ \tfor (;;) {', '+ \t\tr = archive_read_data_block(ar, &buff, &size, &offset);', '+ \t\tif (r == ARCHIVE_EOF) {', '+ \t\t\terrmsg(archive_error_string(ar));', '+ \t\t\treturn (ARCHIVE_OK);', '+ \t\t}', '+ \t\tif (r != ARCHIVE_OK)', '+ \t\t\treturn (r);', '+ \t\tr = archive_write_data_block(aw, buff, size, offset);', '+ \t\tif (r != ARCHIVE_OK) {', '+ \t\t\terrmsg(archive_error_string(ar));', '+ \t\t\treturn (r);', '+ \t\t}', '+ \t}', '+ }', '+ static void', '+ msg(const char *m)', '+ {', '+ \twrite(1, m, strlen(m));', '+ }', '+ static void', '+ errmsg(const char *m)', '+ {', '+ \twrite(2, m, strlen(m));', '+ }', '+ static void', '+ usage(void)', '+ {', '+ \tconst char *m = ""Usage: untar [-tvx] [-f file] [file]\\n"";', '+ \terrmsg(m);', '+ \texit(1);', '+ }']","['+ #include <sys/types.h>', '+ __fbsdid(""$freebsd$"");', '+ #include <sys/stat.h>', '+ #include <archive.h>', '+ #include <archive_entry.h>', '+ #include <fcntl.h>', '+ #include <stdio.h>', '+ #include <stdlib.h>', '+ #include <string.h>', '+ #include <unistd.h>', '+ static void\terrmsg(const char *);', '+ static void\textract(const char *filename, int do_extract, int flags);', '+ static int\tcopy_data(struct archive *, struct archive *);', '+ static void\tmsg(const char *);', '+ static void\tusage(void);', '+ static int verbose = 0;', '+ int', '+ main(int argc, const char **argv)', '+ {', '+ \tconst char *filename = null;', '+ \tint compress, flags, mode, opt;', '+ \t(void)argc;', ""+ \tmode = 'x';"", '+ \tverbose = 0;', ""+ \tcompress = '\\0';"", '+ \tflags = archive_extract_time;', ""+ \twhile (*++argv != null && **argv == '-') {"", '+ \t\tconst char *p = *argv + 1;', ""+ \t\twhile ((opt = *p++) != '\\0') {"", '+ \t\t\tswitch (opt) {', ""+ \t\t\tcase 'f':"", ""+ \t\t\t\tif (*p != '\\0')"", '+ \t\t\t\t\tfilename = p;', '+ \t\t\t\telse', '+ \t\t\t\t\tfilename = *++argv;', '+ \t\t\t\tp += strlen(p);', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 'p':"", '+ \t\t\t\tflags |= archive_extract_perm;', '+ \t\t\t\tflags |= archive_extract_acl;', '+ \t\t\t\tflags |= archive_extract_fflags;', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 't':"", '+ \t\t\t\tmode = opt;', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 'v':"", '+ \t\t\t\tverbose++;', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 'x':"", '+ \t\t\t\tmode = opt;', '+ \t\t\t\tbreak;', '+ \t\t\tdefault:', '+ \t\t\t\tusage();', '+ \t\t\t}', '+ \t\t}', '+ \t}', '+ \tswitch (mode) {', ""+ \tcase 't':"", '+ \t\textract(filename, 0, flags);', '+ \t\tbreak;', ""+ \tcase 'x':"", '+ \t\textract(filename, 1, flags);', '+ \t\tbreak;', '+ \t}', '+ \treturn (0);', '+ }', '+ static void', '+ extract(const char *filename, int do_extract, int flags)', '+ {', '+ \tstruct archive *a;', '+ \tstruct archive *ext;', '+ \tstruct archive_entry *entry;', '+ \tint r;', '+ \ta = archive_read_new();', '+ \text = archive_write_disk_new();', '+ \tarchive_write_disk_set_options(ext, flags);', '+ \tarchive_read_support_format_tar(a);', '+ \tif (filename != null && strcmp(filename, ""-"") == 0)', '+ \t\tfilename = null;', '+ \tif ((r = archive_read_open_file(a, filename, 10240))) {', '+ \t\terrmsg(archive_error_string(a));', '+ \t\terrmsg(""\\n"");', '+ \t\texit(r);', '+ \t}', '+ \tfor (;;) {', '+ \t\tr = archive_read_next_header(a, &entry);', '+ \t\tif (r == archive_eof)', '+ \t\t\tbreak;', '+ \t\tif (r != archive_ok) {', '+ \t\t\terrmsg(archive_error_string(a));', '+ \t\t\terrmsg(""\\n"");', '+ \t\t\texit(1);', '+ \t\t}', '+ \t\tif (verbose && do_extract)', '+ \t\t\tmsg(""x "");', '+ \t\tif (verbose || !do_extract)', '+ \t\t\tmsg(archive_entry_pathname(entry));', '+ \t\tif (do_extract) {', '+ \t\t\tr = archive_write_header(ext, entry);', '+ \t\t\tif (r != archive_ok)', '+ \t\t\t\terrmsg(archive_error_string(a));', '+ \t\t\telse', '+ \t\t\t\tcopy_data(a, ext);', '+ \t\t}', '+ \t\tif (verbose || !do_extract)', '+ \t\t\tmsg(""\\n"");', '+ \t}', '+ \tarchive_read_close(a);', '+ \tarchive_read_finish(a);', '+ \texit(0);', '+ }', '+ static int', '+ copy_data(struct archive *ar, struct archive *aw)', '+ {', '+ \tint r;', '+ \tconst void *buff;', '+ \tsize_t size;', '+ \toff_t offset;', '+ \tfor (;;) {', '+ \t\tr = archive_read_data_block(ar, &buff, &size, &offset);', '+ \t\tif (r == archive_eof) {', '+ \t\t\terrmsg(archive_error_string(ar));', '+ \t\t\treturn (archive_ok);', '+ \t\t}', '+ \t\tif (r != archive_ok)', '+ \t\t\treturn (r);', '+ \t\tr = archive_write_data_block(aw, buff, size, offset);', '+ \t\tif (r != archive_ok) {', '+ \t\t\terrmsg(archive_error_string(ar));', '+ \t\t\treturn (r);', '+ \t\t}', '+ \t}', '+ }', '+ static void', '+ msg(const char *m)', '+ {', '+ \twrite(1, m, strlen(m));', '+ }', '+ static void', '+ errmsg(const char *m)', '+ {', '+ \twrite(2, m, strlen(m));', '+ }', '+ static void', '+ usage(void)', '+ {', '+ \tconst char *m = ""usage: untar [-tvx] [-f file] [file]\\n"";', '+ \terrmsg(m);', '+ \texit(1);', '+ }']","['+ #include <sys/types.h>', '+ __FBSDID(""$FreeBSD$"");', '+ #include <sys/stat.h>', '+ #include <archive.h>', '+ #include <archive_entry.h>', '+ #include <fcntl.h>', '+ #include <stdio.h>', '+ #include <stdlib.h>', '+ #include <string.h>', '+ #include <unistd.h>', '+ static void\terrmsg(const char *);', '+ static void\textract(const char *filename, int do_extract, int flags);', '+ static int\tcopy_data(struct archive *, struct archive *);', '+ static void\tmsg(const char *);', '+ static void\tusage(void);', '+ static int verbose = 0;', '+ int', '+ main(int argc, const char **argv)', '+ {', '+ \tconst char *filename = NULL;', '+ \tint compress, flags, mode, opt;', '+ \t(void)argc;', ""+ \tmode = 'x';"", '+ \tverbose = 0;', ""+ \tcompress = '\\0';"", '+ \tflags = ARCHIVE_EXTRACT_TIME;', ""+ \twhile (*++argv != NULL && **argv == '-') {"", '+ \t\tconst char *p = *argv + 1;', ""+ \t\twhile ((opt = *p++) != '\\0') {"", '+ \t\t\tswitch (opt) {', ""+ \t\t\tcase 'f':"", ""+ \t\t\t\tif (*p != '\\0')"", '+ \t\t\t\t\tfilename = p;', '+ \t\t\t\telse', '+ \t\t\t\t\tfilename = *++argv;', '+ \t\t\t\tp += strlen(p);', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 'p':"", '+ \t\t\t\tflags |= ARCHIVE_EXTRACT_PERM;', '+ \t\t\t\tflags |= ARCHIVE_EXTRACT_ACL;', '+ \t\t\t\tflags |= ARCHIVE_EXTRACT_FFLAGS;', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 't':"", '+ \t\t\t\tmode = opt;', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 'v':"", '+ \t\t\t\tverbose++;', '+ \t\t\t\tbreak;', ""+ \t\t\tcase 'x':"", '+ \t\t\t\tmode = opt;', '+ \t\t\t\tbreak;', '+ \t\t\tdefault:', '+ \t\t\t\tusage();', '+ \t\t\t}', '+ \t\t}', '+ \t}', '+ \tswitch (mode) {', ""+ \tcase 't':"", '+ \t\textract(filename, 0, flags);', '+ \t\tbreak;', ""+ \tcase 'x':"", '+ \t\textract(filename, 1, flags);', '+ \t\tbreak;', '+ \t}', '+ \treturn (0);', '+ }', '+ static void', '+ extract(const char *filename, int do_extract, int flags)', '+ {', '+ \tstruct archive *a;', '+ \tstruct archive *ext;', '+ \tstruct archive_entry *entry;', '+ \tint r;', '+ \ta = archive_read_new();', '+ \text = archive_write_disk_new();', '+ \tarchive_write_disk_set_options(ext, flags);', '+ \tarchive_read_support_format_tar(a);', '+ \tif (filename != NULL && strcmp(filename, ""-"") == 0)', '+ \t\tfilename = NULL;', '+ \tif ((r = archive_read_open_file(a, filename, 10240))) {', '+ \t\terrmsg(archive_error_string(a));', '+ \t\terrmsg(""\\n"");', '+ \t\texit(r);', '+ \t}', '+ \tfor (;;) {', '+ \t\tr = archive_read_next_header(a, &entry);', '+ \t\tif (r == ARCHIVE_EOF)', '+ \t\t\tbreak;', '+ \t\tif (r != ARCHIVE_OK) {', '+ \t\t\terrmsg(archive_error_string(a));', '+ \t\t\terrmsg(""\\n"");', '+ \t\t\texit(1);', '+ \t\t}', '+ \t\tif (verbose && do_extract)', '+ \t\t\tmsg(""x "");', '+ \t\tif (verbose || !do_extract)', '+ \t\t\tmsg(archive_entry_pathname(entry));', '+ \t\tif (do_extract) {', '+ \t\t\tr = archive_write_header(ext, entry);', '+ \t\t\tif (r != ARCHIVE_OK)', '+ \t\t\t\terrmsg(archive_error_string(a));', '+ \t\t\telse', '+ \t\t\t\tcopy_data(a, ext);', '+ \t\t}', '+ \t\tif (verbose || !do_extract)', '+ \t\t\tmsg(""\\n"");', '+ \t}', '+ \tarchive_read_close(a);', '+ \tarchive_read_finish(a);', '+ \texit(0);', '+ }', '+ static int', '+ copy_data(struct archive *ar, struct archive *aw)', '+ {', '+ \tint r;', '+ \tconst void *buff;', '+ \tsize_t size;', '+ \toff_t offset;', '+ \tfor (;;) {', '+ \t\tr = archive_read_data_block(ar, &buff, &size, &offset);', '+ \t\tif (r == ARCHIVE_EOF) {', '+ \t\t\terrmsg(archive_error_string(ar));', '+ \t\t\treturn (ARCHIVE_OK);', '+ \t\t}', '+ \t\tif (r != ARCHIVE_OK)', '+ \t\t\treturn (r);', '+ \t\tr = archive_write_data_block(aw, buff, size, offset);', '+ \t\tif (r != ARCHIVE_OK) {', '+ \t\t\terrmsg(archive_error_string(ar));', '+ \t\t\treturn (r);', '+ \t\t}', '+ \t}', '+ }', '+ static void', '+ msg(const char *m)', '+ {', '+ \twrite(1, m, strlen(m));', '+ }', '+ static void', '+ errmsg(const char *m)', '+ {', '+ \twrite(2, m, strlen(m));', '+ }', '+ static void', '+ usage(void)', '+ {', '+ \tconst char *m = ""Usage: untar [-tvx] [-f file] [file]\\n"";', '+ \terrmsg(m);', '+ \texit(1);', '+ }']",[],150,0.0,150.0,6d04d9655f29085945526bc4f9921c4724895aa2libarchive/libarchive,[]
9aa28f3730fb3dd69c1e06f78bb2bbc43d36c684,inspircd/inspircd,src/dns.cpp,train,C++,1,"['@@ -38,6 +38,8 @@ looks like this, walks like this or tastes like this.\n #include ""configreader.h""\n #include ""socket.h""\n \n+#define DN_COMP_BITMASK\t0xC000\t\t/* highest 6 bits in a DN label header */\n+\n /** Masks to mask off the responses we get from the DNSRequest methods\n  */\n enum QueryInfo\n@@ -161,7 +163,10 @@ int CachedQuery::CalcTTLRemaining()\n /* Allocate the processing buffer */\n DNSRequest::DNSRequest(DNS* dns, int rid, const std::string &original) : dnsobj(dns)\n {\n-\tres = new unsigned char[512];\n+\t/* hardening against overflow here:  make our work buffer twice the theoretical\n+\t * maximum size so that hostile input doesn\'t screw us over.\n+\t */\n+\tres = new unsigned char[sizeof(DNSHeader) * 2];\n \t*res = 0;\n \torig = original;\n \tRequestTimeout* RT = new RequestTimeout(ServerInstance->Config->dns_timeout ? ServerInstance->Config->dns_timeout : 5, this, rid);\n@@ -690,9 +695,9 @@ DNSResult DNS::GetResult()\n /** A result is ready, process it */\n DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n {\n-\tunsigned i = 0;\n+\tunsigned i = 0, o;\n \tint q = 0;\n-\tint curanswer, o;\n+\tint curanswer;\n \tResourceRecord rr;\n  \tunsigned short ptr;\n \n@@ -717,7 +722,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n \t/* Subtract the length of the header from the length of the packet */\n \tlength -= 12;\n \n-\twhile ((unsigned int)q < header.qdcount && i < length)\n+\twhile ((unsigned int)q < header.qdcount && i < (unsigned) length)\n \t{\n \t\tif (header.payload[i] > 63)\n \t\t{\n@@ -738,7 +743,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n \twhile ((unsigned)curanswer < header.ancount)\n \t{\n \t\tq = 0;\n-\t\twhile (q == 0 && i < length)\n+\t\twhile (q == 0 && i < (unsigned) length)\n \t\t{\n \t\t\tif (header.payload[i] > 63)\n \t\t\t{\n@@ -755,7 +760,7 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n \t\t\t\telse i += header.payload[i] + 1; /* skip length and label */\n \t\t\t}\n \t\t}\n-\t\tif (length - i < 10)\n+\t\tif ((unsigned) length - i < 10)\n \t\t\treturn std::make_pair((unsigned char*)NULL,""Incorrectly sized DNS reply"");\n \n \t\t/* XXX: We actually initialise \'rr\' here including its ttl field */\n@@ -790,17 +795,31 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n \n \tswitch (rr.type)\n \t{\n+\t\t/*\n+\t\t * CNAME and PTR are compressed.  We need to decompress them.\n+\t\t */\n \t\tcase DNS_QUERY_CNAME:\n-\t\t\t/* CNAME and PTR have the same processing code */\n \t\tcase DNS_QUERY_PTR:\n \t\t\to = 0;\n \t\t\tq = 0;\n-\t\t\twhile (q == 0 && i < length && o + 256 < 1023)\n+\t\t\twhile (q == 0 && i < (unsigned) length && o + 256 < 1023)\n \t\t\t{\n+\t\t\t\t/* DN label found (byte over 63) */\n \t\t\t\tif (header.payload[i] > 63)\n \t\t\t\t{\n \t\t\t\t\tmemcpy(&ptr,&header.payload[i],2);\n-\t\t\t\t\ti = ntohs(ptr) - 0xC000 - 12;\n+\n+\t\t\t\t\ti = ntohs(ptr);\n+\n+\t\t\t\t\t/* check that highest two bits are set. if not, we\'ve been had */\n+\t\t\t\t\tif (!(i & DN_COMP_BITMASK))\n+\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");\n+\n+\t\t\t\t\t/* mask away the two highest bits. */\n+\t\t\t\t\ti &= ~DN_COMP_BITMASK;\n+\n+\t\t\t\t\t/* and decrease length by 12 bytes. */\n+\t\t\t\t\ti =- 12;\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n@@ -813,7 +832,11 @@ DNSInfo DNSRequest::ResultIsReady(DNSHeader &header, int length)\n \t\t\t\t\t\tres[o] = 0;\n \t\t\t\t\t\tif (o != 0)\n \t\t\t\t\t\t\tres[o++] = \'.\';\n-\t\t\t\t\t\tmemcpy(&res[o],&header.payload[i + 1],header.payload[i]);\n+\n+\t\t\t\t\t\tif (o + header.payload[i] > sizeof(DNSHeader))\n+\t\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");\n+\n+\t\t\t\t\t\tmemcpy(&res[o], &header.payload[i + 1], header.payload[i]);\n \t\t\t\t\t\to += header.payload[i];\n \t\t\t\t\t\ti += header.payload[i] + 1;\n \t\t\t\t\t}\n']",2012-03-20 18:31:14-05:00,"dns: reject messages with lengths larger than DNSHeader with prejudice

This also includes when decompressing name entries.","[['+ ', '+ \tres = new unsigned char[sizeof(DNSHeader) * 2];', '+ \tunsigned i = 0, o;', '+ \tint curanswer;', '+ \twhile ((unsigned int)q < header.qdcount && i < (unsigned) length)', '+ \t\twhile (q == 0 && i < (unsigned) length)', '+ \t\tif ((unsigned) length - i < 10)', '+ \t\t\twhile (q == 0 && i < (unsigned) length && o + 256 < 1023)', '+ ', '+ \t\t\t\t\ti = ntohs(ptr);', '+ ', '+ \t\t\t\t\tif (!(i & DN_COMP_BITMASK))', '+ \t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");', '+ ', '+ \t\t\t\t\ti &= ~DN_COMP_BITMASK;', '+ ', '+ \t\t\t\t\ti =- 12;', '+ ', '+ \t\t\t\t\t\tif (o + header.payload[i] > sizeof(DNSHeader))', '+ \t\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");', '+ ', '+ \t\t\t\t\t\tmemcpy(&res[o], &header.payload[i + 1], header.payload[i]);', '- \tres = new unsigned char[512];', '- \tunsigned i = 0;', '- \tint curanswer, o;', '- \twhile ((unsigned int)q < header.qdcount && i < length)', '- \t\twhile (q == 0 && i < length)', '- \t\tif (length - i < 10)', '- \t\t\twhile (q == 0 && i < length && o + 256 < 1023)', '- \t\t\t\t\ti = ntohs(ptr) - 0xC000 - 12;', '- \t\t\t\t\t\tmemcpy(&res[o],&header.payload[i + 1],header.payload[i]);']]","[['+ ', '+ \tres = new unsigned char[sizeof(dnsheader) * 2];', '+ \tunsigned i = 0, o;', '+ \tint curanswer;', '+ \twhile ((unsigned int)q < header.qdcount && i < (unsigned) length)', '+ \t\twhile (q == 0 && i < (unsigned) length)', '+ \t\tif ((unsigned) length - i < 10)', '+ \t\t\twhile (q == 0 && i < (unsigned) length && o + 256 < 1023)', '+ ', '+ \t\t\t\t\ti = ntohs(ptr);', '+ ', '+ \t\t\t\t\tif (!(i & dn_comp_bitmask))', '+ \t\t\t\t\t\treturn std::make_pair((unsigned char *) null, ""dn label decompression header is bogus"");', '+ ', '+ \t\t\t\t\ti &= ~dn_comp_bitmask;', '+ ', '+ \t\t\t\t\ti =- 12;', '+ ', '+ \t\t\t\t\t\tif (o + header.payload[i] > sizeof(dnsheader))', '+ \t\t\t\t\t\t\treturn std::make_pair((unsigned char *) null, ""dn label decompression is impossible -- malformed/hostile packet?"");', '+ ', '+ \t\t\t\t\t\tmemcpy(&res[o], &header.payload[i + 1], header.payload[i]);', '- \tres = new unsigned char[512];', '- \tunsigned i = 0;', '- \tint curanswer, o;', '- \twhile ((unsigned int)q < header.qdcount && i < length)', '- \t\twhile (q == 0 && i < length)', '- \t\tif (length - i < 10)', '- \t\t\twhile (q == 0 && i < length && o + 256 < 1023)', '- \t\t\t\t\ti = ntohs(ptr) - 0xc000 - 12;', '- \t\t\t\t\t\tmemcpy(&res[o],&header.payload[i + 1],header.payload[i]);']]","[['+ ', '+ \tres = new unsigned char[sizeof(DNSHeader) * 2];', '+ \tunsigned i = 0, o;', '+ \tint curanswer;', '+ \twhile ((unsigned int)q < header.qdcount && i < (unsigned) length)', '+ \t\twhile (q == 0 && i < (unsigned) length)', '+ \t\tif ((unsigned) length - i < 10)', '+ \t\t\twhile (q == 0 && i < (unsigned) length && o + 256 < 1023)', '+ ', '+ \t\t\t\t\ti = ntohs(ptr);', '+ ', '+ \t\t\t\t\tif (!(i & DN_COMP_BITMASK))', '+ \t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, ""DN label decompression header is bogus"");', '+ ', '+ \t\t\t\t\ti &= ~DN_COMP_BITMASK;', '+ ', '+ \t\t\t\t\ti =- 12;', '+ ', '+ \t\t\t\t\t\tif (o + header.payload[i] > sizeof(DNSHeader))', '+ \t\t\t\t\t\t\treturn std::make_pair((unsigned char *) NULL, ""DN label decompression is impossible -- malformed/hostile packet?"");', '+ ', '+ \t\t\t\t\t\tmemcpy(&res[o], &header.payload[i + 1], header.payload[i]);']]","[['- \tres = new unsigned char[512];', '- \tunsigned i = 0;', '- \tint curanswer, o;', '- \twhile ((unsigned int)q < header.qdcount && i < length)', '- \t\twhile (q == 0 && i < length)', '- \t\tif (length - i < 10)', '- \t\t\twhile (q == 0 && i < length && o + 256 < 1023)', '- \t\t\t\t\ti = ntohs(ptr) - 0xC000 - 12;', '- \t\t\t\t\t\tmemcpy(&res[o],&header.payload[i + 1],header.payload[i]);']]",22,9.0,31.0,9aa28f3730fb3dd69c1e06f78bb2bbc43d36c684inspircd/inspircd,['58c893e834ff20495d00770922']
9ba0c846babebfcf79d7633396da2ae3edb29265,yoe/nbd,nbd-server.c,test,C,0,"['@@ -212,10 +212,20 @@ void connectme(int port)\n \tstruct sockaddr_in addrin;\n \tint addrinlen = sizeof(addrin);\n \tint net, sock, newpid;\n+#ifndef sun\n+\tint yes=1;\n+#else\n+\tchar yes=\'1\';\n+#endif\n \n \tif ((sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)\n \t\terr(""socket: %m"");\n \n+\t/* lose the pesky ""Address already in use"" error message */\n+\tif (setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {\n+\t        err(""setsockopt"");\n+\t}\n+\n \tDEBUG(""Waiting for connections... bind, "");\n \taddrin.sin_family = AF_INET;\n \taddrin.sin_port = htons(port);\n']",,,"['+ #ifndef sun', '+ \tint yes=1;', '+ #else', ""+ \tchar yes='1';"", '+ #endif', '+ \tif (setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {', '+ \t        err(""setsockopt"");', '+ \t}']","['+ #ifndef sun', '+ \tint yes=1;', '+ #else', ""+ \tchar yes='1';"", '+ #endif', '+ \tif (setsockopt(sock,sol_socket,so_reuseaddr,&yes,sizeof(int)) == -1) {', '+ \t        err(""setsockopt"");', '+ \t}']","['+ #ifndef sun', '+ \tint yes=1;', '+ #else', ""+ \tchar yes='1';"", '+ #endif', '+ \tif (setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {', '+ \t        err(""setsockopt"");', '+ \t}']",[],8,0.0,8.0,9ba0c846babebfcf79d7633396da2ae3edb29265yoe/nbd,[]
bce096216e558a1a51a8c9130006908314b25c0f,SpiderLabs/ModSecurity,re.c,val,C++,0,"['@@ -1168,12 +1168,32 @@ static int execute_operator(msre_var *var, msre_rule *rule, modsec_rec *msr,\n {\n     apr_time_t time_before_regex;\n     char *my_error_msg = NULL;\n+    char *full_varname = NULL;\n     int rc;\n \n+    /* determine the full var name if not already resolved\n+     *\n+     * NOTE: this can happen if the var does not match but it is \n+     * being tested for non-existance as in:\n+     *   @REQUEST_HEADERS:Foo ""@eq 0""\n+     *   @REQUEST_HEADERS:Foo ""!@eq 1""\n+     */\n+    if (var->param != NULL && var->name != NULL && strchr(var->name,\':\') == NULL) {\n+        full_varname = apr_psprintf(mptmp, ""%s%s:%s"", \n+                                    (var->is_counting ? ""&"" : """"),\n+                                    var->name, var->param);\n+    }\n+    else if ((var->name != NULL) && var->is_counting && (*var->name != \'&\')) {\n+        full_varname = apr_pstrcat(mptmp, ""&"", var->name);\n+    }\n+    else {\n+        full_varname = var->name;\n+    }\n+\n     if (msr->txcfg->debuglog_level >= 4) {\n         msr_log(msr, 4, ""Executing operator %s%s with param \\""%s\\"" against %s."",\n             (rule->op_negated ? ""!"" : """"), rule->op_name,\n-            log_escape(msr->mp, rule->op_param), var->name);\n+            log_escape(msr->mp, rule->op_param), full_varname);\n     }\n \n     if (msr->txcfg->debuglog_level >= 9) {\n@@ -1204,7 +1224,7 @@ static int execute_operator(msre_var *var, msre_rule *rule, modsec_rec *msr,\n             /* Operator did not match so we need to provide a message. */\n             my_error_msg = apr_psprintf(msr->mp, ""Match of \\""%s %s\\"" against \\""%s\\"" required."",\n                 log_escape(msr->mp, rule->op_name), log_escape(msr->mp, rule->op_param),\n-                log_escape(msr->mp, var->name));\n+                log_escape(msr->mp, full_varname));\n         }\n \n         msr->matched_var = apr_pstrdup(msr->mp, var->name);\n']",,,"['+     char *full_varname = NULL;', ""+     if (var->param != NULL && var->name != NULL && strchr(var->name,':') == NULL) {"", '+         full_varname = apr_psprintf(mptmp, ""%s%s:%s"",', '+                                     (var->is_counting ? ""&"" : """"),', '+                                     var->name, var->param);', '+     }', ""+     else if ((var->name != NULL) && var->is_counting && (*var->name != '&')) {"", '+         full_varname = apr_pstrcat(mptmp, ""&"", var->name);', '+     }', '+     else {', '+         full_varname = var->name;', '+     }', '+             log_escape(msr->mp, rule->op_param), full_varname);', '+                 log_escape(msr->mp, full_varname));', '-             log_escape(msr->mp, rule->op_param), var->name);', '-                 log_escape(msr->mp, var->name));']","['+     char *full_varname = null;', ""+     if (var->param != null && var->name != null && strchr(var->name,':') == null) {"", '+         full_varname = apr_psprintf(mptmp, ""%s%s:%s"",', '+                                     (var->is_counting ? ""&"" : """"),', '+                                     var->name, var->param);', '+     }', ""+     else if ((var->name != null) && var->is_counting && (*var->name != '&')) {"", '+         full_varname = apr_pstrcat(mptmp, ""&"", var->name);', '+     }', '+     else {', '+         full_varname = var->name;', '+     }', '+             log_escape(msr->mp, rule->op_param), full_varname);', '+                 log_escape(msr->mp, full_varname));', '-             log_escape(msr->mp, rule->op_param), var->name);', '-                 log_escape(msr->mp, var->name));']","['+     char *full_varname = NULL;', ""+     if (var->param != NULL && var->name != NULL && strchr(var->name,':') == NULL) {"", '+         full_varname = apr_psprintf(mptmp, ""%s%s:%s"",', '+                                     (var->is_counting ? ""&"" : """"),', '+                                     var->name, var->param);', '+     }', ""+     else if ((var->name != NULL) && var->is_counting && (*var->name != '&')) {"", '+         full_varname = apr_pstrcat(mptmp, ""&"", var->name);', '+     }', '+     else {', '+         full_varname = var->name;', '+     }', '+             log_escape(msr->mp, rule->op_param), full_varname);', '+                 log_escape(msr->mp, full_varname));']","['-             log_escape(msr->mp, rule->op_param), var->name);', '-                 log_escape(msr->mp, var->name));']",14,2.0,16.0,bce096216e558a1a51a8c9130006908314b25c0fSpiderLabs/ModSecurity,[]
232340fed0ac6488196cad7d58dd44dfe6123db2,LibRaw/LibRaw,dcraw_emu.cpp,test,C++,0,"['@@ -169,7 +169,7 @@ int main(int argc, char *argv[])\n   for (arg=1; (((opm = argv[arg][0]) - 2) | 2) == \'+\'; ) \n       {\n           opt = argv[arg++][1];\n-          if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt)))\n+          if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt))!=0)\n               for (i=0; i < ""111411111142""[cp-sp]-\'0\'; i++)\n                   if (!isdigit(argv[arg+i][0])) \n                       {\n']",,,"['+           if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt))!=0)', '-           if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt)))']","['+           if ((cp = strchr (sp=(char*)""cnbrkstqmhabcgu"", opt))!=0)', '-           if ((cp = strchr (sp=(char*)""cnbrkstqmhabcgu"", opt)))']","['+           if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt))!=0)']","['-           if ((cp = strchr (sp=(char*)""cnbrkStqmHABCgU"", opt)))']",1,1.0,2.0,232340fed0ac6488196cad7d58dd44dfe6123db2LibRaw/LibRaw,[]
d39871834ac6e88fc8d8276dd1944ac0afbe11b0,mumble-voip/mumble,src/mumble/Settings.cpp,test,C++,1,"['@@ -116,6 +116,8 @@ const QString Settings::cqsDefaultPushClickOn = QLatin1String("":/on.ogg"");\n const QString Settings::cqsDefaultPushClickOff = QLatin1String("":/off.ogg"");\n \n OverlaySettings::OverlaySettings() {\n+\tbEnable = true;\n+\n \tosShow = LinkedChannels;\n \tbAlwaysSelf = true;\n \n@@ -278,8 +280,6 @@ Settings::Settings() {\n \tfAudioMaxDistVolume = 0.80f;\n \tfAudioBloom = 0.5f;\n \n-\tbOverlayEnable = true;\n-\n \tiLCDUserViewMinColWidth = 50;\n \tiLCDUserViewSplitterWidth = 2;\n \n@@ -393,6 +393,8 @@ void OverlaySettings::load() {\n }\n \n void OverlaySettings::load(QSettings* settings_ptr) {\n+\tSAVELOAD(bEnable, ""enable"");\n+\n \tLOADENUM(osShow, ""show"");\n \tSAVELOAD(bAlwaysSelf, ""alwaysself"");\n \n@@ -521,8 +523,6 @@ void Settings::load(QSettings* settings_ptr) {\n \tSAVELOAD(iTTSVolume, ""tts/volume"");\n \tSAVELOAD(iTTSThreshold, ""tts/threshold"");\n \n-\tSAVELOAD(bOverlayEnable, ""overlay/enable"");\n-\n \t// Network settings\n \tSAVELOAD(bTCPCompat, ""net/tcponly"");\n \tSAVELOAD(bQoS, ""net/qos"");\n@@ -647,6 +647,8 @@ void OverlaySettings::save() {\n void OverlaySettings::save(QSettings* settings_ptr) {\n \tOverlaySettings def;\n \n+\tSAVELOAD(bEnable, ""enable"");\n+\n \tSAVELOAD(osShow, ""show"");\n \tSAVELOAD(bAlwaysSelf, ""alwaysself"");\n \tSAVELOAD(fX, ""x"");\n@@ -773,10 +775,6 @@ void Settings::save() {\n \tSAVELOAD(iTTSVolume, ""tts/volume"");\n \tSAVELOAD(iTTSThreshold, ""tts/threshold"");\n \n-\tSAVELOAD(bOverlayEnable, ""overlay/enable"");\n-\n-\tSAVELOAD(bOverlayEnable, ""overlay/enable"");\n-\n \t// Network settings\n \tSAVELOAD(bTCPCompat, ""net/tcponly"");\n \tSAVELOAD(bQoS, ""net/qos"");\n']",2010-08-23 22:40:23+02:00,"Overlay corrections

  * Config dialog now has a proper layout
  * Use the reset/restore functionality of the main config dialog
  * Move overlay enabled state to OverlaySettings (should not be
    externally visible)","[['+ \tbEnable = true;', '+ ', '+ \tSAVELOAD(bEnable, ""enable"");', '+ ', '+ \tSAVELOAD(bEnable, ""enable"");', '+ ', '- \tbOverlayEnable = true;', '- ', '- \tSAVELOAD(bOverlayEnable, ""overlay/enable"");', '- ', '- \tSAVELOAD(bOverlayEnable, ""overlay/enable"");', '- ', '- \tSAVELOAD(bOverlayEnable, ""overlay/enable"");', '- ']]","[['+ \tbenable = true;', '+ ', '+ \tsaveload(benable, ""enable"");', '+ ', '+ \tsaveload(benable, ""enable"");', '+ ', '- \tboverlayenable = true;', '- ', '- \tsaveload(boverlayenable, ""overlay/enable"");', '- ', '- \tsaveload(boverlayenable, ""overlay/enable"");', '- ', '- \tsaveload(boverlayenable, ""overlay/enable"");', '- ']]","[['+ \tbEnable = true;', '+ ', '+ \tSAVELOAD(bEnable, ""enable"");', '+ ', '+ \tSAVELOAD(bEnable, ""enable"");', '+ ']]","[['- \tbOverlayEnable = true;', '- ', '- \tSAVELOAD(bOverlayEnable, ""overlay/enable"");', '- ', '- \tSAVELOAD(bOverlayEnable, ""overlay/enable"");', '- ', '- \tSAVELOAD(bOverlayEnable, ""overlay/enable"");', '- ']]",6,8.0,14.0,d39871834ac6e88fc8d8276dd1944ac0afbe11b0mumble-voip/mumble,['5632c35d6759f5e13a7dfe78e4ee6403ff6a8e3e']
019b5ca288bfda393ab2f0bd816654098253ff24,vadz/libtiff,tif_unix.c,train,C,0,"['@@ -139,6 +139,12 @@ TIFFOpen(const char* name, const char* mode)\n \tm = _TIFFgetMode(mode, module);\n \tif (m == -1)\n \t\treturn ((TIFF*)0);\n+\n+/* for cygwin */        \n+#ifdef O_BINARY\n+        m |= O_BINARY;\n+#endif        \n+        \n #ifdef _AM29K\n \tfd = open(name, m);\n #else\n']",,,"['+ #ifdef O_BINARY', '+         m |= O_BINARY;', '+ #endif']","['+ #ifdef o_binary', '+         m |= o_binary;', '+ #endif']","['+ #ifdef O_BINARY', '+         m |= O_BINARY;', '+ #endif']",[],3,0.0,3.0,019b5ca288bfda393ab2f0bd816654098253ff24vadz/libtiff,[]
23f47542fb0dc408b1a4f1d434d29c4ac7a08a48,jabberd2/jabberd2,mod_amp.c,train,C,0,"['@@ -0,0 +1,445 @@\n+/*\n+ * jabberd - Jabber Open Source Server\n+ * Copyright (c) 2002 Jeremie Miller, Thomas Muldowney,\n+ *                    Ryan Eatmon, Robert Norris\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation; either version 2 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program; if not, write to the Free Software\n+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA02111-1307USA\n+ */\n+\n+#include ""sm.h""\n+#include ""util/util.h""\n+#ifdef HAVE_IDN\n+#include <stringprep.h>\n+#endif\n+\n+/** @file sm/mod_amp.c\n+  * @brief Advanced Message Processing (JEP-0079) module\n+  * @author Cedric Vivier\n+  * $Date: 2004/10/28 14:38:35 $\n+  */\n+\n+typedef struct _mod_amp_config_st {\n+    sm_t   sm;\n+    int    disableActionDrop;\n+    int    disableActionError;\n+    int    disableActionAlert;    \n+    int    disableActionNotify;\n+    int    disableConditionDeliver;\n+    int    disableConditionExpireAt;\n+    int    disableConditionMatchResource;\n+    int    offlinestorageDisabled;\n+} *mod_amp_config_t;\n+\n+#define AMP_TRIGGERED            1\n+#define AMP_INVALID_RULE         2\n+#define AMP_INVALID_CONDITION    3\n+#define AMP_INVALID_ACTION       4\n+#define AMP_INVALID_VALUE        5\n+#define AMP_NOT_ACCEPTABLE       6\n+\n+typedef struct amp_rule_st {\n+\tint result;\n+\tchar *condition;\n+\tchar *value;\n+\tchar *action;\n+\tstruct amp_rule_st *next;\n+} *amp_rule_t;\n+\n+\n+void amp_rule_free(amp_rule_t rule) {\n+\tamp_rule_t rule_c = rule;\n+    amp_rule_t rule_tmp;\n+\twhile (rule_c != NULL) {\n+\t\tif (rule_c->condition) free(rule_c->action);\n+\t\tif (rule_c->value) free(rule_c->value);\n+\t\tif (rule_c->action) free(rule_c->action);\n+        rule_tmp = rule_c->next;\n+        free(rule_c);\n+        rule_c = rule_tmp;\n+\t}\n+}\n+\n+pkt_t amp_build_response_pkt(pkt_t pkt, amp_rule_t rule) {\n+    if (!pkt || !rule) return NULL;\n+    \n+    if (rule->result == AMP_TRIGGERED) {\n+        pkt_t res = pkt_create(pkt->sm, ""message"", NULL, jid_full(pkt->from), jid_full(pkt->to));\n+        pkt_id(pkt, res);\n+    \n+        int ns = nad_add_namespace(res->nad, uri_AMP, NULL);\n+        nad_append_elem(res->nad, ns, ""amp"", 2);\n+        nad_append_attr(res->nad, -1, ""status"", rule->action);\n+        nad_append_attr(res->nad, -1, ""from"", jid_full(pkt->from));\n+        nad_append_attr(res->nad, -1, ""to"",  jid_full(pkt->to));\n+    \n+        nad_append_elem(res->nad, ns, ""rule"", 3);\n+        nad_append_attr(res->nad, -1, ""condition"", rule->condition);\n+        nad_append_attr(res->nad, -1, ""value"", rule->value);\n+        nad_append_attr(res->nad, -1, ""action"", rule->action);\n+        \n+        return res;\n+    }\n+    \n+    return NULL;   \n+}\n+\n+void amp_error_pkt(pkt_t pkt, amp_rule_t rule) {\n+\t/* TODO: implementation */\n+}\n+\n+\n+static mod_ret_t _amp_in_sess(mod_instance_t mi, sess_t sess, pkt_t pkt) {\n+    mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;\n+    int ns, elem, attr;\n+\n+    /* only handle messages */\n+    if (pkt->type != pkt_MESSAGE)\n+        return mod_PASS;\n+\n+    /* we\'re only interested in no to, to our host, or to us */\n+    if (pkt->to != NULL && jid_compare_user(sess->jid, pkt->to) != 0 && strcmp(sess->jid->domain, jid_user(pkt->to)) != 0)\n+        return mod_PASS;\n+\n+    return mod_PASS;\n+}\n+\n+static mod_ret_t _amp_pkt_user(mod_instance_t mi, user_t user, pkt_t pkt) {\n+    mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;\n+    int ns, elem, attr;\n+\n+    /* only handle messages */\n+    if (pkt->type != pkt_MESSAGE)\n+        return mod_PASS;\n+\n+    /* does message have at least one rule for us? */\n+    ns = nad_find_scoped_namespace(pkt->nad, uri_AMP, NULL);\n+    elem = nad_find_elem(pkt->nad, 1, ns, ""amp"", 1);\n+    if (elem < 0\n+\t\t|| nad_find_attr(pkt->nad, elem, -1, ""status"", NULL) >= 0\n+        || (elem = nad_find_elem(pkt->nad, elem, ns, ""rule"", 1)) < 0)\n+        return mod_PASS;\n+\n+    /* loop for rules */\n+    amp_rule_t rule, rule_c;\n+\tint errormode = 0;\n+    rule = malloc(sizeof(struct amp_rule_st));\n+\tmemset(rule, 0, sizeof(struct amp_rule_st));\n+    rule_c = rule;\n+    while (elem >= 0) {\n+\n+        /* actions */    \n+        if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""drop"") >= 0\n+\t\t\t&& !config->disableActionDrop)\n+            rule_c->action = strdup(""drop"");\n+        else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""alert"") >= 0\n+\t\t\t\t && !config->disableActionAlert)\n+            rule_c->action = strdup(""alert"");\n+        else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""error"") >= 0\n+\t\t\t\t && !config->disableActionError)\n+            rule_c->action = strdup(""error"");\n+        else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""notify"") >= 0\n+\t\t\t\t && !config->disableActionNotify)\n+            rule_c->action = strdup(""notify"");\n+    \n+        if (!rule_c->action) {\n+            if ((attr = nad_find_attr(pkt->nad, elem, -1, ""action"", NULL)) >= 0)\n+                rule_c->action = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));\n+            rule_c->result = AMP_INVALID_ACTION;\n+        }        \n+\n+        /* deliver condition */    \n+        if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""deliver"") >= 0\n+\t\t\t&& !config->disableConditionDeliver) {\n+            rule_c->condition = strdup(""deliver"");\n+\n+            /* direct */\n+            if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""direct"") >= 0) {\n+                rule_c->value = strdup(""direct"");\n+                if (user->top != NULL) /* active session so it will be direct */\n+                    rule_c->result = AMP_TRIGGERED;\n+            }\n+            \n+            /* stored */\n+            else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""stored"") >= 0) {\n+                rule_c->value = strdup(""none"");\n+                if (!config->offlinestorageDisabled\n+                    && user->top == NULL) /* no active session so it will be stored */\n+                    rule_c->result = AMP_TRIGGERED;\n+            }\n+\n+            /* none */\n+            else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""none"") >= 0) {\n+                rule_c->value = strdup(""none"");\n+                if (config->offlinestorageDisabled\n+                    && user->top == NULL) /* no active session and no offline storage */\n+                    rule_c->result = AMP_TRIGGERED;\n+            }\n+\n+            if (!rule_c->value) {\n+                if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", NULL)) >= 0)\n+                    rule_c->value = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));\n+                rule_c->result = AMP_INVALID_VALUE;\n+            }\n+        }\n+\n+        /* match-resource condition */    \n+        else if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""match-resource"") >= 0\n+\t\t\t\t&& !config->disableConditionMatchResource) {\n+            rule_c->condition = strdup(""match-resource"");\n+\n+            /* exact */\n+            if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""exact"") >= 0) {\n+                rule_c->value = strdup(""exact"");\n+                if (sess_match_exact(user, pkt->to->resource)) /* resource found */\n+                    rule_c->result = AMP_TRIGGERED;\n+            }\n+            \n+            /* any */\n+            else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""any"") >= 0) {\n+                rule_c->value = strdup(""any"");\n+                if (user->top == NULL) /* no active resource */\n+                    rule_c->result = AMP_TRIGGERED;\n+            }\n+\n+            /* other */\n+            else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""other"") >= 0) {\n+                rule_c->value = strdup(""other"");\n+                if (!sess_match_exact(user, pkt->to->resource)) /* resource not found */\n+                    rule_c->result = AMP_TRIGGERED;                \n+            }\n+\n+            if (!rule_c->value) {\n+                if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", NULL)) >= 0)\n+                    rule_c->value = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));\n+                rule_c->result = AMP_INVALID_VALUE;\n+            }\n+        }\n+\n+        /* expire-at condition */    \n+        else if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""expire-at"") >= 0\n+\t\t\t\t&& !config->disableConditionExpireAt) {\n+            rule_c->condition = strdup(""expire-at"");\n+\n+            if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", NULL)) < 0)\n+\t\t\t\trule_c->result = AMP_INVALID_VALUE;\n+\t\t\telse {\n+\t\t\t\trule_c->value = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));\n+\t\t\t\ttime_t stamp = datetime_in(rule_c->value);\n+\t\t\t\tif (stamp < 0)\n+\t\t\t\t\trule_c->result = AMP_INVALID_VALUE;\n+\t\t\t\telse if (stamp < time(NULL)) /* expired! */\n+\t\t\t\t\trule_c->result = AMP_TRIGGERED;\t\t\t\t\n+\t\t\t}\n+        }\n+\n+        if (!rule_c->condition) {\n+            if ((attr = nad_find_attr(pkt->nad, elem, -1, ""condition"", NULL)) >= 0)\n+                rule_c->condition = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));\n+            rule_c->result = AMP_INVALID_CONDITION;\n+        }\n+\n+\t\t/* if an error is triggered, pass in error mode */\n+\t\tif (rule_c->result > AMP_TRIGGERED)\n+\t\t\terrormode = 1;\n+\n+\t\t/* processing stops at first rule triggerred */\n+        if (rule_c->result == AMP_TRIGGERED && !errormode)\n+            break;\n+       \n+        /* jump to next rule (if any) */\n+        if ((elem = nad_find_elem(pkt->nad, elem, ns, ""rule"", 0)) >= 0) {\n+            rule_c->next = malloc(sizeof(struct amp_rule_st));\n+            memset(rule_c->next, 0, sizeof(struct amp_rule_st));\n+            rule_c = rule_c->next;\n+        }\n+    }\n+    \n+    /* build result packet (if any) */\n+    if (rule_c->result != AMP_TRIGGERED || errormode)  \n+        rule_c = rule;\n+    while (rule_c != NULL) {\n+\t\tif (rule_c->result > 0) {\n+\t\n+\t\t\t/* drop action */\n+\t\t\tif (!strcmp(rule_c->action, ""drop"") && !errormode)\n+\t\t\t\tgoto handled;\n+\t\n+\t\t\t/* alert action */\n+\t\t\telse if (!strcmp(rule_c->action, ""alert"") && !errormode) {\n+\t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);\n+\t\t\t\tpkt_router(res);\n+\t\t\t\tgoto handled;\n+\t\t\t}\n+\t\n+\t\t\t/* error action */\n+\t\t\telse if (!strcmp(rule_c->action, ""error"") && !errormode) {\n+\t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);\n+\t\t\t\tpkt_router(res);            \n+\t\t\t\tgoto handled;\n+\t\t\t}\n+\t\t\t\n+\t\t\t/* notify action */\n+\t\t\telse if (!strcmp(rule_c->action, ""notify"") && !errormode) {\n+\t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);\n+\t\t\t\tpkt_router(res);\n+\t\t\t\tgoto pass; /* ...resume the pkt-user chain happily :) */\n+\t\t\t}\n+\t\t}\n+\t\t\n+        rule_c = rule_c->next;\n+\t}\n+\n+\tpass:\n+\t\tamp_rule_free(rule);\n+\t\treturn mod_PASS;\n+\n+    handled:        \n+        amp_rule_free(rule);\n+        pkt_free(pkt);\n+        return mod_HANDLED;\n+}\n+\n+static mod_ret_t _amp_pkt_sm(mod_instance_t mi, pkt_t pkt) {\n+    mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;\n+    pkt_t res;\n+    int ns, attr;\n+    \n+    /* we only want to play with iq disco#info gets */\n+    if(pkt->type != pkt_IQ || pkt->ns != ns_DISCO_INFO)\n+        return mod_PASS;\n+\n+    /* is disco#info for us ? */\n+    if ((attr = nad_find_attr(pkt->nad, 2, -1, ""node"", NULL)) < 0\n+        || strncmp(NAD_AVAL(pkt->nad, attr), uri_AMP, NAD_AVAL_L(pkt->nad, attr)) != 0)\n+        return mod_PASS;\n+\n+    res = pkt_create(config->sm, ""iq"", ""result"", jid_full(pkt->from), jid_full(pkt->to));\n+    pkt_id(pkt, res);\n+    pkt_free(pkt);\n+\n+    ns = nad_add_namespace(res->nad, uri_DISCO_INFO, NULL);\n+    nad_append_elem(res->nad, ns, ""query"", 2);\n+    nad_append_attr(res->nad, -1, ""node"", uri_AMP);\n+\n+    nad_append_elem(res->nad, ns, ""identity"", 3);\n+    nad_append_attr(res->nad, -1, ""name"", ""Advanced Message Processing support"");\n+    nad_append_attr(res->nad, -1, ""category"", ""im"");\n+    nad_append_attr(res->nad, -1, ""type"", ""server"");\n+\n+    nad_append_elem(res->nad, ns, ""feature"", 3);\n+    nad_append_attr(res->nad, -1, ""var"", uri_AMP);\n+    if (!config->disableActionDrop) {\n+        nad_append_elem(res->nad, ns, ""feature"", 3);\n+        nad_append_attr(res->nad, -1, ""var"", uri_AMP_ACTION_DROP);\n+    }\n+    if (!config->disableActionError) {\n+        nad_append_elem(res->nad, ns, ""feature"", 3);\n+        nad_append_attr(res->nad, -1, ""var"", uri_AMP_ACTION_ERROR);\n+    }\n+    if (!config->disableActionNotify) {\n+        nad_append_elem(res->nad, ns, ""feature"", 3);\n+        nad_append_attr(res->nad, -1, ""var"", uri_AMP_ACTION_NOTIFY);\n+    }\n+    if (!config->disableConditionDeliver) {\n+        nad_append_elem(res->nad, ns, ""feature"", 3);\n+        nad_append_attr(res->nad, -1, ""var"", uri_AMP_CONDITION_DELIVER);\n+    }\n+    if (!config->disableConditionExpireAt) {\n+        nad_append_elem(res->nad, ns, ""feature"", 3);\n+        nad_append_attr(res->nad, -1, ""var"", uri_AMP_CONDITION_EXPIREAT);\n+    }\n+    if (!config->disableConditionMatchResource) {\n+        nad_append_elem(res->nad, ns, ""feature"", 3);\n+        nad_append_attr(res->nad, -1, ""var"", uri_AMP_CONDITION_MATCHRESOURCE);\n+    }    \n+\n+    /* tell them */\n+    pkt_router(res);\n+\n+    return mod_HANDLED;\n+}\n+\n+static void _amp_free(module_t mod) {\n+    free(mod->private);\n+}\n+\n+DLLEXPORT int module_init(mod_instance_t mi, char *arg) {\n+    module_t mod = mi->mod;\n+    mod_amp_config_t config;\n+    char* option;\n+\n+    if (mod->init) return 0;\n+    \n+    config = (mod_amp_config_t) malloc(sizeof(struct _mod_amp_config_st));\n+    memset(config, 0, sizeof(struct _mod_amp_config_st));\n+\n+    config->sm = mod->mm->sm;\n+    option = config_get_one(mod->mm->sm->config, ""amp.disableactions.drop"", 0);\n+    if (option != NULL) {\n+        log_debug(ZONE, ""action Drop disabled in config."");\n+        config->disableActionDrop = 1;\n+    }\n+    option = config_get_one(mod->mm->sm->config, ""amp.disableactions.error"", 0);\n+    if (option != NULL) {\n+        log_debug(ZONE, ""action Error disabled in config."");\n+        config->disableActionError = 1;\n+    }\n+    option = config_get_one(mod->mm->sm->config, ""amp.disableactions.alert"", 0);\n+    if (option != NULL) {\n+        log_debug(ZONE, ""action Alert disabled in config."");\n+        config->disableActionAlert = 1;\n+    }    \n+    option = config_get_one(mod->mm->sm->config, ""amp.disableactions.notify"", 0);\n+    if (option != NULL) {\n+        log_debug(ZONE, ""action Notify disabled in config."");\n+        config->disableActionNotify = 1;\n+    }\n+    option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.deliver"", 0);\n+    if (option != NULL) {\n+        log_debug(ZONE, ""condition Deliver disabled in config."");\n+        config->disableConditionDeliver = 1;\n+    }\n+    option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.expireat"", 0);\n+    if (option != NULL) {\n+        log_debug(ZONE, ""condition Expire-At disabled in config."");\n+        config->disableConditionExpireAt = 1;\n+    }\n+    option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.matchresource"", 0);\n+    if (option != NULL) {\n+        log_debug(ZONE, ""condition Match-Resource disabled in config."");\n+        config->disableConditionMatchResource = 1;\n+    }\n+    option = config_get_one(mod->mm->sm->config, ""amp.offlinestoragedisabled"", 0);\n+    if (option != NULL) {\n+        log_debug(ZONE, ""offline storage disabled in config."");\n+        config->offlinestorageDisabled = 1;\n+    }\n+    option = config_get_one(mod->mm->sm->config, ""offline.dropmessages"", 0);\n+    if (option != NULL) {\n+        log_debug(ZONE, ""offline storage disabled in config."");\n+        config->offlinestorageDisabled = 1;\n+    }\n+    \n+    mod->private = config;    \n+\n+    mod->in_sess = _amp_in_sess;\n+    mod->pkt_user = _amp_pkt_user;\n+    mod->pkt_sm = _amp_pkt_sm;\n+    mod->free = _amp_free;\n+\n+    feature_register(mod->mm->sm, uri_AMP);\n+\n+    return 0;\n+}\n']",,,"['+ #include ""sm.h""', '+ #include ""util/util.h""', '+ #ifdef HAVE_IDN', '+ #include <stringprep.h>', '+ #endif', '+ typedef struct _mod_amp_config_st {', '+     sm_t   sm;', '+     int    disableActionDrop;', '+     int    disableActionError;', '+     int    disableActionAlert;', '+     int    disableActionNotify;', '+     int    disableConditionDeliver;', '+     int    disableConditionExpireAt;', '+     int    disableConditionMatchResource;', '+     int    offlinestorageDisabled;', '+ } *mod_amp_config_t;', '+ #define AMP_TRIGGERED            1', '+ #define AMP_INVALID_RULE         2', '+ #define AMP_INVALID_CONDITION    3', '+ #define AMP_INVALID_ACTION       4', '+ #define AMP_INVALID_VALUE        5', '+ #define AMP_NOT_ACCEPTABLE       6', '+ typedef struct amp_rule_st {', '+ \tint result;', '+ \tchar *condition;', '+ \tchar *value;', '+ \tchar *action;', '+ \tstruct amp_rule_st *next;', '+ } *amp_rule_t;', '+ void amp_rule_free(amp_rule_t rule) {', '+ \tamp_rule_t rule_c = rule;', '+     amp_rule_t rule_tmp;', '+ \twhile (rule_c != NULL) {', '+ \t\tif (rule_c->condition) free(rule_c->action);', '+ \t\tif (rule_c->value) free(rule_c->value);', '+ \t\tif (rule_c->action) free(rule_c->action);', '+         rule_tmp = rule_c->next;', '+         free(rule_c);', '+         rule_c = rule_tmp;', '+ \t}', '+ }', '+ pkt_t amp_build_response_pkt(pkt_t pkt, amp_rule_t rule) {', '+     if (!pkt || !rule) return NULL;', '+     if (rule->result == AMP_TRIGGERED) {', '+         pkt_t res = pkt_create(pkt->sm, ""message"", NULL, jid_full(pkt->from), jid_full(pkt->to));', '+         pkt_id(pkt, res);', '+         int ns = nad_add_namespace(res->nad, uri_AMP, NULL);', '+         nad_append_elem(res->nad, ns, ""amp"", 2);', '+         nad_append_attr(res->nad, -1, ""status"", rule->action);', '+         nad_append_attr(res->nad, -1, ""from"", jid_full(pkt->from));', '+         nad_append_attr(res->nad, -1, ""to"",  jid_full(pkt->to));', '+         nad_append_elem(res->nad, ns, ""rule"", 3);', '+         nad_append_attr(res->nad, -1, ""condition"", rule->condition);', '+         nad_append_attr(res->nad, -1, ""value"", rule->value);', '+         nad_append_attr(res->nad, -1, ""action"", rule->action);', '+         return res;', '+     }', '+     return NULL;', '+ }', '+ void amp_error_pkt(pkt_t pkt, amp_rule_t rule) {', '+ }', '+ static mod_ret_t _amp_in_sess(mod_instance_t mi, sess_t sess, pkt_t pkt) {', '+     mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;', '+     int ns, elem, attr;', '+     if (pkt->type != pkt_MESSAGE)', '+         return mod_PASS;', '+     if (pkt->to != NULL && jid_compare_user(sess->jid, pkt->to) != 0 && strcmp(sess->jid->domain, jid_user(pkt->to)) != 0)', '+         return mod_PASS;', '+     return mod_PASS;', '+ }', '+ static mod_ret_t _amp_pkt_user(mod_instance_t mi, user_t user, pkt_t pkt) {', '+     mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;', '+     int ns, elem, attr;', '+     if (pkt->type != pkt_MESSAGE)', '+         return mod_PASS;', '+     ns = nad_find_scoped_namespace(pkt->nad, uri_AMP, NULL);', '+     elem = nad_find_elem(pkt->nad, 1, ns, ""amp"", 1);', '+     if (elem < 0', '+ \t\t|| nad_find_attr(pkt->nad, elem, -1, ""status"", NULL) >= 0', '+         || (elem = nad_find_elem(pkt->nad, elem, ns, ""rule"", 1)) < 0)', '+         return mod_PASS;', '+     amp_rule_t rule, rule_c;', '+ \tint errormode = 0;', '+     rule = malloc(sizeof(struct amp_rule_st));', '+ \tmemset(rule, 0, sizeof(struct amp_rule_st));', '+     rule_c = rule;', '+     while (elem >= 0) {', '+         if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""drop"") >= 0', '+ \t\t\t&& !config->disableActionDrop)', '+             rule_c->action = strdup(""drop"");', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""alert"") >= 0', '+ \t\t\t\t && !config->disableActionAlert)', '+             rule_c->action = strdup(""alert"");', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""error"") >= 0', '+ \t\t\t\t && !config->disableActionError)', '+             rule_c->action = strdup(""error"");', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""notify"") >= 0', '+ \t\t\t\t && !config->disableActionNotify)', '+             rule_c->action = strdup(""notify"");', '+         if (!rule_c->action) {', '+             if ((attr = nad_find_attr(pkt->nad, elem, -1, ""action"", NULL)) >= 0)', '+                 rule_c->action = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+             rule_c->result = AMP_INVALID_ACTION;', '+         }', '+         if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""deliver"") >= 0', '+ \t\t\t&& !config->disableConditionDeliver) {', '+             rule_c->condition = strdup(""deliver"");', '+             if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""direct"") >= 0) {', '+                 rule_c->value = strdup(""direct"");', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""stored"") >= 0) {', '+                 rule_c->value = strdup(""none"");', '+                 if (!config->offlinestorageDisabled', '+                     rule_c->result = AMP_TRIGGERED;', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""none"") >= 0) {', '+                 rule_c->value = strdup(""none"");', '+                 if (config->offlinestorageDisabled', '+                     rule_c->result = AMP_TRIGGERED;', '+             }', '+             if (!rule_c->value) {', '+                 if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", NULL)) >= 0)', '+                     rule_c->value = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+                 rule_c->result = AMP_INVALID_VALUE;', '+             }', '+         }', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""match-resource"") >= 0', '+ \t\t\t\t&& !config->disableConditionMatchResource) {', '+             rule_c->condition = strdup(""match-resource"");', '+             if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""exact"") >= 0) {', '+                 rule_c->value = strdup(""exact"");', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""any"") >= 0) {', '+                 rule_c->value = strdup(""any"");', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""other"") >= 0) {', '+                 rule_c->value = strdup(""other"");', '+             }', '+             if (!rule_c->value) {', '+                 if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", NULL)) >= 0)', '+                     rule_c->value = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+                 rule_c->result = AMP_INVALID_VALUE;', '+             }', '+         }', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""expire-at"") >= 0', '+ \t\t\t\t&& !config->disableConditionExpireAt) {', '+             rule_c->condition = strdup(""expire-at"");', '+             if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", NULL)) < 0)', '+ \t\t\t\trule_c->result = AMP_INVALID_VALUE;', '+ \t\t\telse {', '+ \t\t\t\trule_c->value = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+ \t\t\t\ttime_t stamp = datetime_in(rule_c->value);', '+ \t\t\t\tif (stamp < 0)', '+ \t\t\t\t\trule_c->result = AMP_INVALID_VALUE;', '+ \t\t\t}', '+         }', '+         if (!rule_c->condition) {', '+             if ((attr = nad_find_attr(pkt->nad, elem, -1, ""condition"", NULL)) >= 0)', '+                 rule_c->condition = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+             rule_c->result = AMP_INVALID_CONDITION;', '+         }', '+ \t\tif (rule_c->result > AMP_TRIGGERED)', '+ \t\t\terrormode = 1;', '+         if (rule_c->result == AMP_TRIGGERED && !errormode)', '+             break;', '+         if ((elem = nad_find_elem(pkt->nad, elem, ns, ""rule"", 0)) >= 0) {', '+             rule_c->next = malloc(sizeof(struct amp_rule_st));', '+             memset(rule_c->next, 0, sizeof(struct amp_rule_st));', '+             rule_c = rule_c->next;', '+         }', '+     }', '+     if (rule_c->result != AMP_TRIGGERED || errormode)', '+         rule_c = rule;', '+     while (rule_c != NULL) {', '+ \t\tif (rule_c->result > 0) {', '+ \t\t\tif (!strcmp(rule_c->action, ""drop"") && !errormode)', '+ \t\t\t\tgoto handled;', '+ \t\t\telse if (!strcmp(rule_c->action, ""alert"") && !errormode) {', '+ \t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);', '+ \t\t\t\tpkt_router(res);', '+ \t\t\t\tgoto handled;', '+ \t\t\t}', '+ \t\t\telse if (!strcmp(rule_c->action, ""error"") && !errormode) {', '+ \t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);', '+ \t\t\t\tpkt_router(res);', '+ \t\t\t\tgoto handled;', '+ \t\t\t}', '+ \t\t\telse if (!strcmp(rule_c->action, ""notify"") && !errormode) {', '+ \t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);', '+ \t\t\t\tpkt_router(res);', '+ \t\t\t}', '+ \t\t}', '+         rule_c = rule_c->next;', '+ \t}', '+ \tpass:', '+ \t\tamp_rule_free(rule);', '+ \t\treturn mod_PASS;', '+     handled:', '+         amp_rule_free(rule);', '+         pkt_free(pkt);', '+         return mod_HANDLED;', '+ }', '+ static mod_ret_t _amp_pkt_sm(mod_instance_t mi, pkt_t pkt) {', '+     mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;', '+     pkt_t res;', '+     int ns, attr;', '+     if(pkt->type != pkt_IQ || pkt->ns != ns_DISCO_INFO)', '+         return mod_PASS;', '+     if ((attr = nad_find_attr(pkt->nad, 2, -1, ""node"", NULL)) < 0', '+         || strncmp(NAD_AVAL(pkt->nad, attr), uri_AMP, NAD_AVAL_L(pkt->nad, attr)) != 0)', '+         return mod_PASS;', '+     res = pkt_create(config->sm, ""iq"", ""result"", jid_full(pkt->from), jid_full(pkt->to));', '+     pkt_id(pkt, res);', '+     pkt_free(pkt);', '+     ns = nad_add_namespace(res->nad, uri_DISCO_INFO, NULL);', '+     nad_append_elem(res->nad, ns, ""query"", 2);', '+     nad_append_attr(res->nad, -1, ""node"", uri_AMP);', '+     nad_append_elem(res->nad, ns, ""identity"", 3);', '+     nad_append_attr(res->nad, -1, ""name"", ""Advanced Message Processing support"");', '+     nad_append_attr(res->nad, -1, ""category"", ""im"");', '+     nad_append_attr(res->nad, -1, ""type"", ""server"");', '+     nad_append_elem(res->nad, ns, ""feature"", 3);', '+     nad_append_attr(res->nad, -1, ""var"", uri_AMP);', '+     if (!config->disableActionDrop) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_ACTION_DROP);', '+     }', '+     if (!config->disableActionError) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_ACTION_ERROR);', '+     }', '+     if (!config->disableActionNotify) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_ACTION_NOTIFY);', '+     }', '+     if (!config->disableConditionDeliver) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_CONDITION_DELIVER);', '+     }', '+     if (!config->disableConditionExpireAt) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_CONDITION_EXPIREAT);', '+     }', '+     if (!config->disableConditionMatchResource) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_CONDITION_MATCHRESOURCE);', '+     }', '+     pkt_router(res);', '+     return mod_HANDLED;', '+ }', '+ static void _amp_free(module_t mod) {', '+     free(mod->private);', '+ }', '+ DLLEXPORT int module_init(mod_instance_t mi, char *arg) {', '+     module_t mod = mi->mod;', '+     mod_amp_config_t config;', '+     char* option;', '+     if (mod->init) return 0;', '+     config = (mod_amp_config_t) malloc(sizeof(struct _mod_amp_config_st));', '+     memset(config, 0, sizeof(struct _mod_amp_config_st));', '+     config->sm = mod->mm->sm;', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.drop"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""action Drop disabled in config."");', '+         config->disableActionDrop = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.error"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""action Error disabled in config."");', '+         config->disableActionError = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.alert"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""action Alert disabled in config."");', '+         config->disableActionAlert = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.notify"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""action Notify disabled in config."");', '+         config->disableActionNotify = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.deliver"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""condition Deliver disabled in config."");', '+         config->disableConditionDeliver = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.expireat"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""condition Expire-At disabled in config."");', '+         config->disableConditionExpireAt = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.matchresource"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""condition Match-Resource disabled in config."");', '+         config->disableConditionMatchResource = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.offlinestoragedisabled"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""offline storage disabled in config."");', '+         config->offlinestorageDisabled = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""offline.dropmessages"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""offline storage disabled in config."");', '+         config->offlinestorageDisabled = 1;', '+     }', '+     mod->private = config;', '+     mod->in_sess = _amp_in_sess;', '+     mod->pkt_user = _amp_pkt_user;', '+     mod->pkt_sm = _amp_pkt_sm;', '+     mod->free = _amp_free;', '+     feature_register(mod->mm->sm, uri_AMP);', '+     return 0;', '+ }']","['+ #include ""sm.h""', '+ #include ""util/util.h""', '+ #ifdef have_idn', '+ #include <stringprep.h>', '+ #endif', '+ typedef struct _mod_amp_config_st {', '+     sm_t   sm;', '+     int    disableactiondrop;', '+     int    disableactionerror;', '+     int    disableactionalert;', '+     int    disableactionnotify;', '+     int    disableconditiondeliver;', '+     int    disableconditionexpireat;', '+     int    disableconditionmatchresource;', '+     int    offlinestoragedisabled;', '+ } *mod_amp_config_t;', '+ #define amp_triggered            1', '+ #define amp_invalid_rule         2', '+ #define amp_invalid_condition    3', '+ #define amp_invalid_action       4', '+ #define amp_invalid_value        5', '+ #define amp_not_acceptable       6', '+ typedef struct amp_rule_st {', '+ \tint result;', '+ \tchar *condition;', '+ \tchar *value;', '+ \tchar *action;', '+ \tstruct amp_rule_st *next;', '+ } *amp_rule_t;', '+ void amp_rule_free(amp_rule_t rule) {', '+ \tamp_rule_t rule_c = rule;', '+     amp_rule_t rule_tmp;', '+ \twhile (rule_c != null) {', '+ \t\tif (rule_c->condition) free(rule_c->action);', '+ \t\tif (rule_c->value) free(rule_c->value);', '+ \t\tif (rule_c->action) free(rule_c->action);', '+         rule_tmp = rule_c->next;', '+         free(rule_c);', '+         rule_c = rule_tmp;', '+ \t}', '+ }', '+ pkt_t amp_build_response_pkt(pkt_t pkt, amp_rule_t rule) {', '+     if (!pkt || !rule) return null;', '+     if (rule->result == amp_triggered) {', '+         pkt_t res = pkt_create(pkt->sm, ""message"", null, jid_full(pkt->from), jid_full(pkt->to));', '+         pkt_id(pkt, res);', '+         int ns = nad_add_namespace(res->nad, uri_amp, null);', '+         nad_append_elem(res->nad, ns, ""amp"", 2);', '+         nad_append_attr(res->nad, -1, ""status"", rule->action);', '+         nad_append_attr(res->nad, -1, ""from"", jid_full(pkt->from));', '+         nad_append_attr(res->nad, -1, ""to"",  jid_full(pkt->to));', '+         nad_append_elem(res->nad, ns, ""rule"", 3);', '+         nad_append_attr(res->nad, -1, ""condition"", rule->condition);', '+         nad_append_attr(res->nad, -1, ""value"", rule->value);', '+         nad_append_attr(res->nad, -1, ""action"", rule->action);', '+         return res;', '+     }', '+     return null;', '+ }', '+ void amp_error_pkt(pkt_t pkt, amp_rule_t rule) {', '+ }', '+ static mod_ret_t _amp_in_sess(mod_instance_t mi, sess_t sess, pkt_t pkt) {', '+     mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;', '+     int ns, elem, attr;', '+     if (pkt->type != pkt_message)', '+         return mod_pass;', '+     if (pkt->to != null && jid_compare_user(sess->jid, pkt->to) != 0 && strcmp(sess->jid->domain, jid_user(pkt->to)) != 0)', '+         return mod_pass;', '+     return mod_pass;', '+ }', '+ static mod_ret_t _amp_pkt_user(mod_instance_t mi, user_t user, pkt_t pkt) {', '+     mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;', '+     int ns, elem, attr;', '+     if (pkt->type != pkt_message)', '+         return mod_pass;', '+     ns = nad_find_scoped_namespace(pkt->nad, uri_amp, null);', '+     elem = nad_find_elem(pkt->nad, 1, ns, ""amp"", 1);', '+     if (elem < 0', '+ \t\t|| nad_find_attr(pkt->nad, elem, -1, ""status"", null) >= 0', '+         || (elem = nad_find_elem(pkt->nad, elem, ns, ""rule"", 1)) < 0)', '+         return mod_pass;', '+     amp_rule_t rule, rule_c;', '+ \tint errormode = 0;', '+     rule = malloc(sizeof(struct amp_rule_st));', '+ \tmemset(rule, 0, sizeof(struct amp_rule_st));', '+     rule_c = rule;', '+     while (elem >= 0) {', '+         if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""drop"") >= 0', '+ \t\t\t&& !config->disableactiondrop)', '+             rule_c->action = strdup(""drop"");', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""alert"") >= 0', '+ \t\t\t\t && !config->disableactionalert)', '+             rule_c->action = strdup(""alert"");', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""error"") >= 0', '+ \t\t\t\t && !config->disableactionerror)', '+             rule_c->action = strdup(""error"");', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""notify"") >= 0', '+ \t\t\t\t && !config->disableactionnotify)', '+             rule_c->action = strdup(""notify"");', '+         if (!rule_c->action) {', '+             if ((attr = nad_find_attr(pkt->nad, elem, -1, ""action"", null)) >= 0)', '+                 rule_c->action = strndup(nad_aval(pkt->nad, attr), nad_aval_l(pkt->nad, attr));', '+             rule_c->result = amp_invalid_action;', '+         }', '+         if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""deliver"") >= 0', '+ \t\t\t&& !config->disableconditiondeliver) {', '+             rule_c->condition = strdup(""deliver"");', '+             if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""direct"") >= 0) {', '+                 rule_c->value = strdup(""direct"");', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""stored"") >= 0) {', '+                 rule_c->value = strdup(""none"");', '+                 if (!config->offlinestoragedisabled', '+                     rule_c->result = amp_triggered;', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""none"") >= 0) {', '+                 rule_c->value = strdup(""none"");', '+                 if (config->offlinestoragedisabled', '+                     rule_c->result = amp_triggered;', '+             }', '+             if (!rule_c->value) {', '+                 if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", null)) >= 0)', '+                     rule_c->value = strndup(nad_aval(pkt->nad, attr), nad_aval_l(pkt->nad, attr));', '+                 rule_c->result = amp_invalid_value;', '+             }', '+         }', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""match-resource"") >= 0', '+ \t\t\t\t&& !config->disableconditionmatchresource) {', '+             rule_c->condition = strdup(""match-resource"");', '+             if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""exact"") >= 0) {', '+                 rule_c->value = strdup(""exact"");', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""any"") >= 0) {', '+                 rule_c->value = strdup(""any"");', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""other"") >= 0) {', '+                 rule_c->value = strdup(""other"");', '+             }', '+             if (!rule_c->value) {', '+                 if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", null)) >= 0)', '+                     rule_c->value = strndup(nad_aval(pkt->nad, attr), nad_aval_l(pkt->nad, attr));', '+                 rule_c->result = amp_invalid_value;', '+             }', '+         }', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""expire-at"") >= 0', '+ \t\t\t\t&& !config->disableconditionexpireat) {', '+             rule_c->condition = strdup(""expire-at"");', '+             if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", null)) < 0)', '+ \t\t\t\trule_c->result = amp_invalid_value;', '+ \t\t\telse {', '+ \t\t\t\trule_c->value = strndup(nad_aval(pkt->nad, attr), nad_aval_l(pkt->nad, attr));', '+ \t\t\t\ttime_t stamp = datetime_in(rule_c->value);', '+ \t\t\t\tif (stamp < 0)', '+ \t\t\t\t\trule_c->result = amp_invalid_value;', '+ \t\t\t}', '+         }', '+         if (!rule_c->condition) {', '+             if ((attr = nad_find_attr(pkt->nad, elem, -1, ""condition"", null)) >= 0)', '+                 rule_c->condition = strndup(nad_aval(pkt->nad, attr), nad_aval_l(pkt->nad, attr));', '+             rule_c->result = amp_invalid_condition;', '+         }', '+ \t\tif (rule_c->result > amp_triggered)', '+ \t\t\terrormode = 1;', '+         if (rule_c->result == amp_triggered && !errormode)', '+             break;', '+         if ((elem = nad_find_elem(pkt->nad, elem, ns, ""rule"", 0)) >= 0) {', '+             rule_c->next = malloc(sizeof(struct amp_rule_st));', '+             memset(rule_c->next, 0, sizeof(struct amp_rule_st));', '+             rule_c = rule_c->next;', '+         }', '+     }', '+     if (rule_c->result != amp_triggered || errormode)', '+         rule_c = rule;', '+     while (rule_c != null) {', '+ \t\tif (rule_c->result > 0) {', '+ \t\t\tif (!strcmp(rule_c->action, ""drop"") && !errormode)', '+ \t\t\t\tgoto handled;', '+ \t\t\telse if (!strcmp(rule_c->action, ""alert"") && !errormode) {', '+ \t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);', '+ \t\t\t\tpkt_router(res);', '+ \t\t\t\tgoto handled;', '+ \t\t\t}', '+ \t\t\telse if (!strcmp(rule_c->action, ""error"") && !errormode) {', '+ \t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);', '+ \t\t\t\tpkt_router(res);', '+ \t\t\t\tgoto handled;', '+ \t\t\t}', '+ \t\t\telse if (!strcmp(rule_c->action, ""notify"") && !errormode) {', '+ \t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);', '+ \t\t\t\tpkt_router(res);', '+ \t\t\t}', '+ \t\t}', '+         rule_c = rule_c->next;', '+ \t}', '+ \tpass:', '+ \t\tamp_rule_free(rule);', '+ \t\treturn mod_pass;', '+     handled:', '+         amp_rule_free(rule);', '+         pkt_free(pkt);', '+         return mod_handled;', '+ }', '+ static mod_ret_t _amp_pkt_sm(mod_instance_t mi, pkt_t pkt) {', '+     mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;', '+     pkt_t res;', '+     int ns, attr;', '+     if(pkt->type != pkt_iq || pkt->ns != ns_disco_info)', '+         return mod_pass;', '+     if ((attr = nad_find_attr(pkt->nad, 2, -1, ""node"", null)) < 0', '+         || strncmp(nad_aval(pkt->nad, attr), uri_amp, nad_aval_l(pkt->nad, attr)) != 0)', '+         return mod_pass;', '+     res = pkt_create(config->sm, ""iq"", ""result"", jid_full(pkt->from), jid_full(pkt->to));', '+     pkt_id(pkt, res);', '+     pkt_free(pkt);', '+     ns = nad_add_namespace(res->nad, uri_disco_info, null);', '+     nad_append_elem(res->nad, ns, ""query"", 2);', '+     nad_append_attr(res->nad, -1, ""node"", uri_amp);', '+     nad_append_elem(res->nad, ns, ""identity"", 3);', '+     nad_append_attr(res->nad, -1, ""name"", ""advanced message processing support"");', '+     nad_append_attr(res->nad, -1, ""category"", ""im"");', '+     nad_append_attr(res->nad, -1, ""type"", ""server"");', '+     nad_append_elem(res->nad, ns, ""feature"", 3);', '+     nad_append_attr(res->nad, -1, ""var"", uri_amp);', '+     if (!config->disableactiondrop) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_amp_action_drop);', '+     }', '+     if (!config->disableactionerror) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_amp_action_error);', '+     }', '+     if (!config->disableactionnotify) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_amp_action_notify);', '+     }', '+     if (!config->disableconditiondeliver) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_amp_condition_deliver);', '+     }', '+     if (!config->disableconditionexpireat) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_amp_condition_expireat);', '+     }', '+     if (!config->disableconditionmatchresource) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_amp_condition_matchresource);', '+     }', '+     pkt_router(res);', '+     return mod_handled;', '+ }', '+ static void _amp_free(module_t mod) {', '+     free(mod->private);', '+ }', '+ dllexport int module_init(mod_instance_t mi, char *arg) {', '+     module_t mod = mi->mod;', '+     mod_amp_config_t config;', '+     char* option;', '+     if (mod->init) return 0;', '+     config = (mod_amp_config_t) malloc(sizeof(struct _mod_amp_config_st));', '+     memset(config, 0, sizeof(struct _mod_amp_config_st));', '+     config->sm = mod->mm->sm;', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.drop"", 0);', '+     if (option != null) {', '+         log_debug(zone, ""action drop disabled in config."");', '+         config->disableactiondrop = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.error"", 0);', '+     if (option != null) {', '+         log_debug(zone, ""action error disabled in config."");', '+         config->disableactionerror = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.alert"", 0);', '+     if (option != null) {', '+         log_debug(zone, ""action alert disabled in config."");', '+         config->disableactionalert = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.notify"", 0);', '+     if (option != null) {', '+         log_debug(zone, ""action notify disabled in config."");', '+         config->disableactionnotify = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.deliver"", 0);', '+     if (option != null) {', '+         log_debug(zone, ""condition deliver disabled in config."");', '+         config->disableconditiondeliver = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.expireat"", 0);', '+     if (option != null) {', '+         log_debug(zone, ""condition expire-at disabled in config."");', '+         config->disableconditionexpireat = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.matchresource"", 0);', '+     if (option != null) {', '+         log_debug(zone, ""condition match-resource disabled in config."");', '+         config->disableconditionmatchresource = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.offlinestoragedisabled"", 0);', '+     if (option != null) {', '+         log_debug(zone, ""offline storage disabled in config."");', '+         config->offlinestoragedisabled = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""offline.dropmessages"", 0);', '+     if (option != null) {', '+         log_debug(zone, ""offline storage disabled in config."");', '+         config->offlinestoragedisabled = 1;', '+     }', '+     mod->private = config;', '+     mod->in_sess = _amp_in_sess;', '+     mod->pkt_user = _amp_pkt_user;', '+     mod->pkt_sm = _amp_pkt_sm;', '+     mod->free = _amp_free;', '+     feature_register(mod->mm->sm, uri_amp);', '+     return 0;', '+ }']","['+ #include ""sm.h""', '+ #include ""util/util.h""', '+ #ifdef HAVE_IDN', '+ #include <stringprep.h>', '+ #endif', '+ typedef struct _mod_amp_config_st {', '+     sm_t   sm;', '+     int    disableActionDrop;', '+     int    disableActionError;', '+     int    disableActionAlert;', '+     int    disableActionNotify;', '+     int    disableConditionDeliver;', '+     int    disableConditionExpireAt;', '+     int    disableConditionMatchResource;', '+     int    offlinestorageDisabled;', '+ } *mod_amp_config_t;', '+ #define AMP_TRIGGERED            1', '+ #define AMP_INVALID_RULE         2', '+ #define AMP_INVALID_CONDITION    3', '+ #define AMP_INVALID_ACTION       4', '+ #define AMP_INVALID_VALUE        5', '+ #define AMP_NOT_ACCEPTABLE       6', '+ typedef struct amp_rule_st {', '+ \tint result;', '+ \tchar *condition;', '+ \tchar *value;', '+ \tchar *action;', '+ \tstruct amp_rule_st *next;', '+ } *amp_rule_t;', '+ void amp_rule_free(amp_rule_t rule) {', '+ \tamp_rule_t rule_c = rule;', '+     amp_rule_t rule_tmp;', '+ \twhile (rule_c != NULL) {', '+ \t\tif (rule_c->condition) free(rule_c->action);', '+ \t\tif (rule_c->value) free(rule_c->value);', '+ \t\tif (rule_c->action) free(rule_c->action);', '+         rule_tmp = rule_c->next;', '+         free(rule_c);', '+         rule_c = rule_tmp;', '+ \t}', '+ }', '+ pkt_t amp_build_response_pkt(pkt_t pkt, amp_rule_t rule) {', '+     if (!pkt || !rule) return NULL;', '+     if (rule->result == AMP_TRIGGERED) {', '+         pkt_t res = pkt_create(pkt->sm, ""message"", NULL, jid_full(pkt->from), jid_full(pkt->to));', '+         pkt_id(pkt, res);', '+         int ns = nad_add_namespace(res->nad, uri_AMP, NULL);', '+         nad_append_elem(res->nad, ns, ""amp"", 2);', '+         nad_append_attr(res->nad, -1, ""status"", rule->action);', '+         nad_append_attr(res->nad, -1, ""from"", jid_full(pkt->from));', '+         nad_append_attr(res->nad, -1, ""to"",  jid_full(pkt->to));', '+         nad_append_elem(res->nad, ns, ""rule"", 3);', '+         nad_append_attr(res->nad, -1, ""condition"", rule->condition);', '+         nad_append_attr(res->nad, -1, ""value"", rule->value);', '+         nad_append_attr(res->nad, -1, ""action"", rule->action);', '+         return res;', '+     }', '+     return NULL;', '+ }', '+ void amp_error_pkt(pkt_t pkt, amp_rule_t rule) {', '+ }', '+ static mod_ret_t _amp_in_sess(mod_instance_t mi, sess_t sess, pkt_t pkt) {', '+     mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;', '+     int ns, elem, attr;', '+     if (pkt->type != pkt_MESSAGE)', '+         return mod_PASS;', '+     if (pkt->to != NULL && jid_compare_user(sess->jid, pkt->to) != 0 && strcmp(sess->jid->domain, jid_user(pkt->to)) != 0)', '+         return mod_PASS;', '+     return mod_PASS;', '+ }', '+ static mod_ret_t _amp_pkt_user(mod_instance_t mi, user_t user, pkt_t pkt) {', '+     mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;', '+     int ns, elem, attr;', '+     if (pkt->type != pkt_MESSAGE)', '+         return mod_PASS;', '+     ns = nad_find_scoped_namespace(pkt->nad, uri_AMP, NULL);', '+     elem = nad_find_elem(pkt->nad, 1, ns, ""amp"", 1);', '+     if (elem < 0', '+ \t\t|| nad_find_attr(pkt->nad, elem, -1, ""status"", NULL) >= 0', '+         || (elem = nad_find_elem(pkt->nad, elem, ns, ""rule"", 1)) < 0)', '+         return mod_PASS;', '+     amp_rule_t rule, rule_c;', '+ \tint errormode = 0;', '+     rule = malloc(sizeof(struct amp_rule_st));', '+ \tmemset(rule, 0, sizeof(struct amp_rule_st));', '+     rule_c = rule;', '+     while (elem >= 0) {', '+         if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""drop"") >= 0', '+ \t\t\t&& !config->disableActionDrop)', '+             rule_c->action = strdup(""drop"");', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""alert"") >= 0', '+ \t\t\t\t && !config->disableActionAlert)', '+             rule_c->action = strdup(""alert"");', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""error"") >= 0', '+ \t\t\t\t && !config->disableActionError)', '+             rule_c->action = strdup(""error"");', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""action"", ""notify"") >= 0', '+ \t\t\t\t && !config->disableActionNotify)', '+             rule_c->action = strdup(""notify"");', '+         if (!rule_c->action) {', '+             if ((attr = nad_find_attr(pkt->nad, elem, -1, ""action"", NULL)) >= 0)', '+                 rule_c->action = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+             rule_c->result = AMP_INVALID_ACTION;', '+         }', '+         if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""deliver"") >= 0', '+ \t\t\t&& !config->disableConditionDeliver) {', '+             rule_c->condition = strdup(""deliver"");', '+             if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""direct"") >= 0) {', '+                 rule_c->value = strdup(""direct"");', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""stored"") >= 0) {', '+                 rule_c->value = strdup(""none"");', '+                 if (!config->offlinestorageDisabled', '+                     rule_c->result = AMP_TRIGGERED;', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""none"") >= 0) {', '+                 rule_c->value = strdup(""none"");', '+                 if (config->offlinestorageDisabled', '+                     rule_c->result = AMP_TRIGGERED;', '+             }', '+             if (!rule_c->value) {', '+                 if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", NULL)) >= 0)', '+                     rule_c->value = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+                 rule_c->result = AMP_INVALID_VALUE;', '+             }', '+         }', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""match-resource"") >= 0', '+ \t\t\t\t&& !config->disableConditionMatchResource) {', '+             rule_c->condition = strdup(""match-resource"");', '+             if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""exact"") >= 0) {', '+                 rule_c->value = strdup(""exact"");', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""any"") >= 0) {', '+                 rule_c->value = strdup(""any"");', '+             }', '+             else if (nad_find_attr(pkt->nad, elem, -1, ""value"", ""other"") >= 0) {', '+                 rule_c->value = strdup(""other"");', '+             }', '+             if (!rule_c->value) {', '+                 if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", NULL)) >= 0)', '+                     rule_c->value = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+                 rule_c->result = AMP_INVALID_VALUE;', '+             }', '+         }', '+         else if (nad_find_attr(pkt->nad, elem, -1, ""condition"", ""expire-at"") >= 0', '+ \t\t\t\t&& !config->disableConditionExpireAt) {', '+             rule_c->condition = strdup(""expire-at"");', '+             if ((attr = nad_find_attr(pkt->nad, elem, -1, ""value"", NULL)) < 0)', '+ \t\t\t\trule_c->result = AMP_INVALID_VALUE;', '+ \t\t\telse {', '+ \t\t\t\trule_c->value = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+ \t\t\t\ttime_t stamp = datetime_in(rule_c->value);', '+ \t\t\t\tif (stamp < 0)', '+ \t\t\t\t\trule_c->result = AMP_INVALID_VALUE;', '+ \t\t\t}', '+         }', '+         if (!rule_c->condition) {', '+             if ((attr = nad_find_attr(pkt->nad, elem, -1, ""condition"", NULL)) >= 0)', '+                 rule_c->condition = strndup(NAD_AVAL(pkt->nad, attr), NAD_AVAL_L(pkt->nad, attr));', '+             rule_c->result = AMP_INVALID_CONDITION;', '+         }', '+ \t\tif (rule_c->result > AMP_TRIGGERED)', '+ \t\t\terrormode = 1;', '+         if (rule_c->result == AMP_TRIGGERED && !errormode)', '+             break;', '+         if ((elem = nad_find_elem(pkt->nad, elem, ns, ""rule"", 0)) >= 0) {', '+             rule_c->next = malloc(sizeof(struct amp_rule_st));', '+             memset(rule_c->next, 0, sizeof(struct amp_rule_st));', '+             rule_c = rule_c->next;', '+         }', '+     }', '+     if (rule_c->result != AMP_TRIGGERED || errormode)', '+         rule_c = rule;', '+     while (rule_c != NULL) {', '+ \t\tif (rule_c->result > 0) {', '+ \t\t\tif (!strcmp(rule_c->action, ""drop"") && !errormode)', '+ \t\t\t\tgoto handled;', '+ \t\t\telse if (!strcmp(rule_c->action, ""alert"") && !errormode) {', '+ \t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);', '+ \t\t\t\tpkt_router(res);', '+ \t\t\t\tgoto handled;', '+ \t\t\t}', '+ \t\t\telse if (!strcmp(rule_c->action, ""error"") && !errormode) {', '+ \t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);', '+ \t\t\t\tpkt_router(res);', '+ \t\t\t\tgoto handled;', '+ \t\t\t}', '+ \t\t\telse if (!strcmp(rule_c->action, ""notify"") && !errormode) {', '+ \t\t\t\tpkt_t res = amp_build_response_pkt(pkt, rule_c);', '+ \t\t\t\tpkt_router(res);', '+ \t\t\t}', '+ \t\t}', '+         rule_c = rule_c->next;', '+ \t}', '+ \tpass:', '+ \t\tamp_rule_free(rule);', '+ \t\treturn mod_PASS;', '+     handled:', '+         amp_rule_free(rule);', '+         pkt_free(pkt);', '+         return mod_HANDLED;', '+ }', '+ static mod_ret_t _amp_pkt_sm(mod_instance_t mi, pkt_t pkt) {', '+     mod_amp_config_t config = (mod_amp_config_t) mi->mod->private;', '+     pkt_t res;', '+     int ns, attr;', '+     if(pkt->type != pkt_IQ || pkt->ns != ns_DISCO_INFO)', '+         return mod_PASS;', '+     if ((attr = nad_find_attr(pkt->nad, 2, -1, ""node"", NULL)) < 0', '+         || strncmp(NAD_AVAL(pkt->nad, attr), uri_AMP, NAD_AVAL_L(pkt->nad, attr)) != 0)', '+         return mod_PASS;', '+     res = pkt_create(config->sm, ""iq"", ""result"", jid_full(pkt->from), jid_full(pkt->to));', '+     pkt_id(pkt, res);', '+     pkt_free(pkt);', '+     ns = nad_add_namespace(res->nad, uri_DISCO_INFO, NULL);', '+     nad_append_elem(res->nad, ns, ""query"", 2);', '+     nad_append_attr(res->nad, -1, ""node"", uri_AMP);', '+     nad_append_elem(res->nad, ns, ""identity"", 3);', '+     nad_append_attr(res->nad, -1, ""name"", ""Advanced Message Processing support"");', '+     nad_append_attr(res->nad, -1, ""category"", ""im"");', '+     nad_append_attr(res->nad, -1, ""type"", ""server"");', '+     nad_append_elem(res->nad, ns, ""feature"", 3);', '+     nad_append_attr(res->nad, -1, ""var"", uri_AMP);', '+     if (!config->disableActionDrop) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_ACTION_DROP);', '+     }', '+     if (!config->disableActionError) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_ACTION_ERROR);', '+     }', '+     if (!config->disableActionNotify) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_ACTION_NOTIFY);', '+     }', '+     if (!config->disableConditionDeliver) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_CONDITION_DELIVER);', '+     }', '+     if (!config->disableConditionExpireAt) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_CONDITION_EXPIREAT);', '+     }', '+     if (!config->disableConditionMatchResource) {', '+         nad_append_elem(res->nad, ns, ""feature"", 3);', '+         nad_append_attr(res->nad, -1, ""var"", uri_AMP_CONDITION_MATCHRESOURCE);', '+     }', '+     pkt_router(res);', '+     return mod_HANDLED;', '+ }', '+ static void _amp_free(module_t mod) {', '+     free(mod->private);', '+ }', '+ DLLEXPORT int module_init(mod_instance_t mi, char *arg) {', '+     module_t mod = mi->mod;', '+     mod_amp_config_t config;', '+     char* option;', '+     if (mod->init) return 0;', '+     config = (mod_amp_config_t) malloc(sizeof(struct _mod_amp_config_st));', '+     memset(config, 0, sizeof(struct _mod_amp_config_st));', '+     config->sm = mod->mm->sm;', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.drop"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""action Drop disabled in config."");', '+         config->disableActionDrop = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.error"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""action Error disabled in config."");', '+         config->disableActionError = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.alert"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""action Alert disabled in config."");', '+         config->disableActionAlert = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableactions.notify"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""action Notify disabled in config."");', '+         config->disableActionNotify = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.deliver"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""condition Deliver disabled in config."");', '+         config->disableConditionDeliver = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.expireat"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""condition Expire-At disabled in config."");', '+         config->disableConditionExpireAt = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.disableconditions.matchresource"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""condition Match-Resource disabled in config."");', '+         config->disableConditionMatchResource = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""amp.offlinestoragedisabled"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""offline storage disabled in config."");', '+         config->offlinestorageDisabled = 1;', '+     }', '+     option = config_get_one(mod->mm->sm->config, ""offline.dropmessages"", 0);', '+     if (option != NULL) {', '+         log_debug(ZONE, ""offline storage disabled in config."");', '+         config->offlinestorageDisabled = 1;', '+     }', '+     mod->private = config;', '+     mod->in_sess = _amp_in_sess;', '+     mod->pkt_user = _amp_pkt_user;', '+     mod->pkt_sm = _amp_pkt_sm;', '+     mod->free = _amp_free;', '+     feature_register(mod->mm->sm, uri_AMP);', '+     return 0;', '+ }']",[],314,0.0,314.0,23f47542fb0dc408b1a4f1d434d29c4ac7a08a48jabberd2/jabberd2,[]
a5253dddadd71cf2981a57621ef207f9dfc167d0,ClusterLabs/pacemaker,penginemain.c,train,C,0,"['@@ -1,4 +1,4 @@\n-/* $Id: penginemain.c,v 1.8 2004/02/26 12:58:58 andrew Exp $ */\n+/* $Id: penginemain.c,v 1.9 2004/02/29 20:24:36 andrew Exp $ */\n /* \n  * Copyright (C) 2004 Andrew Beekhof <andrew@beekhof.net>\n  * \n@@ -159,40 +159,42 @@ init_start(void)\n     register_pid(PID_FILE, FALSE, shutdown);\n \n     IPC_Channel *crm_ch = init_client_ipc_comms(""crmd"",\n-\t\t\t\t\t\t\t\t\t\t\t\tdefault_ipc_input_dispatch,\n-\t\t\t\t\t\t\t\t\t\t\t\tNULL);\n-    send_hello_message(crm_ch, ""1234"", CRM_SYSTEM_PENGINE, ""0"", ""1"");\n+\t\t\t\t\t\tdefault_ipc_input_dispatch,\n+\t\t\t\t\t\tNULL);\n \n-    /* Create the mainloop and run it... */\n-    mainloop = g_main_new(FALSE);\n-    cl_log(LOG_INFO, ""Starting %s"", crm_system_name);\n-\n-    G_main_add_IPC_Channel(G_PRIORITY_LOW,\n-\t\t\t\t\t\t   crm_ch,\n-\t\t\t\t\t\t   FALSE, \n-\t\t\t\t\t\t   default_ipc_input_dispatch,\n-\t\t\t\t\t\t   crm_ch, \n-\t\t\t\t\t\t   default_ipc_input_destroy);\n+    if(crm_ch != NULL) {\n+\t    send_hello_message(crm_ch, ""1234"", CRM_SYSTEM_PENGINE, ""0"", ""1"");\n \n-    \n+    /* Create the mainloop and run it... */\n+\t    mainloop = g_main_new(FALSE);\n+\t    cl_log(LOG_INFO, ""Starting %s"", crm_system_name);\n     \n #ifdef REALTIME_SUPPORT\n-\tstatic int  crm_realtime = 1;\n-    if (crm_realtime == 1){\n-\t\tcl_enable_realtime();\n-    }else if (crm_realtime == 0){\n-\t\tcl_disable_realtime();\n-    }\n-    cl_make_realtime(SCHED_RR, 5, 64, 64);\n+\t    static int  crm_realtime = 1;\n+\t    if (crm_realtime == 1){\n+\t\t    cl_enable_realtime();\n+\t    }else if (crm_realtime == 0){\n+\t\t    cl_disable_realtime();\n+\t    }\n+\t    cl_make_realtime(SCHED_RR, 5, 64, 64);\n #endif\n-\n-    g_main_run(mainloop);\n+\t    \n+\t    g_main_run(mainloop);\n+\t    \n+    } else {\n+\t    cl_log(LOG_ERR, ""Could not connect to the CRMd"");\n+    }\n+    \n     return_to_orig_privs();\n-  \n+    \n     if (unlink(PID_FILE) == 0) {\n-\t\tcl_log(LOG_INFO, ""[%s] stopped"", crm_system_name);\n+\t    cl_log(LOG_INFO, ""[%s] stopped"", crm_system_name);\n     }\n-    return 0;\n+\n+    if(crm_ch != NULL)\n+\t    return 0;\n+\n+    return 1;\n }\n \n void\n']",,,"['+ \t\t\t\t\t\tdefault_ipc_input_dispatch,', '+ \t\t\t\t\t\tNULL);', '+     if(crm_ch != NULL) {', '+ \t    send_hello_message(crm_ch, ""1234"", CRM_SYSTEM_PENGINE, ""0"", ""1"");', '+ \t    mainloop = g_main_new(FALSE);', '+ \t    cl_log(LOG_INFO, ""Starting %s"", crm_system_name);', '+ \t    static int  crm_realtime = 1;', '+ \t    if (crm_realtime == 1){', '+ \t\t    cl_enable_realtime();', '+ \t    }else if (crm_realtime == 0){', '+ \t\t    cl_disable_realtime();', '+ \t    }', '+ \t    cl_make_realtime(SCHED_RR, 5, 64, 64);', '+ \t    g_main_run(mainloop);', '+     } else {', '+ \t    cl_log(LOG_ERR, ""Could not connect to the CRMd"");', '+     }', '+ \t    cl_log(LOG_INFO, ""[%s] stopped"", crm_system_name);', '+     if(crm_ch != NULL)', '+ \t    return 0;', '+     return 1;', '- \t\t\t\t\t\t\t\t\t\t\t\tdefault_ipc_input_dispatch,', '- \t\t\t\t\t\t\t\t\t\t\t\tNULL);', '-     send_hello_message(crm_ch, ""1234"", CRM_SYSTEM_PENGINE, ""0"", ""1"");', '-     mainloop = g_main_new(FALSE);', '-     cl_log(LOG_INFO, ""Starting %s"", crm_system_name);', '-     G_main_add_IPC_Channel(G_PRIORITY_LOW,', '- \t\t\t\t\t\t   crm_ch,', '- \t\t\t\t\t\t   FALSE,', '- \t\t\t\t\t\t   default_ipc_input_dispatch,', '- \t\t\t\t\t\t   crm_ch,', '- \t\t\t\t\t\t   default_ipc_input_destroy);', '- \tstatic int  crm_realtime = 1;', '-     if (crm_realtime == 1){', '- \t\tcl_enable_realtime();', '-     }else if (crm_realtime == 0){', '- \t\tcl_disable_realtime();', '-     }', '-     cl_make_realtime(SCHED_RR, 5, 64, 64);', '-     g_main_run(mainloop);', '- \t\tcl_log(LOG_INFO, ""[%s] stopped"", crm_system_name);', '-     return 0;']","['+ \t\t\t\t\t\tdefault_ipc_input_dispatch,', '+ \t\t\t\t\t\tnull);', '+     if(crm_ch != null) {', '+ \t    send_hello_message(crm_ch, ""1234"", crm_system_pengine, ""0"", ""1"");', '+ \t    mainloop = g_main_new(false);', '+ \t    cl_log(log_info, ""starting %s"", crm_system_name);', '+ \t    static int  crm_realtime = 1;', '+ \t    if (crm_realtime == 1){', '+ \t\t    cl_enable_realtime();', '+ \t    }else if (crm_realtime == 0){', '+ \t\t    cl_disable_realtime();', '+ \t    }', '+ \t    cl_make_realtime(sched_rr, 5, 64, 64);', '+ \t    g_main_run(mainloop);', '+     } else {', '+ \t    cl_log(log_err, ""could not connect to the crmd"");', '+     }', '+ \t    cl_log(log_info, ""[%s] stopped"", crm_system_name);', '+     if(crm_ch != null)', '+ \t    return 0;', '+     return 1;', '- \t\t\t\t\t\t\t\t\t\t\t\tdefault_ipc_input_dispatch,', '- \t\t\t\t\t\t\t\t\t\t\t\tnull);', '-     send_hello_message(crm_ch, ""1234"", crm_system_pengine, ""0"", ""1"");', '-     mainloop = g_main_new(false);', '-     cl_log(log_info, ""starting %s"", crm_system_name);', '-     g_main_add_ipc_channel(g_priority_low,', '- \t\t\t\t\t\t   crm_ch,', '- \t\t\t\t\t\t   false,', '- \t\t\t\t\t\t   default_ipc_input_dispatch,', '- \t\t\t\t\t\t   crm_ch,', '- \t\t\t\t\t\t   default_ipc_input_destroy);', '- \tstatic int  crm_realtime = 1;', '-     if (crm_realtime == 1){', '- \t\tcl_enable_realtime();', '-     }else if (crm_realtime == 0){', '- \t\tcl_disable_realtime();', '-     }', '-     cl_make_realtime(sched_rr, 5, 64, 64);', '-     g_main_run(mainloop);', '- \t\tcl_log(log_info, ""[%s] stopped"", crm_system_name);', '-     return 0;']","['+ \t\t\t\t\t\tdefault_ipc_input_dispatch,', '+ \t\t\t\t\t\tNULL);', '+     if(crm_ch != NULL) {', '+ \t    send_hello_message(crm_ch, ""1234"", CRM_SYSTEM_PENGINE, ""0"", ""1"");', '+ \t    mainloop = g_main_new(FALSE);', '+ \t    cl_log(LOG_INFO, ""Starting %s"", crm_system_name);', '+ \t    static int  crm_realtime = 1;', '+ \t    if (crm_realtime == 1){', '+ \t\t    cl_enable_realtime();', '+ \t    }else if (crm_realtime == 0){', '+ \t\t    cl_disable_realtime();', '+ \t    }', '+ \t    cl_make_realtime(SCHED_RR, 5, 64, 64);', '+ \t    g_main_run(mainloop);', '+     } else {', '+ \t    cl_log(LOG_ERR, ""Could not connect to the CRMd"");', '+     }', '+ \t    cl_log(LOG_INFO, ""[%s] stopped"", crm_system_name);', '+     if(crm_ch != NULL)', '+ \t    return 0;', '+     return 1;']","['- \t\t\t\t\t\t\t\t\t\t\t\tdefault_ipc_input_dispatch,', '- \t\t\t\t\t\t\t\t\t\t\t\tNULL);', '-     send_hello_message(crm_ch, ""1234"", CRM_SYSTEM_PENGINE, ""0"", ""1"");', '-     mainloop = g_main_new(FALSE);', '-     cl_log(LOG_INFO, ""Starting %s"", crm_system_name);', '-     G_main_add_IPC_Channel(G_PRIORITY_LOW,', '- \t\t\t\t\t\t   crm_ch,', '- \t\t\t\t\t\t   FALSE,', '- \t\t\t\t\t\t   default_ipc_input_dispatch,', '- \t\t\t\t\t\t   crm_ch,', '- \t\t\t\t\t\t   default_ipc_input_destroy);', '- \tstatic int  crm_realtime = 1;', '-     if (crm_realtime == 1){', '- \t\tcl_enable_realtime();', '-     }else if (crm_realtime == 0){', '- \t\tcl_disable_realtime();', '-     }', '-     cl_make_realtime(SCHED_RR, 5, 64, 64);', '-     g_main_run(mainloop);', '- \t\tcl_log(LOG_INFO, ""[%s] stopped"", crm_system_name);', '-     return 0;']",21,21.0,42.0,a5253dddadd71cf2981a57621ef207f9dfc167d0ClusterLabs/pacemaker,[]
8670bd3a035b753e0b38b4f79a3e79ed407f067e,libarchive/libarchive,read.c,test,C,0,"['@@ -150,6 +150,11 @@ read_archive(struct bsdtar *bsdtar, char mode)\n \t\tif (r == ARCHIVE_FATAL)\n \t\t\tbreak;\n \n+\t\tif (bsdtar->option_numeric_owner) {\n+\t\t\tarchive_entry_set_uname(entry, NULL);\n+\t\t\tarchive_entry_set_gname(entry, NULL);\n+\t\t}\n+\n \t\t/*\n \t\t * Exclude entries that are too old.\n \t\t */\n']",,,"['+ \t\tif (bsdtar->option_numeric_owner) {', '+ \t\t\tarchive_entry_set_uname(entry, NULL);', '+ \t\t\tarchive_entry_set_gname(entry, NULL);', '+ \t\t}']","['+ \t\tif (bsdtar->option_numeric_owner) {', '+ \t\t\tarchive_entry_set_uname(entry, null);', '+ \t\t\tarchive_entry_set_gname(entry, null);', '+ \t\t}']","['+ \t\tif (bsdtar->option_numeric_owner) {', '+ \t\t\tarchive_entry_set_uname(entry, NULL);', '+ \t\t\tarchive_entry_set_gname(entry, NULL);', '+ \t\t}']",[],4,0.0,4.0,8670bd3a035b753e0b38b4f79a3e79ed407f067elibarchive/libarchive,[]
726359c17553adfc2180a77a6db5f771da9fee5f,ClusterLabs/pacemaker,crmd.c,test,C,0,"['@@ -305,8 +305,8 @@ crmd_ipc_input_callback(IPC_Channel *client, gpointer user_data)\n \tif(curr_client != NULL)\n \t{\n \t    CRM_DEBUG(""###-###-### Removing client from hash table"");\n-\t    if(curr_client->table_key != NULL)\n-\t\tg_hash_table_remove(ipc_clients, curr_client->table_key);\n+/* \t    if(curr_client->table_key != NULL) */\n+/* \t\tg_hash_table_remove(ipc_clients, curr_client->table_key); */\n \t    \n \t    if(curr_client->sub_sys == NULL) CRM_DEBUG(""Client had not registered with us yet"");\n \t    else if(strcmp(CRM_SYSTEM_LRMD, curr_client->sub_sys) == 0) have_lrmd = FALSE;\n@@ -332,7 +332,7 @@ crmd_ipc_input_callback(IPC_Channel *client, gpointer user_data)\n \t// else nothign to do, they never registered\n \t    \n  \tCRM_DEBUG(""this client is now gone."");\n-\tFNRET(!hack_return_good);\n+\tFNRET(!hack_return_good); // definitly required\n     }\n     \n \t \n']",,,"['- \t    if(curr_client->table_key != NULL)', '- \t\tg_hash_table_remove(ipc_clients, curr_client->table_key);', '- \tFNRET(!hack_return_good);']","['- \t    if(curr_client->table_key != null)', '- \t\tg_hash_table_remove(ipc_clients, curr_client->table_key);', '- \tfnret(!hack_return_good);']",[],"['- \t    if(curr_client->table_key != NULL)', '- \t\tg_hash_table_remove(ipc_clients, curr_client->table_key);', '- \tFNRET(!hack_return_good);']",0,3.0,3.0,726359c17553adfc2180a77a6db5f771da9fee5fClusterLabs/pacemaker,[]
3e584505132e6cb161bfdd1d86d75609ebee7564,php/php-src,main.c,train,C,0,"['@@ -63,6 +63,7 @@\n #endif\n #include ""zend.h""\n #include ""php_ini.h""\n+#include ""php_globals.h""\n #include ""main.h""\n #include ""control_structures.h""\n #include ""fopen-wrappers.h""\n@@ -104,6 +105,10 @@ int compiler_globals_id;\n int executor_globals_id;\n #endif\n \n+#ifndef ZTS\n+php_core_globals core_globals;\n+#endif\n+\n void *gLock;\t\t\t\t\t/*mutex variable */\n \n \n@@ -115,6 +120,34 @@ void *gLock;\t\t\t\t\t/*mutex variable */\n HashTable configuration_hash;\n char *php3_ini_path = NULL;\n \n+PHP_INI_MH(OnSetPrecision)\n+{\n+\tELS_FETCH();\n+\n+\tEG(precision) = atoi(new_value);\n+\treturn SUCCESS;\n+}\n+\n+\n+PHP_INI_BEGIN()\n+\tPHP_INI_ENTRY(""short_open_tag"",\t\t""1"",\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)\n+\tPHP_INI_ENTRY(""asp_tags"",\t\t\t""0"",\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)\n+\tPHP_INI_ENTRY(""precision"",\t\t\t""14"",\t\tPHP_INI_ALL,\t\tOnSetPrecision,\tNULL)\n+\n+\tPHP_INI_ENTRY(""highlight.comment"",\tHL_COMMENT_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)\n+\tPHP_INI_ENTRY(""highlight.default"",\tHL_DEFAULT_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)\n+\tPHP_INI_ENTRY(""highlight.html"",\t\tHL_HTML_COLOR,\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)\n+\tPHP_INI_ENTRY(""highlight.string"",\tHL_STRING_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)\n+\tPHP_INI_ENTRY(""highlight.bg"",\t\tHL_BG_COLOR,\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)\n+\tPHP_INI_ENTRY(""highlight.keyword"",\tHL_KEYWORD_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)\n+\n+\tPHP_INI_ENTRY(""magic_quotes_gpc"",\t\t""1"",\t\t\tPHP_INI_ALL,\t\tOnUpdateInt,\t(void *) XtOffsetOf(php_core_globals, magic_quotes_gpc))\n+\tPHP_INI_ENTRY(""magic_quotes_runtime"",\t""0"",\t\t\tPHP_INI_ALL,\t\tOnUpdateInt,\t(void *) XtOffsetOf(php_core_globals, magic_quotes_runtime))\n+\tPHP_INI_ENTRY(""magic_quotes_sybase"",\t""0"",\t\t\tPHP_INI_ALL,\t\tOnUpdateInt,\t(void *) XtOffsetOf(php_core_globals, magic_quotes_sybase))\n+PHP_INI_END()\n+\n+\n+\n #ifndef THREAD_SAFE\n /*\n  * Globals yet to be protected\n@@ -534,7 +567,6 @@ int php3_request_startup(CLS_D ELS_DC)\n \t\tEG(error_reporting) = php3_ini.errors;\n \t\tGLOBAL(header_is_being_sent) = 0;\n \t\tGLOBAL(php3_track_vars) = php3_ini.track_vars;\n-\t\tEG(precision) = php3_ini.precision;\n \t}\n \n \tif (php3_init_request_info((void *) &php3_ini)) {\n@@ -696,9 +728,6 @@ static int php3_config_ini_startup(ELS_D)\n \t\tif (cfg_get_long(""memory_limit"", &php3_ini.memory_limit) == FAILURE) {\n \t\t\tphp3_ini.memory_limit = 1<<23;  /* 8MB */\n \t\t}\n-\t\tif (cfg_get_long(""precision"", &php3_ini.precision) == FAILURE) {\n-\t\t\tphp3_ini.precision = 14;\n-\t\t}\n \t\tif (cfg_get_string(""SMTP"", &php3_ini.smtp) == FAILURE) {\n \t\t\tphp3_ini.smtp = ""localhost"";\n \t\t}\n@@ -733,15 +762,6 @@ static int php3_config_ini_startup(ELS_D)\n \t\tif (cfg_get_long(""warn_plus_overloading"", &php3_ini.warn_plus_overloading) == FAILURE) {\n \t\t\tphp3_ini.warn_plus_overloading = 0;\n \t\t}\n-\t\tif (cfg_get_long(""magic_quotes_gpc"", &php3_ini.magic_quotes_gpc) == FAILURE) {\n-\t\t\tphp3_ini.magic_quotes_gpc = MAGIC_QUOTES;\n-\t\t}\n-\t\tif (cfg_get_long(""magic_quotes_runtime"", &php3_ini.magic_quotes_runtime) == FAILURE) {\n-\t\t\tphp3_ini.magic_quotes_runtime = MAGIC_QUOTES;\n-\t\t}\n-\t\tif (cfg_get_long(""magic_quotes_sybase"", &php3_ini.magic_quotes_sybase) == FAILURE) {\n-\t\t\tphp3_ini.magic_quotes_sybase = 0;\n-\t\t}\n \t\tif (cfg_get_long(""y2k_compliance"", &php3_ini.y2k_compliance) == FAILURE) {\n \t\t\tphp3_ini.y2k_compliance = 0;\n \t\t}\n@@ -815,25 +835,6 @@ static int php3_config_ini_startup(ELS_D)\n \t\tif (cfg_get_long(""sql.safe_mode"", &php3_ini.sql_safe_mode) == FAILURE) {\n \t\t\tphp3_ini.sql_safe_mode = 0;\n \t\t}\n-\t\t/* Syntax highlighting */\n-\t\tif (cfg_get_string(""highlight.comment"", &php3_ini.highlight_comment) == FAILURE) {\n-\t\t\tphp3_ini.highlight_comment = HL_COMMENT_COLOR;\n-\t\t}\n-\t\tif (cfg_get_string(""highlight.default"", &php3_ini.highlight_default) == FAILURE) {\n-\t\t\tphp3_ini.highlight_default = HL_DEFAULT_COLOR;\n-\t\t}\n-\t\tif (cfg_get_string(""highlight.html"", &php3_ini.highlight_html) == FAILURE) {\n-\t\t\tphp3_ini.highlight_html = HL_HTML_COLOR;\n-\t\t}\n-\t\tif (cfg_get_string(""highlight.string"", &php3_ini.highlight_string) == FAILURE) {\n-\t\t\tphp3_ini.highlight_string = HL_STRING_COLOR;\n-\t\t}\n-\t\tif (cfg_get_string(""highlight.bg"", &php3_ini.highlight_bg) == FAILURE) {\n-\t\t\tphp3_ini.highlight_bg = HL_BG_COLOR;\n-\t\t}\n-\t\tif (cfg_get_string(""highlight.keyword"", &php3_ini.highlight_keyword) == FAILURE) {\n-\t\t\tphp3_ini.highlight_keyword = HL_KEYWORD_COLOR;\n-\t\t}\n \t\tif (cfg_get_long(""engine"", &php3_ini.engine) == FAILURE) {\n \t\t\tphp3_ini.engine = 1;\n \t\t}\n@@ -890,6 +891,7 @@ int php3_module_startup(CLS_D ELS_DC)\n {\n \tzend_utility_functions zuf;\n \tzend_utility_values zuv;\n+\tint module_number=0;\t/* for REGISTER_INI_ENTRIES() */\n \n #if (WIN32|WINNT) && !(USE_SAPI)\n \tWORD wVersionRequested;\n@@ -917,8 +919,6 @@ int php3_module_startup(CLS_D ELS_DC)\n \n \tzend_startup(&zuf, &zuv, NULL);\n \n-\tphp_ini_mstartup();\n-\n #if HAVE_SETLOCALE\n \tsetlocale(LC_CTYPE, """");\n #endif\n@@ -948,6 +948,9 @@ int php3_module_startup(CLS_D ELS_DC)\n \t}\n #endif\t\n \n+\tphp_ini_mstartup();\n+\tREGISTER_INI_ENTRIES();\n+\n \tif (module_startup_modules() == FAILURE) {\n \t\tphp3_printf(""Unable to start modules\\n"");\n \t\treturn FAILURE;\n@@ -964,6 +967,7 @@ void php3_module_shutdown_for_exec(void)\n \n void php3_module_shutdown()\n {\n+\tint module_number=0;\t/* for UNREGISTER_INI_ENTRIES() */\n \tCLS_FETCH();\n \tELS_FETCH();\n \n@@ -991,6 +995,7 @@ void php3_module_shutdown()\n #endif\n \n \tzend_shutdown();\n+\tUNREGISTER_INI_ENTRIES();\n \tphp_ini_mshutdown();\n \tshutdown_memory_manager(0, 1);\n }\n']",,,"['+ #include ""php_globals.h""', '+ #ifndef ZTS', '+ php_core_globals core_globals;', '+ #endif', '+ PHP_INI_MH(OnSetPrecision)', '+ {', '+ \tELS_FETCH();', '+ \tEG(precision) = atoi(new_value);', '+ \treturn SUCCESS;', '+ }', '+ PHP_INI_BEGIN()', '+ \tPHP_INI_ENTRY(""short_open_tag"",\t\t""1"",\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""asp_tags"",\t\t\t""0"",\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""precision"",\t\t\t""14"",\t\tPHP_INI_ALL,\t\tOnSetPrecision,\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.comment"",\tHL_COMMENT_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.default"",\tHL_DEFAULT_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.html"",\t\tHL_HTML_COLOR,\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.string"",\tHL_STRING_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.bg"",\t\tHL_BG_COLOR,\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.keyword"",\tHL_KEYWORD_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""magic_quotes_gpc"",\t\t""1"",\t\t\tPHP_INI_ALL,\t\tOnUpdateInt,\t(void *) XtOffsetOf(php_core_globals, magic_quotes_gpc))', '+ \tPHP_INI_ENTRY(""magic_quotes_runtime"",\t""0"",\t\t\tPHP_INI_ALL,\t\tOnUpdateInt,\t(void *) XtOffsetOf(php_core_globals, magic_quotes_runtime))', '+ \tPHP_INI_ENTRY(""magic_quotes_sybase"",\t""0"",\t\t\tPHP_INI_ALL,\t\tOnUpdateInt,\t(void *) XtOffsetOf(php_core_globals, magic_quotes_sybase))', '+ PHP_INI_END()', '+ \tphp_ini_mstartup();', '+ \tREGISTER_INI_ENTRIES();', '+ \tUNREGISTER_INI_ENTRIES();', '- \t\tEG(precision) = php3_ini.precision;', '- \t\tif (cfg_get_long(""precision"", &php3_ini.precision) == FAILURE) {', '- \t\t\tphp3_ini.precision = 14;', '- \t\t}', '- \t\tif (cfg_get_long(""magic_quotes_gpc"", &php3_ini.magic_quotes_gpc) == FAILURE) {', '- \t\t\tphp3_ini.magic_quotes_gpc = MAGIC_QUOTES;', '- \t\t}', '- \t\tif (cfg_get_long(""magic_quotes_runtime"", &php3_ini.magic_quotes_runtime) == FAILURE) {', '- \t\t\tphp3_ini.magic_quotes_runtime = MAGIC_QUOTES;', '- \t\t}', '- \t\tif (cfg_get_long(""magic_quotes_sybase"", &php3_ini.magic_quotes_sybase) == FAILURE) {', '- \t\t\tphp3_ini.magic_quotes_sybase = 0;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.comment"", &php3_ini.highlight_comment) == FAILURE) {', '- \t\t\tphp3_ini.highlight_comment = HL_COMMENT_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.default"", &php3_ini.highlight_default) == FAILURE) {', '- \t\t\tphp3_ini.highlight_default = HL_DEFAULT_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.html"", &php3_ini.highlight_html) == FAILURE) {', '- \t\t\tphp3_ini.highlight_html = HL_HTML_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.string"", &php3_ini.highlight_string) == FAILURE) {', '- \t\t\tphp3_ini.highlight_string = HL_STRING_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.bg"", &php3_ini.highlight_bg) == FAILURE) {', '- \t\t\tphp3_ini.highlight_bg = HL_BG_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.keyword"", &php3_ini.highlight_keyword) == FAILURE) {', '- \t\t\tphp3_ini.highlight_keyword = HL_KEYWORD_COLOR;', '- \t\t}', '- \tphp_ini_mstartup();']","['+ #include ""php_globals.h""', '+ #ifndef zts', '+ php_core_globals core_globals;', '+ #endif', '+ php_ini_mh(onsetprecision)', '+ {', '+ \tels_fetch();', '+ \teg(precision) = atoi(new_value);', '+ \treturn success;', '+ }', '+ php_ini_begin()', '+ \tphp_ini_entry(""short_open_tag"",\t\t""1"",\t\tphp_ini_all,\t\tnull,\t\t\tnull)', '+ \tphp_ini_entry(""asp_tags"",\t\t\t""0"",\t\tphp_ini_all,\t\tnull,\t\t\tnull)', '+ \tphp_ini_entry(""precision"",\t\t\t""14"",\t\tphp_ini_all,\t\tonsetprecision,\tnull)', '+ \tphp_ini_entry(""highlight.comment"",\thl_comment_color,\tphp_ini_all,\t\tnull,\t\t\tnull)', '+ \tphp_ini_entry(""highlight.default"",\thl_default_color,\tphp_ini_all,\t\tnull,\t\t\tnull)', '+ \tphp_ini_entry(""highlight.html"",\t\thl_html_color,\t\tphp_ini_all,\t\tnull,\t\t\tnull)', '+ \tphp_ini_entry(""highlight.string"",\thl_string_color,\tphp_ini_all,\t\tnull,\t\t\tnull)', '+ \tphp_ini_entry(""highlight.bg"",\t\thl_bg_color,\t\tphp_ini_all,\t\tnull,\t\t\tnull)', '+ \tphp_ini_entry(""highlight.keyword"",\thl_keyword_color,\tphp_ini_all,\t\tnull,\t\t\tnull)', '+ \tphp_ini_entry(""magic_quotes_gpc"",\t\t""1"",\t\t\tphp_ini_all,\t\tonupdateint,\t(void *) xtoffsetof(php_core_globals, magic_quotes_gpc))', '+ \tphp_ini_entry(""magic_quotes_runtime"",\t""0"",\t\t\tphp_ini_all,\t\tonupdateint,\t(void *) xtoffsetof(php_core_globals, magic_quotes_runtime))', '+ \tphp_ini_entry(""magic_quotes_sybase"",\t""0"",\t\t\tphp_ini_all,\t\tonupdateint,\t(void *) xtoffsetof(php_core_globals, magic_quotes_sybase))', '+ php_ini_end()', '+ \tphp_ini_mstartup();', '+ \tregister_ini_entries();', '+ \tunregister_ini_entries();', '- \t\teg(precision) = php3_ini.precision;', '- \t\tif (cfg_get_long(""precision"", &php3_ini.precision) == failure) {', '- \t\t\tphp3_ini.precision = 14;', '- \t\t}', '- \t\tif (cfg_get_long(""magic_quotes_gpc"", &php3_ini.magic_quotes_gpc) == failure) {', '- \t\t\tphp3_ini.magic_quotes_gpc = magic_quotes;', '- \t\t}', '- \t\tif (cfg_get_long(""magic_quotes_runtime"", &php3_ini.magic_quotes_runtime) == failure) {', '- \t\t\tphp3_ini.magic_quotes_runtime = magic_quotes;', '- \t\t}', '- \t\tif (cfg_get_long(""magic_quotes_sybase"", &php3_ini.magic_quotes_sybase) == failure) {', '- \t\t\tphp3_ini.magic_quotes_sybase = 0;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.comment"", &php3_ini.highlight_comment) == failure) {', '- \t\t\tphp3_ini.highlight_comment = hl_comment_color;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.default"", &php3_ini.highlight_default) == failure) {', '- \t\t\tphp3_ini.highlight_default = hl_default_color;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.html"", &php3_ini.highlight_html) == failure) {', '- \t\t\tphp3_ini.highlight_html = hl_html_color;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.string"", &php3_ini.highlight_string) == failure) {', '- \t\t\tphp3_ini.highlight_string = hl_string_color;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.bg"", &php3_ini.highlight_bg) == failure) {', '- \t\t\tphp3_ini.highlight_bg = hl_bg_color;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.keyword"", &php3_ini.highlight_keyword) == failure) {', '- \t\t\tphp3_ini.highlight_keyword = hl_keyword_color;', '- \t\t}', '- \tphp_ini_mstartup();']","['+ #include ""php_globals.h""', '+ #ifndef ZTS', '+ php_core_globals core_globals;', '+ #endif', '+ PHP_INI_MH(OnSetPrecision)', '+ {', '+ \tELS_FETCH();', '+ \tEG(precision) = atoi(new_value);', '+ \treturn SUCCESS;', '+ }', '+ PHP_INI_BEGIN()', '+ \tPHP_INI_ENTRY(""short_open_tag"",\t\t""1"",\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""asp_tags"",\t\t\t""0"",\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""precision"",\t\t\t""14"",\t\tPHP_INI_ALL,\t\tOnSetPrecision,\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.comment"",\tHL_COMMENT_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.default"",\tHL_DEFAULT_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.html"",\t\tHL_HTML_COLOR,\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.string"",\tHL_STRING_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.bg"",\t\tHL_BG_COLOR,\t\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""highlight.keyword"",\tHL_KEYWORD_COLOR,\tPHP_INI_ALL,\t\tNULL,\t\t\tNULL)', '+ \tPHP_INI_ENTRY(""magic_quotes_gpc"",\t\t""1"",\t\t\tPHP_INI_ALL,\t\tOnUpdateInt,\t(void *) XtOffsetOf(php_core_globals, magic_quotes_gpc))', '+ \tPHP_INI_ENTRY(""magic_quotes_runtime"",\t""0"",\t\t\tPHP_INI_ALL,\t\tOnUpdateInt,\t(void *) XtOffsetOf(php_core_globals, magic_quotes_runtime))', '+ \tPHP_INI_ENTRY(""magic_quotes_sybase"",\t""0"",\t\t\tPHP_INI_ALL,\t\tOnUpdateInt,\t(void *) XtOffsetOf(php_core_globals, magic_quotes_sybase))', '+ PHP_INI_END()', '+ \tphp_ini_mstartup();', '+ \tREGISTER_INI_ENTRIES();', '+ \tUNREGISTER_INI_ENTRIES();']","['- \t\tEG(precision) = php3_ini.precision;', '- \t\tif (cfg_get_long(""precision"", &php3_ini.precision) == FAILURE) {', '- \t\t\tphp3_ini.precision = 14;', '- \t\t}', '- \t\tif (cfg_get_long(""magic_quotes_gpc"", &php3_ini.magic_quotes_gpc) == FAILURE) {', '- \t\t\tphp3_ini.magic_quotes_gpc = MAGIC_QUOTES;', '- \t\t}', '- \t\tif (cfg_get_long(""magic_quotes_runtime"", &php3_ini.magic_quotes_runtime) == FAILURE) {', '- \t\t\tphp3_ini.magic_quotes_runtime = MAGIC_QUOTES;', '- \t\t}', '- \t\tif (cfg_get_long(""magic_quotes_sybase"", &php3_ini.magic_quotes_sybase) == FAILURE) {', '- \t\t\tphp3_ini.magic_quotes_sybase = 0;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.comment"", &php3_ini.highlight_comment) == FAILURE) {', '- \t\t\tphp3_ini.highlight_comment = HL_COMMENT_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.default"", &php3_ini.highlight_default) == FAILURE) {', '- \t\t\tphp3_ini.highlight_default = HL_DEFAULT_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.html"", &php3_ini.highlight_html) == FAILURE) {', '- \t\t\tphp3_ini.highlight_html = HL_HTML_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.string"", &php3_ini.highlight_string) == FAILURE) {', '- \t\t\tphp3_ini.highlight_string = HL_STRING_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.bg"", &php3_ini.highlight_bg) == FAILURE) {', '- \t\t\tphp3_ini.highlight_bg = HL_BG_COLOR;', '- \t\t}', '- \t\tif (cfg_get_string(""highlight.keyword"", &php3_ini.highlight_keyword) == FAILURE) {', '- \t\t\tphp3_ini.highlight_keyword = HL_KEYWORD_COLOR;', '- \t\t}', '- \tphp_ini_mstartup();']",27,32.0,59.0,3e584505132e6cb161bfdd1d86d75609ebee7564php/php-src,[]
cdab1deb61563383148956a32cf20fceb0ffa9b9,krb5/krb5,ustime.c,train,C,0,"['@@ -13,7 +13,7 @@\n #ifndef\tlint\n static char rcsid_mstime_c[] =\n ""$Id$"";\n-#endif\tlint\n+#endif\t/* lint */\n \n #include <krb5/copyright.h>\n \n@@ -28,7 +28,8 @@ extern int errno;\n \n krb5_error_code\n krb5_ms_timeofday(seconds, milliseconds)\n-register krb5_int32 *seconds, *milliseconds;\n+register krb5_int32 *seconds;\n+register krb5_int16 *milliseconds;\n {\n     struct timeval tv;\n \n']",,,"['+ register krb5_int32 *seconds;', '+ register krb5_int16 *milliseconds;', '- #endif\tlint', '- register krb5_int32 *seconds, *milliseconds;']","['+ register krb5_int32 *seconds;', '+ register krb5_int16 *milliseconds;', '- #endif\tlint', '- register krb5_int32 *seconds, *milliseconds;']","['+ register krb5_int32 *seconds;', '+ register krb5_int16 *milliseconds;']","['- #endif\tlint', '- register krb5_int32 *seconds, *milliseconds;']",2,2.0,4.0,cdab1deb61563383148956a32cf20fceb0ffa9b9krb5/krb5,[]
f8974ca74f2342f574a877dd66fff91104a09997,LawnGnome/php-radius,radlib_compat.c,train,C,0,"['@@ -1,40 +1,60 @@\n+/*\n+  +----------------------------------------------------------------------+\n+  | PHP Version 4                                                        |\n+  +----------------------------------------------------------------------+\n+  | Copyright (c) 1997-2002 The PHP Group                                |\n+  +----------------------------------------------------------------------+\n+  | This source file is subject to version 2.02 of the PHP license,      |\n+  | that is bundled with this package in the file LICENSE, and is        |\n+  | available at through the world-wide-web at                           |\n+  | http://www.php.net/license/2_02.txt.                                 |\n+  | If you did not receive a copy of the PHP license and are unable to   |\n+  | obtain it through the world-wide-web, please send a note to          |\n+  | license@php.net so we can mail you a copy immediately.               |\n+  +----------------------------------------------------------------------+\n+  | Author: Michael Bretterklieber <mbretter@bretterklieber.com>         |\n+  +----------------------------------------------------------------------+\n+\n+  $Id$ \n+*/\n \n #include <stddef.h>\n #include ""php.h""\n #include ""time.h""\n \n-int inet_aton(const char *cp, struct in_addr *inp) {\n-  inp->s_addr = inet_addr(cp);\n+int inet_aton(const char *cp, struct in_addr *inp) \n+{\n+    inp->s_addr = inet_addr(cp);\n \n-  if (inp->s_addr == INADDR_NONE) {\n-\t  return 0;\n-  }\n+    if (inp->s_addr == INADDR_NONE) {\n+        return 0;\n+    }\n \n-  return 1;\n+    return 1;\n }\n \n-char *strsep(char **stringp,\tconst char *delim)\n+char *strsep(char **stringp,\tconst char *delim) \n {\n-\tchar *s;\n-\tconst char *spanp;\n-\tint c, sc;\n-\tchar *tok;\n+    char *s;\n+    const char *spanp;\n+    int c, sc;\n+    char *tok;\n \n-\tif ((s = *stringp) == NULL)\n-\t\treturn (NULL);\n-\tfor (tok = s;;) {\n-\t\tc = *s++;\n-\t\tspanp = delim;\n-\t\tdo {\n-\t\t\tif ((sc = *spanp++) == c) {\n-\t\t\t\tif (c == 0)\n-\t\t\t\t\ts = NULL;\n-\t\t\t\telse\n-\t\t\t\t\ts[-1] = 0;\n-\t\t\t\t*stringp = s;\n-\t\t\t\treturn (tok);\n-\t\t\t}\n-\t\t} while (sc != 0);\n-\t}\n-\t/* NOTREACHED */\n-}\n\\ No newline at end of file\n+    if ((s = *stringp) == NULL)\n+        return (NULL);\n+    for (tok = s;;) {\n+        c = *s++;\n+        spanp = delim;\n+        do {\n+            if ((sc = *spanp++) == c) {\n+                if (c == 0)\n+                    s = NULL;\n+                else\n+                    s[-1] = 0;\n+                *stringp = s;\n+                return (tok);\n+            }\n+        } while (sc != 0);\n+    }\n+    /* NOTREACHED */\n+}\n']",,,"['+ int inet_aton(const char *cp, struct in_addr *inp)', '+ {', '+     inp->s_addr = inet_addr(cp);', '+     if (inp->s_addr == INADDR_NONE) {', '+         return 0;', '+     }', '+     return 1;', '+ char *strsep(char **stringp,\tconst char *delim)', '+     char *s;', '+     const char *spanp;', '+     int c, sc;', '+     char *tok;', '+     if ((s = *stringp) == NULL)', '+         return (NULL);', '+     for (tok = s;;) {', '+         c = *s++;', '+         spanp = delim;', '+         do {', '+             if ((sc = *spanp++) == c) {', '+                 if (c == 0)', '+                     s = NULL;', '+                 else', '+                     s[-1] = 0;', '+                 *stringp = s;', '+                 return (tok);', '+             }', '+         } while (sc != 0);', '+     }', '+ }', '- int inet_aton(const char *cp, struct in_addr *inp) {', '-   inp->s_addr = inet_addr(cp);', '-   if (inp->s_addr == INADDR_NONE) {', '- \t  return 0;', '-   }', '-   return 1;', '- char *strsep(char **stringp,\tconst char *delim)', '- \tchar *s;', '- \tconst char *spanp;', '- \tint c, sc;', '- \tchar *tok;', '- \tif ((s = *stringp) == NULL)', '- \t\treturn (NULL);', '- \tfor (tok = s;;) {', '- \t\tc = *s++;', '- \t\tspanp = delim;', '- \t\tdo {', '- \t\t\tif ((sc = *spanp++) == c) {', '- \t\t\t\tif (c == 0)', '- \t\t\t\t\ts = NULL;', '- \t\t\t\telse', '- \t\t\t\t\ts[-1] = 0;', '- \t\t\t\t*stringp = s;', '- \t\t\t\treturn (tok);', '- \t\t\t}', '- \t\t} while (sc != 0);', '- \t}', '- }']","['+ int inet_aton(const char *cp, struct in_addr *inp)', '+ {', '+     inp->s_addr = inet_addr(cp);', '+     if (inp->s_addr == inaddr_none) {', '+         return 0;', '+     }', '+     return 1;', '+ char *strsep(char **stringp,\tconst char *delim)', '+     char *s;', '+     const char *spanp;', '+     int c, sc;', '+     char *tok;', '+     if ((s = *stringp) == null)', '+         return (null);', '+     for (tok = s;;) {', '+         c = *s++;', '+         spanp = delim;', '+         do {', '+             if ((sc = *spanp++) == c) {', '+                 if (c == 0)', '+                     s = null;', '+                 else', '+                     s[-1] = 0;', '+                 *stringp = s;', '+                 return (tok);', '+             }', '+         } while (sc != 0);', '+     }', '+ }', '- int inet_aton(const char *cp, struct in_addr *inp) {', '-   inp->s_addr = inet_addr(cp);', '-   if (inp->s_addr == inaddr_none) {', '- \t  return 0;', '-   }', '-   return 1;', '- char *strsep(char **stringp,\tconst char *delim)', '- \tchar *s;', '- \tconst char *spanp;', '- \tint c, sc;', '- \tchar *tok;', '- \tif ((s = *stringp) == null)', '- \t\treturn (null);', '- \tfor (tok = s;;) {', '- \t\tc = *s++;', '- \t\tspanp = delim;', '- \t\tdo {', '- \t\t\tif ((sc = *spanp++) == c) {', '- \t\t\t\tif (c == 0)', '- \t\t\t\t\ts = null;', '- \t\t\t\telse', '- \t\t\t\t\ts[-1] = 0;', '- \t\t\t\t*stringp = s;', '- \t\t\t\treturn (tok);', '- \t\t\t}', '- \t\t} while (sc != 0);', '- \t}', '- }']","['+ int inet_aton(const char *cp, struct in_addr *inp)', '+ {', '+     inp->s_addr = inet_addr(cp);', '+     if (inp->s_addr == INADDR_NONE) {', '+         return 0;', '+     }', '+     return 1;', '+ char *strsep(char **stringp,\tconst char *delim)', '+     char *s;', '+     const char *spanp;', '+     int c, sc;', '+     char *tok;', '+     if ((s = *stringp) == NULL)', '+         return (NULL);', '+     for (tok = s;;) {', '+         c = *s++;', '+         spanp = delim;', '+         do {', '+             if ((sc = *spanp++) == c) {', '+                 if (c == 0)', '+                     s = NULL;', '+                 else', '+                     s[-1] = 0;', '+                 *stringp = s;', '+                 return (tok);', '+             }', '+         } while (sc != 0);', '+     }', '+ }']","['- int inet_aton(const char *cp, struct in_addr *inp) {', '-   inp->s_addr = inet_addr(cp);', '-   if (inp->s_addr == INADDR_NONE) {', '- \t  return 0;', '-   }', '-   return 1;', '- char *strsep(char **stringp,\tconst char *delim)', '- \tchar *s;', '- \tconst char *spanp;', '- \tint c, sc;', '- \tchar *tok;', '- \tif ((s = *stringp) == NULL)', '- \t\treturn (NULL);', '- \tfor (tok = s;;) {', '- \t\tc = *s++;', '- \t\tspanp = delim;', '- \t\tdo {', '- \t\t\tif ((sc = *spanp++) == c) {', '- \t\t\t\tif (c == 0)', '- \t\t\t\t\ts = NULL;', '- \t\t\t\telse', '- \t\t\t\t\ts[-1] = 0;', '- \t\t\t\t*stringp = s;', '- \t\t\t\treturn (tok);', '- \t\t\t}', '- \t\t} while (sc != 0);', '- \t}', '- }']",29,28.0,57.0,f8974ca74f2342f574a877dd66fff91104a09997LawnGnome/php-radius,[]
980fc7b83458fe6bbd58910813ba7ad3faf6cf76,FFmpeg/FFmpeg,dsputil.c,train,C,0,"['@@ -21,7 +21,7 @@\n #include ""avcodec.h""\n #include ""dsputil.h""\n \n-#ifdef CONFIG_MMX\n+#ifdef HAVE_MMX\n int mm_flags; /* multimedia extension flags */\n #endif\n \n@@ -377,7 +377,7 @@ void dsputil_init(void)\n     pix_abs16x16_xy2 = pix_abs16x16_xy2_c;\n     av_fdct = jpeg_fdct_ifast;\n \n-#ifdef CONFIG_MMX\n+#ifdef HAVE_MMX\n     dsputil_init_mmx();\n #endif\n }\n']",,,"['+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX', '- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX']","['+ #ifdef have_mmx', '+ #ifdef have_mmx', '- #ifdef config_mmx', '- #ifdef config_mmx']","['+ #ifdef HAVE_MMX', '+ #ifdef HAVE_MMX']","['- #ifdef CONFIG_MMX', '- #ifdef CONFIG_MMX']",2,2.0,4.0,980fc7b83458fe6bbd58910813ba7ad3faf6cf76FFmpeg/FFmpeg,[]
d1bf207d30fe62a15d0e8669d186374c68e6eae8,quassel/quassel,src/core/coreauthhandler.cpp,train,C++,1,"['@@ -32,22 +32,94 @@\n using namespace Protocol;\n \n CoreAuthHandler::CoreAuthHandler(QTcpSocket *socket, QObject *parent)\n-    : AuthHandler(parent)\n-    , _peer(0)\n-    , _clientRegistered(false)\n+    : AuthHandler(parent),\n+    _peer(0),\n+    _magicReceived(false),\n+    _legacy(false),\n+    _clientRegistered(false),\n+    _connectionFeatures(0)\n {\n     setSocket(socket);\n+    connect(socket, SIGNAL(readyRead()), SLOT(onReadyRead()));\n \n-    // TODO: protocol detection\n+    // TODO: Timeout for the handshake phase\n \n-    // FIXME: make sure _peer gets deleted\n-    // TODO: socket ownership goes to the peer! (-> use shared ptr later...)\n-    _peer = new LegacyPeer(this, socket, this);\n-    // only in compat mode\n-    connect(_peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));\n }\n \n \n+void CoreAuthHandler::onReadyRead()\n+{\n+    if (socket()->bytesAvailable() < 4)\n+        return;\n+\n+    // once we have selected a peer, we certainly don\'t want to read more data!\n+    if (_peer)\n+        return;\n+\n+    if (!_magicReceived) {\n+        quint32 magic;\n+        socket()->peek((char*)&magic, 4);\n+        magic = qFromBigEndian<quint32>(magic);\n+\n+        if ((magic & 0xffffff00) != Protocol::magic) {\n+            // no magic, assume legacy protocol\n+            qDebug() << ""Legacy client detected, switching to compatibility mode"";\n+            _legacy = true;\n+            RemotePeer *peer = new LegacyPeer(this, socket(), this);\n+            connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));\n+            setPeer(peer);\n+            return;\n+        }\n+\n+        _magicReceived = true;\n+        quint8 features = magic & 0xff;\n+        // figure out which connection features we\'ll use based on the client\'s support\n+        if (Core::sslSupported() && (features & Protocol::Encryption))\n+            _connectionFeatures |= Protocol::Encryption;\n+        if (features & Protocol::Compression)\n+            _connectionFeatures |= Protocol::Compression;\n+\n+        socket()->read((char*)&magic, 4); // read the 4 bytes we\'ve just peeked at\n+    }\n+\n+    // read the list of protocols supported by the client\n+    while (socket()->bytesAvailable() >= 4) {\n+        quint32 data;\n+        socket()->read((char*)&data, 4);\n+        data = qFromBigEndian<quint32>(data);\n+\n+        Protocol::Type type = static_cast<Protocol::Type>(data & 0xff);\n+        quint16 protoFeatures = static_cast<quint16>(data>>8 & 0xffff);\n+        _supportedProtos.append(PeerFactory::ProtoDescriptor(type, protoFeatures));\n+\n+        if (data >= 0x80000000) { // last protocol\n+            RemotePeer *peer = PeerFactory::createPeer(_supportedProtos, this, socket(), this);\n+            if (peer->protocol() == Protocol::LegacyProtocol) {\n+                _legacy = true;\n+                connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));\n+            }\n+            setPeer(peer);\n+\n+            // inform the client\n+            quint32 reply = peer->protocol() | peer->enabledFeatures()<<8 | _connectionFeatures<<24;\n+            reply = qToBigEndian<quint32>(reply);\n+            socket()->write((char*)&reply, 4);\n+            socket()->flush();\n+\n+            if (!_legacy && (_connectionFeatures & Protocol::Encryption))\n+                startSsl(); // legacy peer enables it later\n+            return;\n+        }\n+    }\n+}\n+\n+\n+void CoreAuthHandler::setPeer(RemotePeer *peer)\n+{\n+    _peer = peer;\n+    disconnect(socket(), SIGNAL(readyRead()), this, SLOT(onReadyRead()));\n+}\n+\n // only in compat mode\n void CoreAuthHandler::onProtocolVersionMismatch(int actual, int expected)\n {\n@@ -60,35 +132,11 @@ void CoreAuthHandler::onProtocolVersionMismatch(int actual, int expected)\n }\n \n \n-void CoreAuthHandler::startSsl()\n-{\n-#ifdef HAVE_SSL\n-    QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());\n-    Q_ASSERT(sslSocket);\n-\n-    qDebug() << qPrintable(tr(""Starting encryption for Client:""))  << _peer->description();\n-    connect(sslSocket, SIGNAL(sslErrors(const QList<QSslError> &)), SLOT(onSslErrors()));\n-    sslSocket->flush(); // ensure that the write cache is flushed before we switch to ssl (bug 682)\n-    sslSocket->startServerEncryption();\n-#endif\n-}\n-\n-\n-#ifdef HAVE_SSL\n-void CoreAuthHandler::onSslErrors()\n-{\n-    QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());\n-    Q_ASSERT(sslSocket);\n-    sslSocket->ignoreSslErrors();\n-}\n-#endif\n-\n-\n bool CoreAuthHandler::checkClientRegistered()\n {\n     if (!_clientRegistered) {\n-        qWarning() << qPrintable(tr(""Client"")) << qPrintable(socket()->peerAddress().toString()) << qPrintable(tr(""did not send an init message before trying to login, rejecting.""));\n-        _peer->dispatch(ClientDenied(tr(""<b>Client not initialized!</b><br>You need to send an init message before trying to login."")));\n+        qWarning() << qPrintable(tr(""Client"")) << qPrintable(socket()->peerAddress().toString()) << qPrintable(tr(""did not send a registration message before trying to login, rejecting.""));\n+        _peer->dispatch(ClientDenied(tr(""<b>Client not initialized!</b><br>You need to send a registration message before trying to login."")));\n         _peer->close();\n         return false;\n     }\n@@ -98,25 +146,27 @@ bool CoreAuthHandler::checkClientRegistered()\n \n void CoreAuthHandler::handle(const RegisterClient &msg)\n {\n-    // TODO: only in compat mode\n-    bool useSsl = false;\n-#ifdef HAVE_SSL\n-    if (Quassel::isOptionSet(""require-ssl"") && !msg.sslSupported) {\n+    bool useSsl;\n+    if (_legacy)\n+        useSsl = Core::sslSupported() && msg.sslSupported;\n+    else\n+        useSsl = _connectionFeatures & Protocol::Encryption;\n+\n+    if (Quassel::isOptionSet(""require-ssl"") && !useSsl) {\n         _peer->dispatch(ClientDenied(tr(""<b>SSL is required!</b><br>You need to use SSL in order to connect to this core."")));\n         _peer->close();\n         return;\n     }\n-    if (Core::sslSupported() && msg.sslSupported)\n-        useSsl = true;\n-#endif\n+\n     QVariantList backends;\n     bool configured = Core::isConfigured();\n     if (!configured)\n         backends = Core::backendInfo();\n \n+    // useSsl and startTime are only used for the legacy protocol\n     _peer->dispatch(ClientRegistered(Quassel::features(), configured, backends, useSsl, Core::instance()->startTime()));\n-    // TODO: only in compat mode\n-    if (useSsl)\n+\n+    if (_legacy && useSsl)\n         startSsl();\n \n     _clientRegistered = true;\n@@ -157,3 +207,30 @@ void CoreAuthHandler::handle(const Login &msg)\n     socket()->flush(); // Make sure all data is sent before handing over the peer (and socket) to the session thread (bug 682)\n     emit handshakeComplete(_peer, uid);\n }\n+\n+\n+/*** SSL Stuff ***/\n+\n+void CoreAuthHandler::startSsl()\n+{\n+    #ifdef HAVE_SSL\n+    QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());\n+    Q_ASSERT(sslSocket);\n+\n+    qDebug() << qPrintable(tr(""Starting encryption for Client:""))  << _peer->description();\n+    connect(sslSocket, SIGNAL(sslErrors(const QList<QSslError> &)), SLOT(onSslErrors()));\n+    sslSocket->flush(); // ensure that the write cache is flushed before we switch to ssl (bug 682)\n+    sslSocket->startServerEncryption();\n+    #endif /* HAVE_SSL */\n+}\n+\n+\n+#ifdef HAVE_SSL\n+void CoreAuthHandler::onSslErrors()\n+{\n+    QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());\n+    Q_ASSERT(sslSocket);\n+    sslSocket->ignoreSslErrors();\n+}\n+#endif\n+\n']",2014-01-23 20:36:43+01:00,"Implement protocol detection

This introduces a new initial handshake for negotiating the supported
protocols and connection features on both sides. It is completely
backwards compatible with older releases, in which case we go into
fallback mode.

Arguably, we could've used a nice, verbose, text-based handshake, but
that would've introduced questions around string formats, parsing and so
on. Also I felt like doing some bitbanging, so now the probing only
exchanges a few bytes which are described in the wiki [1]. If we ever
plan to use a more verbose or different format, changing the magic that
starts the whole shebang will be sufficient to indicate a new format.

Immediately after probing, if both core and client support the new format
(and a protocol other than the legacy one),we'll enable SSL and compression [2]
as appropriate, instead of doing it somewhat later in the middle of the legacy
handshake.

To retain compatibility, the magic number sent by the client is designed such
that older cores will immediately close the connection; we'll then reconnect
in compatibility mode. The other way round, if an older client connects to
a new core, we'll figure out that there's no magic being sent and switch to
legacy mode as well.

The unchanged legacy protocol is also the last resort even if both ends speak
the new handshake as long as we don't have an alternative to offer. So for now,
we'll probe for protocol support, get back the legacy protocol as only choice,
and use that as before. This also disables early SSL and compression mentioned above.

This means that 3rd party clients could already implement the handshake in
preparation for the future without changing anything else. Note that they should
also implement the detection of older cores in order to stay compatible with them -
simply detect a disconnect after the first few bytes sent and reconnect again
in compat mode.

[1] http://bugs.quassel-irc.org/projects/quassel-irc/wiki/Doc_quassel_protocols
[2] Not implemented yet.","[['+     : AuthHandler(parent),', '+     _peer(0),', '+     _magicReceived(false),', '+     _legacy(false),', '+     _clientRegistered(false),', '+     _connectionFeatures(0)', '+     connect(socket, SIGNAL(readyRead()), SLOT(onReadyRead()));', '+ void CoreAuthHandler::onReadyRead()', '+ {', '+     if (socket()->bytesAvailable() < 4)', '+         return;', '+ ', '+     if (_peer)', '+         return;', '+ ', '+     if (!_magicReceived) {', '+         quint32 magic;', '+         socket()->peek((char*)&magic, 4);', '+         magic = qFromBigEndian<quint32>(magic);', '+ ', '+         if ((magic & 0xffffff00) != Protocol::magic) {', '+             qDebug() << ""Legacy client detected, switching to compatibility mode"";', '+             _legacy = true;', '+             RemotePeer *peer = new LegacyPeer(this, socket(), this);', '+             connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));', '+             setPeer(peer);', '+             return;', '+         }', '+ ', '+         _magicReceived = true;', '+         quint8 features = magic & 0xff;', '+         if (Core::sslSupported() && (features & Protocol::Encryption))', '+             _connectionFeatures |= Protocol::Encryption;', '+         if (features & Protocol::Compression)', '+             _connectionFeatures |= Protocol::Compression;', '+ ', '+     }', '+ ', '+     while (socket()->bytesAvailable() >= 4) {', '+         quint32 data;', '+         socket()->read((char*)&data, 4);', '+         data = qFromBigEndian<quint32>(data);', '+ ', '+         Protocol::Type type = static_cast<Protocol::Type>(data & 0xff);', '+         quint16 protoFeatures = static_cast<quint16>(data>>8 & 0xffff);', '+         _supportedProtos.append(PeerFactory::ProtoDescriptor(type, protoFeatures));', '+ ', '+     }', '+ }', '+ ', '+ ', '+ void CoreAuthHandler::setPeer(RemotePeer *peer)', '+ {', '+     _peer = peer;', '+     disconnect(socket(), SIGNAL(readyRead()), this, SLOT(onReadyRead()));', '+ }', '+ ', '+         qWarning() << qPrintable(tr(""Client"")) << qPrintable(socket()->peerAddress().toString()) << qPrintable(tr(""did not send a registration message before trying to login, rejecting.""));', '+         _peer->dispatch(ClientDenied(tr(""<b>Client not initialized!</b><br>You need to send a registration message before trying to login."")));', '+     bool useSsl;', '+     if (_legacy)', '+         useSsl = Core::sslSupported() && msg.sslSupported;', '+     else', '+         useSsl = _connectionFeatures & Protocol::Encryption;', '+ ', '+     if (Quassel::isOptionSet(""require-ssl"") && !useSsl) {', '+ ', '+ ', '+     if (_legacy && useSsl)', '+ ', '+ ', '+ ', '+ void CoreAuthHandler::startSsl()', '+ {', '+     #ifdef HAVE_SSL', '+     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());', '+     Q_ASSERT(sslSocket);', '+ ', '+     qDebug() << qPrintable(tr(""Starting encryption for Client:""))  << _peer->description();', '+     connect(sslSocket, SIGNAL(sslErrors(const QList<QSslError> &)), SLOT(onSslErrors()));', '+     sslSocket->startServerEncryption();', '+ }', '+ ', '+ ', '+ #ifdef HAVE_SSL', '+ void CoreAuthHandler::onSslErrors()', '+ {', '+     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());', '+     Q_ASSERT(sslSocket);', '+     sslSocket->ignoreSslErrors();', '+ }', '+ #endif', '+ ', '-     : AuthHandler(parent)', '-     , _peer(0)', '-     , _clientRegistered(false)', '-     _peer = new LegacyPeer(this, socket, this);', '-     connect(_peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));', '- void CoreAuthHandler::startSsl()', '- {', '- #ifdef HAVE_SSL', '-     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());', '-     Q_ASSERT(sslSocket);', '- ', '-     qDebug() << qPrintable(tr(""Starting encryption for Client:""))  << _peer->description();', '-     connect(sslSocket, SIGNAL(sslErrors(const QList<QSslError> &)), SLOT(onSslErrors()));', '-     sslSocket->startServerEncryption();', '- #endif', '- }', '- ', '- ', '- #ifdef HAVE_SSL', '- void CoreAuthHandler::onSslErrors()', '- {', '-     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());', '-     Q_ASSERT(sslSocket);', '-     sslSocket->ignoreSslErrors();', '- }', '- #endif', '- ', '- ', '-         qWarning() << qPrintable(tr(""Client"")) << qPrintable(socket()->peerAddress().toString()) << qPrintable(tr(""did not send an init message before trying to login, rejecting.""));', '-         _peer->dispatch(ClientDenied(tr(""<b>Client not initialized!</b><br>You need to send an init message before trying to login."")));', '-     bool useSsl = false;', '- #ifdef HAVE_SSL', '-     if (Quassel::isOptionSet(""require-ssl"") && !msg.sslSupported) {', '-     if (Core::sslSupported() && msg.sslSupported)', '-         useSsl = true;', '- #endif', '-     if (useSsl)']]","[['+     : authhandler(parent),', '+     _peer(0),', '+     _magicreceived(false),', '+     _legacy(false),', '+     _clientregistered(false),', '+     _connectionfeatures(0)', '+     connect(socket, signal(readyread()), slot(onreadyread()));', '+ void coreauthhandler::onreadyread()', '+ {', '+     if (socket()->bytesavailable() < 4)', '+         return;', '+ ', '+     if (_peer)', '+         return;', '+ ', '+     if (!_magicreceived) {', '+         quint32 magic;', '+         socket()->peek((char*)&magic, 4);', '+         magic = qfrombigendian<quint32>(magic);', '+ ', '+         if ((magic & 0xffffff00) != protocol::magic) {', '+             qdebug() << ""legacy client detected, switching to compatibility mode"";', '+             _legacy = true;', '+             remotepeer *peer = new legacypeer(this, socket(), this);', '+             connect(peer, signal(protocolversionmismatch(int,int)), slot(onprotocolversionmismatch(int,int)));', '+             setpeer(peer);', '+             return;', '+         }', '+ ', '+         _magicreceived = true;', '+         quint8 features = magic & 0xff;', '+         if (core::sslsupported() && (features & protocol::encryption))', '+             _connectionfeatures |= protocol::encryption;', '+         if (features & protocol::compression)', '+             _connectionfeatures |= protocol::compression;', '+ ', '+     }', '+ ', '+     while (socket()->bytesavailable() >= 4) {', '+         quint32 data;', '+         socket()->read((char*)&data, 4);', '+         data = qfrombigendian<quint32>(data);', '+ ', '+         protocol::type type = static_cast<protocol::type>(data & 0xff);', '+         quint16 protofeatures = static_cast<quint16>(data>>8 & 0xffff);', '+         _supportedprotos.append(peerfactory::protodescriptor(type, protofeatures));', '+ ', '+     }', '+ }', '+ ', '+ ', '+ void coreauthhandler::setpeer(remotepeer *peer)', '+ {', '+     _peer = peer;', '+     disconnect(socket(), signal(readyread()), this, slot(onreadyread()));', '+ }', '+ ', '+         qwarning() << qprintable(tr(""client"")) << qprintable(socket()->peeraddress().tostring()) << qprintable(tr(""did not send a registration message before trying to login, rejecting.""));', '+         _peer->dispatch(clientdenied(tr(""<b>client not initialized!</b><br>you need to send a registration message before trying to login."")));', '+     bool usessl;', '+     if (_legacy)', '+         usessl = core::sslsupported() && msg.sslsupported;', '+     else', '+         usessl = _connectionfeatures & protocol::encryption;', '+ ', '+     if (quassel::isoptionset(""require-ssl"") && !usessl) {', '+ ', '+ ', '+     if (_legacy && usessl)', '+ ', '+ ', '+ ', '+ void coreauthhandler::startssl()', '+ {', '+     #ifdef have_ssl', '+     qsslsocket *sslsocket = qobject_cast<qsslsocket *>(socket());', '+     q_assert(sslsocket);', '+ ', '+     qdebug() << qprintable(tr(""starting encryption for client:""))  << _peer->description();', '+     connect(sslsocket, signal(sslerrors(const qlist<qsslerror> &)), slot(onsslerrors()));', '+     sslsocket->startserverencryption();', '+ }', '+ ', '+ ', '+ #ifdef have_ssl', '+ void coreauthhandler::onsslerrors()', '+ {', '+     qsslsocket *sslsocket = qobject_cast<qsslsocket *>(socket());', '+     q_assert(sslsocket);', '+     sslsocket->ignoresslerrors();', '+ }', '+ #endif', '+ ', '-     : authhandler(parent)', '-     , _peer(0)', '-     , _clientregistered(false)', '-     _peer = new legacypeer(this, socket, this);', '-     connect(_peer, signal(protocolversionmismatch(int,int)), slot(onprotocolversionmismatch(int,int)));', '- void coreauthhandler::startssl()', '- {', '- #ifdef have_ssl', '-     qsslsocket *sslsocket = qobject_cast<qsslsocket *>(socket());', '-     q_assert(sslsocket);', '- ', '-     qdebug() << qprintable(tr(""starting encryption for client:""))  << _peer->description();', '-     connect(sslsocket, signal(sslerrors(const qlist<qsslerror> &)), slot(onsslerrors()));', '-     sslsocket->startserverencryption();', '- #endif', '- }', '- ', '- ', '- #ifdef have_ssl', '- void coreauthhandler::onsslerrors()', '- {', '-     qsslsocket *sslsocket = qobject_cast<qsslsocket *>(socket());', '-     q_assert(sslsocket);', '-     sslsocket->ignoresslerrors();', '- }', '- #endif', '- ', '- ', '-         qwarning() << qprintable(tr(""client"")) << qprintable(socket()->peeraddress().tostring()) << qprintable(tr(""did not send an init message before trying to login, rejecting.""));', '-         _peer->dispatch(clientdenied(tr(""<b>client not initialized!</b><br>you need to send an init message before trying to login."")));', '-     bool usessl = false;', '- #ifdef have_ssl', '-     if (quassel::isoptionset(""require-ssl"") && !msg.sslsupported) {', '-     if (core::sslsupported() && msg.sslsupported)', '-         usessl = true;', '- #endif', '-     if (usessl)']]","[['+     : AuthHandler(parent),', '+     _peer(0),', '+     _magicReceived(false),', '+     _legacy(false),', '+     _clientRegistered(false),', '+     _connectionFeatures(0)', '+     connect(socket, SIGNAL(readyRead()), SLOT(onReadyRead()));', '+ void CoreAuthHandler::onReadyRead()', '+ {', '+     if (socket()->bytesAvailable() < 4)', '+         return;', '+ ', '+     if (_peer)', '+         return;', '+ ', '+     if (!_magicReceived) {', '+         quint32 magic;', '+         socket()->peek((char*)&magic, 4);', '+         magic = qFromBigEndian<quint32>(magic);', '+ ', '+         if ((magic & 0xffffff00) != Protocol::magic) {', '+             qDebug() << ""Legacy client detected, switching to compatibility mode"";', '+             _legacy = true;', '+             RemotePeer *peer = new LegacyPeer(this, socket(), this);', '+             connect(peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));', '+             setPeer(peer);', '+             return;', '+         }', '+ ', '+         _magicReceived = true;', '+         quint8 features = magic & 0xff;', '+         if (Core::sslSupported() && (features & Protocol::Encryption))', '+             _connectionFeatures |= Protocol::Encryption;', '+         if (features & Protocol::Compression)', '+             _connectionFeatures |= Protocol::Compression;', '+ ', '+     }', '+ ', '+     while (socket()->bytesAvailable() >= 4) {', '+         quint32 data;', '+         socket()->read((char*)&data, 4);', '+         data = qFromBigEndian<quint32>(data);', '+ ', '+         Protocol::Type type = static_cast<Protocol::Type>(data & 0xff);', '+         quint16 protoFeatures = static_cast<quint16>(data>>8 & 0xffff);', '+         _supportedProtos.append(PeerFactory::ProtoDescriptor(type, protoFeatures));', '+ ', '+     }', '+ }', '+ ', '+ ', '+ void CoreAuthHandler::setPeer(RemotePeer *peer)', '+ {', '+     _peer = peer;', '+     disconnect(socket(), SIGNAL(readyRead()), this, SLOT(onReadyRead()));', '+ }', '+ ', '+         qWarning() << qPrintable(tr(""Client"")) << qPrintable(socket()->peerAddress().toString()) << qPrintable(tr(""did not send a registration message before trying to login, rejecting.""));', '+         _peer->dispatch(ClientDenied(tr(""<b>Client not initialized!</b><br>You need to send a registration message before trying to login."")));', '+     bool useSsl;', '+     if (_legacy)', '+         useSsl = Core::sslSupported() && msg.sslSupported;', '+     else', '+         useSsl = _connectionFeatures & Protocol::Encryption;', '+ ', '+     if (Quassel::isOptionSet(""require-ssl"") && !useSsl) {', '+ ', '+ ', '+     if (_legacy && useSsl)', '+ ', '+ ', '+ ', '+ void CoreAuthHandler::startSsl()', '+ {', '+     #ifdef HAVE_SSL', '+     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());', '+     Q_ASSERT(sslSocket);', '+ ', '+     qDebug() << qPrintable(tr(""Starting encryption for Client:""))  << _peer->description();', '+     connect(sslSocket, SIGNAL(sslErrors(const QList<QSslError> &)), SLOT(onSslErrors()));', '+     sslSocket->startServerEncryption();', '+ }', '+ ', '+ ', '+ #ifdef HAVE_SSL', '+ void CoreAuthHandler::onSslErrors()', '+ {', '+     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());', '+     Q_ASSERT(sslSocket);', '+     sslSocket->ignoreSslErrors();', '+ }', '+ #endif', '+ ']]","[['-     : AuthHandler(parent)', '-     , _peer(0)', '-     , _clientRegistered(false)', '-     _peer = new LegacyPeer(this, socket, this);', '-     connect(_peer, SIGNAL(protocolVersionMismatch(int,int)), SLOT(onProtocolVersionMismatch(int,int)));', '- void CoreAuthHandler::startSsl()', '- {', '- #ifdef HAVE_SSL', '-     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());', '-     Q_ASSERT(sslSocket);', '- ', '-     qDebug() << qPrintable(tr(""Starting encryption for Client:""))  << _peer->description();', '-     connect(sslSocket, SIGNAL(sslErrors(const QList<QSslError> &)), SLOT(onSslErrors()));', '-     sslSocket->startServerEncryption();', '- #endif', '- }', '- ', '- ', '- #ifdef HAVE_SSL', '- void CoreAuthHandler::onSslErrors()', '- {', '-     QSslSocket *sslSocket = qobject_cast<QSslSocket *>(socket());', '-     Q_ASSERT(sslSocket);', '-     sslSocket->ignoreSslErrors();', '- }', '- #endif', '- ', '- ', '-         qWarning() << qPrintable(tr(""Client"")) << qPrintable(socket()->peerAddress().toString()) << qPrintable(tr(""did not send an init message before trying to login, rejecting.""));', '-         _peer->dispatch(ClientDenied(tr(""<b>Client not initialized!</b><br>You need to send an init message before trying to login."")));', '-     bool useSsl = false;', '- #ifdef HAVE_SSL', '-     if (Quassel::isOptionSet(""require-ssl"") && !msg.sslSupported) {', '-     if (Core::sslSupported() && msg.sslSupported)', '-         useSsl = true;', '- #endif', '-     if (useSsl)']]",93,37.0,130.0,d1bf207d30fe62a15d0e8669d186374c68e6eae8quassel/quassel,['e678873']
3f931efcfd206219ac2a5a66b5e2b21e1ab30aff,file/file,src/readelf.c,train,C,1,"['@@ -38,7 +38,7 @@\n #include ""magic.h""\n \n #ifndef lint\n-FILE_RCSID(""@(#)$File: readelf.c,v 1.74 2008/05/28 21:02:29 christos Exp $"")\n+FILE_RCSID(""@(#)$File: readelf.c,v 1.75 2008/06/05 12:59:15 christos Exp $"")\n #endif\n \n #ifdef\tELFCORE\n@@ -49,7 +49,7 @@ private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t,\n     off_t, int *, int);\n private int doshn(struct magic_set *, int, int, int, off_t, int, size_t, int *,\n     int);\n-private size_t donote(struct magic_set *, unsigned char *, size_t, size_t, int,\n+private size_t donote(struct magic_set *, void *, size_t, size_t, int,\n     int, size_t, int *);\n \n #define\tELF_ALIGN(a)\t((((a) + align - 1) / align) * align)\n@@ -135,72 +135,72 @@ getu64(int swap, uint64_t value)\n # define elf_getu64(swap, value) getu64(swap, value)\n #endif\n \n-#define xsh_addr\t(class == ELFCLASS32\t\t\t\\\n+#define xsh_addr\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? (void *) &sh32\t\t\t\\\n \t\t\t : (void *) &sh64)\n-#define xsh_sizeof\t(class == ELFCLASS32\t\t\t\\\n+#define xsh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? sizeof sh32\t\t\t\t\\\n \t\t\t : sizeof sh64)\n-#define xsh_size\t(class == ELFCLASS32\t\t\t\\\n+#define xsh_size\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? elf_getu32(swap, sh32.sh_size)\t\\\n \t\t\t : elf_getu64(swap, sh64.sh_size))\n-#define xsh_offset\t(class == ELFCLASS32\t\t\t\\\n+#define xsh_offset\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? elf_getu32(swap, sh32.sh_offset)\t\\\n \t\t\t : elf_getu64(swap, sh64.sh_offset))\n-#define xsh_type\t(class == ELFCLASS32\t\t\t\\\n+#define xsh_type\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? elf_getu32(swap, sh32.sh_type)\t\\\n \t\t\t : elf_getu32(swap, sh64.sh_type))\n-#define xph_addr\t(class == ELFCLASS32\t\t\t\\\n+#define xph_addr\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? (void *) &ph32\t\t\t\\\n \t\t\t : (void *) &ph64)\n-#define xph_sizeof\t(class == ELFCLASS32\t\t\t\\\n+#define xph_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? sizeof ph32\t\t\t\t\\\n \t\t\t : sizeof ph64)\n-#define xph_type\t(class == ELFCLASS32\t\t\t\\\n+#define xph_type\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? elf_getu32(swap, ph32.p_type)\t\\\n \t\t\t : elf_getu32(swap, ph64.p_type))\n-#define xph_offset\t(off_t)(class == ELFCLASS32\t\t\\\n+#define xph_offset\t(off_t)(clazz == ELFCLASS32\t\t\\\n \t\t\t ? elf_getu32(swap, ph32.p_offset)\t\\\n \t\t\t : elf_getu64(swap, ph64.p_offset))\n-#define xph_align\t(size_t)((class == ELFCLASS32\t\t\\\n+#define xph_align\t(size_t)((clazz == ELFCLASS32\t\t\\\n \t\t\t ? (off_t) (ph32.p_align ? \t\t\\\n \t\t\t    elf_getu32(swap, ph32.p_align) : 4) \\\n \t\t\t : (off_t) (ph64.p_align ?\t\t\\\n \t\t\t    elf_getu64(swap, ph64.p_align) : 4)))\n-#define xph_filesz\t(size_t)((class == ELFCLASS32\t\t\\\n+#define xph_filesz\t(size_t)((clazz == ELFCLASS32\t\t\\\n \t\t\t ? elf_getu32(swap, ph32.p_filesz)\t\\\n \t\t\t : elf_getu64(swap, ph64.p_filesz)))\n-#define xnh_addr\t(class == ELFCLASS32\t\t\t\\\n+#define xnh_addr\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? (void *) &nh32\t\t\t\\\n \t\t\t : (void *) &nh64)\n-#define xph_memsz\t(size_t)((class == ELFCLASS32\t\t\\\n+#define xph_memsz\t(size_t)((clazz == ELFCLASS32\t\t\\\n \t\t\t ? elf_getu32(swap, ph32.p_memsz)\t\\\n \t\t\t : elf_getu64(swap, ph64.p_memsz)))\n-#define xnh_sizeof\t(class == ELFCLASS32\t\t\t\\\n+#define xnh_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? sizeof nh32\t\t\t\t\\\n \t\t\t : sizeof nh64)\n-#define xnh_type\t(class == ELFCLASS32\t\t\t\\\n+#define xnh_type\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? elf_getu32(swap, nh32.n_type)\t\\\n \t\t\t : elf_getu32(swap, nh64.n_type))\n-#define xnh_namesz\t(class == ELFCLASS32\t\t\t\\\n+#define xnh_namesz\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? elf_getu32(swap, nh32.n_namesz)\t\\\n \t\t\t : elf_getu32(swap, nh64.n_namesz))\n-#define xnh_descsz\t(class == ELFCLASS32\t\t\t\\\n+#define xnh_descsz\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? elf_getu32(swap, nh32.n_descsz)\t\\\n \t\t\t : elf_getu32(swap, nh64.n_descsz))\n-#define prpsoffsets(i)\t(class == ELFCLASS32\t\t\t\\\n+#define prpsoffsets(i)\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? prpsoffsets32[i]\t\t\t\\\n \t\t\t : prpsoffsets64[i])\n-#define xcap_addr\t(class == ELFCLASS32\t\t\t\\\n+#define xcap_addr\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? (void *) &cap32\t\t\t\\\n \t\t\t : (void *) &cap64)\n-#define xcap_sizeof\t(class == ELFCLASS32\t\t\t\\\n+#define xcap_sizeof\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? sizeof cap32\t\t\t\t\\\n \t\t\t : sizeof cap64)\n-#define xcap_tag\t(class == ELFCLASS32\t\t\t\\\n+#define xcap_tag\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? elf_getu32(swap, cap32.c_tag)\t\\\n \t\t\t : elf_getu64(swap, cap64.c_tag))\n-#define xcap_val\t(class == ELFCLASS32\t\t\t\\\n+#define xcap_val\t(clazz == ELFCLASS32\t\t\t\\\n \t\t\t ? elf_getu32(swap, cap32.c_un.c_val)\t\\\n \t\t\t : elf_getu64(swap, cap64.c_un.c_val))\n \n@@ -242,7 +242,7 @@ static const size_t\tprpsoffsets64[] = {\n #define\tNOFFSETS32\t(sizeof prpsoffsets32 / sizeof prpsoffsets32[0])\n #define NOFFSETS64\t(sizeof prpsoffsets64 / sizeof prpsoffsets64[0])\n \n-#define NOFFSETS\t(class == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)\n+#define NOFFSETS\t(clazz == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)\n \n /*\n  * Look through the program headers of an executable image, searching\n@@ -288,7 +288,7 @@ private const char os_style_names[][8] = {\n #define FLAGS_DID_CORE_STYLE\t4\n \n private int\n-dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,\n+dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n     int num, size_t size, off_t fsize, int *flags)\n {\n \tElf32_Phdr ph32;\n@@ -353,7 +353,7 @@ dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,\n \t\t\tif (offset >= (size_t)bufsize)\n \t\t\t\tbreak;\n \t\t\toffset = donote(ms, nbuf, offset, (size_t)bufsize,\n-\t\t\t    class, swap, 4, flags);\n+\t\t\t    clazz, swap, 4, flags);\n \t\t\tif (offset == 0)\n \t\t\t\tbreak;\n \n@@ -364,8 +364,8 @@ dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,\n #endif\n \n private size_t\n-donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n-    int class, int swap, size_t align, int *flags)\n+donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,\n+    int clazz, int swap, size_t align, int *flags)\n {\n \tElf32_Nhdr nh32;\n \tElf64_Nhdr nh64;\n@@ -374,6 +374,7 @@ donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n \tint os_style = -1;\n #endif\n \tuint32_t namesz, descsz;\n+\tunsigned char *nbuf = CAST(unsigned char *, vbuf);\n \n \t(void)memcpy(xnh_addr, &nbuf[offset], xnh_sizeof);\n \toffset += xnh_sizeof;\n@@ -814,7 +815,7 @@ static const cap_desc_t cap_desc_386[] = {\n };\n \n private int\n-doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,\n+doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,\n     size_t size, int *flags, int mach)\n {\n \tElf32_Shdr sh32;\n@@ -877,7 +878,7 @@ doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,\n \t\t\t\tif (noff >= (size_t)xsh_size)\n \t\t\t\t\tbreak;\n \t\t\t\tnoff = donote(ms, nbuf, (size_t)noff,\n-\t\t\t\t    (size_t)xsh_size, class, swap, 4,\n+\t\t\t\t    (size_t)xsh_size, clazz, swap, 4,\n \t\t\t\t    flags);\n \t\t\t\tif (noff == 0)\n \t\t\t\t\tbreak;\n@@ -1007,7 +1008,7 @@ doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,\n  * otherwise it\'s statically linked.\n  */\n private int\n-dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,\n+dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,\n     int num, size_t size, off_t fsize, int *flags, int sh_num)\n {\n \tElf32_Phdr ph32;\n@@ -1099,7 +1100,7 @@ dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,\n \t\t\t\tif (offset >= (size_t)bufsize)\n \t\t\t\t\tbreak;\n \t\t\t\toffset = donote(ms, nbuf, offset,\n-\t\t\t\t    (size_t)bufsize, class, swap, align,\n+\t\t\t\t    (size_t)bufsize, clazz, swap, align,\n \t\t\t\t    flags);\n \t\t\t\tif (offset == 0)\n \t\t\t\t\tbreak;\n@@ -1128,7 +1129,7 @@ file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,\n \t\tint32_t l;\n \t\tchar c[sizeof (int32_t)];\n \t} u;\n-\tint class;\n+\tint clazz;\n \tint swap;\n \tstruct stat st;\n \toff_t fsize;\n@@ -1163,9 +1164,9 @@ file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,\n \t}\n \tfsize = st.st_size;\n \n-\tclass = buf[EI_CLASS];\n+\tclazz = buf[EI_CLASS];\n \n-\tswitch (class) {\n+\tswitch (clazz) {\n \tcase ELFCLASS32:\n #undef elf_getu\n #define elf_getu(a, b)\telf_getu32(a, b)\n@@ -1179,7 +1180,7 @@ file_tryelf(struct magic_set *ms, int fd, const unsigned char *buf,\n #define elfhdr elf64hdr\n #include ""elfclass.h""\n \tdefault:\n-\t    if (file_printf(ms, "", unknown class %d"", class) == -1)\n+\t    if (file_printf(ms, "", unknown class %d"", clazz) == -1)\n \t\t    return -1;\n \t    break;\n \t}\n']",2008-07-16 18:00:57+00:00,make this compilable with a c++ compiler.,"[['+ FILE_RCSID(""@(#)$File: readelf.c,v 1.75 2008/06/05 12:59:15 christos Exp $"")', '+ private size_t donote(struct magic_set *, void *, size_t, size_t, int,', '+ #define xsh_addr\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xsh_sizeof\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xsh_size\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xsh_offset\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xsh_type\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_addr\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_sizeof\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_type\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_offset\t(off_t)(clazz == ELFCLASS32\t\t\\', '+ #define xph_align\t(size_t)((clazz == ELFCLASS32\t\t\\', '+ #define xph_filesz\t(size_t)((clazz == ELFCLASS32\t\t\\', '+ #define xnh_addr\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_memsz\t(size_t)((clazz == ELFCLASS32\t\t\\', '+ #define xnh_sizeof\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xnh_type\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xnh_namesz\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xnh_descsz\t(clazz == ELFCLASS32\t\t\t\\', '+ #define prpsoffsets(i)\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xcap_addr\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xcap_sizeof\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xcap_tag\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xcap_val\t(clazz == ELFCLASS32\t\t\t\\', '+ #define NOFFSETS\t(clazz == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)', '+ dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,', '+ \t\t\t    clazz, swap, 4, flags);', '+ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,', '+     int clazz, int swap, size_t align, int *flags)', '+ \tunsigned char *nbuf = CAST(unsigned char *, vbuf);', '+ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,', '+ \t\t\t\t    (size_t)xsh_size, clazz, swap, 4,', '+ dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,', '+ \t\t\t\t    (size_t)bufsize, clazz, swap, align,', '+ \tint clazz;', '+ \tclazz = buf[EI_CLASS];', '+ \tswitch (clazz) {', '+ \t    if (file_printf(ms, "", unknown class %d"", clazz) == -1)', '- FILE_RCSID(""@(#)$File: readelf.c,v 1.74 2008/05/28 21:02:29 christos Exp $"")', '- private size_t donote(struct magic_set *, unsigned char *, size_t, size_t, int,', '- #define xsh_addr\t(class == ELFCLASS32\t\t\t\\', '- #define xsh_sizeof\t(class == ELFCLASS32\t\t\t\\', '- #define xsh_size\t(class == ELFCLASS32\t\t\t\\', '- #define xsh_offset\t(class == ELFCLASS32\t\t\t\\', '- #define xsh_type\t(class == ELFCLASS32\t\t\t\\', '- #define xph_addr\t(class == ELFCLASS32\t\t\t\\', '- #define xph_sizeof\t(class == ELFCLASS32\t\t\t\\', '- #define xph_type\t(class == ELFCLASS32\t\t\t\\', '- #define xph_offset\t(off_t)(class == ELFCLASS32\t\t\\', '- #define xph_align\t(size_t)((class == ELFCLASS32\t\t\\', '- #define xph_filesz\t(size_t)((class == ELFCLASS32\t\t\\', '- #define xnh_addr\t(class == ELFCLASS32\t\t\t\\', '- #define xph_memsz\t(size_t)((class == ELFCLASS32\t\t\\', '- #define xnh_sizeof\t(class == ELFCLASS32\t\t\t\\', '- #define xnh_type\t(class == ELFCLASS32\t\t\t\\', '- #define xnh_namesz\t(class == ELFCLASS32\t\t\t\\', '- #define xnh_descsz\t(class == ELFCLASS32\t\t\t\\', '- #define prpsoffsets(i)\t(class == ELFCLASS32\t\t\t\\', '- #define xcap_addr\t(class == ELFCLASS32\t\t\t\\', '- #define xcap_sizeof\t(class == ELFCLASS32\t\t\t\\', '- #define xcap_tag\t(class == ELFCLASS32\t\t\t\\', '- #define xcap_val\t(class == ELFCLASS32\t\t\t\\', '- #define NOFFSETS\t(class == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)', '- dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,', '- \t\t\t    class, swap, 4, flags);', '- donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,', '-     int class, int swap, size_t align, int *flags)', '- doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,', '- \t\t\t\t    (size_t)xsh_size, class, swap, 4,', '- dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,', '- \t\t\t\t    (size_t)bufsize, class, swap, align,', '- \tint class;', '- \tclass = buf[EI_CLASS];', '- \tswitch (class) {', '- \t    if (file_printf(ms, "", unknown class %d"", class) == -1)']]","[['+ file_rcsid(""@(#)$file: readelf.c,v 1.75 2008/06/05 12:59:15 christos exp $"")', '+ private size_t donote(struct magic_set *, void *, size_t, size_t, int,', '+ #define xsh_addr\t(clazz == elfclass32\t\t\t\\', '+ #define xsh_sizeof\t(clazz == elfclass32\t\t\t\\', '+ #define xsh_size\t(clazz == elfclass32\t\t\t\\', '+ #define xsh_offset\t(clazz == elfclass32\t\t\t\\', '+ #define xsh_type\t(clazz == elfclass32\t\t\t\\', '+ #define xph_addr\t(clazz == elfclass32\t\t\t\\', '+ #define xph_sizeof\t(clazz == elfclass32\t\t\t\\', '+ #define xph_type\t(clazz == elfclass32\t\t\t\\', '+ #define xph_offset\t(off_t)(clazz == elfclass32\t\t\\', '+ #define xph_align\t(size_t)((clazz == elfclass32\t\t\\', '+ #define xph_filesz\t(size_t)((clazz == elfclass32\t\t\\', '+ #define xnh_addr\t(clazz == elfclass32\t\t\t\\', '+ #define xph_memsz\t(size_t)((clazz == elfclass32\t\t\\', '+ #define xnh_sizeof\t(clazz == elfclass32\t\t\t\\', '+ #define xnh_type\t(clazz == elfclass32\t\t\t\\', '+ #define xnh_namesz\t(clazz == elfclass32\t\t\t\\', '+ #define xnh_descsz\t(clazz == elfclass32\t\t\t\\', '+ #define prpsoffsets(i)\t(clazz == elfclass32\t\t\t\\', '+ #define xcap_addr\t(clazz == elfclass32\t\t\t\\', '+ #define xcap_sizeof\t(clazz == elfclass32\t\t\t\\', '+ #define xcap_tag\t(clazz == elfclass32\t\t\t\\', '+ #define xcap_val\t(clazz == elfclass32\t\t\t\\', '+ #define noffsets\t(clazz == elfclass32 ? noffsets32 : noffsets64)', '+ dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,', '+ \t\t\t    clazz, swap, 4, flags);', '+ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,', '+     int clazz, int swap, size_t align, int *flags)', '+ \tunsigned char *nbuf = cast(unsigned char *, vbuf);', '+ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,', '+ \t\t\t\t    (size_t)xsh_size, clazz, swap, 4,', '+ dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,', '+ \t\t\t\t    (size_t)bufsize, clazz, swap, align,', '+ \tint clazz;', '+ \tclazz = buf[ei_class];', '+ \tswitch (clazz) {', '+ \t    if (file_printf(ms, "", unknown class %d"", clazz) == -1)', '- file_rcsid(""@(#)$file: readelf.c,v 1.74 2008/05/28 21:02:29 christos exp $"")', '- private size_t donote(struct magic_set *, unsigned char *, size_t, size_t, int,', '- #define xsh_addr\t(class == elfclass32\t\t\t\\', '- #define xsh_sizeof\t(class == elfclass32\t\t\t\\', '- #define xsh_size\t(class == elfclass32\t\t\t\\', '- #define xsh_offset\t(class == elfclass32\t\t\t\\', '- #define xsh_type\t(class == elfclass32\t\t\t\\', '- #define xph_addr\t(class == elfclass32\t\t\t\\', '- #define xph_sizeof\t(class == elfclass32\t\t\t\\', '- #define xph_type\t(class == elfclass32\t\t\t\\', '- #define xph_offset\t(off_t)(class == elfclass32\t\t\\', '- #define xph_align\t(size_t)((class == elfclass32\t\t\\', '- #define xph_filesz\t(size_t)((class == elfclass32\t\t\\', '- #define xnh_addr\t(class == elfclass32\t\t\t\\', '- #define xph_memsz\t(size_t)((class == elfclass32\t\t\\', '- #define xnh_sizeof\t(class == elfclass32\t\t\t\\', '- #define xnh_type\t(class == elfclass32\t\t\t\\', '- #define xnh_namesz\t(class == elfclass32\t\t\t\\', '- #define xnh_descsz\t(class == elfclass32\t\t\t\\', '- #define prpsoffsets(i)\t(class == elfclass32\t\t\t\\', '- #define xcap_addr\t(class == elfclass32\t\t\t\\', '- #define xcap_sizeof\t(class == elfclass32\t\t\t\\', '- #define xcap_tag\t(class == elfclass32\t\t\t\\', '- #define xcap_val\t(class == elfclass32\t\t\t\\', '- #define noffsets\t(class == elfclass32 ? noffsets32 : noffsets64)', '- dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,', '- \t\t\t    class, swap, 4, flags);', '- donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,', '-     int class, int swap, size_t align, int *flags)', '- doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,', '- \t\t\t\t    (size_t)xsh_size, class, swap, 4,', '- dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,', '- \t\t\t\t    (size_t)bufsize, class, swap, align,', '- \tint class;', '- \tclass = buf[ei_class];', '- \tswitch (class) {', '- \t    if (file_printf(ms, "", unknown class %d"", class) == -1)']]","[['+ FILE_RCSID(""@(#)$File: readelf.c,v 1.75 2008/06/05 12:59:15 christos Exp $"")', '+ private size_t donote(struct magic_set *, void *, size_t, size_t, int,', '+ #define xsh_addr\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xsh_sizeof\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xsh_size\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xsh_offset\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xsh_type\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_addr\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_sizeof\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_type\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_offset\t(off_t)(clazz == ELFCLASS32\t\t\\', '+ #define xph_align\t(size_t)((clazz == ELFCLASS32\t\t\\', '+ #define xph_filesz\t(size_t)((clazz == ELFCLASS32\t\t\\', '+ #define xnh_addr\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xph_memsz\t(size_t)((clazz == ELFCLASS32\t\t\\', '+ #define xnh_sizeof\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xnh_type\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xnh_namesz\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xnh_descsz\t(clazz == ELFCLASS32\t\t\t\\', '+ #define prpsoffsets(i)\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xcap_addr\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xcap_sizeof\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xcap_tag\t(clazz == ELFCLASS32\t\t\t\\', '+ #define xcap_val\t(clazz == ELFCLASS32\t\t\t\\', '+ #define NOFFSETS\t(clazz == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)', '+ dophn_core(struct magic_set *ms, int clazz, int swap, int fd, off_t off,', '+ \t\t\t    clazz, swap, 4, flags);', '+ donote(struct magic_set *ms, void *vbuf, size_t offset, size_t size,', '+     int clazz, int swap, size_t align, int *flags)', '+ \tunsigned char *nbuf = CAST(unsigned char *, vbuf);', '+ doshn(struct magic_set *ms, int clazz, int swap, int fd, off_t off, int num,', '+ \t\t\t\t    (size_t)xsh_size, clazz, swap, 4,', '+ dophn_exec(struct magic_set *ms, int clazz, int swap, int fd, off_t off,', '+ \t\t\t\t    (size_t)bufsize, clazz, swap, align,', '+ \tint clazz;', '+ \tclazz = buf[EI_CLASS];', '+ \tswitch (clazz) {', '+ \t    if (file_printf(ms, "", unknown class %d"", clazz) == -1)']]","[['- FILE_RCSID(""@(#)$File: readelf.c,v 1.74 2008/05/28 21:02:29 christos Exp $"")', '- private size_t donote(struct magic_set *, unsigned char *, size_t, size_t, int,', '- #define xsh_addr\t(class == ELFCLASS32\t\t\t\\', '- #define xsh_sizeof\t(class == ELFCLASS32\t\t\t\\', '- #define xsh_size\t(class == ELFCLASS32\t\t\t\\', '- #define xsh_offset\t(class == ELFCLASS32\t\t\t\\', '- #define xsh_type\t(class == ELFCLASS32\t\t\t\\', '- #define xph_addr\t(class == ELFCLASS32\t\t\t\\', '- #define xph_sizeof\t(class == ELFCLASS32\t\t\t\\', '- #define xph_type\t(class == ELFCLASS32\t\t\t\\', '- #define xph_offset\t(off_t)(class == ELFCLASS32\t\t\\', '- #define xph_align\t(size_t)((class == ELFCLASS32\t\t\\', '- #define xph_filesz\t(size_t)((class == ELFCLASS32\t\t\\', '- #define xnh_addr\t(class == ELFCLASS32\t\t\t\\', '- #define xph_memsz\t(size_t)((class == ELFCLASS32\t\t\\', '- #define xnh_sizeof\t(class == ELFCLASS32\t\t\t\\', '- #define xnh_type\t(class == ELFCLASS32\t\t\t\\', '- #define xnh_namesz\t(class == ELFCLASS32\t\t\t\\', '- #define xnh_descsz\t(class == ELFCLASS32\t\t\t\\', '- #define prpsoffsets(i)\t(class == ELFCLASS32\t\t\t\\', '- #define xcap_addr\t(class == ELFCLASS32\t\t\t\\', '- #define xcap_sizeof\t(class == ELFCLASS32\t\t\t\\', '- #define xcap_tag\t(class == ELFCLASS32\t\t\t\\', '- #define xcap_val\t(class == ELFCLASS32\t\t\t\\', '- #define NOFFSETS\t(class == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)', '- dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,', '- \t\t\t    class, swap, 4, flags);', '- donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,', '-     int class, int swap, size_t align, int *flags)', '- doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,', '- \t\t\t\t    (size_t)xsh_size, class, swap, 4,', '- dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,', '- \t\t\t\t    (size_t)bufsize, class, swap, align,', '- \tint class;', '- \tclass = buf[EI_CLASS];', '- \tswitch (class) {', '- \t    if (file_printf(ms, "", unknown class %d"", class) == -1)']]",38,37.0,75.0,3f931efcfd206219ac2a5a66b5e2b21e1ab30afffile/file,['39c7ac1106be844a5296d3eb5971946cc09ffda0']
9f435cf2fe2d97b9f2648977f3ac13266c231539,file/file,ascmagic.c,train,C,0,"['@@ -31,6 +31,10 @@\n #include ""file.h""\n #include ""names.h""\n \n+#ifndef\tlint\n+static char *moduleid = ""$Header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.4 1987/09/16 10:11:40 ian Exp $"";\n+#endif\t/* lint */\n+\n char ckfmsg[] = ""write error on output"";\n \n \t\t\t/* an optimisation over plain strcmp() */\n']",,,"['+ #ifndef\tlint', '+ static char *moduleid = ""$Header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.4 1987/09/16 10:11:40 ian Exp $"";']","['+ #ifndef\tlint', '+ static char *moduleid = ""$header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.4 1987/09/16 10:11:40 ian exp $"";']","['+ #ifndef\tlint', '+ static char *moduleid = ""$Header: /home/glen/git/file/cvs/file/src/ascmagic.c,v 1.4 1987/09/16 10:11:40 ian Exp $"";']",[],2,0.0,2.0,9f435cf2fe2d97b9f2648977f3ac13266c231539file/file,[]
cf024ded050d3d42a5321b60b3c7c672a7f86f57,SpiderLabs/ModSecurity,msc_util.c,train,C++,0,"['@@ -428,11 +428,11 @@ unsigned char *c2x(unsigned what, unsigned char *where) {\n }\n \n char *log_escape(apr_pool_t *mp, const char *text) {\n-    return _log_escape(mp, (const unsigned char *)text, strlen(text), 1, 0);\n+    return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 1, 0);\n }\n \n char *log_escape_nq(apr_pool_t *mp, const char *text) {\n-    return _log_escape(mp, (const unsigned char *)text, strlen(text), 0, 0);\n+    return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 0, 0);\n }\n \n char *log_escape_ex(apr_pool_t *mp, const char *text, unsigned long int text_length) {\n@@ -444,7 +444,7 @@ char *log_escape_nq_ex(apr_pool_t *mp, const char *text, unsigned long int text_\n }\n \n char *log_escape_header_name(apr_pool_t *mp, const char *text) {\n-    return _log_escape(mp, (const unsigned char *)text, strlen(text), 0, 1);\n+    return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 0, 1);\n }\n \n /**\n']",,,"['+     return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 1, 0);', '+     return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 0, 0);', '+     return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 0, 1);', '-     return _log_escape(mp, (const unsigned char *)text, strlen(text), 1, 0);', '-     return _log_escape(mp, (const unsigned char *)text, strlen(text), 0, 0);', '-     return _log_escape(mp, (const unsigned char *)text, strlen(text), 0, 1);']","['+     return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 1, 0);', '+     return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 0, 0);', '+     return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 0, 1);', '-     return _log_escape(mp, (const unsigned char *)text, strlen(text), 1, 0);', '-     return _log_escape(mp, (const unsigned char *)text, strlen(text), 0, 0);', '-     return _log_escape(mp, (const unsigned char *)text, strlen(text), 0, 1);']","['+     return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 1, 0);', '+     return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 0, 0);', '+     return _log_escape(mp, (const unsigned char *)text, text ? strlen(text) : 0, 0, 1);']","['-     return _log_escape(mp, (const unsigned char *)text, strlen(text), 1, 0);', '-     return _log_escape(mp, (const unsigned char *)text, strlen(text), 0, 0);', '-     return _log_escape(mp, (const unsigned char *)text, strlen(text), 0, 1);']",3,3.0,6.0,cf024ded050d3d42a5321b60b3c7c672a7f86f57SpiderLabs/ModSecurity,[]
f72f5d182ce50dcab1e4a890b6479ac250e2fac8,vadz/libtiff,libtiff/tif_predict.c,train,C,1,"['@@ -42,6 +42,8 @@ static void swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc);\n static void horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc);\n static void horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);\n static void horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static void swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);\n+static void swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);\n static void fpAcc(TIFF* tif, uint8* cp0, tmsize_t cc);\n static void fpDiff(TIFF* tif, uint8* cp0, tmsize_t cc);\n static int PredictorDecodeRow(TIFF* tif, uint8* op0, tmsize_t occ0, uint16 s);\n@@ -207,7 +209,24 @@ PredictorSetupEncode(TIFF* tif)\n                     sp->encodetile = tif->tif_encodetile;\n                     tif->tif_encodetile = PredictorEncodeTile;\n                 }\n-\t}\n+\n+                /*\n+                 * If the data is horizontally differenced 16-bit data that\n+                 * requires byte-swapping, then it must be byte swapped after\n+                 * the differenciation step.  We do this with a special-purpose\n+                 * routine and override the normal post decoding logic that\n+                 * the library setup when the directory was read.\n+                 */\n+                if (tif->tif_flags & TIFF_SWAB) {\n+                    if (sp->encodepfunc == horDiff16) {\n+                            sp->encodepfunc = swabHorDiff16;\n+                            tif->tif_postdecode = _TIFFNoPostDecode;\n+                    } else if (sp->encodepfunc == horDiff32) {\n+                            sp->encodepfunc = swabHorDiff32;\n+                            tif->tif_postdecode = _TIFFNoPostDecode;\n+                    }\n+                }\n+        }\n \n \telse if (sp->predictor == 3) {\n \t\tsp->encodepfunc = fpDiff;\n@@ -298,20 +317,11 @@ horAcc8(TIFF* tif, uint8* cp0, tmsize_t cc)\n static void\n swabHorAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n-\ttmsize_t stride = PredictorState(tif)->stride;\n \tuint16* wp = (uint16*) cp0;\n \ttmsize_t wc = cc / 2;\n \n-\tassert((cc%(2*stride))==0);\n-\n-\tif (wc > stride) {\n-\t\tTIFFSwabArrayOfShort(wp, wc);\n-\t\twc -= stride;\n-\t\tdo {\n-\t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)\n-\t\t\twc -= stride;\n-\t\t} while (wc > 0);\n-\t}\n+        TIFFSwabArrayOfShort(wp, wc);\n+        horAcc16(tif, cp0, cc);\n }\n \n static void\n@@ -335,20 +345,11 @@ horAcc16(TIFF* tif, uint8* cp0, tmsize_t cc)\n static void\n swabHorAcc32(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n-\ttmsize_t stride = PredictorState(tif)->stride;\n \tuint32* wp = (uint32*) cp0;\n \ttmsize_t wc = cc / 4;\n \n-\tassert((cc%(4*stride))==0);\n-\n-\tif (wc > stride) {\n-\t\tTIFFSwabArrayOfLong(wp, wc);\n-\t\twc -= stride;\n-\t\tdo {\n-\t\t\tREPEAT4(stride, wp[stride] += wp[0]; wp++)\n-\t\t\twc -= stride;\n-\t\t} while (wc > 0);\n-\t}\n+        TIFFSwabArrayOfLong(wp, wc);\n+\thorAcc32(tif, cp0, cc);\n }\n \n static void\n@@ -524,6 +525,17 @@ horDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n \t}\n }\n \n+static void\n+swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)\n+{\n+    uint16* wp = (uint16*) cp0;\n+    tmsize_t wc = cc / 2;\n+\n+    horDiff16(tif, cp0, cc);\n+\n+    TIFFSwabArrayOfShort(wp, wc);\n+}\n+\n static void\n horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n {\n@@ -544,6 +556,17 @@ horDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n \t}\n }\n \n+static void\n+swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)\n+{\n+    uint32* wp = (uint32*) cp0;\n+    tmsize_t wc = cc / 4;\n+\n+    horDiff32(tif, cp0, cc);\n+\n+    TIFFSwabArrayOfLong(wp, wc);\n+}\n+\n /*\n  * Floating point predictor differencing routine.\n  */\n']",2015-08-31 14:36:10+00:00,"* libtiff/tif_predict.c: fix generation of output with 16 bit
or 32 bit integer, when byte swapping is needed, in
horizontal predictor (#2521). Also fixes decoding when there is
a single pixel to code (unlikely case...) and byte swapping is
involved.","[['+ static void swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);', '+ static void swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);', '+ ', '+                 if (tif->tif_flags & TIFF_SWAB) {', '+                     if (sp->encodepfunc == horDiff16) {', '+                             sp->encodepfunc = swabHorDiff16;', '+                             tif->tif_postdecode = _TIFFNoPostDecode;', '+                     } else if (sp->encodepfunc == horDiff32) {', '+                             sp->encodepfunc = swabHorDiff32;', '+                             tif->tif_postdecode = _TIFFNoPostDecode;', '+                     }', '+                 }', '+         }', '+         TIFFSwabArrayOfShort(wp, wc);', '+         horAcc16(tif, cp0, cc);', '+         TIFFSwabArrayOfLong(wp, wc);', '+ \thorAcc32(tif, cp0, cc);', '+ static void', '+ swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)', '+ {', '+     uint16* wp = (uint16*) cp0;', '+     tmsize_t wc = cc / 2;', '+ ', '+     horDiff16(tif, cp0, cc);', '+ ', '+     TIFFSwabArrayOfShort(wp, wc);', '+ }', '+ ', '+ static void', '+ swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)', '+ {', '+     uint32* wp = (uint32*) cp0;', '+     tmsize_t wc = cc / 4;', '+ ', '+     horDiff32(tif, cp0, cc);', '+ ', '+     TIFFSwabArrayOfLong(wp, wc);', '+ }', '+ ', '- \t}', '- \ttmsize_t stride = PredictorState(tif)->stride;', '- \tassert((cc%(2*stride))==0);', '- ', '- \tif (wc > stride) {', '- \t\tTIFFSwabArrayOfShort(wp, wc);', '- \t\twc -= stride;', '- \t\tdo {', '- \t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)', '- \t\t\twc -= stride;', '- \t\t} while (wc > 0);', '- \t}', '- \ttmsize_t stride = PredictorState(tif)->stride;', '- \tassert((cc%(4*stride))==0);', '- ', '- \tif (wc > stride) {', '- \t\tTIFFSwabArrayOfLong(wp, wc);', '- \t\twc -= stride;', '- \t\tdo {', '- \t\t\tREPEAT4(stride, wp[stride] += wp[0]; wp++)', '- \t\t\twc -= stride;', '- \t\t} while (wc > 0);', '- \t}']]","[['+ static void swabhordiff16(tiff* tif, uint8* cp0, tmsize_t cc);', '+ static void swabhordiff32(tiff* tif, uint8* cp0, tmsize_t cc);', '+ ', '+                 if (tif->tif_flags & tiff_swab) {', '+                     if (sp->encodepfunc == hordiff16) {', '+                             sp->encodepfunc = swabhordiff16;', '+                             tif->tif_postdecode = _tiffnopostdecode;', '+                     } else if (sp->encodepfunc == hordiff32) {', '+                             sp->encodepfunc = swabhordiff32;', '+                             tif->tif_postdecode = _tiffnopostdecode;', '+                     }', '+                 }', '+         }', '+         tiffswabarrayofshort(wp, wc);', '+         horacc16(tif, cp0, cc);', '+         tiffswabarrayoflong(wp, wc);', '+ \thoracc32(tif, cp0, cc);', '+ static void', '+ swabhordiff16(tiff* tif, uint8* cp0, tmsize_t cc)', '+ {', '+     uint16* wp = (uint16*) cp0;', '+     tmsize_t wc = cc / 2;', '+ ', '+     hordiff16(tif, cp0, cc);', '+ ', '+     tiffswabarrayofshort(wp, wc);', '+ }', '+ ', '+ static void', '+ swabhordiff32(tiff* tif, uint8* cp0, tmsize_t cc)', '+ {', '+     uint32* wp = (uint32*) cp0;', '+     tmsize_t wc = cc / 4;', '+ ', '+     hordiff32(tif, cp0, cc);', '+ ', '+     tiffswabarrayoflong(wp, wc);', '+ }', '+ ', '- \t}', '- \ttmsize_t stride = predictorstate(tif)->stride;', '- \tassert((cc%(2*stride))==0);', '- ', '- \tif (wc > stride) {', '- \t\ttiffswabarrayofshort(wp, wc);', '- \t\twc -= stride;', '- \t\tdo {', '- \t\t\trepeat4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)', '- \t\t\twc -= stride;', '- \t\t} while (wc > 0);', '- \t}', '- \ttmsize_t stride = predictorstate(tif)->stride;', '- \tassert((cc%(4*stride))==0);', '- ', '- \tif (wc > stride) {', '- \t\ttiffswabarrayoflong(wp, wc);', '- \t\twc -= stride;', '- \t\tdo {', '- \t\t\trepeat4(stride, wp[stride] += wp[0]; wp++)', '- \t\t\twc -= stride;', '- \t\t} while (wc > 0);', '- \t}']]","[['+ static void swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc);', '+ static void swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc);', '+ ', '+                 if (tif->tif_flags & TIFF_SWAB) {', '+                     if (sp->encodepfunc == horDiff16) {', '+                             sp->encodepfunc = swabHorDiff16;', '+                             tif->tif_postdecode = _TIFFNoPostDecode;', '+                     } else if (sp->encodepfunc == horDiff32) {', '+                             sp->encodepfunc = swabHorDiff32;', '+                             tif->tif_postdecode = _TIFFNoPostDecode;', '+                     }', '+                 }', '+         }', '+         TIFFSwabArrayOfShort(wp, wc);', '+         horAcc16(tif, cp0, cc);', '+         TIFFSwabArrayOfLong(wp, wc);', '+ \thorAcc32(tif, cp0, cc);', '+ static void', '+ swabHorDiff16(TIFF* tif, uint8* cp0, tmsize_t cc)', '+ {', '+     uint16* wp = (uint16*) cp0;', '+     tmsize_t wc = cc / 2;', '+ ', '+     horDiff16(tif, cp0, cc);', '+ ', '+     TIFFSwabArrayOfShort(wp, wc);', '+ }', '+ ', '+ static void', '+ swabHorDiff32(TIFF* tif, uint8* cp0, tmsize_t cc)', '+ {', '+     uint32* wp = (uint32*) cp0;', '+     tmsize_t wc = cc / 4;', '+ ', '+     horDiff32(tif, cp0, cc);', '+ ', '+     TIFFSwabArrayOfLong(wp, wc);', '+ }', '+ ']]","[['- \t}', '- \ttmsize_t stride = PredictorState(tif)->stride;', '- \tassert((cc%(2*stride))==0);', '- ', '- \tif (wc > stride) {', '- \t\tTIFFSwabArrayOfShort(wp, wc);', '- \t\twc -= stride;', '- \t\tdo {', '- \t\t\tREPEAT4(stride, wp[stride] = (uint16)(((unsigned int)wp[stride] + (unsigned int)wp[0]) & 0xffff); wp++)', '- \t\t\twc -= stride;', '- \t\t} while (wc > 0);', '- \t}', '- \ttmsize_t stride = PredictorState(tif)->stride;', '- \tassert((cc%(4*stride))==0);', '- ', '- \tif (wc > stride) {', '- \t\tTIFFSwabArrayOfLong(wp, wc);', '- \t\twc -= stride;', '- \t\tdo {', '- \t\t\tREPEAT4(stride, wp[stride] += wp[0]; wp++)', '- \t\t\twc -= stride;', '- \t\t} while (wc > 0);', '- \t}']]",39,23.0,62.0,f72f5d182ce50dcab1e4a890b6479ac250e2fac8vadz/libtiff,['3ca657a8793dd011bf869695d72ad31c779c3cc1']
ae086bb44e0d83b5b19d7cb263471320c9c2152c,libarchive/libarchive,bsdtar.c,test,C,0,"['@@ -24,7 +24,7 @@\n  */\n \n #include ""bsdtar_platform.h""\n-__FBSDID(""$FreeBSD: src/usr.bin/tar/bsdtar.c,v 1.86 2008/03/15 05:08:21 kientzle Exp $"");\n+__FBSDID(""$FreeBSD: src/usr.bin/tar/bsdtar.c,v 1.88 2008/05/02 05:40:05 kientzle Exp $"");\n \n #ifdef HAVE_SYS_PARAM_H\n #include <sys/param.h>\n']",,,"['+ __FBSDID(""$FreeBSD: src/usr.bin/tar/bsdtar.c,v 1.88 2008/05/02 05:40:05 kientzle Exp $"");', '- __FBSDID(""$FreeBSD: src/usr.bin/tar/bsdtar.c,v 1.86 2008/03/15 05:08:21 kientzle Exp $"");']","['+ __fbsdid(""$freebsd: src/usr.bin/tar/bsdtar.c,v 1.88 2008/05/02 05:40:05 kientzle exp $"");', '- __fbsdid(""$freebsd: src/usr.bin/tar/bsdtar.c,v 1.86 2008/03/15 05:08:21 kientzle exp $"");']","['+ __FBSDID(""$FreeBSD: src/usr.bin/tar/bsdtar.c,v 1.88 2008/05/02 05:40:05 kientzle Exp $"");']","['- __FBSDID(""$FreeBSD: src/usr.bin/tar/bsdtar.c,v 1.86 2008/03/15 05:08:21 kientzle Exp $"");']",1,1.0,2.0,ae086bb44e0d83b5b19d7cb263471320c9c2152clibarchive/libarchive,[]
346d389d40d63c587f1d57a8b68e651a89433a77,jabberd2/jabberd2,storage_pgsql.c,train,C,0,"['@@ -468,6 +468,72 @@ static st_ret_t _st_pgsql_get(st_driver_t drv, const char *type, const char *own\n     return st_SUCCESS;\n }\n \n+static st_ret_t _st_pgsql_count(st_driver_t drv, const char *type, const char *owner, const char *filter, int *count) {\n+    drvdata_t data = (drvdata_t) drv->private;\n+    char *cond, *buf = NULL;\n+    int buflen = 0;\n+    PGresult *res;\n+    int ntuples, nfields;\n+    char tbuf[128];\n+\n+    if(data->prefix != NULL) {\n+        snprintf(tbuf, sizeof(tbuf), ""%s%s"", data->prefix, type);\n+        type = tbuf;\n+    }\n+\n+    cond = _st_pgsql_convert_filter(drv, owner, filter);\n+    log_debug(ZONE, ""generated filter: %s"", cond);\n+\n+    PGSQL_SAFE(buf, strlen(type) + strlen(cond) + 31, buflen);\n+    sprintf(buf, ""SELECT COUNT(*) FROM \\""%s\\"" WHERE %s"", type, cond);\n+    free(cond);\n+\n+    log_debug(ZONE, ""prepared sql: %s"", buf);\n+\n+    res = PQexec(data->conn, buf);\n+\n+    if(PQresultStatus(res) != PGRES_TUPLES_OK && PQstatus(data->conn) != CONNECTION_OK) {\n+        log_write(drv->st->sm->log, LOG_ERR, ""pgsql: lost connection to database, attempting reconnect"");\n+        PQclear(res);\n+        PQreset(data->conn);\n+        res = PQexec(data->conn, buf);\n+    }\n+\n+    free(buf);\n+\n+    if(PQresultStatus(res) != PGRES_TUPLES_OK) {\n+        log_write(drv->st->sm->log, LOG_ERR, ""pgsql: sql select failed: %s"", PQresultErrorMessage(res));\n+        PQclear(res);\n+        return st_FAILED;\n+    }\n+\n+    ntuples = PQntuples(res);\n+    if(ntuples == 0) {\n+        PQclear(res);\n+        return st_NOTFOUND;\n+    }\n+\n+    log_debug(ZONE, ""%d tuples returned"", ntuples);\n+\n+    nfields = PQnfields(res);\n+\n+    if(nfields == 0) {\n+        log_debug(ZONE, ""weird, tuples were returned but no fields *shrug*"");\n+        PQclear(res);\n+        return st_NOTFOUND;\n+    }\n+\n+    if(PQgetisnull(res, 0, 0) || PQftype(res, 0) != 23)\n+        return st_NOTFOUND;\n+\n+    if (count!=NULL)\n+        *count = atoi(PQgetvalue(res, 0, 0));\n+\n+    PQclear(res);\n+\n+    return st_SUCCESS;\n+}\n+\n static st_ret_t _st_pgsql_delete(st_driver_t drv, const char *type, const char *owner, const char *filter) {\n     drvdata_t data = (drvdata_t) drv->private;\n     char *cond, *buf = NULL;\n@@ -631,6 +697,7 @@ st_ret_t st_pgsql_init(st_driver_t drv) {\n \n     drv->add_type = _st_pgsql_add_type;\n     drv->put = _st_pgsql_put;\n+    drv->count = _st_pgsql_count;\n     drv->get = _st_pgsql_get;\n     drv->delete = _st_pgsql_delete;\n     drv->replace = _st_pgsql_replace;\n']",,,"['+ static st_ret_t _st_pgsql_count(st_driver_t drv, const char *type, const char *owner, const char *filter, int *count) {', '+     drvdata_t data = (drvdata_t) drv->private;', '+     char *cond, *buf = NULL;', '+     int buflen = 0;', '+     PGresult *res;', '+     int ntuples, nfields;', '+     char tbuf[128];', '+     if(data->prefix != NULL) {', '+         snprintf(tbuf, sizeof(tbuf), ""%s%s"", data->prefix, type);', '+         type = tbuf;', '+     }', '+     cond = _st_pgsql_convert_filter(drv, owner, filter);', '+     log_debug(ZONE, ""generated filter: %s"", cond);', '+     PGSQL_SAFE(buf, strlen(type) + strlen(cond) + 31, buflen);', '+     sprintf(buf, ""SELECT COUNT(*) FROM \\""%s\\"" WHERE %s"", type, cond);', '+     free(cond);', '+     log_debug(ZONE, ""prepared sql: %s"", buf);', '+     res = PQexec(data->conn, buf);', '+     if(PQresultStatus(res) != PGRES_TUPLES_OK && PQstatus(data->conn) != CONNECTION_OK) {', '+         log_write(drv->st->sm->log, LOG_ERR, ""pgsql: lost connection to database, attempting reconnect"");', '+         PQclear(res);', '+         PQreset(data->conn);', '+         res = PQexec(data->conn, buf);', '+     }', '+     free(buf);', '+     if(PQresultStatus(res) != PGRES_TUPLES_OK) {', '+         log_write(drv->st->sm->log, LOG_ERR, ""pgsql: sql select failed: %s"", PQresultErrorMessage(res));', '+         PQclear(res);', '+         return st_FAILED;', '+     }', '+     ntuples = PQntuples(res);', '+     if(ntuples == 0) {', '+         PQclear(res);', '+         return st_NOTFOUND;', '+     }', '+     log_debug(ZONE, ""%d tuples returned"", ntuples);', '+     nfields = PQnfields(res);', '+     if(nfields == 0) {', '+         log_debug(ZONE, ""weird, tuples were returned but no fields *shrug*"");', '+         PQclear(res);', '+         return st_NOTFOUND;', '+     }', '+     if(PQgetisnull(res, 0, 0) || PQftype(res, 0) != 23)', '+         return st_NOTFOUND;', '+     if (count!=NULL)', '+         *count = atoi(PQgetvalue(res, 0, 0));', '+     PQclear(res);', '+     return st_SUCCESS;', '+ }', '+     drv->count = _st_pgsql_count;']","['+ static st_ret_t _st_pgsql_count(st_driver_t drv, const char *type, const char *owner, const char *filter, int *count) {', '+     drvdata_t data = (drvdata_t) drv->private;', '+     char *cond, *buf = null;', '+     int buflen = 0;', '+     pgresult *res;', '+     int ntuples, nfields;', '+     char tbuf[128];', '+     if(data->prefix != null) {', '+         snprintf(tbuf, sizeof(tbuf), ""%s%s"", data->prefix, type);', '+         type = tbuf;', '+     }', '+     cond = _st_pgsql_convert_filter(drv, owner, filter);', '+     log_debug(zone, ""generated filter: %s"", cond);', '+     pgsql_safe(buf, strlen(type) + strlen(cond) + 31, buflen);', '+     sprintf(buf, ""select count(*) from \\""%s\\"" where %s"", type, cond);', '+     free(cond);', '+     log_debug(zone, ""prepared sql: %s"", buf);', '+     res = pqexec(data->conn, buf);', '+     if(pqresultstatus(res) != pgres_tuples_ok && pqstatus(data->conn) != connection_ok) {', '+         log_write(drv->st->sm->log, log_err, ""pgsql: lost connection to database, attempting reconnect"");', '+         pqclear(res);', '+         pqreset(data->conn);', '+         res = pqexec(data->conn, buf);', '+     }', '+     free(buf);', '+     if(pqresultstatus(res) != pgres_tuples_ok) {', '+         log_write(drv->st->sm->log, log_err, ""pgsql: sql select failed: %s"", pqresulterrormessage(res));', '+         pqclear(res);', '+         return st_failed;', '+     }', '+     ntuples = pqntuples(res);', '+     if(ntuples == 0) {', '+         pqclear(res);', '+         return st_notfound;', '+     }', '+     log_debug(zone, ""%d tuples returned"", ntuples);', '+     nfields = pqnfields(res);', '+     if(nfields == 0) {', '+         log_debug(zone, ""weird, tuples were returned but no fields *shrug*"");', '+         pqclear(res);', '+         return st_notfound;', '+     }', '+     if(pqgetisnull(res, 0, 0) || pqftype(res, 0) != 23)', '+         return st_notfound;', '+     if (count!=null)', '+         *count = atoi(pqgetvalue(res, 0, 0));', '+     pqclear(res);', '+     return st_success;', '+ }', '+     drv->count = _st_pgsql_count;']","['+ static st_ret_t _st_pgsql_count(st_driver_t drv, const char *type, const char *owner, const char *filter, int *count) {', '+     drvdata_t data = (drvdata_t) drv->private;', '+     char *cond, *buf = NULL;', '+     int buflen = 0;', '+     PGresult *res;', '+     int ntuples, nfields;', '+     char tbuf[128];', '+     if(data->prefix != NULL) {', '+         snprintf(tbuf, sizeof(tbuf), ""%s%s"", data->prefix, type);', '+         type = tbuf;', '+     }', '+     cond = _st_pgsql_convert_filter(drv, owner, filter);', '+     log_debug(ZONE, ""generated filter: %s"", cond);', '+     PGSQL_SAFE(buf, strlen(type) + strlen(cond) + 31, buflen);', '+     sprintf(buf, ""SELECT COUNT(*) FROM \\""%s\\"" WHERE %s"", type, cond);', '+     free(cond);', '+     log_debug(ZONE, ""prepared sql: %s"", buf);', '+     res = PQexec(data->conn, buf);', '+     if(PQresultStatus(res) != PGRES_TUPLES_OK && PQstatus(data->conn) != CONNECTION_OK) {', '+         log_write(drv->st->sm->log, LOG_ERR, ""pgsql: lost connection to database, attempting reconnect"");', '+         PQclear(res);', '+         PQreset(data->conn);', '+         res = PQexec(data->conn, buf);', '+     }', '+     free(buf);', '+     if(PQresultStatus(res) != PGRES_TUPLES_OK) {', '+         log_write(drv->st->sm->log, LOG_ERR, ""pgsql: sql select failed: %s"", PQresultErrorMessage(res));', '+         PQclear(res);', '+         return st_FAILED;', '+     }', '+     ntuples = PQntuples(res);', '+     if(ntuples == 0) {', '+         PQclear(res);', '+         return st_NOTFOUND;', '+     }', '+     log_debug(ZONE, ""%d tuples returned"", ntuples);', '+     nfields = PQnfields(res);', '+     if(nfields == 0) {', '+         log_debug(ZONE, ""weird, tuples were returned but no fields *shrug*"");', '+         PQclear(res);', '+         return st_NOTFOUND;', '+     }', '+     if(PQgetisnull(res, 0, 0) || PQftype(res, 0) != 23)', '+         return st_NOTFOUND;', '+     if (count!=NULL)', '+         *count = atoi(PQgetvalue(res, 0, 0));', '+     PQclear(res);', '+     return st_SUCCESS;', '+ }', '+     drv->count = _st_pgsql_count;']",[],50,0.0,50.0,346d389d40d63c587f1d57a8b68e651a89433a77jabberd2/jabberd2,[]
2d66a58ccde05e764594bd7e5f0f9244634d0b2c,FFmpeg/FFmpeg,libavcodec/g2meet.c,val,C,1,"['@@ -0,0 +1,825 @@\n+/*\n+ * Go2Webinar decoder\n+ * Copyright (c) 2012 Konstantin Shishkov\n+ *\n+ * This file is part of Libav.\n+ *\n+ * Libav is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2.1 of the License, or (at your option) any later version.\n+ *\n+ * Libav is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with Libav; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n+ */\n+\n+/**\n+ * @file\n+ * Go2Webinar decoder\n+ */\n+\n+#include <zlib.h>\n+\n+#include ""libavutil/intreadwrite.h""\n+#include ""avcodec.h""\n+#include ""bytestream.h""\n+#include ""dsputil.h""\n+#include ""get_bits.h""\n+#include ""internal.h""\n+#include ""mjpeg.h""\n+\n+enum ChunkType {\n+    FRAME_INFO = 0xC8,\n+    TILE_DATA,\n+    CURSOR_POS,\n+    CURSOR_SHAPE,\n+    CHUNK_CC,\n+    CHUNK_CD\n+};\n+\n+enum Compression {\n+    COMPR_EPIC_J_B = 2,\n+    COMPR_KEMPF_J_B,\n+};\n+\n+static const uint8_t luma_quant[64] = {\n+     8,  6,  5,  8, 12, 20, 26, 31,\n+     6,  6,  7, 10, 13, 29, 30, 28,\n+     7,  7,  8, 12, 20, 29, 35, 28,\n+     7,  9, 11, 15, 26, 44, 40, 31,\n+     9, 11, 19, 28, 34, 55, 52, 39,\n+    12, 18, 28, 32, 41, 52, 57, 46,\n+    25, 32, 39, 44, 52, 61, 60, 51,\n+    36, 46, 48, 49, 56, 50, 52, 50\n+};\n+\n+static const uint8_t chroma_quant[64] = {\n+     9,  9, 12, 24, 50, 50, 50, 50,\n+     9, 11, 13, 33, 50, 50, 50, 50,\n+    12, 13, 28, 50, 50, 50, 50, 50,\n+    24, 33, 50, 50, 50, 50, 50, 50,\n+    50, 50, 50, 50, 50, 50, 50, 50,\n+    50, 50, 50, 50, 50, 50, 50, 50,\n+    50, 50, 50, 50, 50, 50, 50, 50,\n+    50, 50, 50, 50, 50, 50, 50, 50,\n+};\n+\n+typedef struct JPGContext {\n+    DSPContext dsp;\n+    ScanTable  scantable;\n+\n+    VLC        dc_vlc[2], ac_vlc[2];\n+    int        prev_dc[3];\n+    DECLARE_ALIGNED(16, int16_t, block)[6][64];\n+\n+    uint8_t    *buf;\n+} JPGContext;\n+\n+typedef struct G2MContext {\n+    JPGContext jc;\n+    int        version;\n+\n+    int        compression;\n+    int        width, height, bpp;\n+    int        tile_width, tile_height;\n+    int        tiles_x, tiles_y, tile_x, tile_y;\n+\n+    int        got_header;\n+\n+    uint8_t    *framebuf;\n+    int        framebuf_stride, old_width, old_height;\n+\n+    uint8_t    *synth_tile, *jpeg_tile;\n+    int        tile_stride, old_tile_w, old_tile_h;\n+\n+    uint8_t    *kempf_buf, *kempf_flags;\n+\n+    uint8_t    *cursor;\n+    int        cursor_stride;\n+    int        cursor_fmt;\n+    int        cursor_w, cursor_h, cursor_x, cursor_y;\n+    int        cursor_hot_x, cursor_hot_y;\n+} G2MContext;\n+\n+static av_cold int build_vlc(VLC *vlc, const uint8_t *bits_table,\n+                             const uint8_t *val_table, int nb_codes,\n+                             int is_ac)\n+{\n+    uint8_t  huff_size[256] = { 0 };\n+    uint16_t huff_code[256];\n+    uint16_t huff_sym[256];\n+    int i;\n+\n+    ff_mjpeg_build_huffman_codes(huff_size, huff_code, bits_table, val_table);\n+\n+    for (i = 0; i < 256; i++)\n+        huff_sym[i] = i + 16 * is_ac;\n+\n+    if (is_ac)\n+        huff_sym[0] = 16 * 256;\n+\n+    return ff_init_vlc_sparse(vlc, 9, nb_codes, huff_size, 1, 1,\n+                              huff_code, 2, 2, huff_sym, 2, 2, 0);\n+}\n+\n+static av_cold int jpg_init(AVCodecContext *avctx, JPGContext *c)\n+{\n+    int ret;\n+\n+    ret = build_vlc(&c->dc_vlc[0], avpriv_mjpeg_bits_dc_luminance,\n+                    avpriv_mjpeg_val_dc, 12, 0);\n+    if (ret)\n+        return ret;\n+    ret = build_vlc(&c->dc_vlc[1], avpriv_mjpeg_bits_dc_chrominance,\n+                    avpriv_mjpeg_val_dc, 12, 0);\n+    if (ret)\n+        return ret;\n+    ret = build_vlc(&c->ac_vlc[0], avpriv_mjpeg_bits_ac_luminance,\n+                    avpriv_mjpeg_val_ac_luminance, 251, 1);\n+    if (ret)\n+        return ret;\n+    ret = build_vlc(&c->ac_vlc[1], avpriv_mjpeg_bits_ac_chrominance,\n+                    avpriv_mjpeg_val_ac_chrominance, 251, 1);\n+    if (ret)\n+        return ret;\n+\n+    ff_dsputil_init(&c->dsp, avctx);\n+    ff_init_scantable(c->dsp.idct_permutation, &c->scantable,\n+                      ff_zigzag_direct);\n+\n+    return 0;\n+}\n+\n+static av_cold void jpg_free_context(JPGContext *ctx)\n+{\n+    int i;\n+\n+    for (i = 0; i < 2; i++) {\n+        ff_free_vlc(&ctx->dc_vlc[i]);\n+        ff_free_vlc(&ctx->ac_vlc[i]);\n+    }\n+\n+    av_freep(&ctx->buf);\n+}\n+\n+static void jpg_unescape(const uint8_t *src, int src_size,\n+                         uint8_t *dst, int *dst_size)\n+{\n+    const uint8_t *src_end = src + src_size;\n+    uint8_t *dst_start = dst;\n+\n+    while (src < src_end) {\n+        uint8_t x = *src++;\n+\n+        *dst++ = x;\n+\n+        if (x == 0xFF && !*src)\n+            src++;\n+    }\n+    *dst_size = dst - dst_start;\n+}\n+\n+static int jpg_decode_block(JPGContext *c, GetBitContext *gb,\n+                            int plane, int16_t *block)\n+{\n+    int dc, val, pos;\n+    const int is_chroma = !!plane;\n+    const uint8_t *qmat = is_chroma ? chroma_quant : luma_quant;\n+\n+    c->dsp.clear_block(block);\n+    dc = get_vlc2(gb, c->dc_vlc[is_chroma].table, 9, 3);\n+    if (dc < 0)\n+        return AVERROR_INVALIDDATA;\n+    if (dc)\n+        dc = get_xbits(gb, dc);\n+    dc = dc * qmat[0] + c->prev_dc[plane];\n+    block[0] = dc;\n+    c->prev_dc[plane] = dc;\n+\n+    pos = 0;\n+    while (pos < 63) {\n+        val = get_vlc2(gb, c->ac_vlc[is_chroma].table, 9, 3);\n+        if (val < 0)\n+            return AVERROR_INVALIDDATA;\n+        pos += val >> 4;\n+        val &= 0xF;\n+        if (pos > 63)\n+            return val ? AVERROR_INVALIDDATA : 0;\n+        if (val) {\n+            int nbits = val;\n+\n+            val = get_xbits(gb, nbits);\n+            val *= qmat[ff_zigzag_direct[pos]];\n+            block[c->scantable.permutated[pos]] = val;\n+        }\n+    }\n+    return 0;\n+}\n+\n+static inline void yuv2rgb(uint8_t *out, int Y, int U, int V)\n+{\n+    out[0] = av_clip_uint8(Y + (             91881 * V + 32768 >> 16));\n+    out[1] = av_clip_uint8(Y + (-22554 * U - 46802 * V + 32768 >> 16));\n+    out[2] = av_clip_uint8(Y + (116130 * U             + 32768 >> 16));\n+}\n+\n+static int jpg_decode_data(JPGContext *c, int width, int height,\n+                           const uint8_t *src, int src_size,\n+                           uint8_t *dst, int dst_stride,\n+                           const uint8_t *mask, int mask_stride, int num_mbs,\n+                           int swapuv)\n+{\n+    GetBitContext gb;\n+    uint8_t *tmp;\n+    int mb_w, mb_h, mb_x, mb_y, i, j;\n+    int bx, by;\n+    int unesc_size;\n+    int ret;\n+\n+    tmp = av_realloc(c->buf, src_size + FF_INPUT_BUFFER_PADDING_SIZE);\n+    if (!tmp)\n+        return AVERROR(ENOMEM);\n+    c->buf = tmp;\n+    jpg_unescape(src, src_size, c->buf, &unesc_size);\n+    memset(c->buf + unesc_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);\n+    init_get_bits(&gb, c->buf, unesc_size * 8);\n+\n+    width = FFALIGN(width, 16);\n+    mb_w  =  width        >> 4;\n+    mb_h  = (height + 15) >> 4;\n+\n+    if (!num_mbs)\n+        num_mbs = mb_w * mb_h;\n+\n+    for (i = 0; i < 3; i++)\n+        c->prev_dc[i] = 1024;\n+    bx = by = 0;\n+    for (mb_y = 0; mb_y < mb_h; mb_y++) {\n+        for (mb_x = 0; mb_x < mb_w; mb_x++) {\n+            if (mask && !mask[mb_x]) {\n+                bx += 16;\n+                continue;\n+            }\n+            for (j = 0; j < 2; j++) {\n+                for (i = 0; i < 2; i++) {\n+                    if ((ret = jpg_decode_block(c, &gb, 0,\n+                                                c->block[i + j * 2])) != 0)\n+                        return ret;\n+                    c->dsp.idct(c->block[i + j * 2]);\n+                }\n+            }\n+            for (i = 1; i < 3; i++) {\n+                if ((ret = jpg_decode_block(c, &gb, i, c->block[i + 3])) != 0)\n+                    return ret;\n+                c->dsp.idct(c->block[i + 3]);\n+            }\n+\n+            for (j = 0; j < 16; j++) {\n+                uint8_t *out = dst + bx * 3 + (by + j) * dst_stride;\n+                for (i = 0; i < 16; i++) {\n+                    int Y, U, V;\n+\n+                    Y = c->block[(j >> 3) * 2 + (i >> 3)][(i & 7) + (j & 7) * 8];\n+                    U = c->block[4 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;\n+                    V = c->block[5 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;\n+                    yuv2rgb(out + i * 3, Y, U, V);\n+                }\n+            }\n+\n+            if (!--num_mbs)\n+                return 0;\n+            bx += 16;\n+        }\n+        bx  = 0;\n+        by += 16;\n+        if (mask)\n+            mask += mask_stride;\n+    }\n+\n+    return 0;\n+}\n+\n+static void kempf_restore_buf(const uint8_t *src, int len,\n+                              uint8_t *dst, int stride,\n+                              const uint8_t *jpeg_tile, int tile_stride,\n+                              int width, int height,\n+                              const uint8_t *pal, int npal, int tidx)\n+{\n+    GetBitContext gb;\n+    int i, j, nb, col;\n+\n+    init_get_bits(&gb, src, len * 8);\n+\n+    if (npal <= 2)       nb = 1;\n+    else if (npal <= 4)  nb = 2;\n+    else if (npal <= 16) nb = 4;\n+    else                 nb = 8;\n+\n+    for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {\n+        if (get_bits(&gb, 8))\n+            continue;\n+        for (i = 0; i < width; i++) {\n+            col = get_bits(&gb, nb);\n+            if (col != tidx)\n+                memcpy(dst + i * 3, pal + col * 3, 3);\n+            else\n+                memcpy(dst + i * 3, jpeg_tile + i * 3, 3);\n+        }\n+    }\n+}\n+\n+static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,\n+                             const uint8_t *src, int src_size)\n+{\n+    int width, height;\n+    int hdr, zsize, npal, tidx = -1, ret;\n+    int i, j;\n+    const uint8_t *src_end = src + src_size;\n+    uint8_t pal[768], transp[3];\n+    uLongf dlen = (c->tile_width + 1) * c->tile_height;\n+    int sub_type;\n+    int nblocks, cblocks, bstride;\n+    int bits, bitbuf, coded;\n+    uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +\n+                   tile_y * c->tile_height * c->framebuf_stride;\n+\n+    if (src_size < 2)\n+        return AVERROR_INVALIDDATA;\n+\n+    width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);\n+    height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);\n+\n+    hdr = *src++;\n+    sub_type = hdr >> 5;\n+    if (sub_type == 0) {\n+        int j;\n+        memcpy(transp, src, 3);\n+        src += 3;\n+        for (j = 0; j < height; j++, dst += c->framebuf_stride)\n+            for (i = 0; i < width; i++)\n+                memcpy(dst + i * 3, transp, 3);\n+        return 0;\n+    } else if (sub_type == 1) {\n+        return jpg_decode_data(&c->jc, width, height, src, src_end - src,\n+                               dst, c->framebuf_stride, NULL, 0, 0, 0);\n+    }\n+\n+    if (sub_type != 2) {\n+        memcpy(transp, src, 3);\n+        src += 3;\n+    }\n+    npal = *src++ + 1;\n+    memcpy(pal, src, npal * 3); src += npal * 3;\n+    if (sub_type != 2) {\n+        for (i = 0; i < npal; i++) {\n+            if (!memcmp(pal + i * 3, transp, 3)) {\n+               tidx = i;\n+               break;\n+            }\n+        }\n+    }\n+\n+    if (src_end - src < 2)\n+        return 0;\n+    zsize = (src[0] << 8) | src[1]; src += 2;\n+\n+    if (src_end - src < zsize)\n+        return AVERROR_INVALIDDATA;\n+\n+    ret = uncompress(c->kempf_buf, &dlen, src, zsize);\n+    if (ret)\n+        return AVERROR_INVALIDDATA;\n+    src += zsize;\n+\n+    if (sub_type == 2) {\n+        kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n+                          NULL, 0, width, height, pal, npal, tidx);\n+        return 0;\n+    }\n+\n+    nblocks = *src++ + 1;\n+    cblocks = 0;\n+    bstride = FFALIGN(width, 16) >> 4;\n+    // blocks are coded LSB and we need normal bitreader for JPEG data\n+    bits = 0;\n+    for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {\n+        for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {\n+            if (!bits) {\n+                bitbuf = *src++;\n+                bits   = 8;\n+            }\n+            coded = bitbuf & 1;\n+            bits--;\n+            bitbuf >>= 1;\n+            cblocks += coded;\n+            if (cblocks > nblocks)\n+                return AVERROR_INVALIDDATA;\n+            c->kempf_flags[j + i * bstride] = coded;\n+        }\n+    }\n+\n+    memset(c->jpeg_tile, 0, c->tile_stride * height);\n+    jpg_decode_data(&c->jc, width, height, src, src_end - src,\n+                    c->jpeg_tile, c->tile_stride,\n+                    c->kempf_flags, bstride, nblocks, 0);\n+\n+    kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,\n+                      c->jpeg_tile, c->tile_stride,\n+                      width, height, pal, npal, tidx);\n+\n+    return 0;\n+}\n+\n+static int g2m_init_buffers(G2MContext *c)\n+{\n+    int aligned_height;\n+\n+    if (!c->framebuf || c->old_width < c->width || c->height < c->height) {\n+        c->framebuf_stride = FFALIGN(c->width * 3, 16);\n+        aligned_height     = FFALIGN(c->height,    16);\n+        av_free(c->framebuf);\n+        c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);\n+        if (!c->framebuf)\n+            return AVERROR(ENOMEM);\n+    }\n+    if (!c->synth_tile || !c->jpeg_tile ||\n+        c->old_tile_w < c->tile_width ||\n+        c->old_tile_h < c->tile_height) {\n+        c->tile_stride = FFALIGN(c->tile_width * 3, 16);\n+        aligned_height = FFALIGN(c->tile_height,    16);\n+        av_free(c->synth_tile);\n+        av_free(c->jpeg_tile);\n+        c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);\n+        c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);\n+        c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height\n+                                    + FF_INPUT_BUFFER_PADDING_SIZE);\n+        c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);\n+        if (!c->synth_tile || !c->jpeg_tile ||\n+            !c->kempf_buf || !c->kempf_flags)\n+            return AVERROR(ENOMEM);\n+    }\n+\n+    return 0;\n+}\n+\n+static int g2m_load_cursor(G2MContext *c, GetByteContext *gb)\n+{\n+    int i, j, k;\n+    uint8_t *dst;\n+    uint32_t bits;\n+\n+    c->cursor_stride = c->cursor_w * 4;\n+    c->cursor        = av_realloc(c->cursor, c->cursor_stride * c->cursor_h);\n+    if (!c->cursor)\n+        return AVERROR(ENOMEM);\n+\n+    dst = c->cursor;\n+    switch (c->cursor_fmt) {\n+    case 1: // old monochrome\n+        for (j = 0; j < c->cursor_h; j++) {\n+            for (i = 0; i < c->cursor_w; i += 32) {\n+                bits = bytestream2_get_be32(gb);\n+                for (k = 0; k < 32; k++) {\n+                    dst[0] = !!(bits & 0x80000000);\n+                    dst += 4;\n+                    bits <<= 1;\n+                }\n+            }\n+        }\n+\n+        dst = c->cursor;\n+        for (j = 0; j < c->cursor_h; j++) {\n+            for (i = 0; i < c->cursor_w; i += 32) {\n+                bits = bytestream2_get_be32(gb);\n+                for (k = 0; k < 32; k++) {\n+                    int mask_bit = !!(bits & 0x80000000);\n+                    switch (dst[0] * 2 + mask_bit) {\n+                    case 0:\n+                        dst[0] = 0xFF; dst[1] = 0x00;\n+                        dst[2] = 0x00; dst[3] = 0x00;\n+                        break;\n+                    case 1:\n+                        dst[0] = 0xFF; dst[1] = 0xFF;\n+                        dst[2] = 0xFF; dst[3] = 0xFF;\n+                        break;\n+                    default:\n+                        dst[0] = 0x00; dst[1] = 0x00;\n+                        dst[2] = 0x00; dst[3] = 0x00;\n+                    }\n+                    dst += 4;\n+                    bits <<= 1;\n+                }\n+            }\n+        }\n+        break;\n+    case 32: // full colour\n+        /* skip monochrome version of the cursor and decode RGBA instead */\n+        bytestream2_skip(gb, c->cursor_h * (FFALIGN(c->cursor_w, 32) >> 3));\n+        for (j = 0; j < c->cursor_h; j++) {\n+            for (i = 0; i < c->cursor_w; i++) {\n+                int val = bytestream2_get_be32(gb);\n+                *dst++ = val >>  0;\n+                *dst++ = val >>  8;\n+                *dst++ = val >> 16;\n+                *dst++ = val >> 24;\n+            }\n+        }\n+        break;\n+    default:\n+        return AVERROR_PATCHWELCOME;\n+    }\n+    return 0;\n+}\n+\n+#define APPLY_ALPHA(src, new, alpha) \\\n+    src = (src * (256 - alpha) + new * alpha) >> 8\n+\n+static void g2m_paint_cursor(G2MContext *c, uint8_t *dst, int stride)\n+{\n+    int i, j;\n+    int x, y, w, h;\n+    const uint8_t *cursor;\n+\n+    if (!c->cursor)\n+        return;\n+\n+    x = c->cursor_x - c->cursor_hot_x;\n+    y = c->cursor_y - c->cursor_hot_y;\n+\n+    cursor = c->cursor;\n+    w      = c->cursor_w;\n+    h      = c->cursor_h;\n+\n+    if (x + w > c->width)\n+        w = c->width - x;\n+    if (y + h > c->height)\n+        h = c->height - y;\n+    if (x < 0) {\n+        w      +=  x;\n+        cursor += -x * 4;\n+    } else {\n+        dst    +=  x * 3;\n+    }\n+    if (y < 0) {\n+        h      +=  y;\n+        cursor += -y * c->cursor_stride;\n+    } else {\n+        dst    +=  y * stride;\n+    }\n+    if (w < 0 || h < 0)\n+        return;\n+\n+    for (j = 0; j < h; j++) {\n+        for (i = 0; i < w; i++) {\n+            uint8_t alpha = cursor[i * 4];\n+            APPLY_ALPHA(dst[i * 3 + 0], cursor[i * 4 + 1], alpha);\n+            APPLY_ALPHA(dst[i * 3 + 1], cursor[i * 4 + 2], alpha);\n+            APPLY_ALPHA(dst[i * 3 + 2], cursor[i * 4 + 3], alpha);\n+        }\n+        dst    += stride;\n+        cursor += c->cursor_stride;\n+    }\n+}\n+\n+static int g2m_decode_frame(AVCodecContext *avctx, void *data,\n+                            int *got_picture_ptr, AVPacket *avpkt)\n+{\n+    const uint8_t *buf = avpkt->data;\n+    int buf_size = avpkt->size;\n+    G2MContext *c = avctx->priv_data;\n+    AVFrame *pic = data;\n+    GetByteContext bc, tbc;\n+    int magic;\n+    int got_header = 0;\n+    uint32_t chunk_size, cur_size;\n+    int chunk_type;\n+    int i;\n+    int ret;\n+\n+    if (buf_size < 12) {\n+        av_log(avctx, AV_LOG_ERROR,\n+               ""Frame should have at least 12 bytes, got %d instead\\n"",\n+               buf_size);\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n+    bytestream2_init(&bc, buf, buf_size);\n+\n+    magic = bytestream2_get_be32(&bc);\n+    if ((magic & ~0xF) != MKBETAG(\'G\', \'2\', \'M\', \'0\') ||\n+        (magic & 0xF) < 2 || (magic & 0xF) > 4) {\n+        av_log(avctx, AV_LOG_ERROR, ""Wrong magic %08X\\n"", magic);\n+        return AVERROR_INVALIDDATA;\n+    }\n+\n+    if ((magic & 0xF) != 4) {\n+        av_log(avctx, AV_LOG_ERROR, ""G2M2 and G2M3 are not yet supported\\n"");\n+        return AVERROR(ENOSYS);\n+    }\n+\n+    while (bytestream2_get_bytes_left(&bc) > 5) {\n+        chunk_size = bytestream2_get_le32(&bc) - 1;\n+        chunk_type = bytestream2_get_byte(&bc);\n+        if (chunk_size > bytestream2_get_bytes_left(&bc)) {\n+            av_log(avctx, AV_LOG_ERROR, ""Invalid chunk size %d type %02X\\n"",\n+                   chunk_size, chunk_type);\n+            break;\n+        }\n+        switch (chunk_type) {\n+        case FRAME_INFO:\n+            c->got_header = 0;\n+            if (chunk_size < 21) {\n+                av_log(avctx, AV_LOG_ERROR, ""Invalid frame info size %d\\n"",\n+                       chunk_size);\n+                break;\n+            }\n+            c->width  = bytestream2_get_be32(&bc);\n+            c->height = bytestream2_get_be32(&bc);\n+            if (c->width  < 16 || c->width  > avctx->width ||\n+                c->height < 16 || c->height > avctx->height) {\n+                av_log(avctx, AV_LOG_ERROR,\n+                       ""Invalid frame dimensions %dx%d\\n"",\n+                       c->width, c->height);\n+                c->width = c->height = 0;\n+                bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));\n+            }\n+            if (c->width != avctx->width || c->height != avctx->height)\n+                avcodec_set_dimensions(avctx, c->width, c->height);\n+            c->compression = bytestream2_get_be32(&bc);\n+            if (c->compression != 2 && c->compression != 3) {\n+                av_log(avctx, AV_LOG_ERROR,\n+                       ""Unknown compression method %d\\n"",\n+                       c->compression);\n+                return AVERROR_PATCHWELCOME;\n+            }\n+            c->tile_width  = bytestream2_get_be32(&bc);\n+            c->tile_height = bytestream2_get_be32(&bc);\n+            if (!c->tile_width || !c->tile_height) {\n+                av_log(avctx, AV_LOG_ERROR,\n+                       ""Invalid tile dimensions %dx%d\\n"",\n+                       c->tile_width, c->tile_height);\n+                return AVERROR_INVALIDDATA;\n+            }\n+            c->tiles_x = (c->width  + c->tile_width  - 1) / c->tile_width;\n+            c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height;\n+            c->bpp = bytestream2_get_byte(&bc);\n+            chunk_size -= 21;\n+            bytestream2_skip(&bc, chunk_size);\n+            if (g2m_init_buffers(c))\n+                return AVERROR(ENOMEM);\n+            got_header = 1;\n+            break;\n+        case TILE_DATA:\n+            if (!c->tiles_x || !c->tiles_y) {\n+                av_log(avctx, AV_LOG_WARNING,\n+                       ""No frame header - skipping tile\\n"");\n+                bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));\n+                break;\n+            }\n+            if (chunk_size < 2) {\n+                av_log(avctx, AV_LOG_ERROR, ""Invalid tile data size %d\\n"",\n+                       chunk_size);\n+                break;\n+            }\n+            c->tile_x = bytestream2_get_byte(&bc);\n+            c->tile_y = bytestream2_get_byte(&bc);\n+            if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) {\n+                av_log(avctx, AV_LOG_ERROR,\n+                       ""Invalid tile pos %d,%d (in %dx%d grid)\\n"",\n+                       c->tile_x, c->tile_y, c->tiles_x, c->tiles_y);\n+                break;\n+            }\n+            chunk_size -= 2;\n+            ret = 0;\n+            switch (c->compression) {\n+            case COMPR_EPIC_J_B:\n+                av_log(avctx, AV_LOG_ERROR,\n+                       ""ePIC j-b compression is not implemented yet\\n"");\n+                return AVERROR(ENOSYS);\n+            case COMPR_KEMPF_J_B:\n+                ret = kempf_decode_tile(c, c->tile_x, c->tile_y,\n+                                        buf + bytestream2_tell(&bc),\n+                                        chunk_size);\n+                break;\n+            }\n+            if (ret && c->framebuf)\n+                av_log(avctx, AV_LOG_ERROR, ""Error decoding tile %d,%d\\n"",\n+                       c->tile_x, c->tile_y);\n+            bytestream2_skip(&bc, chunk_size);\n+            break;\n+        case CURSOR_POS:\n+            if (chunk_size < 5) {\n+                av_log(avctx, AV_LOG_ERROR, ""Invalid cursor pos size %d\\n"",\n+                       chunk_size);\n+                break;\n+            }\n+            c->cursor_x = bytestream2_get_be16(&bc);\n+            c->cursor_y = bytestream2_get_be16(&bc);\n+            bytestream2_skip(&bc, chunk_size - 4);\n+            break;\n+        case CURSOR_SHAPE:\n+            if (chunk_size < 8) {\n+                av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\\n"",\n+                       chunk_size);\n+                break;\n+            }\n+            bytestream2_init(&tbc, buf + bytestream2_tell(&bc),\n+                             chunk_size - 4);\n+            cur_size        = bytestream2_get_be32(&tbc);\n+            c->cursor_w     = bytestream2_get_byte(&tbc);\n+            c->cursor_h     = bytestream2_get_byte(&tbc);\n+            c->cursor_hot_x = bytestream2_get_byte(&tbc);\n+            c->cursor_hot_y = bytestream2_get_byte(&tbc);\n+            c->cursor_fmt   = bytestream2_get_byte(&tbc);\n+            if (cur_size >= chunk_size ||\n+                c->cursor_w * c->cursor_h / 4 > cur_size) {\n+                av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\\n"",\n+                       chunk_size);\n+                break;\n+            }\n+            g2m_load_cursor(c, &tbc);\n+            bytestream2_skip(&bc, chunk_size);\n+            break;\n+        case CHUNK_CC:\n+        case CHUNK_CD:\n+            bytestream2_skip(&bc, chunk_size);\n+            break;\n+        default:\n+            av_log(avctx, AV_LOG_WARNING, ""Skipping chunk type %02X\\n"",\n+                   chunk_type);\n+            bytestream2_skip(&bc, chunk_size);\n+        }\n+    }\n+    if (got_header)\n+        c->got_header = 1;\n+\n+    if (c->width && c->height) {\n+        if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) {\n+            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\\n"");\n+            return ret;\n+        }\n+\n+        pic->key_frame = got_header;\n+        pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n+\n+        for (i = 0; i < avctx->height; i++)\n+            memcpy(pic->data[0] + i * pic->linesize[0],\n+                   c->framebuf  + i * c->framebuf_stride,\n+                   c->width * 3);\n+        g2m_paint_cursor(c, pic->data[0], pic->linesize[0]);\n+\n+        *got_picture_ptr = 1;\n+    }\n+\n+    return buf_size;\n+}\n+\n+static av_cold int g2m_decode_init(AVCodecContext *avctx)\n+{\n+    G2MContext * const c = avctx->priv_data;\n+    int ret;\n+\n+    if ((ret = jpg_init(avctx, &c->jc)) != 0) {\n+        av_log(avctx, AV_LOG_ERROR, ""Cannot initialise VLCs\\n"");\n+        jpg_free_context(&c->jc);\n+        return AVERROR(ENOMEM);\n+    }\n+\n+    avctx->pix_fmt     = PIX_FMT_RGB24;\n+\n+    return 0;\n+}\n+\n+static av_cold int g2m_decode_end(AVCodecContext *avctx)\n+{\n+    G2MContext * const c = avctx->priv_data;\n+\n+    jpg_free_context(&c->jc);\n+\n+    av_freep(&c->kempf_buf);\n+    av_freep(&c->kempf_flags);\n+    av_freep(&c->synth_tile);\n+    av_freep(&c->jpeg_tile);\n+    av_freep(&c->cursor);\n+    av_freep(&c->framebuf);\n+\n+    return 0;\n+}\n+\n+AVCodec ff_g2m_decoder = {\n+    .name           = ""g2m"",\n+    .long_name      = NULL_IF_CONFIG_SMALL(""Go2Meeting""),\n+    .type           = AVMEDIA_TYPE_VIDEO,\n+    .id             = AV_CODEC_ID_G2M,\n+    .priv_data_size = sizeof(G2MContext),\n+    .init           = g2m_decode_init,\n+    .close          = g2m_decode_end,\n+    .decode         = g2m_decode_frame,\n+    .capabilities   = CODEC_CAP_DR1,\n+};\n']",2013-06-03 09:24:55+02:00,Go2Webinar decoder,"[['+ ', '+ ', '+ #include <zlib.h>', '+ ', '+ #include ""libavutil/intreadwrite.h""', '+ #include ""avcodec.h""', '+ #include ""bytestream.h""', '+ #include ""dsputil.h""', '+ #include ""get_bits.h""', '+ #include ""internal.h""', '+ #include ""mjpeg.h""', '+ ', '+ enum ChunkType {', '+     FRAME_INFO = 0xC8,', '+     TILE_DATA,', '+     CURSOR_POS,', '+     CURSOR_SHAPE,', '+     CHUNK_CC,', '+     CHUNK_CD', '+ };', '+ ', '+ enum Compression {', '+     COMPR_EPIC_J_B = 2,', '+     COMPR_KEMPF_J_B,', '+ };', '+ ', '+ static const uint8_t luma_quant[64] = {', '+      8,  6,  5,  8, 12, 20, 26, 31,', '+      6,  6,  7, 10, 13, 29, 30, 28,', '+      7,  7,  8, 12, 20, 29, 35, 28,', '+      7,  9, 11, 15, 26, 44, 40, 31,', '+      9, 11, 19, 28, 34, 55, 52, 39,', '+     12, 18, 28, 32, 41, 52, 57, 46,', '+     25, 32, 39, 44, 52, 61, 60, 51,', '+     36, 46, 48, 49, 56, 50, 52, 50', '+ };', '+ ', '+ static const uint8_t chroma_quant[64] = {', '+      9,  9, 12, 24, 50, 50, 50, 50,', '+      9, 11, 13, 33, 50, 50, 50, 50,', '+     12, 13, 28, 50, 50, 50, 50, 50,', '+     24, 33, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+ };', '+ ', '+ typedef struct JPGContext {', '+     DSPContext dsp;', '+     ScanTable  scantable;', '+ ', '+     VLC        dc_vlc[2], ac_vlc[2];', '+     int        prev_dc[3];', '+     DECLARE_ALIGNED(16, int16_t, block)[6][64];', '+ ', '+     uint8_t    *buf;', '+ } JPGContext;', '+ ', '+ typedef struct G2MContext {', '+     JPGContext jc;', '+     int        version;', '+ ', '+     int        compression;', '+     int        width, height, bpp;', '+     int        tile_width, tile_height;', '+     int        tiles_x, tiles_y, tile_x, tile_y;', '+ ', '+     int        got_header;', '+ ', '+     uint8_t    *framebuf;', '+     int        framebuf_stride, old_width, old_height;', '+ ', '+     uint8_t    *synth_tile, *jpeg_tile;', '+     int        tile_stride, old_tile_w, old_tile_h;', '+ ', '+     uint8_t    *kempf_buf, *kempf_flags;', '+ ', '+     uint8_t    *cursor;', '+     int        cursor_stride;', '+     int        cursor_fmt;', '+     int        cursor_w, cursor_h, cursor_x, cursor_y;', '+     int        cursor_hot_x, cursor_hot_y;', '+ } G2MContext;', '+ ', '+ static av_cold int build_vlc(VLC *vlc, const uint8_t *bits_table,', '+                              const uint8_t *val_table, int nb_codes,', '+                              int is_ac)', '+ {', '+     uint8_t  huff_size[256] = { 0 };', '+     uint16_t huff_code[256];', '+     uint16_t huff_sym[256];', '+     int i;', '+ ', '+     ff_mjpeg_build_huffman_codes(huff_size, huff_code, bits_table, val_table);', '+ ', '+     for (i = 0; i < 256; i++)', '+         huff_sym[i] = i + 16 * is_ac;', '+ ', '+     if (is_ac)', '+         huff_sym[0] = 16 * 256;', '+ ', '+     return ff_init_vlc_sparse(vlc, 9, nb_codes, huff_size, 1, 1,', '+                               huff_code, 2, 2, huff_sym, 2, 2, 0);', '+ }', '+ ', '+ static av_cold int jpg_init(AVCodecContext *avctx, JPGContext *c)', '+ {', '+     int ret;', '+ ', '+     ret = build_vlc(&c->dc_vlc[0], avpriv_mjpeg_bits_dc_luminance,', '+                     avpriv_mjpeg_val_dc, 12, 0);', '+     if (ret)', '+         return ret;', '+     ret = build_vlc(&c->dc_vlc[1], avpriv_mjpeg_bits_dc_chrominance,', '+                     avpriv_mjpeg_val_dc, 12, 0);', '+     if (ret)', '+         return ret;', '+     ret = build_vlc(&c->ac_vlc[0], avpriv_mjpeg_bits_ac_luminance,', '+                     avpriv_mjpeg_val_ac_luminance, 251, 1);', '+     if (ret)', '+         return ret;', '+     ret = build_vlc(&c->ac_vlc[1], avpriv_mjpeg_bits_ac_chrominance,', '+                     avpriv_mjpeg_val_ac_chrominance, 251, 1);', '+     if (ret)', '+         return ret;', '+ ', '+     ff_dsputil_init(&c->dsp, avctx);', '+     ff_init_scantable(c->dsp.idct_permutation, &c->scantable,', '+                       ff_zigzag_direct);', '+ ', '+     return 0;', '+ }', '+ ', '+ static av_cold void jpg_free_context(JPGContext *ctx)', '+ {', '+     int i;', '+ ', '+     for (i = 0; i < 2; i++) {', '+         ff_free_vlc(&ctx->dc_vlc[i]);', '+         ff_free_vlc(&ctx->ac_vlc[i]);', '+     }', '+ ', '+     av_freep(&ctx->buf);', '+ }', '+ ', '+ static void jpg_unescape(const uint8_t *src, int src_size,', '+                          uint8_t *dst, int *dst_size)', '+ {', '+     const uint8_t *src_end = src + src_size;', '+     uint8_t *dst_start = dst;', '+ ', '+     while (src < src_end) {', '+         uint8_t x = *src++;', '+ ', '+         *dst++ = x;', '+ ', '+         if (x == 0xFF && !*src)', '+             src++;', '+     }', '+     *dst_size = dst - dst_start;', '+ }', '+ ', '+ static int jpg_decode_block(JPGContext *c, GetBitContext *gb,', '+                             int plane, int16_t *block)', '+ {', '+     int dc, val, pos;', '+     const int is_chroma = !!plane;', '+     const uint8_t *qmat = is_chroma ? chroma_quant : luma_quant;', '+ ', '+     c->dsp.clear_block(block);', '+     dc = get_vlc2(gb, c->dc_vlc[is_chroma].table, 9, 3);', '+     if (dc < 0)', '+         return AVERROR_INVALIDDATA;', '+     if (dc)', '+         dc = get_xbits(gb, dc);', '+     dc = dc * qmat[0] + c->prev_dc[plane];', '+     block[0] = dc;', '+     c->prev_dc[plane] = dc;', '+ ', '+     pos = 0;', '+     while (pos < 63) {', '+         val = get_vlc2(gb, c->ac_vlc[is_chroma].table, 9, 3);', '+         if (val < 0)', '+             return AVERROR_INVALIDDATA;', '+         pos += val >> 4;', '+         val &= 0xF;', '+         if (pos > 63)', '+             return val ? AVERROR_INVALIDDATA : 0;', '+         if (val) {', '+             int nbits = val;', '+ ', '+             val = get_xbits(gb, nbits);', '+             val *= qmat[ff_zigzag_direct[pos]];', '+             block[c->scantable.permutated[pos]] = val;', '+         }', '+     }', '+     return 0;', '+ }', '+ ', '+ static inline void yuv2rgb(uint8_t *out, int Y, int U, int V)', '+ {', '+     out[0] = av_clip_uint8(Y + (             91881 * V + 32768 >> 16));', '+     out[1] = av_clip_uint8(Y + (-22554 * U - 46802 * V + 32768 >> 16));', '+     out[2] = av_clip_uint8(Y + (116130 * U             + 32768 >> 16));', '+ }', '+ ', '+ static int jpg_decode_data(JPGContext *c, int width, int height,', '+                            const uint8_t *src, int src_size,', '+                            uint8_t *dst, int dst_stride,', '+                            const uint8_t *mask, int mask_stride, int num_mbs,', '+                            int swapuv)', '+ {', '+     GetBitContext gb;', '+     uint8_t *tmp;', '+     int mb_w, mb_h, mb_x, mb_y, i, j;', '+     int bx, by;', '+     int unesc_size;', '+     int ret;', '+ ', '+     tmp = av_realloc(c->buf, src_size + FF_INPUT_BUFFER_PADDING_SIZE);', '+     if (!tmp)', '+         return AVERROR(ENOMEM);', '+     c->buf = tmp;', '+     jpg_unescape(src, src_size, c->buf, &unesc_size);', '+     memset(c->buf + unesc_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);', '+     init_get_bits(&gb, c->buf, unesc_size * 8);', '+ ', '+     width = FFALIGN(width, 16);', '+     mb_w  =  width        >> 4;', '+     mb_h  = (height + 15) >> 4;', '+ ', '+     if (!num_mbs)', '+         num_mbs = mb_w * mb_h;', '+ ', '+     for (i = 0; i < 3; i++)', '+         c->prev_dc[i] = 1024;', '+     bx = by = 0;', '+     for (mb_y = 0; mb_y < mb_h; mb_y++) {', '+         for (mb_x = 0; mb_x < mb_w; mb_x++) {', '+             if (mask && !mask[mb_x]) {', '+                 bx += 16;', '+                 continue;', '+             }', '+             for (j = 0; j < 2; j++) {', '+                 for (i = 0; i < 2; i++) {', '+                     if ((ret = jpg_decode_block(c, &gb, 0,', '+                                                 c->block[i + j * 2])) != 0)', '+                         return ret;', '+                     c->dsp.idct(c->block[i + j * 2]);', '+                 }', '+             }', '+             for (i = 1; i < 3; i++) {', '+                 if ((ret = jpg_decode_block(c, &gb, i, c->block[i + 3])) != 0)', '+                     return ret;', '+                 c->dsp.idct(c->block[i + 3]);', '+             }', '+ ', '+             for (j = 0; j < 16; j++) {', '+                 uint8_t *out = dst + bx * 3 + (by + j) * dst_stride;', '+                 for (i = 0; i < 16; i++) {', '+                     int Y, U, V;', '+ ', '+                     Y = c->block[(j >> 3) * 2 + (i >> 3)][(i & 7) + (j & 7) * 8];', '+                     U = c->block[4 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;', '+                     V = c->block[5 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;', '+                     yuv2rgb(out + i * 3, Y, U, V);', '+                 }', '+             }', '+ ', '+             if (!--num_mbs)', '+                 return 0;', '+             bx += 16;', '+         }', '+         bx  = 0;', '+         by += 16;', '+         if (mask)', '+             mask += mask_stride;', '+     }', '+ ', '+     return 0;', '+ }', '+ ', '+ static void kempf_restore_buf(const uint8_t *src, int len,', '+                               uint8_t *dst, int stride,', '+                               const uint8_t *jpeg_tile, int tile_stride,', '+                               int width, int height,', '+                               const uint8_t *pal, int npal, int tidx)', '+ {', '+     GetBitContext gb;', '+     int i, j, nb, col;', '+ ', '+     init_get_bits(&gb, src, len * 8);', '+ ', '+     if (npal <= 2)       nb = 1;', '+     else if (npal <= 4)  nb = 2;', '+     else if (npal <= 16) nb = 4;', '+     else                 nb = 8;', '+ ', '+     for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {', '+         if (get_bits(&gb, 8))', '+             continue;', '+         for (i = 0; i < width; i++) {', '+             col = get_bits(&gb, nb);', '+             if (col != tidx)', '+                 memcpy(dst + i * 3, pal + col * 3, 3);', '+             else', '+                 memcpy(dst + i * 3, jpeg_tile + i * 3, 3);', '+         }', '+     }', '+ }', '+ ', '+ static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,', '+                              const uint8_t *src, int src_size)', '+ {', '+     int width, height;', '+     int hdr, zsize, npal, tidx = -1, ret;', '+     int i, j;', '+     const uint8_t *src_end = src + src_size;', '+     uint8_t pal[768], transp[3];', '+     uLongf dlen = (c->tile_width + 1) * c->tile_height;', '+     int sub_type;', '+     int nblocks, cblocks, bstride;', '+     int bits, bitbuf, coded;', '+     uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +', '+                    tile_y * c->tile_height * c->framebuf_stride;', '+ ', '+     if (src_size < 2)', '+         return AVERROR_INVALIDDATA;', '+ ', '+     width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);', '+     height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);', '+ ', '+     hdr = *src++;', '+     sub_type = hdr >> 5;', '+     if (sub_type == 0) {', '+         int j;', '+         memcpy(transp, src, 3);', '+         src += 3;', '+         for (j = 0; j < height; j++, dst += c->framebuf_stride)', '+             for (i = 0; i < width; i++)', '+                 memcpy(dst + i * 3, transp, 3);', '+         return 0;', '+     } else if (sub_type == 1) {', '+         return jpg_decode_data(&c->jc, width, height, src, src_end - src,', '+                                dst, c->framebuf_stride, NULL, 0, 0, 0);', '+     }', '+ ', '+     if (sub_type != 2) {', '+         memcpy(transp, src, 3);', '+         src += 3;', '+     }', '+     npal = *src++ + 1;', '+     memcpy(pal, src, npal * 3); src += npal * 3;', '+     if (sub_type != 2) {', '+         for (i = 0; i < npal; i++) {', '+             if (!memcmp(pal + i * 3, transp, 3)) {', '+                tidx = i;', '+                break;', '+             }', '+         }', '+     }', '+ ', '+     if (src_end - src < 2)', '+         return 0;', '+     zsize = (src[0] << 8) | src[1]; src += 2;', '+ ', '+     if (src_end - src < zsize)', '+         return AVERROR_INVALIDDATA;', '+ ', '+     ret = uncompress(c->kempf_buf, &dlen, src, zsize);', '+     if (ret)', '+         return AVERROR_INVALIDDATA;', '+     src += zsize;', '+ ', '+     if (sub_type == 2) {', '+         kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,', '+                           NULL, 0, width, height, pal, npal, tidx);', '+         return 0;', '+     }', '+ ', '+     nblocks = *src++ + 1;', '+     cblocks = 0;', '+     bstride = FFALIGN(width, 16) >> 4;', '+     bits = 0;', '+     for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {', '+         for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {', '+             if (!bits) {', '+                 bitbuf = *src++;', '+                 bits   = 8;', '+             }', '+             coded = bitbuf & 1;', '+             bits--;', '+             bitbuf >>= 1;', '+             cblocks += coded;', '+             if (cblocks > nblocks)', '+                 return AVERROR_INVALIDDATA;', '+             c->kempf_flags[j + i * bstride] = coded;', '+         }', '+     }', '+ ', '+     memset(c->jpeg_tile, 0, c->tile_stride * height);', '+     jpg_decode_data(&c->jc, width, height, src, src_end - src,', '+                     c->jpeg_tile, c->tile_stride,', '+                     c->kempf_flags, bstride, nblocks, 0);', '+ ', '+     kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,', '+                       c->jpeg_tile, c->tile_stride,', '+                       width, height, pal, npal, tidx);', '+ ', '+     return 0;', '+ }', '+ ', '+ static int g2m_init_buffers(G2MContext *c)', '+ {', '+     int aligned_height;', '+ ', '+     if (!c->framebuf || c->old_width < c->width || c->height < c->height) {', '+         c->framebuf_stride = FFALIGN(c->width * 3, 16);', '+         aligned_height     = FFALIGN(c->height,    16);', '+         av_free(c->framebuf);', '+         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);', '+         if (!c->framebuf)', '+             return AVERROR(ENOMEM);', '+     }', '+     if (!c->synth_tile || !c->jpeg_tile ||', '+         c->old_tile_w < c->tile_width ||', '+         c->old_tile_h < c->tile_height) {', '+         c->tile_stride = FFALIGN(c->tile_width * 3, 16);', '+         aligned_height = FFALIGN(c->tile_height,    16);', '+         av_free(c->synth_tile);', '+         av_free(c->jpeg_tile);', '+         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);', '+         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);', '+         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height', '+                                     + FF_INPUT_BUFFER_PADDING_SIZE);', '+         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);', '+         if (!c->synth_tile || !c->jpeg_tile ||', '+             !c->kempf_buf || !c->kempf_flags)', '+             return AVERROR(ENOMEM);', '+     }', '+ ', '+     return 0;', '+ }', '+ ', '+ static int g2m_load_cursor(G2MContext *c, GetByteContext *gb)', '+ {', '+     int i, j, k;', '+     uint8_t *dst;', '+     uint32_t bits;', '+ ', '+     c->cursor_stride = c->cursor_w * 4;', '+     c->cursor        = av_realloc(c->cursor, c->cursor_stride * c->cursor_h);', '+     if (!c->cursor)', '+         return AVERROR(ENOMEM);', '+ ', '+     dst = c->cursor;', '+     switch (c->cursor_fmt) {', '+         for (j = 0; j < c->cursor_h; j++) {', '+             for (i = 0; i < c->cursor_w; i += 32) {', '+                 bits = bytestream2_get_be32(gb);', '+                 for (k = 0; k < 32; k++) {', '+                     dst[0] = !!(bits & 0x80000000);', '+                     dst += 4;', '+                     bits <<= 1;', '+                 }', '+             }', '+         }', '+ ', '+         dst = c->cursor;', '+         for (j = 0; j < c->cursor_h; j++) {', '+             for (i = 0; i < c->cursor_w; i += 32) {', '+                 bits = bytestream2_get_be32(gb);', '+                 for (k = 0; k < 32; k++) {', '+                     int mask_bit = !!(bits & 0x80000000);', '+                     switch (dst[0] * 2 + mask_bit) {', '+                     case 0:', '+                         dst[0] = 0xFF; dst[1] = 0x00;', '+                         dst[2] = 0x00; dst[3] = 0x00;', '+                         break;', '+                     case 1:', '+                         dst[0] = 0xFF; dst[1] = 0xFF;', '+                         dst[2] = 0xFF; dst[3] = 0xFF;', '+                         break;', '+                     default:', '+                         dst[0] = 0x00; dst[1] = 0x00;', '+                         dst[2] = 0x00; dst[3] = 0x00;', '+                     }', '+                     dst += 4;', '+                     bits <<= 1;', '+                 }', '+             }', '+         }', '+         break;', '+         bytestream2_skip(gb, c->cursor_h * (FFALIGN(c->cursor_w, 32) >> 3));', '+         for (j = 0; j < c->cursor_h; j++) {', '+             for (i = 0; i < c->cursor_w; i++) {', '+                 int val = bytestream2_get_be32(gb);', '+                 *dst++ = val >>  0;', '+                 *dst++ = val >>  8;', '+                 *dst++ = val >> 16;', '+                 *dst++ = val >> 24;', '+             }', '+         }', '+         break;', '+     default:', '+         return AVERROR_PATCHWELCOME;', '+     }', '+     return 0;', '+ }', '+ ', '+ #define APPLY_ALPHA(src, new, alpha) \\', '+     src = (src * (256 - alpha) + new * alpha) >> 8', '+ ', '+ static void g2m_paint_cursor(G2MContext *c, uint8_t *dst, int stride)', '+ {', '+     int i, j;', '+     int x, y, w, h;', '+     const uint8_t *cursor;', '+ ', '+     if (!c->cursor)', '+         return;', '+ ', '+     x = c->cursor_x - c->cursor_hot_x;', '+     y = c->cursor_y - c->cursor_hot_y;', '+ ', '+     cursor = c->cursor;', '+     w      = c->cursor_w;', '+     h      = c->cursor_h;', '+ ', '+     if (x + w > c->width)', '+         w = c->width - x;', '+     if (y + h > c->height)', '+         h = c->height - y;', '+     if (x < 0) {', '+         w      +=  x;', '+         cursor += -x * 4;', '+     } else {', '+         dst    +=  x * 3;', '+     }', '+     if (y < 0) {', '+         h      +=  y;', '+         cursor += -y * c->cursor_stride;', '+     } else {', '+         dst    +=  y * stride;', '+     }', '+     if (w < 0 || h < 0)', '+         return;', '+ ', '+     for (j = 0; j < h; j++) {', '+         for (i = 0; i < w; i++) {', '+             uint8_t alpha = cursor[i * 4];', '+             APPLY_ALPHA(dst[i * 3 + 0], cursor[i * 4 + 1], alpha);', '+             APPLY_ALPHA(dst[i * 3 + 1], cursor[i * 4 + 2], alpha);', '+             APPLY_ALPHA(dst[i * 3 + 2], cursor[i * 4 + 3], alpha);', '+         }', '+         dst    += stride;', '+         cursor += c->cursor_stride;', '+     }', '+ }', '+ ', '+ static int g2m_decode_frame(AVCodecContext *avctx, void *data,', '+                             int *got_picture_ptr, AVPacket *avpkt)', '+ {', '+     const uint8_t *buf = avpkt->data;', '+     int buf_size = avpkt->size;', '+     G2MContext *c = avctx->priv_data;', '+     AVFrame *pic = data;', '+     GetByteContext bc, tbc;', '+     int magic;', '+     int got_header = 0;', '+     uint32_t chunk_size, cur_size;', '+     int chunk_type;', '+     int i;', '+     int ret;', '+ ', '+     if (buf_size < 12) {', '+         av_log(avctx, AV_LOG_ERROR,', '+                ""Frame should have at least 12 bytes, got %d instead\\n"",', '+                buf_size);', '+         return AVERROR_INVALIDDATA;', '+     }', '+ ', '+     bytestream2_init(&bc, buf, buf_size);', '+ ', '+     magic = bytestream2_get_be32(&bc);', ""+     if ((magic & ~0xF) != MKBETAG('G', '2', 'M', '0') ||"", '+         (magic & 0xF) < 2 || (magic & 0xF) > 4) {', '+         av_log(avctx, AV_LOG_ERROR, ""Wrong magic %08X\\n"", magic);', '+         return AVERROR_INVALIDDATA;', '+     }', '+ ', '+     if ((magic & 0xF) != 4) {', '+         av_log(avctx, AV_LOG_ERROR, ""G2M2 and G2M3 are not yet supported\\n"");', '+         return AVERROR(ENOSYS);', '+     }', '+ ', '+     while (bytestream2_get_bytes_left(&bc) > 5) {', '+         chunk_size = bytestream2_get_le32(&bc) - 1;', '+         chunk_type = bytestream2_get_byte(&bc);', '+         if (chunk_size > bytestream2_get_bytes_left(&bc)) {', '+             av_log(avctx, AV_LOG_ERROR, ""Invalid chunk size %d type %02X\\n"",', '+                    chunk_size, chunk_type);', '+             break;', '+         }', '+         switch (chunk_type) {', '+         case FRAME_INFO:', '+             c->got_header = 0;', '+             if (chunk_size < 21) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid frame info size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             c->width  = bytestream2_get_be32(&bc);', '+             c->height = bytestream2_get_be32(&bc);', '+             if (c->width  < 16 || c->width  > avctx->width ||', '+                 c->height < 16 || c->height > avctx->height) {', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""Invalid frame dimensions %dx%d\\n"",', '+                        c->width, c->height);', '+                 c->width = c->height = 0;', '+                 bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));', '+             }', '+             if (c->width != avctx->width || c->height != avctx->height)', '+                 avcodec_set_dimensions(avctx, c->width, c->height);', '+             c->compression = bytestream2_get_be32(&bc);', '+             if (c->compression != 2 && c->compression != 3) {', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""Unknown compression method %d\\n"",', '+                        c->compression);', '+                 return AVERROR_PATCHWELCOME;', '+             }', '+             c->tile_width  = bytestream2_get_be32(&bc);', '+             c->tile_height = bytestream2_get_be32(&bc);', '+             if (!c->tile_width || !c->tile_height) {', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""Invalid tile dimensions %dx%d\\n"",', '+                        c->tile_width, c->tile_height);', '+                 return AVERROR_INVALIDDATA;', '+             }', '+             c->tiles_x = (c->width  + c->tile_width  - 1) / c->tile_width;', '+             c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height;', '+             c->bpp = bytestream2_get_byte(&bc);', '+             chunk_size -= 21;', '+             bytestream2_skip(&bc, chunk_size);', '+             if (g2m_init_buffers(c))', '+                 return AVERROR(ENOMEM);', '+             got_header = 1;', '+             break;', '+         case TILE_DATA:', '+             if (!c->tiles_x || !c->tiles_y) {', '+                 av_log(avctx, AV_LOG_WARNING,', '+                        ""No frame header - skipping tile\\n"");', '+                 bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));', '+                 break;', '+             }', '+             if (chunk_size < 2) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid tile data size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             c->tile_x = bytestream2_get_byte(&bc);', '+             c->tile_y = bytestream2_get_byte(&bc);', '+             if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) {', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""Invalid tile pos %d,%d (in %dx%d grid)\\n"",', '+                        c->tile_x, c->tile_y, c->tiles_x, c->tiles_y);', '+                 break;', '+             }', '+             chunk_size -= 2;', '+             ret = 0;', '+             switch (c->compression) {', '+             case COMPR_EPIC_J_B:', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""ePIC j-b compression is not implemented yet\\n"");', '+                 return AVERROR(ENOSYS);', '+             case COMPR_KEMPF_J_B:', '+                 ret = kempf_decode_tile(c, c->tile_x, c->tile_y,', '+                                         buf + bytestream2_tell(&bc),', '+                                         chunk_size);', '+                 break;', '+             }', '+             if (ret && c->framebuf)', '+                 av_log(avctx, AV_LOG_ERROR, ""Error decoding tile %d,%d\\n"",', '+                        c->tile_x, c->tile_y);', '+             bytestream2_skip(&bc, chunk_size);', '+             break;', '+         case CURSOR_POS:', '+             if (chunk_size < 5) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid cursor pos size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             c->cursor_x = bytestream2_get_be16(&bc);', '+             c->cursor_y = bytestream2_get_be16(&bc);', '+             bytestream2_skip(&bc, chunk_size - 4);', '+             break;', '+         case CURSOR_SHAPE:', '+             if (chunk_size < 8) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             bytestream2_init(&tbc, buf + bytestream2_tell(&bc),', '+                              chunk_size - 4);', '+             cur_size        = bytestream2_get_be32(&tbc);', '+             c->cursor_w     = bytestream2_get_byte(&tbc);', '+             c->cursor_h     = bytestream2_get_byte(&tbc);', '+             c->cursor_hot_x = bytestream2_get_byte(&tbc);', '+             c->cursor_hot_y = bytestream2_get_byte(&tbc);', '+             c->cursor_fmt   = bytestream2_get_byte(&tbc);', '+             if (cur_size >= chunk_size ||', '+                 c->cursor_w * c->cursor_h / 4 > cur_size) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             g2m_load_cursor(c, &tbc);', '+             bytestream2_skip(&bc, chunk_size);', '+             break;', '+         case CHUNK_CC:', '+         case CHUNK_CD:', '+             bytestream2_skip(&bc, chunk_size);', '+             break;', '+         default:', '+             av_log(avctx, AV_LOG_WARNING, ""Skipping chunk type %02X\\n"",', '+                    chunk_type);', '+             bytestream2_skip(&bc, chunk_size);', '+         }', '+     }', '+     if (got_header)', '+         c->got_header = 1;', '+ ', '+     if (c->width && c->height) {', '+         if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) {', '+             av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\\n"");', '+             return ret;', '+         }', '+ ', '+         pic->key_frame = got_header;', '+         pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;', '+ ', '+         for (i = 0; i < avctx->height; i++)', '+             memcpy(pic->data[0] + i * pic->linesize[0],', '+                    c->framebuf  + i * c->framebuf_stride,', '+                    c->width * 3);', '+         g2m_paint_cursor(c, pic->data[0], pic->linesize[0]);', '+ ', '+         *got_picture_ptr = 1;', '+     }', '+ ', '+     return buf_size;', '+ }', '+ ', '+ static av_cold int g2m_decode_init(AVCodecContext *avctx)', '+ {', '+     G2MContext * const c = avctx->priv_data;', '+     int ret;', '+ ', '+     if ((ret = jpg_init(avctx, &c->jc)) != 0) {', '+         av_log(avctx, AV_LOG_ERROR, ""Cannot initialise VLCs\\n"");', '+         jpg_free_context(&c->jc);', '+         return AVERROR(ENOMEM);', '+     }', '+ ', '+     avctx->pix_fmt     = PIX_FMT_RGB24;', '+ ', '+     return 0;', '+ }', '+ ', '+ static av_cold int g2m_decode_end(AVCodecContext *avctx)', '+ {', '+     G2MContext * const c = avctx->priv_data;', '+ ', '+     jpg_free_context(&c->jc);', '+ ', '+     av_freep(&c->kempf_buf);', '+     av_freep(&c->kempf_flags);', '+     av_freep(&c->synth_tile);', '+     av_freep(&c->jpeg_tile);', '+     av_freep(&c->cursor);', '+     av_freep(&c->framebuf);', '+ ', '+     return 0;', '+ }', '+ ', '+ AVCodec ff_g2m_decoder = {', '+     .name           = ""g2m"",', '+     .long_name      = NULL_IF_CONFIG_SMALL(""Go2Meeting""),', '+     .type           = AVMEDIA_TYPE_VIDEO,', '+     .id             = AV_CODEC_ID_G2M,', '+     .priv_data_size = sizeof(G2MContext),', '+     .init           = g2m_decode_init,', '+     .close          = g2m_decode_end,', '+     .decode         = g2m_decode_frame,', '+     .capabilities   = CODEC_CAP_DR1,', '+ };']]","[['+ ', '+ ', '+ #include <zlib.h>', '+ ', '+ #include ""libavutil/intreadwrite.h""', '+ #include ""avcodec.h""', '+ #include ""bytestream.h""', '+ #include ""dsputil.h""', '+ #include ""get_bits.h""', '+ #include ""internal.h""', '+ #include ""mjpeg.h""', '+ ', '+ enum chunktype {', '+     frame_info = 0xc8,', '+     tile_data,', '+     cursor_pos,', '+     cursor_shape,', '+     chunk_cc,', '+     chunk_cd', '+ };', '+ ', '+ enum compression {', '+     compr_epic_j_b = 2,', '+     compr_kempf_j_b,', '+ };', '+ ', '+ static const uint8_t luma_quant[64] = {', '+      8,  6,  5,  8, 12, 20, 26, 31,', '+      6,  6,  7, 10, 13, 29, 30, 28,', '+      7,  7,  8, 12, 20, 29, 35, 28,', '+      7,  9, 11, 15, 26, 44, 40, 31,', '+      9, 11, 19, 28, 34, 55, 52, 39,', '+     12, 18, 28, 32, 41, 52, 57, 46,', '+     25, 32, 39, 44, 52, 61, 60, 51,', '+     36, 46, 48, 49, 56, 50, 52, 50', '+ };', '+ ', '+ static const uint8_t chroma_quant[64] = {', '+      9,  9, 12, 24, 50, 50, 50, 50,', '+      9, 11, 13, 33, 50, 50, 50, 50,', '+     12, 13, 28, 50, 50, 50, 50, 50,', '+     24, 33, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+ };', '+ ', '+ typedef struct jpgcontext {', '+     dspcontext dsp;', '+     scantable  scantable;', '+ ', '+     vlc        dc_vlc[2], ac_vlc[2];', '+     int        prev_dc[3];', '+     declare_aligned(16, int16_t, block)[6][64];', '+ ', '+     uint8_t    *buf;', '+ } jpgcontext;', '+ ', '+ typedef struct g2mcontext {', '+     jpgcontext jc;', '+     int        version;', '+ ', '+     int        compression;', '+     int        width, height, bpp;', '+     int        tile_width, tile_height;', '+     int        tiles_x, tiles_y, tile_x, tile_y;', '+ ', '+     int        got_header;', '+ ', '+     uint8_t    *framebuf;', '+     int        framebuf_stride, old_width, old_height;', '+ ', '+     uint8_t    *synth_tile, *jpeg_tile;', '+     int        tile_stride, old_tile_w, old_tile_h;', '+ ', '+     uint8_t    *kempf_buf, *kempf_flags;', '+ ', '+     uint8_t    *cursor;', '+     int        cursor_stride;', '+     int        cursor_fmt;', '+     int        cursor_w, cursor_h, cursor_x, cursor_y;', '+     int        cursor_hot_x, cursor_hot_y;', '+ } g2mcontext;', '+ ', '+ static av_cold int build_vlc(vlc *vlc, const uint8_t *bits_table,', '+                              const uint8_t *val_table, int nb_codes,', '+                              int is_ac)', '+ {', '+     uint8_t  huff_size[256] = { 0 };', '+     uint16_t huff_code[256];', '+     uint16_t huff_sym[256];', '+     int i;', '+ ', '+     ff_mjpeg_build_huffman_codes(huff_size, huff_code, bits_table, val_table);', '+ ', '+     for (i = 0; i < 256; i++)', '+         huff_sym[i] = i + 16 * is_ac;', '+ ', '+     if (is_ac)', '+         huff_sym[0] = 16 * 256;', '+ ', '+     return ff_init_vlc_sparse(vlc, 9, nb_codes, huff_size, 1, 1,', '+                               huff_code, 2, 2, huff_sym, 2, 2, 0);', '+ }', '+ ', '+ static av_cold int jpg_init(avcodeccontext *avctx, jpgcontext *c)', '+ {', '+     int ret;', '+ ', '+     ret = build_vlc(&c->dc_vlc[0], avpriv_mjpeg_bits_dc_luminance,', '+                     avpriv_mjpeg_val_dc, 12, 0);', '+     if (ret)', '+         return ret;', '+     ret = build_vlc(&c->dc_vlc[1], avpriv_mjpeg_bits_dc_chrominance,', '+                     avpriv_mjpeg_val_dc, 12, 0);', '+     if (ret)', '+         return ret;', '+     ret = build_vlc(&c->ac_vlc[0], avpriv_mjpeg_bits_ac_luminance,', '+                     avpriv_mjpeg_val_ac_luminance, 251, 1);', '+     if (ret)', '+         return ret;', '+     ret = build_vlc(&c->ac_vlc[1], avpriv_mjpeg_bits_ac_chrominance,', '+                     avpriv_mjpeg_val_ac_chrominance, 251, 1);', '+     if (ret)', '+         return ret;', '+ ', '+     ff_dsputil_init(&c->dsp, avctx);', '+     ff_init_scantable(c->dsp.idct_permutation, &c->scantable,', '+                       ff_zigzag_direct);', '+ ', '+     return 0;', '+ }', '+ ', '+ static av_cold void jpg_free_context(jpgcontext *ctx)', '+ {', '+     int i;', '+ ', '+     for (i = 0; i < 2; i++) {', '+         ff_free_vlc(&ctx->dc_vlc[i]);', '+         ff_free_vlc(&ctx->ac_vlc[i]);', '+     }', '+ ', '+     av_freep(&ctx->buf);', '+ }', '+ ', '+ static void jpg_unescape(const uint8_t *src, int src_size,', '+                          uint8_t *dst, int *dst_size)', '+ {', '+     const uint8_t *src_end = src + src_size;', '+     uint8_t *dst_start = dst;', '+ ', '+     while (src < src_end) {', '+         uint8_t x = *src++;', '+ ', '+         *dst++ = x;', '+ ', '+         if (x == 0xff && !*src)', '+             src++;', '+     }', '+     *dst_size = dst - dst_start;', '+ }', '+ ', '+ static int jpg_decode_block(jpgcontext *c, getbitcontext *gb,', '+                             int plane, int16_t *block)', '+ {', '+     int dc, val, pos;', '+     const int is_chroma = !!plane;', '+     const uint8_t *qmat = is_chroma ? chroma_quant : luma_quant;', '+ ', '+     c->dsp.clear_block(block);', '+     dc = get_vlc2(gb, c->dc_vlc[is_chroma].table, 9, 3);', '+     if (dc < 0)', '+         return averror_invaliddata;', '+     if (dc)', '+         dc = get_xbits(gb, dc);', '+     dc = dc * qmat[0] + c->prev_dc[plane];', '+     block[0] = dc;', '+     c->prev_dc[plane] = dc;', '+ ', '+     pos = 0;', '+     while (pos < 63) {', '+         val = get_vlc2(gb, c->ac_vlc[is_chroma].table, 9, 3);', '+         if (val < 0)', '+             return averror_invaliddata;', '+         pos += val >> 4;', '+         val &= 0xf;', '+         if (pos > 63)', '+             return val ? averror_invaliddata : 0;', '+         if (val) {', '+             int nbits = val;', '+ ', '+             val = get_xbits(gb, nbits);', '+             val *= qmat[ff_zigzag_direct[pos]];', '+             block[c->scantable.permutated[pos]] = val;', '+         }', '+     }', '+     return 0;', '+ }', '+ ', '+ static inline void yuv2rgb(uint8_t *out, int y, int u, int v)', '+ {', '+     out[0] = av_clip_uint8(y + (             91881 * v + 32768 >> 16));', '+     out[1] = av_clip_uint8(y + (-22554 * u - 46802 * v + 32768 >> 16));', '+     out[2] = av_clip_uint8(y + (116130 * u             + 32768 >> 16));', '+ }', '+ ', '+ static int jpg_decode_data(jpgcontext *c, int width, int height,', '+                            const uint8_t *src, int src_size,', '+                            uint8_t *dst, int dst_stride,', '+                            const uint8_t *mask, int mask_stride, int num_mbs,', '+                            int swapuv)', '+ {', '+     getbitcontext gb;', '+     uint8_t *tmp;', '+     int mb_w, mb_h, mb_x, mb_y, i, j;', '+     int bx, by;', '+     int unesc_size;', '+     int ret;', '+ ', '+     tmp = av_realloc(c->buf, src_size + ff_input_buffer_padding_size);', '+     if (!tmp)', '+         return averror(enomem);', '+     c->buf = tmp;', '+     jpg_unescape(src, src_size, c->buf, &unesc_size);', '+     memset(c->buf + unesc_size, 0, ff_input_buffer_padding_size);', '+     init_get_bits(&gb, c->buf, unesc_size * 8);', '+ ', '+     width = ffalign(width, 16);', '+     mb_w  =  width        >> 4;', '+     mb_h  = (height + 15) >> 4;', '+ ', '+     if (!num_mbs)', '+         num_mbs = mb_w * mb_h;', '+ ', '+     for (i = 0; i < 3; i++)', '+         c->prev_dc[i] = 1024;', '+     bx = by = 0;', '+     for (mb_y = 0; mb_y < mb_h; mb_y++) {', '+         for (mb_x = 0; mb_x < mb_w; mb_x++) {', '+             if (mask && !mask[mb_x]) {', '+                 bx += 16;', '+                 continue;', '+             }', '+             for (j = 0; j < 2; j++) {', '+                 for (i = 0; i < 2; i++) {', '+                     if ((ret = jpg_decode_block(c, &gb, 0,', '+                                                 c->block[i + j * 2])) != 0)', '+                         return ret;', '+                     c->dsp.idct(c->block[i + j * 2]);', '+                 }', '+             }', '+             for (i = 1; i < 3; i++) {', '+                 if ((ret = jpg_decode_block(c, &gb, i, c->block[i + 3])) != 0)', '+                     return ret;', '+                 c->dsp.idct(c->block[i + 3]);', '+             }', '+ ', '+             for (j = 0; j < 16; j++) {', '+                 uint8_t *out = dst + bx * 3 + (by + j) * dst_stride;', '+                 for (i = 0; i < 16; i++) {', '+                     int y, u, v;', '+ ', '+                     y = c->block[(j >> 3) * 2 + (i >> 3)][(i & 7) + (j & 7) * 8];', '+                     u = c->block[4 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;', '+                     v = c->block[5 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;', '+                     yuv2rgb(out + i * 3, y, u, v);', '+                 }', '+             }', '+ ', '+             if (!--num_mbs)', '+                 return 0;', '+             bx += 16;', '+         }', '+         bx  = 0;', '+         by += 16;', '+         if (mask)', '+             mask += mask_stride;', '+     }', '+ ', '+     return 0;', '+ }', '+ ', '+ static void kempf_restore_buf(const uint8_t *src, int len,', '+                               uint8_t *dst, int stride,', '+                               const uint8_t *jpeg_tile, int tile_stride,', '+                               int width, int height,', '+                               const uint8_t *pal, int npal, int tidx)', '+ {', '+     getbitcontext gb;', '+     int i, j, nb, col;', '+ ', '+     init_get_bits(&gb, src, len * 8);', '+ ', '+     if (npal <= 2)       nb = 1;', '+     else if (npal <= 4)  nb = 2;', '+     else if (npal <= 16) nb = 4;', '+     else                 nb = 8;', '+ ', '+     for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {', '+         if (get_bits(&gb, 8))', '+             continue;', '+         for (i = 0; i < width; i++) {', '+             col = get_bits(&gb, nb);', '+             if (col != tidx)', '+                 memcpy(dst + i * 3, pal + col * 3, 3);', '+             else', '+                 memcpy(dst + i * 3, jpeg_tile + i * 3, 3);', '+         }', '+     }', '+ }', '+ ', '+ static int kempf_decode_tile(g2mcontext *c, int tile_x, int tile_y,', '+                              const uint8_t *src, int src_size)', '+ {', '+     int width, height;', '+     int hdr, zsize, npal, tidx = -1, ret;', '+     int i, j;', '+     const uint8_t *src_end = src + src_size;', '+     uint8_t pal[768], transp[3];', '+     ulongf dlen = (c->tile_width + 1) * c->tile_height;', '+     int sub_type;', '+     int nblocks, cblocks, bstride;', '+     int bits, bitbuf, coded;', '+     uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +', '+                    tile_y * c->tile_height * c->framebuf_stride;', '+ ', '+     if (src_size < 2)', '+         return averror_invaliddata;', '+ ', '+     width  = ffmin(c->width  - tile_x * c->tile_width,  c->tile_width);', '+     height = ffmin(c->height - tile_y * c->tile_height, c->tile_height);', '+ ', '+     hdr = *src++;', '+     sub_type = hdr >> 5;', '+     if (sub_type == 0) {', '+         int j;', '+         memcpy(transp, src, 3);', '+         src += 3;', '+         for (j = 0; j < height; j++, dst += c->framebuf_stride)', '+             for (i = 0; i < width; i++)', '+                 memcpy(dst + i * 3, transp, 3);', '+         return 0;', '+     } else if (sub_type == 1) {', '+         return jpg_decode_data(&c->jc, width, height, src, src_end - src,', '+                                dst, c->framebuf_stride, null, 0, 0, 0);', '+     }', '+ ', '+     if (sub_type != 2) {', '+         memcpy(transp, src, 3);', '+         src += 3;', '+     }', '+     npal = *src++ + 1;', '+     memcpy(pal, src, npal * 3); src += npal * 3;', '+     if (sub_type != 2) {', '+         for (i = 0; i < npal; i++) {', '+             if (!memcmp(pal + i * 3, transp, 3)) {', '+                tidx = i;', '+                break;', '+             }', '+         }', '+     }', '+ ', '+     if (src_end - src < 2)', '+         return 0;', '+     zsize = (src[0] << 8) | src[1]; src += 2;', '+ ', '+     if (src_end - src < zsize)', '+         return averror_invaliddata;', '+ ', '+     ret = uncompress(c->kempf_buf, &dlen, src, zsize);', '+     if (ret)', '+         return averror_invaliddata;', '+     src += zsize;', '+ ', '+     if (sub_type == 2) {', '+         kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,', '+                           null, 0, width, height, pal, npal, tidx);', '+         return 0;', '+     }', '+ ', '+     nblocks = *src++ + 1;', '+     cblocks = 0;', '+     bstride = ffalign(width, 16) >> 4;', '+     bits = 0;', '+     for (i = 0; i < (ffalign(height, 16) >> 4); i++) {', '+         for (j = 0; j < (ffalign(width, 16) >> 4); j++) {', '+             if (!bits) {', '+                 bitbuf = *src++;', '+                 bits   = 8;', '+             }', '+             coded = bitbuf & 1;', '+             bits--;', '+             bitbuf >>= 1;', '+             cblocks += coded;', '+             if (cblocks > nblocks)', '+                 return averror_invaliddata;', '+             c->kempf_flags[j + i * bstride] = coded;', '+         }', '+     }', '+ ', '+     memset(c->jpeg_tile, 0, c->tile_stride * height);', '+     jpg_decode_data(&c->jc, width, height, src, src_end - src,', '+                     c->jpeg_tile, c->tile_stride,', '+                     c->kempf_flags, bstride, nblocks, 0);', '+ ', '+     kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,', '+                       c->jpeg_tile, c->tile_stride,', '+                       width, height, pal, npal, tidx);', '+ ', '+     return 0;', '+ }', '+ ', '+ static int g2m_init_buffers(g2mcontext *c)', '+ {', '+     int aligned_height;', '+ ', '+     if (!c->framebuf || c->old_width < c->width || c->height < c->height) {', '+         c->framebuf_stride = ffalign(c->width * 3, 16);', '+         aligned_height     = ffalign(c->height,    16);', '+         av_free(c->framebuf);', '+         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);', '+         if (!c->framebuf)', '+             return averror(enomem);', '+     }', '+     if (!c->synth_tile || !c->jpeg_tile ||', '+         c->old_tile_w < c->tile_width ||', '+         c->old_tile_h < c->tile_height) {', '+         c->tile_stride = ffalign(c->tile_width * 3, 16);', '+         aligned_height = ffalign(c->tile_height,    16);', '+         av_free(c->synth_tile);', '+         av_free(c->jpeg_tile);', '+         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);', '+         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);', '+         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height', '+                                     + ff_input_buffer_padding_size);', '+         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);', '+         if (!c->synth_tile || !c->jpeg_tile ||', '+             !c->kempf_buf || !c->kempf_flags)', '+             return averror(enomem);', '+     }', '+ ', '+     return 0;', '+ }', '+ ', '+ static int g2m_load_cursor(g2mcontext *c, getbytecontext *gb)', '+ {', '+     int i, j, k;', '+     uint8_t *dst;', '+     uint32_t bits;', '+ ', '+     c->cursor_stride = c->cursor_w * 4;', '+     c->cursor        = av_realloc(c->cursor, c->cursor_stride * c->cursor_h);', '+     if (!c->cursor)', '+         return averror(enomem);', '+ ', '+     dst = c->cursor;', '+     switch (c->cursor_fmt) {', '+         for (j = 0; j < c->cursor_h; j++) {', '+             for (i = 0; i < c->cursor_w; i += 32) {', '+                 bits = bytestream2_get_be32(gb);', '+                 for (k = 0; k < 32; k++) {', '+                     dst[0] = !!(bits & 0x80000000);', '+                     dst += 4;', '+                     bits <<= 1;', '+                 }', '+             }', '+         }', '+ ', '+         dst = c->cursor;', '+         for (j = 0; j < c->cursor_h; j++) {', '+             for (i = 0; i < c->cursor_w; i += 32) {', '+                 bits = bytestream2_get_be32(gb);', '+                 for (k = 0; k < 32; k++) {', '+                     int mask_bit = !!(bits & 0x80000000);', '+                     switch (dst[0] * 2 + mask_bit) {', '+                     case 0:', '+                         dst[0] = 0xff; dst[1] = 0x00;', '+                         dst[2] = 0x00; dst[3] = 0x00;', '+                         break;', '+                     case 1:', '+                         dst[0] = 0xff; dst[1] = 0xff;', '+                         dst[2] = 0xff; dst[3] = 0xff;', '+                         break;', '+                     default:', '+                         dst[0] = 0x00; dst[1] = 0x00;', '+                         dst[2] = 0x00; dst[3] = 0x00;', '+                     }', '+                     dst += 4;', '+                     bits <<= 1;', '+                 }', '+             }', '+         }', '+         break;', '+         bytestream2_skip(gb, c->cursor_h * (ffalign(c->cursor_w, 32) >> 3));', '+         for (j = 0; j < c->cursor_h; j++) {', '+             for (i = 0; i < c->cursor_w; i++) {', '+                 int val = bytestream2_get_be32(gb);', '+                 *dst++ = val >>  0;', '+                 *dst++ = val >>  8;', '+                 *dst++ = val >> 16;', '+                 *dst++ = val >> 24;', '+             }', '+         }', '+         break;', '+     default:', '+         return averror_patchwelcome;', '+     }', '+     return 0;', '+ }', '+ ', '+ #define apply_alpha(src, new, alpha) \\', '+     src = (src * (256 - alpha) + new * alpha) >> 8', '+ ', '+ static void g2m_paint_cursor(g2mcontext *c, uint8_t *dst, int stride)', '+ {', '+     int i, j;', '+     int x, y, w, h;', '+     const uint8_t *cursor;', '+ ', '+     if (!c->cursor)', '+         return;', '+ ', '+     x = c->cursor_x - c->cursor_hot_x;', '+     y = c->cursor_y - c->cursor_hot_y;', '+ ', '+     cursor = c->cursor;', '+     w      = c->cursor_w;', '+     h      = c->cursor_h;', '+ ', '+     if (x + w > c->width)', '+         w = c->width - x;', '+     if (y + h > c->height)', '+         h = c->height - y;', '+     if (x < 0) {', '+         w      +=  x;', '+         cursor += -x * 4;', '+     } else {', '+         dst    +=  x * 3;', '+     }', '+     if (y < 0) {', '+         h      +=  y;', '+         cursor += -y * c->cursor_stride;', '+     } else {', '+         dst    +=  y * stride;', '+     }', '+     if (w < 0 || h < 0)', '+         return;', '+ ', '+     for (j = 0; j < h; j++) {', '+         for (i = 0; i < w; i++) {', '+             uint8_t alpha = cursor[i * 4];', '+             apply_alpha(dst[i * 3 + 0], cursor[i * 4 + 1], alpha);', '+             apply_alpha(dst[i * 3 + 1], cursor[i * 4 + 2], alpha);', '+             apply_alpha(dst[i * 3 + 2], cursor[i * 4 + 3], alpha);', '+         }', '+         dst    += stride;', '+         cursor += c->cursor_stride;', '+     }', '+ }', '+ ', '+ static int g2m_decode_frame(avcodeccontext *avctx, void *data,', '+                             int *got_picture_ptr, avpacket *avpkt)', '+ {', '+     const uint8_t *buf = avpkt->data;', '+     int buf_size = avpkt->size;', '+     g2mcontext *c = avctx->priv_data;', '+     avframe *pic = data;', '+     getbytecontext bc, tbc;', '+     int magic;', '+     int got_header = 0;', '+     uint32_t chunk_size, cur_size;', '+     int chunk_type;', '+     int i;', '+     int ret;', '+ ', '+     if (buf_size < 12) {', '+         av_log(avctx, av_log_error,', '+                ""frame should have at least 12 bytes, got %d instead\\n"",', '+                buf_size);', '+         return averror_invaliddata;', '+     }', '+ ', '+     bytestream2_init(&bc, buf, buf_size);', '+ ', '+     magic = bytestream2_get_be32(&bc);', ""+     if ((magic & ~0xf) != mkbetag('g', '2', 'm', '0') ||"", '+         (magic & 0xf) < 2 || (magic & 0xf) > 4) {', '+         av_log(avctx, av_log_error, ""wrong magic %08x\\n"", magic);', '+         return averror_invaliddata;', '+     }', '+ ', '+     if ((magic & 0xf) != 4) {', '+         av_log(avctx, av_log_error, ""g2m2 and g2m3 are not yet supported\\n"");', '+         return averror(enosys);', '+     }', '+ ', '+     while (bytestream2_get_bytes_left(&bc) > 5) {', '+         chunk_size = bytestream2_get_le32(&bc) - 1;', '+         chunk_type = bytestream2_get_byte(&bc);', '+         if (chunk_size > bytestream2_get_bytes_left(&bc)) {', '+             av_log(avctx, av_log_error, ""invalid chunk size %d type %02x\\n"",', '+                    chunk_size, chunk_type);', '+             break;', '+         }', '+         switch (chunk_type) {', '+         case frame_info:', '+             c->got_header = 0;', '+             if (chunk_size < 21) {', '+                 av_log(avctx, av_log_error, ""invalid frame info size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             c->width  = bytestream2_get_be32(&bc);', '+             c->height = bytestream2_get_be32(&bc);', '+             if (c->width  < 16 || c->width  > avctx->width ||', '+                 c->height < 16 || c->height > avctx->height) {', '+                 av_log(avctx, av_log_error,', '+                        ""invalid frame dimensions %dx%d\\n"",', '+                        c->width, c->height);', '+                 c->width = c->height = 0;', '+                 bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));', '+             }', '+             if (c->width != avctx->width || c->height != avctx->height)', '+                 avcodec_set_dimensions(avctx, c->width, c->height);', '+             c->compression = bytestream2_get_be32(&bc);', '+             if (c->compression != 2 && c->compression != 3) {', '+                 av_log(avctx, av_log_error,', '+                        ""unknown compression method %d\\n"",', '+                        c->compression);', '+                 return averror_patchwelcome;', '+             }', '+             c->tile_width  = bytestream2_get_be32(&bc);', '+             c->tile_height = bytestream2_get_be32(&bc);', '+             if (!c->tile_width || !c->tile_height) {', '+                 av_log(avctx, av_log_error,', '+                        ""invalid tile dimensions %dx%d\\n"",', '+                        c->tile_width, c->tile_height);', '+                 return averror_invaliddata;', '+             }', '+             c->tiles_x = (c->width  + c->tile_width  - 1) / c->tile_width;', '+             c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height;', '+             c->bpp = bytestream2_get_byte(&bc);', '+             chunk_size -= 21;', '+             bytestream2_skip(&bc, chunk_size);', '+             if (g2m_init_buffers(c))', '+                 return averror(enomem);', '+             got_header = 1;', '+             break;', '+         case tile_data:', '+             if (!c->tiles_x || !c->tiles_y) {', '+                 av_log(avctx, av_log_warning,', '+                        ""no frame header - skipping tile\\n"");', '+                 bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));', '+                 break;', '+             }', '+             if (chunk_size < 2) {', '+                 av_log(avctx, av_log_error, ""invalid tile data size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             c->tile_x = bytestream2_get_byte(&bc);', '+             c->tile_y = bytestream2_get_byte(&bc);', '+             if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) {', '+                 av_log(avctx, av_log_error,', '+                        ""invalid tile pos %d,%d (in %dx%d grid)\\n"",', '+                        c->tile_x, c->tile_y, c->tiles_x, c->tiles_y);', '+                 break;', '+             }', '+             chunk_size -= 2;', '+             ret = 0;', '+             switch (c->compression) {', '+             case compr_epic_j_b:', '+                 av_log(avctx, av_log_error,', '+                        ""epic j-b compression is not implemented yet\\n"");', '+                 return averror(enosys);', '+             case compr_kempf_j_b:', '+                 ret = kempf_decode_tile(c, c->tile_x, c->tile_y,', '+                                         buf + bytestream2_tell(&bc),', '+                                         chunk_size);', '+                 break;', '+             }', '+             if (ret && c->framebuf)', '+                 av_log(avctx, av_log_error, ""error decoding tile %d,%d\\n"",', '+                        c->tile_x, c->tile_y);', '+             bytestream2_skip(&bc, chunk_size);', '+             break;', '+         case cursor_pos:', '+             if (chunk_size < 5) {', '+                 av_log(avctx, av_log_error, ""invalid cursor pos size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             c->cursor_x = bytestream2_get_be16(&bc);', '+             c->cursor_y = bytestream2_get_be16(&bc);', '+             bytestream2_skip(&bc, chunk_size - 4);', '+             break;', '+         case cursor_shape:', '+             if (chunk_size < 8) {', '+                 av_log(avctx, av_log_error, ""invalid cursor data size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             bytestream2_init(&tbc, buf + bytestream2_tell(&bc),', '+                              chunk_size - 4);', '+             cur_size        = bytestream2_get_be32(&tbc);', '+             c->cursor_w     = bytestream2_get_byte(&tbc);', '+             c->cursor_h     = bytestream2_get_byte(&tbc);', '+             c->cursor_hot_x = bytestream2_get_byte(&tbc);', '+             c->cursor_hot_y = bytestream2_get_byte(&tbc);', '+             c->cursor_fmt   = bytestream2_get_byte(&tbc);', '+             if (cur_size >= chunk_size ||', '+                 c->cursor_w * c->cursor_h / 4 > cur_size) {', '+                 av_log(avctx, av_log_error, ""invalid cursor data size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             g2m_load_cursor(c, &tbc);', '+             bytestream2_skip(&bc, chunk_size);', '+             break;', '+         case chunk_cc:', '+         case chunk_cd:', '+             bytestream2_skip(&bc, chunk_size);', '+             break;', '+         default:', '+             av_log(avctx, av_log_warning, ""skipping chunk type %02x\\n"",', '+                    chunk_type);', '+             bytestream2_skip(&bc, chunk_size);', '+         }', '+     }', '+     if (got_header)', '+         c->got_header = 1;', '+ ', '+     if (c->width && c->height) {', '+         if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) {', '+             av_log(avctx, av_log_error, ""get_buffer() failed\\n"");', '+             return ret;', '+         }', '+ ', '+         pic->key_frame = got_header;', '+         pic->pict_type = got_header ? av_picture_type_i : av_picture_type_p;', '+ ', '+         for (i = 0; i < avctx->height; i++)', '+             memcpy(pic->data[0] + i * pic->linesize[0],', '+                    c->framebuf  + i * c->framebuf_stride,', '+                    c->width * 3);', '+         g2m_paint_cursor(c, pic->data[0], pic->linesize[0]);', '+ ', '+         *got_picture_ptr = 1;', '+     }', '+ ', '+     return buf_size;', '+ }', '+ ', '+ static av_cold int g2m_decode_init(avcodeccontext *avctx)', '+ {', '+     g2mcontext * const c = avctx->priv_data;', '+     int ret;', '+ ', '+     if ((ret = jpg_init(avctx, &c->jc)) != 0) {', '+         av_log(avctx, av_log_error, ""cannot initialise vlcs\\n"");', '+         jpg_free_context(&c->jc);', '+         return averror(enomem);', '+     }', '+ ', '+     avctx->pix_fmt     = pix_fmt_rgb24;', '+ ', '+     return 0;', '+ }', '+ ', '+ static av_cold int g2m_decode_end(avcodeccontext *avctx)', '+ {', '+     g2mcontext * const c = avctx->priv_data;', '+ ', '+     jpg_free_context(&c->jc);', '+ ', '+     av_freep(&c->kempf_buf);', '+     av_freep(&c->kempf_flags);', '+     av_freep(&c->synth_tile);', '+     av_freep(&c->jpeg_tile);', '+     av_freep(&c->cursor);', '+     av_freep(&c->framebuf);', '+ ', '+     return 0;', '+ }', '+ ', '+ avcodec ff_g2m_decoder = {', '+     .name           = ""g2m"",', '+     .long_name      = null_if_config_small(""go2meeting""),', '+     .type           = avmedia_type_video,', '+     .id             = av_codec_id_g2m,', '+     .priv_data_size = sizeof(g2mcontext),', '+     .init           = g2m_decode_init,', '+     .close          = g2m_decode_end,', '+     .decode         = g2m_decode_frame,', '+     .capabilities   = codec_cap_dr1,', '+ };']]","[['+ ', '+ ', '+ #include <zlib.h>', '+ ', '+ #include ""libavutil/intreadwrite.h""', '+ #include ""avcodec.h""', '+ #include ""bytestream.h""', '+ #include ""dsputil.h""', '+ #include ""get_bits.h""', '+ #include ""internal.h""', '+ #include ""mjpeg.h""', '+ ', '+ enum ChunkType {', '+     FRAME_INFO = 0xC8,', '+     TILE_DATA,', '+     CURSOR_POS,', '+     CURSOR_SHAPE,', '+     CHUNK_CC,', '+     CHUNK_CD', '+ };', '+ ', '+ enum Compression {', '+     COMPR_EPIC_J_B = 2,', '+     COMPR_KEMPF_J_B,', '+ };', '+ ', '+ static const uint8_t luma_quant[64] = {', '+      8,  6,  5,  8, 12, 20, 26, 31,', '+      6,  6,  7, 10, 13, 29, 30, 28,', '+      7,  7,  8, 12, 20, 29, 35, 28,', '+      7,  9, 11, 15, 26, 44, 40, 31,', '+      9, 11, 19, 28, 34, 55, 52, 39,', '+     12, 18, 28, 32, 41, 52, 57, 46,', '+     25, 32, 39, 44, 52, 61, 60, 51,', '+     36, 46, 48, 49, 56, 50, 52, 50', '+ };', '+ ', '+ static const uint8_t chroma_quant[64] = {', '+      9,  9, 12, 24, 50, 50, 50, 50,', '+      9, 11, 13, 33, 50, 50, 50, 50,', '+     12, 13, 28, 50, 50, 50, 50, 50,', '+     24, 33, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+     50, 50, 50, 50, 50, 50, 50, 50,', '+ };', '+ ', '+ typedef struct JPGContext {', '+     DSPContext dsp;', '+     ScanTable  scantable;', '+ ', '+     VLC        dc_vlc[2], ac_vlc[2];', '+     int        prev_dc[3];', '+     DECLARE_ALIGNED(16, int16_t, block)[6][64];', '+ ', '+     uint8_t    *buf;', '+ } JPGContext;', '+ ', '+ typedef struct G2MContext {', '+     JPGContext jc;', '+     int        version;', '+ ', '+     int        compression;', '+     int        width, height, bpp;', '+     int        tile_width, tile_height;', '+     int        tiles_x, tiles_y, tile_x, tile_y;', '+ ', '+     int        got_header;', '+ ', '+     uint8_t    *framebuf;', '+     int        framebuf_stride, old_width, old_height;', '+ ', '+     uint8_t    *synth_tile, *jpeg_tile;', '+     int        tile_stride, old_tile_w, old_tile_h;', '+ ', '+     uint8_t    *kempf_buf, *kempf_flags;', '+ ', '+     uint8_t    *cursor;', '+     int        cursor_stride;', '+     int        cursor_fmt;', '+     int        cursor_w, cursor_h, cursor_x, cursor_y;', '+     int        cursor_hot_x, cursor_hot_y;', '+ } G2MContext;', '+ ', '+ static av_cold int build_vlc(VLC *vlc, const uint8_t *bits_table,', '+                              const uint8_t *val_table, int nb_codes,', '+                              int is_ac)', '+ {', '+     uint8_t  huff_size[256] = { 0 };', '+     uint16_t huff_code[256];', '+     uint16_t huff_sym[256];', '+     int i;', '+ ', '+     ff_mjpeg_build_huffman_codes(huff_size, huff_code, bits_table, val_table);', '+ ', '+     for (i = 0; i < 256; i++)', '+         huff_sym[i] = i + 16 * is_ac;', '+ ', '+     if (is_ac)', '+         huff_sym[0] = 16 * 256;', '+ ', '+     return ff_init_vlc_sparse(vlc, 9, nb_codes, huff_size, 1, 1,', '+                               huff_code, 2, 2, huff_sym, 2, 2, 0);', '+ }', '+ ', '+ static av_cold int jpg_init(AVCodecContext *avctx, JPGContext *c)', '+ {', '+     int ret;', '+ ', '+     ret = build_vlc(&c->dc_vlc[0], avpriv_mjpeg_bits_dc_luminance,', '+                     avpriv_mjpeg_val_dc, 12, 0);', '+     if (ret)', '+         return ret;', '+     ret = build_vlc(&c->dc_vlc[1], avpriv_mjpeg_bits_dc_chrominance,', '+                     avpriv_mjpeg_val_dc, 12, 0);', '+     if (ret)', '+         return ret;', '+     ret = build_vlc(&c->ac_vlc[0], avpriv_mjpeg_bits_ac_luminance,', '+                     avpriv_mjpeg_val_ac_luminance, 251, 1);', '+     if (ret)', '+         return ret;', '+     ret = build_vlc(&c->ac_vlc[1], avpriv_mjpeg_bits_ac_chrominance,', '+                     avpriv_mjpeg_val_ac_chrominance, 251, 1);', '+     if (ret)', '+         return ret;', '+ ', '+     ff_dsputil_init(&c->dsp, avctx);', '+     ff_init_scantable(c->dsp.idct_permutation, &c->scantable,', '+                       ff_zigzag_direct);', '+ ', '+     return 0;', '+ }', '+ ', '+ static av_cold void jpg_free_context(JPGContext *ctx)', '+ {', '+     int i;', '+ ', '+     for (i = 0; i < 2; i++) {', '+         ff_free_vlc(&ctx->dc_vlc[i]);', '+         ff_free_vlc(&ctx->ac_vlc[i]);', '+     }', '+ ', '+     av_freep(&ctx->buf);', '+ }', '+ ', '+ static void jpg_unescape(const uint8_t *src, int src_size,', '+                          uint8_t *dst, int *dst_size)', '+ {', '+     const uint8_t *src_end = src + src_size;', '+     uint8_t *dst_start = dst;', '+ ', '+     while (src < src_end) {', '+         uint8_t x = *src++;', '+ ', '+         *dst++ = x;', '+ ', '+         if (x == 0xFF && !*src)', '+             src++;', '+     }', '+     *dst_size = dst - dst_start;', '+ }', '+ ', '+ static int jpg_decode_block(JPGContext *c, GetBitContext *gb,', '+                             int plane, int16_t *block)', '+ {', '+     int dc, val, pos;', '+     const int is_chroma = !!plane;', '+     const uint8_t *qmat = is_chroma ? chroma_quant : luma_quant;', '+ ', '+     c->dsp.clear_block(block);', '+     dc = get_vlc2(gb, c->dc_vlc[is_chroma].table, 9, 3);', '+     if (dc < 0)', '+         return AVERROR_INVALIDDATA;', '+     if (dc)', '+         dc = get_xbits(gb, dc);', '+     dc = dc * qmat[0] + c->prev_dc[plane];', '+     block[0] = dc;', '+     c->prev_dc[plane] = dc;', '+ ', '+     pos = 0;', '+     while (pos < 63) {', '+         val = get_vlc2(gb, c->ac_vlc[is_chroma].table, 9, 3);', '+         if (val < 0)', '+             return AVERROR_INVALIDDATA;', '+         pos += val >> 4;', '+         val &= 0xF;', '+         if (pos > 63)', '+             return val ? AVERROR_INVALIDDATA : 0;', '+         if (val) {', '+             int nbits = val;', '+ ', '+             val = get_xbits(gb, nbits);', '+             val *= qmat[ff_zigzag_direct[pos]];', '+             block[c->scantable.permutated[pos]] = val;', '+         }', '+     }', '+     return 0;', '+ }', '+ ', '+ static inline void yuv2rgb(uint8_t *out, int Y, int U, int V)', '+ {', '+     out[0] = av_clip_uint8(Y + (             91881 * V + 32768 >> 16));', '+     out[1] = av_clip_uint8(Y + (-22554 * U - 46802 * V + 32768 >> 16));', '+     out[2] = av_clip_uint8(Y + (116130 * U             + 32768 >> 16));', '+ }', '+ ', '+ static int jpg_decode_data(JPGContext *c, int width, int height,', '+                            const uint8_t *src, int src_size,', '+                            uint8_t *dst, int dst_stride,', '+                            const uint8_t *mask, int mask_stride, int num_mbs,', '+                            int swapuv)', '+ {', '+     GetBitContext gb;', '+     uint8_t *tmp;', '+     int mb_w, mb_h, mb_x, mb_y, i, j;', '+     int bx, by;', '+     int unesc_size;', '+     int ret;', '+ ', '+     tmp = av_realloc(c->buf, src_size + FF_INPUT_BUFFER_PADDING_SIZE);', '+     if (!tmp)', '+         return AVERROR(ENOMEM);', '+     c->buf = tmp;', '+     jpg_unescape(src, src_size, c->buf, &unesc_size);', '+     memset(c->buf + unesc_size, 0, FF_INPUT_BUFFER_PADDING_SIZE);', '+     init_get_bits(&gb, c->buf, unesc_size * 8);', '+ ', '+     width = FFALIGN(width, 16);', '+     mb_w  =  width        >> 4;', '+     mb_h  = (height + 15) >> 4;', '+ ', '+     if (!num_mbs)', '+         num_mbs = mb_w * mb_h;', '+ ', '+     for (i = 0; i < 3; i++)', '+         c->prev_dc[i] = 1024;', '+     bx = by = 0;', '+     for (mb_y = 0; mb_y < mb_h; mb_y++) {', '+         for (mb_x = 0; mb_x < mb_w; mb_x++) {', '+             if (mask && !mask[mb_x]) {', '+                 bx += 16;', '+                 continue;', '+             }', '+             for (j = 0; j < 2; j++) {', '+                 for (i = 0; i < 2; i++) {', '+                     if ((ret = jpg_decode_block(c, &gb, 0,', '+                                                 c->block[i + j * 2])) != 0)', '+                         return ret;', '+                     c->dsp.idct(c->block[i + j * 2]);', '+                 }', '+             }', '+             for (i = 1; i < 3; i++) {', '+                 if ((ret = jpg_decode_block(c, &gb, i, c->block[i + 3])) != 0)', '+                     return ret;', '+                 c->dsp.idct(c->block[i + 3]);', '+             }', '+ ', '+             for (j = 0; j < 16; j++) {', '+                 uint8_t *out = dst + bx * 3 + (by + j) * dst_stride;', '+                 for (i = 0; i < 16; i++) {', '+                     int Y, U, V;', '+ ', '+                     Y = c->block[(j >> 3) * 2 + (i >> 3)][(i & 7) + (j & 7) * 8];', '+                     U = c->block[4 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;', '+                     V = c->block[5 ^ swapuv][(i >> 1) + (j >> 1) * 8] - 128;', '+                     yuv2rgb(out + i * 3, Y, U, V);', '+                 }', '+             }', '+ ', '+             if (!--num_mbs)', '+                 return 0;', '+             bx += 16;', '+         }', '+         bx  = 0;', '+         by += 16;', '+         if (mask)', '+             mask += mask_stride;', '+     }', '+ ', '+     return 0;', '+ }', '+ ', '+ static void kempf_restore_buf(const uint8_t *src, int len,', '+                               uint8_t *dst, int stride,', '+                               const uint8_t *jpeg_tile, int tile_stride,', '+                               int width, int height,', '+                               const uint8_t *pal, int npal, int tidx)', '+ {', '+     GetBitContext gb;', '+     int i, j, nb, col;', '+ ', '+     init_get_bits(&gb, src, len * 8);', '+ ', '+     if (npal <= 2)       nb = 1;', '+     else if (npal <= 4)  nb = 2;', '+     else if (npal <= 16) nb = 4;', '+     else                 nb = 8;', '+ ', '+     for (j = 0; j < height; j++, dst += stride, jpeg_tile += tile_stride) {', '+         if (get_bits(&gb, 8))', '+             continue;', '+         for (i = 0; i < width; i++) {', '+             col = get_bits(&gb, nb);', '+             if (col != tidx)', '+                 memcpy(dst + i * 3, pal + col * 3, 3);', '+             else', '+                 memcpy(dst + i * 3, jpeg_tile + i * 3, 3);', '+         }', '+     }', '+ }', '+ ', '+ static int kempf_decode_tile(G2MContext *c, int tile_x, int tile_y,', '+                              const uint8_t *src, int src_size)', '+ {', '+     int width, height;', '+     int hdr, zsize, npal, tidx = -1, ret;', '+     int i, j;', '+     const uint8_t *src_end = src + src_size;', '+     uint8_t pal[768], transp[3];', '+     uLongf dlen = (c->tile_width + 1) * c->tile_height;', '+     int sub_type;', '+     int nblocks, cblocks, bstride;', '+     int bits, bitbuf, coded;', '+     uint8_t *dst = c->framebuf + tile_x * c->tile_width * 3 +', '+                    tile_y * c->tile_height * c->framebuf_stride;', '+ ', '+     if (src_size < 2)', '+         return AVERROR_INVALIDDATA;', '+ ', '+     width  = FFMIN(c->width  - tile_x * c->tile_width,  c->tile_width);', '+     height = FFMIN(c->height - tile_y * c->tile_height, c->tile_height);', '+ ', '+     hdr = *src++;', '+     sub_type = hdr >> 5;', '+     if (sub_type == 0) {', '+         int j;', '+         memcpy(transp, src, 3);', '+         src += 3;', '+         for (j = 0; j < height; j++, dst += c->framebuf_stride)', '+             for (i = 0; i < width; i++)', '+                 memcpy(dst + i * 3, transp, 3);', '+         return 0;', '+     } else if (sub_type == 1) {', '+         return jpg_decode_data(&c->jc, width, height, src, src_end - src,', '+                                dst, c->framebuf_stride, NULL, 0, 0, 0);', '+     }', '+ ', '+     if (sub_type != 2) {', '+         memcpy(transp, src, 3);', '+         src += 3;', '+     }', '+     npal = *src++ + 1;', '+     memcpy(pal, src, npal * 3); src += npal * 3;', '+     if (sub_type != 2) {', '+         for (i = 0; i < npal; i++) {', '+             if (!memcmp(pal + i * 3, transp, 3)) {', '+                tidx = i;', '+                break;', '+             }', '+         }', '+     }', '+ ', '+     if (src_end - src < 2)', '+         return 0;', '+     zsize = (src[0] << 8) | src[1]; src += 2;', '+ ', '+     if (src_end - src < zsize)', '+         return AVERROR_INVALIDDATA;', '+ ', '+     ret = uncompress(c->kempf_buf, &dlen, src, zsize);', '+     if (ret)', '+         return AVERROR_INVALIDDATA;', '+     src += zsize;', '+ ', '+     if (sub_type == 2) {', '+         kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,', '+                           NULL, 0, width, height, pal, npal, tidx);', '+         return 0;', '+     }', '+ ', '+     nblocks = *src++ + 1;', '+     cblocks = 0;', '+     bstride = FFALIGN(width, 16) >> 4;', '+     bits = 0;', '+     for (i = 0; i < (FFALIGN(height, 16) >> 4); i++) {', '+         for (j = 0; j < (FFALIGN(width, 16) >> 4); j++) {', '+             if (!bits) {', '+                 bitbuf = *src++;', '+                 bits   = 8;', '+             }', '+             coded = bitbuf & 1;', '+             bits--;', '+             bitbuf >>= 1;', '+             cblocks += coded;', '+             if (cblocks > nblocks)', '+                 return AVERROR_INVALIDDATA;', '+             c->kempf_flags[j + i * bstride] = coded;', '+         }', '+     }', '+ ', '+     memset(c->jpeg_tile, 0, c->tile_stride * height);', '+     jpg_decode_data(&c->jc, width, height, src, src_end - src,', '+                     c->jpeg_tile, c->tile_stride,', '+                     c->kempf_flags, bstride, nblocks, 0);', '+ ', '+     kempf_restore_buf(c->kempf_buf, dlen, dst, c->framebuf_stride,', '+                       c->jpeg_tile, c->tile_stride,', '+                       width, height, pal, npal, tidx);', '+ ', '+     return 0;', '+ }', '+ ', '+ static int g2m_init_buffers(G2MContext *c)', '+ {', '+     int aligned_height;', '+ ', '+     if (!c->framebuf || c->old_width < c->width || c->height < c->height) {', '+         c->framebuf_stride = FFALIGN(c->width * 3, 16);', '+         aligned_height     = FFALIGN(c->height,    16);', '+         av_free(c->framebuf);', '+         c->framebuf = av_mallocz(c->framebuf_stride * aligned_height);', '+         if (!c->framebuf)', '+             return AVERROR(ENOMEM);', '+     }', '+     if (!c->synth_tile || !c->jpeg_tile ||', '+         c->old_tile_w < c->tile_width ||', '+         c->old_tile_h < c->tile_height) {', '+         c->tile_stride = FFALIGN(c->tile_width * 3, 16);', '+         aligned_height = FFALIGN(c->tile_height,    16);', '+         av_free(c->synth_tile);', '+         av_free(c->jpeg_tile);', '+         c->synth_tile  = av_mallocz(c->tile_stride      * aligned_height);', '+         c->jpeg_tile   = av_mallocz(c->tile_stride      * aligned_height);', '+         c->kempf_buf   = av_mallocz((c->tile_width + 1) * aligned_height', '+                                     + FF_INPUT_BUFFER_PADDING_SIZE);', '+         c->kempf_flags = av_mallocz( c->tile_width      * aligned_height);', '+         if (!c->synth_tile || !c->jpeg_tile ||', '+             !c->kempf_buf || !c->kempf_flags)', '+             return AVERROR(ENOMEM);', '+     }', '+ ', '+     return 0;', '+ }', '+ ', '+ static int g2m_load_cursor(G2MContext *c, GetByteContext *gb)', '+ {', '+     int i, j, k;', '+     uint8_t *dst;', '+     uint32_t bits;', '+ ', '+     c->cursor_stride = c->cursor_w * 4;', '+     c->cursor        = av_realloc(c->cursor, c->cursor_stride * c->cursor_h);', '+     if (!c->cursor)', '+         return AVERROR(ENOMEM);', '+ ', '+     dst = c->cursor;', '+     switch (c->cursor_fmt) {', '+         for (j = 0; j < c->cursor_h; j++) {', '+             for (i = 0; i < c->cursor_w; i += 32) {', '+                 bits = bytestream2_get_be32(gb);', '+                 for (k = 0; k < 32; k++) {', '+                     dst[0] = !!(bits & 0x80000000);', '+                     dst += 4;', '+                     bits <<= 1;', '+                 }', '+             }', '+         }', '+ ', '+         dst = c->cursor;', '+         for (j = 0; j < c->cursor_h; j++) {', '+             for (i = 0; i < c->cursor_w; i += 32) {', '+                 bits = bytestream2_get_be32(gb);', '+                 for (k = 0; k < 32; k++) {', '+                     int mask_bit = !!(bits & 0x80000000);', '+                     switch (dst[0] * 2 + mask_bit) {', '+                     case 0:', '+                         dst[0] = 0xFF; dst[1] = 0x00;', '+                         dst[2] = 0x00; dst[3] = 0x00;', '+                         break;', '+                     case 1:', '+                         dst[0] = 0xFF; dst[1] = 0xFF;', '+                         dst[2] = 0xFF; dst[3] = 0xFF;', '+                         break;', '+                     default:', '+                         dst[0] = 0x00; dst[1] = 0x00;', '+                         dst[2] = 0x00; dst[3] = 0x00;', '+                     }', '+                     dst += 4;', '+                     bits <<= 1;', '+                 }', '+             }', '+         }', '+         break;', '+         bytestream2_skip(gb, c->cursor_h * (FFALIGN(c->cursor_w, 32) >> 3));', '+         for (j = 0; j < c->cursor_h; j++) {', '+             for (i = 0; i < c->cursor_w; i++) {', '+                 int val = bytestream2_get_be32(gb);', '+                 *dst++ = val >>  0;', '+                 *dst++ = val >>  8;', '+                 *dst++ = val >> 16;', '+                 *dst++ = val >> 24;', '+             }', '+         }', '+         break;', '+     default:', '+         return AVERROR_PATCHWELCOME;', '+     }', '+     return 0;', '+ }', '+ ', '+ #define APPLY_ALPHA(src, new, alpha) \\', '+     src = (src * (256 - alpha) + new * alpha) >> 8', '+ ', '+ static void g2m_paint_cursor(G2MContext *c, uint8_t *dst, int stride)', '+ {', '+     int i, j;', '+     int x, y, w, h;', '+     const uint8_t *cursor;', '+ ', '+     if (!c->cursor)', '+         return;', '+ ', '+     x = c->cursor_x - c->cursor_hot_x;', '+     y = c->cursor_y - c->cursor_hot_y;', '+ ', '+     cursor = c->cursor;', '+     w      = c->cursor_w;', '+     h      = c->cursor_h;', '+ ', '+     if (x + w > c->width)', '+         w = c->width - x;', '+     if (y + h > c->height)', '+         h = c->height - y;', '+     if (x < 0) {', '+         w      +=  x;', '+         cursor += -x * 4;', '+     } else {', '+         dst    +=  x * 3;', '+     }', '+     if (y < 0) {', '+         h      +=  y;', '+         cursor += -y * c->cursor_stride;', '+     } else {', '+         dst    +=  y * stride;', '+     }', '+     if (w < 0 || h < 0)', '+         return;', '+ ', '+     for (j = 0; j < h; j++) {', '+         for (i = 0; i < w; i++) {', '+             uint8_t alpha = cursor[i * 4];', '+             APPLY_ALPHA(dst[i * 3 + 0], cursor[i * 4 + 1], alpha);', '+             APPLY_ALPHA(dst[i * 3 + 1], cursor[i * 4 + 2], alpha);', '+             APPLY_ALPHA(dst[i * 3 + 2], cursor[i * 4 + 3], alpha);', '+         }', '+         dst    += stride;', '+         cursor += c->cursor_stride;', '+     }', '+ }', '+ ', '+ static int g2m_decode_frame(AVCodecContext *avctx, void *data,', '+                             int *got_picture_ptr, AVPacket *avpkt)', '+ {', '+     const uint8_t *buf = avpkt->data;', '+     int buf_size = avpkt->size;', '+     G2MContext *c = avctx->priv_data;', '+     AVFrame *pic = data;', '+     GetByteContext bc, tbc;', '+     int magic;', '+     int got_header = 0;', '+     uint32_t chunk_size, cur_size;', '+     int chunk_type;', '+     int i;', '+     int ret;', '+ ', '+     if (buf_size < 12) {', '+         av_log(avctx, AV_LOG_ERROR,', '+                ""Frame should have at least 12 bytes, got %d instead\\n"",', '+                buf_size);', '+         return AVERROR_INVALIDDATA;', '+     }', '+ ', '+     bytestream2_init(&bc, buf, buf_size);', '+ ', '+     magic = bytestream2_get_be32(&bc);', ""+     if ((magic & ~0xF) != MKBETAG('G', '2', 'M', '0') ||"", '+         (magic & 0xF) < 2 || (magic & 0xF) > 4) {', '+         av_log(avctx, AV_LOG_ERROR, ""Wrong magic %08X\\n"", magic);', '+         return AVERROR_INVALIDDATA;', '+     }', '+ ', '+     if ((magic & 0xF) != 4) {', '+         av_log(avctx, AV_LOG_ERROR, ""G2M2 and G2M3 are not yet supported\\n"");', '+         return AVERROR(ENOSYS);', '+     }', '+ ', '+     while (bytestream2_get_bytes_left(&bc) > 5) {', '+         chunk_size = bytestream2_get_le32(&bc) - 1;', '+         chunk_type = bytestream2_get_byte(&bc);', '+         if (chunk_size > bytestream2_get_bytes_left(&bc)) {', '+             av_log(avctx, AV_LOG_ERROR, ""Invalid chunk size %d type %02X\\n"",', '+                    chunk_size, chunk_type);', '+             break;', '+         }', '+         switch (chunk_type) {', '+         case FRAME_INFO:', '+             c->got_header = 0;', '+             if (chunk_size < 21) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid frame info size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             c->width  = bytestream2_get_be32(&bc);', '+             c->height = bytestream2_get_be32(&bc);', '+             if (c->width  < 16 || c->width  > avctx->width ||', '+                 c->height < 16 || c->height > avctx->height) {', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""Invalid frame dimensions %dx%d\\n"",', '+                        c->width, c->height);', '+                 c->width = c->height = 0;', '+                 bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));', '+             }', '+             if (c->width != avctx->width || c->height != avctx->height)', '+                 avcodec_set_dimensions(avctx, c->width, c->height);', '+             c->compression = bytestream2_get_be32(&bc);', '+             if (c->compression != 2 && c->compression != 3) {', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""Unknown compression method %d\\n"",', '+                        c->compression);', '+                 return AVERROR_PATCHWELCOME;', '+             }', '+             c->tile_width  = bytestream2_get_be32(&bc);', '+             c->tile_height = bytestream2_get_be32(&bc);', '+             if (!c->tile_width || !c->tile_height) {', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""Invalid tile dimensions %dx%d\\n"",', '+                        c->tile_width, c->tile_height);', '+                 return AVERROR_INVALIDDATA;', '+             }', '+             c->tiles_x = (c->width  + c->tile_width  - 1) / c->tile_width;', '+             c->tiles_y = (c->height + c->tile_height - 1) / c->tile_height;', '+             c->bpp = bytestream2_get_byte(&bc);', '+             chunk_size -= 21;', '+             bytestream2_skip(&bc, chunk_size);', '+             if (g2m_init_buffers(c))', '+                 return AVERROR(ENOMEM);', '+             got_header = 1;', '+             break;', '+         case TILE_DATA:', '+             if (!c->tiles_x || !c->tiles_y) {', '+                 av_log(avctx, AV_LOG_WARNING,', '+                        ""No frame header - skipping tile\\n"");', '+                 bytestream2_skip(&bc, bytestream2_get_bytes_left(&bc));', '+                 break;', '+             }', '+             if (chunk_size < 2) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid tile data size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             c->tile_x = bytestream2_get_byte(&bc);', '+             c->tile_y = bytestream2_get_byte(&bc);', '+             if (c->tile_x >= c->tiles_x || c->tile_y >= c->tiles_y) {', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""Invalid tile pos %d,%d (in %dx%d grid)\\n"",', '+                        c->tile_x, c->tile_y, c->tiles_x, c->tiles_y);', '+                 break;', '+             }', '+             chunk_size -= 2;', '+             ret = 0;', '+             switch (c->compression) {', '+             case COMPR_EPIC_J_B:', '+                 av_log(avctx, AV_LOG_ERROR,', '+                        ""ePIC j-b compression is not implemented yet\\n"");', '+                 return AVERROR(ENOSYS);', '+             case COMPR_KEMPF_J_B:', '+                 ret = kempf_decode_tile(c, c->tile_x, c->tile_y,', '+                                         buf + bytestream2_tell(&bc),', '+                                         chunk_size);', '+                 break;', '+             }', '+             if (ret && c->framebuf)', '+                 av_log(avctx, AV_LOG_ERROR, ""Error decoding tile %d,%d\\n"",', '+                        c->tile_x, c->tile_y);', '+             bytestream2_skip(&bc, chunk_size);', '+             break;', '+         case CURSOR_POS:', '+             if (chunk_size < 5) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid cursor pos size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             c->cursor_x = bytestream2_get_be16(&bc);', '+             c->cursor_y = bytestream2_get_be16(&bc);', '+             bytestream2_skip(&bc, chunk_size - 4);', '+             break;', '+         case CURSOR_SHAPE:', '+             if (chunk_size < 8) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             bytestream2_init(&tbc, buf + bytestream2_tell(&bc),', '+                              chunk_size - 4);', '+             cur_size        = bytestream2_get_be32(&tbc);', '+             c->cursor_w     = bytestream2_get_byte(&tbc);', '+             c->cursor_h     = bytestream2_get_byte(&tbc);', '+             c->cursor_hot_x = bytestream2_get_byte(&tbc);', '+             c->cursor_hot_y = bytestream2_get_byte(&tbc);', '+             c->cursor_fmt   = bytestream2_get_byte(&tbc);', '+             if (cur_size >= chunk_size ||', '+                 c->cursor_w * c->cursor_h / 4 > cur_size) {', '+                 av_log(avctx, AV_LOG_ERROR, ""Invalid cursor data size %d\\n"",', '+                        chunk_size);', '+                 break;', '+             }', '+             g2m_load_cursor(c, &tbc);', '+             bytestream2_skip(&bc, chunk_size);', '+             break;', '+         case CHUNK_CC:', '+         case CHUNK_CD:', '+             bytestream2_skip(&bc, chunk_size);', '+             break;', '+         default:', '+             av_log(avctx, AV_LOG_WARNING, ""Skipping chunk type %02X\\n"",', '+                    chunk_type);', '+             bytestream2_skip(&bc, chunk_size);', '+         }', '+     }', '+     if (got_header)', '+         c->got_header = 1;', '+ ', '+     if (c->width && c->height) {', '+         if ((ret = ff_get_buffer(avctx, pic, 0)) < 0) {', '+             av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\\n"");', '+             return ret;', '+         }', '+ ', '+         pic->key_frame = got_header;', '+         pic->pict_type = got_header ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;', '+ ', '+         for (i = 0; i < avctx->height; i++)', '+             memcpy(pic->data[0] + i * pic->linesize[0],', '+                    c->framebuf  + i * c->framebuf_stride,', '+                    c->width * 3);', '+         g2m_paint_cursor(c, pic->data[0], pic->linesize[0]);', '+ ', '+         *got_picture_ptr = 1;', '+     }', '+ ', '+     return buf_size;', '+ }', '+ ', '+ static av_cold int g2m_decode_init(AVCodecContext *avctx)', '+ {', '+     G2MContext * const c = avctx->priv_data;', '+     int ret;', '+ ', '+     if ((ret = jpg_init(avctx, &c->jc)) != 0) {', '+         av_log(avctx, AV_LOG_ERROR, ""Cannot initialise VLCs\\n"");', '+         jpg_free_context(&c->jc);', '+         return AVERROR(ENOMEM);', '+     }', '+ ', '+     avctx->pix_fmt     = PIX_FMT_RGB24;', '+ ', '+     return 0;', '+ }', '+ ', '+ static av_cold int g2m_decode_end(AVCodecContext *avctx)', '+ {', '+     G2MContext * const c = avctx->priv_data;', '+ ', '+     jpg_free_context(&c->jc);', '+ ', '+     av_freep(&c->kempf_buf);', '+     av_freep(&c->kempf_flags);', '+     av_freep(&c->synth_tile);', '+     av_freep(&c->jpeg_tile);', '+     av_freep(&c->cursor);', '+     av_freep(&c->framebuf);', '+ ', '+     return 0;', '+ }', '+ ', '+ AVCodec ff_g2m_decoder = {', '+     .name           = ""g2m"",', '+     .long_name      = NULL_IF_CONFIG_SMALL(""Go2Meeting""),', '+     .type           = AVMEDIA_TYPE_VIDEO,', '+     .id             = AV_CODEC_ID_G2M,', '+     .priv_data_size = sizeof(G2MContext),', '+     .init           = g2m_decode_init,', '+     .close          = g2m_decode_end,', '+     .decode         = g2m_decode_frame,', '+     .capabilities   = CODEC_CAP_DR1,', '+ };']]",[[]],797,0.0,797.0,2d66a58ccde05e764594bd7e5f0f9244634d0b2cFFmpeg/FFmpeg,['e07ac727c1cc9eed39e7f9117c97006f719864bd']
0356ae807f03c59393e17cb6c20c7efba6d1197f,dajobe/raptor,raptor_rdfxml.c,train,C,0,"['@@ -114,6 +114,7 @@ typedef librdf_uri rapier_uri;\n #define LIBRDF_DEBUG2(function, msg, arg1) do {fprintf(stderr, ""%s:%d:%s: "" msg, __FILE__, __LINE__, #function, arg1);} while(0)\n #define LIBRDF_DEBUG3(function, msg, arg1, arg2) do {fprintf(stderr, ""%s:%d:%s: "" msg, __FILE__, __LINE__, #function, arg1, arg2);} while(0)\n #define LIBRDF_DEBUG4(function, msg, arg1, arg2, arg3) do {fprintf(stderr, ""%s:%d:%s: "" msg, __FILE__, __LINE__, #function, arg1, arg2, arg3);} while(0)\n+#define LIBRDF_DEBUG4(function, msg, arg1, arg2, arg3) do {fprintf(stderr, ""%s:%d:%s: "" msg, __FILE__, __LINE__, #function, arg1, arg2, arg3);} while(0)\n \n #else\n /* DEBUGGING TURNED OFF */\n@@ -126,6 +127,12 @@ typedef librdf_uri rapier_uri;\n \n #endif\n \n+/* Fatal errors - always happen */\n+#define LIBRDF_FATAL1(function, msg) do {fprintf(stderr, ""%s:%d:%s: fatal error: "" msg, __FILE__, __LINE__ , #function); abort();} while(0)\n+#define LIBRDF_FATAL2(function, msg,arg) do {fprintf(stderr, ""%s:%d:%s: fatal error: "" msg, __FILE__, __LINE__ , #function, arg); abort();} while(0)\n+\n+\n+\n typedef const char rapier_uri;\n \n #endif\n@@ -149,15 +156,21 @@ typedef const char rapier_uri;\n #endif\n \n #ifdef NEED_LIBXML\n+\n+#ifdef HAVE_PARSER_H\n+#include <parser.h>\n+#else\n #ifdef HAVE_GNOME_XML_PARSER_H\n #include <gnome-xml/parser.h>\n-/* translate names from expat to libxml */\n-#define XML_Char xmlChar\n #else\n-#include <parser.h>\n+DIE\n #endif\n #endif\n \n+/* translate names from expat to libxml */\n+#define XML_Char xmlChar\n+#endif\n+\n \n /* Rapier includes */\n #include <rapier.h>\n@@ -167,6 +180,8 @@ typedef const char rapier_uri;\n typedef struct rapier_ns_map_s rapier_ns_map;\n \n typedef enum {\n+  RAPIER_STATE_INVALID = 0,\n+\n   /* Not in RDF grammar yet - searching for a start element.\n    * This can be <rdf:RDF> (goto 6.1) but since it is optional,\n    * the start element can also be <Description> (goto 6.3), \n@@ -176,29 +191,27 @@ typedef enum {\n    * CHOICE: Search for <rdf:RDF> node before starting match\n    * OR assume RDF content, hence go straight to production\n    */\n-  RAPIER_STATE_UNKNOWN = 0,\n-\n-  /* Met production 6.1 (RDF) <rdf:RDF> element seen and can now\n-   * expect:\n-   *    <rdf:Description> (goto 6.3)\n-   *    <rdf:Seq> (goto 6.25) (or typedNode CHOICE)\n-   *    <rdf:Bag> (goto 6.26) (or typedNode CHOICE)\n-   *    <rdf:Alt> (goto 6.27) (or typedNode CHOICE)\n-   * OR from 6.3 can have ANY other element matching\n-   * typedNode (6.13) - goto 6.3\n-   */\n-  RAPIER_STATE_IN_RDF   = 6010,\n+  RAPIER_STATE_UNKNOWN = 1000,\n \n-  /* No need for 6.2 - already chose 6.3, 6.25, 6.26 or 6.27 */\n-  RAPIER_STATE_NOT_USED_1   = 6020,\n+  /* No need for 6.1 - go straight to 6.2 */\n+  RAPIER_STATE_NOT_USED_1   = 6010,\n+\n+  /* Met production 6.1 (RDF) <rdf:RDF> element or 6.17 (value) and expecting\n+   *   description (6.3) | container (6.4)\n+   * = description (6.3) | sequence (6.25) | bag (6.26) | alternative (6.27)\n+   */\n+  RAPIER_STATE_OBJ   = 6020,\n \n   /* Met production 6.3 (description) <rdf:Description> element\n-   * OR 6.13 (typedNode) [pretty much anything else]\n-   * CHOICE: Create a bag here (always? even if no bagId given) \n-   * CHOICES: Match rdf:resource/resource, ID/rdf:ID attributes etc.\n+   * OR 6.13 (typedNode)\n    */\n   RAPIER_STATE_DESCRIPTION = 6030,\n \n+  /* production 6.4 (container) - not used (pick one of sequence, bag,\n+   * alternative immediately in state 6.2\n+   */\n+  \n+  /* productions 6.5-6.11 are for attributes - not used */\n \n   /* met production 6.12 (propertyElt)\n    */\n@@ -209,6 +222,12 @@ typedef enum {\n   RAPIER_STATE_TYPED_NODE = 6130,\n \n \n+  /* productions 6.14-6.16 are for attributes - not used */\n+\n+  /* production 6.17 (value) - not used */\n+\n+  /* productions 6.18-6.24 are for attributes / values - not used */\n+\n \n   /* Met production 6.25 (sequence) <rdf:Seq> element seen. Goto 6.28  */\n   RAPIER_STATE_SEQ = 6250,\n@@ -230,17 +249,21 @@ typedef enum {\n    * Found a container item with reference - <rdf:li (rdf:)resource=""..""/> */\n   RAPIER_STATE_REFERENCEDITEM = 6290,\n \n-\n   /* met production 6.30 (inlineItem) part 1 - plain container item */\n   RAPIER_STATE_INLINEITEM = 6300,\n \n+\n+  /* productions 6.31-6.33 are for attributes - not used */\n+\n+\n   /* met production 6.30 (inlineItem) part 2 - container item with\n    * rdf:parseType=""literal"" */\n-  RAPIER_STATE_PARSETYPE_LITERAL = 6301,\n+  RAPIER_STATE_PARSETYPE_LITERAL = 6400,\n \n   /* met production 6.30 (inlineItem) part 3 - container item with \n    * rdf:parseType=""literal"" */\n-  RAPIER_STATE_PARSETYPE_RESOURCE = 6302,\n+  RAPIER_STATE_PARSETYPE_RESOURCE = 6410,\n+\n \n \n \n@@ -248,15 +271,52 @@ typedef enum {\n   /* Additional non-M&S states */\n \n   /* Another kind of container, not Seq, Bag or Alt */\n-  RAPIER_STATE_CONTAINER = 7000,\n+  RAPIER_STATE_CONTAINER = 6420,\n \n   /* met production 6.30 (inlineItem) - container item \n    * with other rdf:parseType value */\n-  RAPIER_STATE_PARSETYPE_OTHER = 7010,\n+  RAPIER_STATE_PARSETYPE_OTHER = 6430,\n+\n \n } rapier_state;\n \n \n+static const char * const rapier_state_names[]={\n+  NULL, /* No 6.0 */\n+  NULL, /* 6.1 not used */\n+  ""object (6.2)"",\n+  ""description (6.3)"",\n+  NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL, /* 6.4 - 6.11 not used */\n+  ""propertyElt (6.12)"",\n+  ""typed_node (6.13)"",\n+  NULL,NULL,NULL, NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL, /* 6.14 - 6.24 not used */\n+  ""sequence (6.25)"",\n+  ""bag (6.26)"",\n+  ""alternative (6.27)"",\n+  ""member (6.28)"",\n+  ""referencedItem (6.29)"",\n+  ""inlineItem (6.30 part 1)"",\n+  NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,\n+  ""parseTypeLiteral (6.30 part 2)"",\n+  ""parseTypeResource (6.30 part 3)"",\n+  ""container (not M&S)"",\n+  ""parseTypeOther (not M&S)"",\n+};\n+\n+\n+static const char * rapier_state_as_string(rapier_state state) \n+{\n+  int offset=(state - 6000)/10;\n+  if(state == RAPIER_STATE_UNKNOWN)\n+    return ""UNKNOWN"";\n+  if(offset<0 || offset > 43)\n+    return ""INVALID"";\n+  if(!rapier_state_names[offset])\n+    return ""NOT-USED"";\n+  return rapier_state_names[offset];\n+}\n+\n+\n /* Forms:\n  * 1) prefix=NULL uri=<URI>      - default namespace defined\n  * 2) prefix=NULL, uri=NULL      - no default namespace\n@@ -296,8 +356,9 @@ typedef struct {\n } rapier_ns_name;\n \n \n-/* These are only used in the RDF/XML syntax and as attributes,\n- * never as elements and are not in the RDF model\n+/* These are used in the RDF/XML syntax as attributes, not\n+ * elements and are mostly not concepts in the RDF model (except for\n+ * the type attribute which is a property too).\n  */\n typedef enum {\n   RDF_ATTR_about           = 0, /* value of rdf:about attribute */\n@@ -306,7 +367,7 @@ typedef enum {\n   RDF_ATTR_ID              = 3, /* "" rdf:ID */\n   RDF_ATTR_bagID           = 4, /* "" rdf:bagID */\n   RDF_ATTR_resource        = 5, /* "" rdf:resource */\n-  RDF_ATTR_type            = 6, /* "" rdf:type */\n+  RDF_ATTR_type            = 6, /* "" rdf:type -- IS a property in RDF Model */\n   RDF_ATTR_parseType       = 7, /* "" rdf:parseType */\n \n   RDF_ATTR_LAST            = RDF_ATTR_parseType\n@@ -340,10 +401,16 @@ typedef enum {\n typedef enum {\n   /* undetermined yet - whitespace is stored */\n   RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN,\n-  /* cdata / literal content - whitespace is significant*/\n-  RAPIER_ELEMENT_CONTENT_TYPE_CDATA,\n-  /* elements, whitespace is ignored, any non-whitespace is error */\n-  RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS,\n+  /* empty - no elements or cdata - whitespace is ignored */\n+  RAPIER_ELEMENT_CONTENT_TYPE_EMPTY,\n+  /* literal content (cdata) - whitespace is significant */\n+  RAPIER_ELEMENT_CONTENT_TYPE_LITERAL,\n+  /* properties (0+ elements) - whitespace is ignored,\n+   * any non-whitespace is error */\n+  RAPIER_ELEMENT_CONTENT_TYPE_PROPERTIES,\n+  /* resource (0 or 1 element) - whitespace is ignored,\n+   * any non-whitespace is error */\n+  RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE,\n   /* all content is preserved */\n   RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED\n } rapier_element_content_type;\n@@ -362,6 +429,8 @@ struct rapier_element_s {\n \n   rapier_state state; /* state that this production matches */\n \n+  rapier_state child_state; /* starting state for children of this element */\n+\n   /* XML elements in RDF can contain EITHER cdata OR just sub-elements\n    * Mixed content is not allowed \n    */\n@@ -408,7 +477,7 @@ struct rapier_parser_s {\n   /* structure holding sax event handlers */\n   xmlSAXHandler sax;\n   /* parser context */\n-  /* xmlParserCtxtPtr xc; */\n+  xmlParserCtxtPtr xc;\n #endif  \n \n   /* element depth */\n@@ -486,7 +555,7 @@ struct rapier_parser_s {\n #define RAPIER_RDF_type_URI LIBRDF_MS_type_URI\n #define RAPIER_RDF_Seq_URI LIBRDF_MS_Seq_URI\n #define RAPIER_RDF_Bag_URI LIBRDF_MS_Bag_URI\n-#define RAPIER_RDF_Alt_URI LIBRDF_MS_alt_URI\n+#define RAPIER_RDF_Alt_URI LIBRDF_MS_Alt_URI\n #else\n static const char * const rapier_rdf_ms_uri=RAPIER_RDF_MS_URI;\n static const char * const rapier_rdf_schema_uri=RAPIER_RDF_SCHEMA_URI;\n@@ -514,9 +583,12 @@ static void rapier_end_namespace_decl_handler(void *user_data, const XML_Char *p\n \n /* libxml-only prototypes */\n #ifdef NEED_LIBXML\n-static void rapier_xml_warning(void *context, rapier_locator *locator, const char *msg, ...);\n-static void rapier_xml_error(void *context, rapier_locator *locator, const char *msg, ...);\n-static void rapier_xml_fatal_error(void *context, rapier_locator *locator, const char *msg, ...);\n+static void rapier_xml_warning(void *context, const char *msg, ...);\n+static void rapier_xml_error(void *context, const char *msg, ...);\n+static void rapier_xml_fatal_error(void *context, const char *msg, ...);\n+static void rapier_xml_validation_error(void *context, const char *msg, ...);\n+static void rapier_xml_validation_warning(void *context, const char *msg, ...);\n+static void rapier_xml_set_document_locator (void *ctx, xmlSAXLocatorPtr loc);\n #endif\n \n \n@@ -986,7 +1058,7 @@ rapier_free_element(rapier_element *element)\n     LIBRDF_FREE(rapier_ns_name_array, element->content_cdata);\n \n   if(element->id_is_generated)\n-    LIBRDF_FREE(cstring, element->id);\n+    LIBRDF_FREE(cstring, (char*)element->id);\n \n   if(element->uri)\n     RAPIER_FREE_URI(element->uri);\n@@ -1041,6 +1113,10 @@ rapier_xml_start_element_handler(void *user_data,\n   rapier_locator *locator=&rdf_parser->locator; /* for storing error info */\n #endif\n \n+#ifdef RAPIER_DEBUG\n+  fputc(\'\\n\', stderr);\n+#endif\n+\n #ifdef NEED_EXPAT\n   locator->line=XML_GetCurrentLineNumber(rdf_parser->xp);\n   locator->column=XML_GetCurrentColumnNumber(rdf_parser->xp);\n@@ -1159,12 +1235,8 @@ rapier_xml_start_element_handler(void *user_data,\n       } /* end if RDF M&S namespaced-prefixed attributes */\n \n \n-      /* If non namespace-prefixed RDF M&S attributes found on\n-       * rdf namespace-prefixed element\n-       */\n-      if(rdf_parser->feature_allow_non_ns_attributes &&\n-         attribute && !attribute->namespace &&\n-         element_name->namespace && element_name->namespace->is_rdf_ms) {\n+      /* If non namespace-prefixed RDF M&S attributes found on an element */\n+      if(rdf_parser->feature_allow_non_ns_attributes && attribute) {\n         const char *attr_name=attribute->qname;\n         int j;\n \n@@ -1208,29 +1280,29 @@ rapier_xml_start_element_handler(void *user_data,\n \n \n   if(element->parent) {\n+    element->content_type=element->parent->content_type;\n+\n     element->parent->content_element_seen++;\n-    if(element->parent->content_type == RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN) {\n-      LIBRDF_DEBUG2(rapier_xml_start_element_handler, ""Set element %s content type to elements\\n"", element->name->qname);\n-      element->parent->content_type=RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS;\n     \n-      if(element->parent->content_element_seen == 1 &&\n-         element->parent->content_cdata_seen == 1) {\n-        /* Uh oh - mixed content, the parent element has cdata too */\n-        rapier_parser_warning(rdf_parser, ""element %s has mixed content."", \n-                              element->parent->name->qname);\n-      }\n-\n-      /* If there is some existing all-whitespace content cdata\n+    if(element->parent->content_element_seen == 1 &&\n+       element->parent->content_cdata_seen == 1) {\n+      /* Uh oh - mixed content, the parent element has cdata too */\n+      rapier_parser_warning(rdf_parser, ""element %s has mixed content."", \n+                            element->parent->name->qname);\n+    }\n+    \n+    /* If there is some existing all-whitespace content cdata\n        * (which is probably before the first element) delete it\n        */\n-      if(element->parent->content_element_seen &&\n-         element->parent->content_cdata_all_whitespace) {\n-        LIBRDF_FREE(rapier_ns_name_array, element->content_cdata);\n-        element->content_cdata=NULL;\n-        element->content_cdata_length=0;\n-      }\n+    if(element->parent->content_element_seen &&\n+       element->parent->content_cdata_all_whitespace &&\n+       element->parent->content_cdata) {\n+      LIBRDF_FREE(rapier_ns_name_array, element->parent->content_cdata);\n+      element->parent->content_cdata=NULL;\n+      element->parent->content_cdata_length=0;\n     }\n-  }\n+\n+  } /* end if element->parent */\n \n \n #ifdef RAPIER_DEBUG\n@@ -1272,7 +1344,7 @@ rapier_xml_end_element_handler(void *user_data, const XML_Char *name)\n \n \n #ifdef RAPIER_DEBUG\n-  fprintf(stderr, ""rapier_xml_end_element_handler: End ns-element: "");\n+  fprintf(stderr, ""\\nrapier_xml_end_element_handler: End ns-element: "");\n   rapier_print_ns_name(stderr, element_name);\n   fputc(\'\\n\', stderr);\n #endif\n@@ -1294,6 +1366,11 @@ rapier_xml_end_element_handler(void *user_data, const XML_Char *name)\n   rapier_free_element(element);\n \n   rdf_parser->depth--;\n+\n+#ifdef RAPIER_DEBUG\n+  fputc(\'\\n\', stderr);\n+#endif\n+\n }\n \n \n@@ -1310,7 +1387,6 @@ rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len)\n   char *buffer;\n   char *ptr;\n   int all_whitespace=1;\n-  int ignore_all_whitespace=0;\n   int i;\n \n   for(i=0; i<len; i++)\n@@ -1324,7 +1400,8 @@ rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len)\n   /* cdata never changes the parser state */\n \n   state=element->state;\n-  LIBRDF_DEBUG2(rapier_xml_cdata_handler, ""in state %d\\n"", state);\n+  LIBRDF_DEBUG3(rapier_xml_cdata_handler, ""in state %d - %s\\n"", state,\n+                rapier_state_as_string(state));\n   switch(state) {\n     case RAPIER_STATE_UNKNOWN:\n       /* Ignore all cdata if still looking for RDF */\n@@ -1341,15 +1418,16 @@ rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len)\n       rapier_parser_warning(rdf_parser, ""Found cdata before RDF element."");\n       break;\n \n-    case RAPIER_STATE_PARSETYPE_LITERAL:\n+    case RAPIER_STATE_PARSETYPE_OTHER:\n       /* FIXME */\n-      break;\n \n-    case RAPIER_STATE_PARSETYPE_RESOURCE:\n+      /* FALLTHROUGH */\n+\n+    case RAPIER_STATE_PARSETYPE_LITERAL:\n       /* FIXME */\n       break;\n \n-    case RAPIER_STATE_PARSETYPE_OTHER:\n+    case RAPIER_STATE_PARSETYPE_RESOURCE:\n       /* FIXME */\n       break;\n \n@@ -1358,19 +1436,12 @@ rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len)\n     } /* end switch */\n \n \n-  /* See if we can determine content rules yet */\n-  if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN) {\n-    if(!all_whitespace) {\n-      LIBRDF_DEBUG2(rapier_xml_end_element_handler, ""Set element %s content type to cdata\\n"", element->name->qname);\n-      element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_CDATA;\n-    }\n-  }\n-\n+  /* Whitespace is ignored except for literal or preserved content types */\n   if(all_whitespace && \n-     (ignore_all_whitespace ||\n-      element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS)) {\n+     element->content_type != RAPIER_ELEMENT_CONTENT_TYPE_LITERAL &&\n+     element->content_type != RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED) {\n     \n-    LIBRDF_DEBUG2(rapier_xml_end_element_handler, ""Ignoring whitespace cdata inside element %s\\n"", element->name->qname);\n+    LIBRDF_DEBUG2(rapier_xml_cdata_handler, ""Ignoring whitespace cdata inside element %s\\n"", element->name->qname);\n     return;\n   }\n \n@@ -1408,9 +1479,16 @@ rapier_xml_cdata_handler(void *user_data, const XML_Char *s, int len)\n   ptr += len;\n   *ptr = \'\\0\';\n \n+#if 0\n   LIBRDF_DEBUG3(rapier_xml_cdata_handler, \n                 ""content cdata now: \'%s\' (%d bytes)\\n"", \n                 buffer, element->content_cdata_length);\n+#endif\n+\n+  LIBRDF_DEBUG3(rapier_xml_cdata_handler, \n+                ""ending in state %d - %s\\n"",\n+                state, rapier_state_as_string(state));\n+\n }\n \n \n@@ -1439,6 +1517,7 @@ rapier_end_namespace_decl_handler(void *user_data, const XML_Char *prefix)\n #endif\n \n \n+#ifdef NEED_EXPAT\n /* This is called for a declaration of an unparsed (NDATA) entity */\n static void\n rapier_xml_unparsed_entity_decl_handler(void *user_data,\n@@ -1458,7 +1537,7 @@ rapier_xml_unparsed_entity_decl_handler(void *user_data,\n \n \n static int \n-rapier_xml_external_entity_ref_handler(XML_Parser parser,\n+rapier_xml_external_entity_ref_handler(void *user_data,\n                                        const XML_Char *context,\n                                        const XML_Char *base,\n                                        const XML_Char *systemId,\n@@ -1466,8 +1545,8 @@ rapier_xml_external_entity_ref_handler(XML_Parser parser,\n {\n /*  rapier_parser* rdf_parser=(rapier_parser*)user_data; */\n   fprintf(stderr,\n-          ""rapier_xml_external_entity_ref_handler: context %s base %s systemId %s publicId %s\\n"",\n-          context, (base ? base : ""(None)""), \n+          ""rapier_xml_external_entity_ref_handler: base %s systemId %s publicId %s\\n"",\n+          (base ? base : ""(None)""), \n           systemId, (publicId ? publicId: ""(None)""));\n \n   /* ""The handler should return 0 if processing should not continue\n@@ -1475,7 +1554,7 @@ rapier_xml_external_entity_ref_handler(XML_Parser parser,\n    */\n   return 1;\n }\n-\n+#endif\n \n \n #ifdef NEED_LIBXML\n@@ -1484,24 +1563,27 @@ rapier_xml_external_entity_ref_handler(XML_Parser parser,\n static const char* xml_warning_prefix=""XML parser warning - "";\n static const char* xml_error_prefix=""XML parser error - "";\n static const char* xml_fatal_error_prefix=""XML parser fatal error - "";\n+static const char* xml_validation_error_prefix=""XML parser validation error - "";\n+static const char* xml_validation_warning_prefix=""XML parser validation warning - "";\n \n static void\n rapier_xml_warning(void *ctx, const char *msg, ...) \n {\n   va_list args;\n+  rapier_parser* rdf_parser=(rapier_parser*)ctx;\n   int length;\n   char *nmsg;\n \n   va_start(args, msg);\n   length=strlen(xml_warning_prefix)+strlen(msg)+1;\n-  msg=(char*)LIBRDF_MALLOC(cstring, length);\n-  if(!msg) {\n+  nmsg=(char*)LIBRDF_MALLOC(cstring, length);\n+  if(!nmsg) {\n     /* just pass on, might be out of memory error */\n-    rapier_parser_warning(parser, msg, args);\n+    rapier_parser_warning(rdf_parser, msg, args);\n   } else {\n     strcpy(nmsg, xml_warning_prefix);\n     strcat(nmsg, msg);\n-    rapier_parser_warning(parser, nmsg, args);\n+    rapier_parser_warning(rdf_parser, nmsg, args);\n     LIBRDF_FREE(cstring,nmsg);\n   }\n   va_end(args);\n@@ -1512,19 +1594,20 @@ static void\n rapier_xml_error(void *ctx, const char *msg, ...) \n {\n   va_list args;\n+  rapier_parser* rdf_parser=(rapier_parser*)ctx;\n   int length;\n   char *nmsg;\n \n   va_start(args, msg);\n   length=strlen(xml_error_prefix)+strlen(msg)+1;\n-  msg=(char*)LIBRDF_MALLOC(cstring, length);\n-  if(!msg) {\n+  nmsg=(char*)LIBRDF_MALLOC(cstring, length);\n+  if(!nmsg) {\n     /* just pass on, might be out of memory error */\n-    rapier_parser_error(parser, msg, args);\n+    rapier_parser_error(rdf_parser, nmsg, args);\n   } else {\n     strcpy(nmsg, xml_error_prefix);\n     strcat(nmsg, msg);\n-    rapier_parser_error(parser, nmsg, args);\n+    rapier_parser_error(rdf_parser, nmsg, args);\n     LIBRDF_FREE(cstring,nmsg);\n   }\n   va_end(args);\n@@ -1535,24 +1618,85 @@ static void\n rapier_xml_fatal_error(void *ctx, const char *msg, ...) \n {\n   va_list args;\n+  rapier_parser* rdf_parser=(rapier_parser*)ctx;\n   int length;\n   char *nmsg;\n \n   va_start(args, msg);\n   length=strlen(xml_fatal_error_prefix)+strlen(msg)+1;\n-  msg=(char*)LIBRDF_MALLOC(cstring, length);\n-  if(!msg) {\n+  nmsg=(char*)LIBRDF_MALLOC(cstring, length);\n+  if(!nmsg) {\n     /* just pass on, might be out of memory error */\n-    rapier_parser_fatal_error(parser, msg, args);\n+    rapier_parser_fatal_error(rdf_parser, nmsg, args);\n   } else {\n     strcpy(nmsg, xml_error_prefix);\n     strcat(nmsg, msg);\n-    rapier_parser_fatal_error(parser, nmsg, args);\n+    rapier_parser_fatal_error(rdf_parser, nmsg, args);\n+    LIBRDF_FREE(cstring,nmsg);\n+  }\n+  va_end(args);\n+}\n+\n+\n+static void\n+rapier_xml_validation_error(void *ctx, const char *msg, ...) \n+{\n+  va_list args;\n+  rapier_parser* rdf_parser=(rapier_parser*)ctx;\n+  int length;\n+  char *nmsg;\n+\n+  va_start(args, msg);\n+  length=strlen(xml_validation_error_prefix)+strlen(msg)+1;\n+  nmsg=(char*)LIBRDF_MALLOC(cstring, length);\n+  if(!nmsg) {\n+    /* just pass on, might be out of memory error */\n+    rapier_parser_fatal_error(rdf_parser, nmsg, args);\n+  } else {\n+    strcpy(nmsg, xml_validation_error_prefix);\n+    strcat(nmsg, msg);\n+    rapier_parser_fatal_error(rdf_parser, nmsg, args);\n     LIBRDF_FREE(cstring,nmsg);\n   }\n   va_end(args);\n }\n \n+\n+static void\n+rapier_xml_validation_warning(void *ctx, const char *msg, ...) \n+{\n+  va_list args;\n+  rapier_parser* rdf_parser=(rapier_parser*)ctx;\n+  int length;\n+  char *nmsg;\n+\n+  va_start(args, msg);\n+  length=strlen(xml_validation_warning_prefix)+strlen(msg)+1;\n+  nmsg=(char*)LIBRDF_MALLOC(cstring, length);\n+  if(!nmsg) {\n+    /* just pass on, might be out of memory error */\n+    rapier_parser_warning(rdf_parser, nmsg, args);\n+  } else {\n+    strcpy(nmsg, xml_validation_warning_prefix);\n+    strcat(nmsg, msg);\n+    rapier_parser_fatal_error(rdf_parser, nmsg, args);\n+    LIBRDF_FREE(cstring,nmsg);\n+  }\n+  va_end(args);\n+}\n+\n+\n+static void\n+rapier_xml_set_document_locator (void *ctx, xmlSAXLocatorPtr loc) \n+{\n+  rapier_parser* rdf_parser=(rapier_parser*)ctx;\n+  rapier_locator *locator=&rdf_parser->locator; /* for storing error info */\n+\n+  locator->line=loc->getLineNumber(rdf_parser->xc);\n+  locator->column=loc->getColumnNumber(rdf_parser->xc);\n+}\n+  \n+\n #endif\n \n \n@@ -1662,39 +1806,6 @@ rapier_parser_warning(rapier_parser* parser, const char *message, ...)\n }\n \n \n-#ifdef NEED_LIBXML\n-/* from http://www.daa.com.au/~james/gnome/xml-sax/implementing.html */\n-#include <parserInternals.h>\n-\n-static int myXmlSAXParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename);\n-\n-static int\n-myXmlSAXParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename)\n-{\n-  int ret = 0;\n-  xmlParserCtxtPtr ctxt;\n-\n-  ctxt = xmlCreateFileParserCtxt(filename);\n-  if (ctxt == NULL) return -1;\n-  ctxt->sax = sax;\n-  ctxt->userData = user_data;\n-\n-  xmlParseDocument(ctxt);\n-\n-  if (ctxt->wellFormed)\n-    ret = 0;\n-  else\n-    ret = -1;\n-  if (sax)\n-    ctxt->sax = NULL;\n-  xmlFreeParserCtxt(ctxt);\n-\n-  return ret;\n-}\n-#endif\n-\n-\n-\n \n /* PUBLIC FUNCTIONS */\n \n@@ -1761,6 +1872,8 @@ rapier_new(rapier_uri *base_uri)\n   rdf_parser->sax.error=rapier_xml_error;\n   rdf_parser->sax.fatalError=rapier_xml_fatal_error;\n \n+  rdf_parser->sax.setDocumentLocator=rapier_xml_set_document_locator;\n+\n   /* xmlInitParserCtxt(&rdf_parser->xc); */\n #endif\n \n@@ -1885,7 +1998,7 @@ rapier_parse_file(rapier_parser* rdf_parser,  const char *uri,\n #endif\n #ifdef NEED_LIBXML\n   /* parser context */\n-  xmlParserCtxtPtr xc;\n+  xmlParserCtxtPtr xc=NULL;\n #endif\n #define RBS 1024\n   FILE *fh;\n@@ -1933,6 +2046,18 @@ rapier_parse_file(rapier_parser* rdf_parser,  const char *uri,\n   if(len>0) {\n     xc = xmlCreatePushParserCtxt(&rdf_parser->sax, rdf_parser,\n                                  buffer, len, filename);\n+    if(!xc) {\n+      fclose(fh);\n+      LIBRDF_FREE(cstring, (void*)filename);\n+      return 1;\n+    }\n+    xc->userData = rdf_parser;\n+    xc->vctxt.userData = rdf_parser;\n+    xc->vctxt.error=rapier_xml_validation_error;\n+    xc->vctxt.warning=rapier_xml_validation_warning;\n+    \n+    rdf_parser->xc = xc;\n+    \n   } else {\n     fclose(fh);\n     fh=NULL;\n@@ -1968,6 +2093,7 @@ rapier_parse_file(rapier_parser* rdf_parser,  const char *uri,\n   }\n   fclose(fh);\n \n+\n #ifdef NEED_EXPAT\n   if(!rc) {\n     int xe=XML_GetErrorCode(xp);\n@@ -1985,8 +2111,11 @@ rapier_parse_file(rapier_parser* rdf_parser,  const char *uri,\n   XML_ParserFree(xp);\n #endif /* EXPAT */\n #ifdef NEED_LIBXML\n-  if(rc) {\n-    rapier_parser_error(parser, ""XML Parsing failed"");\n+  if(rc)\n+    rapier_parser_error(rdf_parser, ""XML Parsing failed"");\n+\n+  xmlFreeParserCtxt(xc);\n+\n #endif\n \n   LIBRDF_FREE(cstring, (void*)filename);\n@@ -2060,6 +2189,15 @@ rapier_generate_statement(rapier_parser *rdf_parser,\n   statement.object_type=object_type;\n \n #ifdef RAPIER_DEBUG\n+  if(!subject)\n+    LIBRDF_FATAL1(rapier_generate_statement, ""Property has no subject"");\n+  \n+  if(!predicate)\n+    LIBRDF_FATAL1(rapier_generate_statement, ""Property has no predicate"");\n+  \n+  if(!object)\n+    LIBRDF_FATAL1(rapier_generate_statement, ""Statement has no object"");\n+  \n   fprintf(stderr, ""rapier_generate_statement: Generating statement: "");\n   rapier_print_statement_detailed(&statement, 1, stderr);\n   fputc(\'\\n\', stderr);\n@@ -2107,6 +2245,18 @@ rapier_generate_property(rapier_parser *rdf_parser,\n #ifdef RAPIER_DEBUG\n   const char *predicate_string=(predicate_type == RAPIER_PREDICATE_TYPE_PREDICATE) ? RAPIER_URI_AS_STRING((rapier_uri*)predicate) : (const char*)predicate;\n \n+  if(!element)\n+    LIBRDF_FATAL1(rapier_generate_property, ""Property has no subject"");\n+  \n+  if(!element->uri)\n+    LIBRDF_FATAL1(rapier_generate_property, ""Property has no subject URI"");\n+  \n+  if(!predicate)\n+    LIBRDF_FATAL1(rapier_generate_property, ""Property has no predicate"");\n+  \n+  if(!value)\n+    LIBRDF_FATAL1(rapier_generate_property, ""Property has no object"");\n+  \n   if(value_is_literal)\n     LIBRDF_DEBUG4(rapier_generate_property, \n                   ""Found property %s on element %s with literal value \'%s\'\\n"",\n@@ -2168,7 +2318,7 @@ rapier_generate_id(rapier_parser *rdf_parser, const int id_for_bag)\n   int id=++rdf_parser->genid;\n   int tmpid=id;\n \n-  while(tmpid/10)\n+  while(tmpid/=10)\n     length++;\n   buffer=(char*)LIBRDF_MALLOC(cstring, length);\n   if(!buffer)\n@@ -2183,19 +2333,32 @@ static rapier_uri*\n rapier_make_uri_from_id(rapier_uri *base_uri, const char *id) \n {\n #ifdef LIBRDF_INTERNAL\n+  librdf_uri *new_uri;\n+  char *qname;\n+  int len;\n #else\n   char *new_uri;\n   int len;\n+#endif\n+\n+#if 0\n   LIBRDF_DEBUG3(rapier_make_uri_from_id, \n                 ""Using base URI %s and ID %s\\n"", \n                 base_uri, id);\n #endif\n \n #ifdef LIBRDF_INTERNAL\n-  FIXME;\n+  len=1+strlen(id)+1; /* ""#id\\0"" */\n+  qname=LIBRDF_MALLOC(cstring, len);\n+  if(!qname)\n+    return NULL;\n+  *qname=\'#\';\n+  strcpy(qname+1, id);\n+  new_uri=librdf_new_uri_from_uri_qname(base_uri, qname);\n+  LIBRDF_FREE(cstring, qname);\n+  return new_uri;\n #else\n   len=strlen(base_uri)+1+strlen(id)+1;\n-\n   new_uri=LIBRDF_MALLOC(cstring, len);\n   if(!new_uri)\n     return NULL;\n@@ -2208,18 +2371,20 @@ rapier_make_uri_from_id(rapier_uri *base_uri, const char *id)\n static rapier_uri*\n rapier_make_uri(rapier_uri *base_uri, const char *uri_string) \n {\n-#ifdef LIBRDF_INTERNAL\n-#else\n+#ifndef LIBRDF_INTERNAL\n   char *new_uri;\n   const char *p;\n   int base_uri_len=strlen(base_uri);\n+#endif\n \n+#if 0\n   LIBRDF_DEBUG3(rapier_make_uri, \n                 ""Using base URI %s and URI string \'%s\'\\n"", \n                 base_uri, uri_string);\n #endif\n+\n #ifdef LIBRDF_INTERNAL\n-  FIXME;\n+  return librdf_new_uri_relative_to_base(base_uri, uri_string);\n #else\n   /* If URI string is empty, just copy base URI */\n   if(!*uri_string) {\n@@ -2330,24 +2495,33 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n   int finished;\n   rapier_state state;\n   int i;\n+  const char *el_name=element->name->qname;\n+  int element_in_rdf_ns=(element->name->namespace && \n+                         element->name->namespace->is_rdf_ms);\n \n-  finished= 0;\n-  if(element->parent)\n-    state=element->parent->state;\n-  else\n+\n+  if(element->parent) {\n+    state=element->parent->child_state;\n+    if(!state) {\n+      state=element->parent->state;\n+      LIBRDF_DEBUG3(rapier_start_element_grammar,\n+                    ""NO CHILD STATE set - taking parent state %d - %s\\n"",\n+                    state, rapier_state_as_string(state));\n+    }\n+    \n+  } else\n     state=RAPIER_STATE_UNKNOWN;\n+  LIBRDF_DEBUG3(rapier_start_element_grammar, ""starting in state %d - %s\\n"",\n+                state, rapier_state_as_string(state));\n \n+  finished= 0;\n   while(!finished) {\n-    const char *el_name=element->name->qname;\n-    int element_in_rdf_ns=(element->name->namespace && \n-                           element->name->namespace->is_rdf_ms);\n-\n     switch(state) {\n       case RAPIER_STATE_UNKNOWN:\n         /* found <rdf:RDF> ? */\n         if(element_in_rdf_ns && \n           IS_RDF_MS_CONCEPT(el_name, element->name->uri, RDF)) {\n-          state=RAPIER_STATE_IN_RDF;\n+          element->child_state=RAPIER_STATE_OBJ;\n           /* Yes - need more content before can continue,\n            * so wait for another element\n            */\n@@ -2364,43 +2538,88 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n         /* Otherwise the choice of the next state can be made\n          * from the current element by the IN_RDF state\n          */\n-        state=RAPIER_STATE_IN_RDF;\n+        state=RAPIER_STATE_OBJ;\n         break;\n \n \n-      case RAPIER_STATE_IN_RDF:\n+      case RAPIER_STATE_OBJ:\n+        /* Handling either 6.1 (RDF) <rdf:RDF> or 6.17 (value) and expecting\n+         * description (6.3) | sequence (6.25) | bag (6.26) | alternative (6.27)\n+         * [|other container (not M&S)]\n+         *\n+         * CHOICES:\n+         *   <rdf:Description> (goto 6.3)\n+         *   <rdf:Seq> (goto 6.25) (or typedNode CHOICE)\n+         *   <rdf:Bag> (goto 6.26) (or typedNode CHOICE)\n+         *   <rdf:Alt> (goto 6.27) (or typedNode CHOICE)\n+         * OR from 6.3 can have ANY other element matching\n+         * typedNode (6.13) - goto 6.3\n+         */\n+\n         if(element_in_rdf_ns) {\n           if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Description)) {\n             state=RAPIER_STATE_DESCRIPTION;\n             break;\n-          } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Seq)) {\n+          } \n+\n+          if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Seq)) {\n             /* CHOICE - can choose either sequence or typedNode productions */\n             if(rdf_parser->feature_interpret_containers_as_typedNode) {\n               rdf_parser->typed_node_block_type=RAPIER_TYPED_NODE_BLOCK_TYPE_SEQ;\n               state=RAPIER_STATE_TYPED_NODE;\n-            } else\n-              state=RAPIER_STATE_SEQ;\n+            } else {\n+              /* However, if there are non rdf:ID attributes, it must\n+               * be interpreted as a typedNode\n+               */\n+              if(element->rdf_attr_count -\n+                 (element->rdf_attr[RDF_ATTR_ID] != NULL))\n+                state=RAPIER_STATE_TYPED_NODE;\n+              else\n+                state=RAPIER_STATE_SEQ;\n+            }\n \n             break;\n-          } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Bag)) {\n+          }\n+\n+          if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Bag)) {\n             /* CHOICE - can choose either sequence or typedNode productions */\n             if(rdf_parser->feature_interpret_containers_as_typedNode) {\n               rdf_parser->typed_node_block_type=RAPIER_TYPED_NODE_BLOCK_TYPE_BAG;\n               state=RAPIER_STATE_TYPED_NODE;\n-            } else\n-              state=RAPIER_STATE_BAG;\n+            } else {\n+              /* However, if there are non rdf:ID attributes, it must\n+               * be interpreted as a typedNode\n+               */\n+              if(element->rdf_attr_count -\n+                 (element->rdf_attr[RDF_ATTR_ID] != NULL))\n+                state=RAPIER_STATE_TYPED_NODE;\n+              else\n+                state=RAPIER_STATE_BAG;\n+            }\n \n             break;\n-          } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Alt)) {\n+          }\n+\n+          if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Alt)) {\n             /* CHOICE - can choose either sequence or typedNode productions */\n             if(rdf_parser->feature_interpret_containers_as_typedNode) {\n               rdf_parser->typed_node_block_type=RAPIER_TYPED_NODE_BLOCK_TYPE_ALT;\n               state=RAPIER_STATE_TYPED_NODE;\n-            } else\n-              state=RAPIER_STATE_ALT;\n+            } else {\n+              /* However, if there are non rdf:ID attributes, it must\n+               * be interpreted as a typedNode\n+               */\n+              if(element->rdf_attr_count -\n+                 (element->rdf_attr[RDF_ATTR_ID] != NULL))\n+                state=RAPIER_STATE_TYPED_NODE;\n+              else\n+                state=RAPIER_STATE_ALT;\n+            }\n \n             break;\n-          } else if(rdf_parser->container_test_handler) {\n+          }\n+\n+          if(rdf_parser->container_test_handler) {\n             if(rdf_parser->container_test_handler(element->name->uri)) {\n               /* CHOICE - can choose either \'container\' or typedNode productions */\n               if(rdf_parser->feature_interpret_containers_as_typedNode) {\n@@ -2429,7 +2648,9 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n \n       case RAPIER_STATE_DESCRIPTION:\n       case RAPIER_STATE_TYPED_NODE:\n-        /* Handling either 6.3 (description) or 6.13 (typedNode)\n+      case RAPIER_STATE_PARSETYPE_RESOURCE:\n+        /* Handling 6.3 (description), 6.13 (typedNode) or contents\n+         * of a property (propertyElt or member) with parseType=""resource""\n          *\n          * 6.3 (description):\n          * <rdf:Description idAboutAttr? bagIdAttr? propAttr* >\n@@ -2447,8 +2668,12 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n          * Expect here from production 6.13 (typedNode)\n          * <typeName idAboutAttr? bagIdAttr? propAttr* />\n          *   Attributes: (ID|about|aboutEach|aboutEachPrefix)? bagID? propAttr*\n+         *\n+         * CHOICE (description): Create a bag here (always? even if\n+         * no bagId given?) FIXME - not implemented yet.\n          */\n \n+\n         /* lets add booleans - isn\'t C wonderful! */\n         if((element->rdf_attr[RDF_ATTR_ID] != NULL) +\n            (element->rdf_attr[RDF_ATTR_about] != NULL) +\n@@ -2482,31 +2707,37 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n           element->bag_uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->bag_id);\n         }\n \n-        /* Store our URI in our parent (if we have one) */\n+        /* If there is a parent element (property) containing this\n+         * element (node)\n+         */\n         if(element->parent) {\n+          \n           /* Free any existing object URI still around */\n           if(element->parent->object_uri)\n             RAPIER_FREE_URI(element->parent->object_uri);\n \n+          /* Store our URI in our parent as the object URI */\n           element->parent->object_uri=rapier_copy_uri(element->uri);\n-        }\n \n+          element->parent->content_type = RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE;\n+        }\n \n \n-        /* Extra work for typedNode - generate the typedNode\n-         * type statement about resource / XML name\n+        /* If this is a typed node, generate the rdf:type statement\n+         * from this node\n          */\n         if(state == RAPIER_STATE_TYPED_NODE) {\n           rapier_object_type object_type=(element->name->uri) ? RAPIER_OBJECT_TYPE_RESOURCE : RAPIER_OBJECT_TYPE_XML_NAME;\n           void *object=(element->name->uri) ? (void*)element->name->uri : (void*)element->name->qname;\n \n           rapier_generate_statement(rdf_parser, \n-                                    element->uri, /* subject - node URI */\n+                                    element->uri, /* subject - this node URI */\n                                     RAPIER_SUBJECT_TYPE_RESOURCE,\n                                     RAPIER_RDF_type_URI, /* predicate - rdf:type */\n                                     RAPIER_PREDICATE_TYPE_PREDICATE,\n                                     object,\n                                     object_type);\n+\n         }\n \n \n@@ -2516,7 +2747,8 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n          * property elements before can do any more work.\n          */\n \n-        state=RAPIER_STATE_PROPERTYELT;\n+        element->child_state=RAPIER_STATE_PROPERTYELT;\n+        element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_PROPERTIES;\n         finished=1;\n         break;\n \n@@ -2548,9 +2780,17 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n         element->uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->id);\n \n         /* Store URI of new thing in our parent */\n-        if(element->parent)\n+        if(element->parent) {\n+          /* Free any existing object URI still around */\n+          if(element->parent->object_uri)\n+            RAPIER_FREE_URI(element->parent->object_uri);\n+\n+          /* Store our URI in our parent as the object URI */\n           element->parent->object_uri=rapier_copy_uri(element->uri);\n \n+          element->parent->content_type = RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE;\n+        }\n+\n \n         /* Generate container type statement if we can */\n         if(state == RAPIER_STATE_CONTAINER) {\n@@ -2650,7 +2890,7 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n         } /* end for ... attributes */\n \n \n-        state=RAPIER_STATE_MEMBER;\n+        element->child_state=RAPIER_STATE_MEMBER;\n         finished=1;\n         break;\n \n@@ -2682,17 +2922,17 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n           const char *parse_type=element->rdf_attr[RDF_ATTR_parseType];\n \n           if(!strcasecmp(parse_type, ""literal"")) {\n-            state=RAPIER_STATE_PARSETYPE_LITERAL;\n+            element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;\n           } else if (!strcasecmp(parse_type, ""resource"")) {\n-            state=RAPIER_STATE_PARSETYPE_LITERAL;\n+            element->child_state=RAPIER_STATE_PARSETYPE_RESOURCE;\n           } else {\n             if(rdf_parser->feature_allow_other_parseTypes)\n-              state=RAPIER_STATE_PARSETYPE_OTHER;\n+              element->child_state=RAPIER_STATE_PARSETYPE_OTHER;\n             else\n-              state=RAPIER_STATE_PARSETYPE_LITERAL;\n+              element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;\n           }\n         } else\n-          state=RAPIER_STATE_INLINEITEM;\n+          element->child_state=RAPIER_STATE_INLINEITEM;\n \n         finished=1;\n         break;\n@@ -2706,19 +2946,16 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n         finished=1;\n         break;\n \n-      case RAPIER_STATE_PARSETYPE_LITERAL:\n-        finished=1;\n-        break;\n+      case RAPIER_STATE_PARSETYPE_OTHER:\n+        /* FIXME */\n \n-      case RAPIER_STATE_PARSETYPE_RESOURCE:\n-        finished=1;\n-        break;\n+        /* FALLTHROUGH */\n \n-      case RAPIER_STATE_PARSETYPE_OTHER:\n+      case RAPIER_STATE_PARSETYPE_LITERAL:\n+        /* FIXME */\n         finished=1;\n         break;\n \n-\n         /* choices here from production 6.12 (propertyElt)\n          *   <propName idAttr?> value </propName>\n          *     Attributes: ID?\n@@ -2733,58 +2970,96 @@ rapier_start_element_grammar(rapier_parser *rdf_parser,\n          * uses only attributes and no content.\n          */\n       case RAPIER_STATE_PROPERTYELT:\n-        element->id=element->rdf_attr[RDF_ATTR_ID];\n \n-        if(element->rdf_attr[RDF_ATTR_resource]) {\n-          /* Handle last case */\n-          element->uri=rapier_make_uri(rdf_parser->base_uri,\n-                                       element->rdf_attr[RDF_ATTR_resource]);\n+        /* Handle rdf:li as a property in member state above */ \n+        if(element_in_rdf_ns && \n+           IS_RDF_MS_CONCEPT(el_name, element->name->uri, li)) {\n+          state=RAPIER_STATE_MEMBER;\n+          break;\n+        }\n \n-          if(element->rdf_attr[RDF_ATTR_bagID]) {\n-            element->bag_id=element->rdf_attr[RDF_ATTR_bagID];\n-            element->bag_uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->bag_id);\n-          }\n \n-          rapier_process_property_attributes(rdf_parser, element);\n-        }\n+        /* M&S says: ""The value of the ID attribute, if specified, is\n+         * the identifier for the resource that represents the\n+         * reification of the statement."" */\n+        element->id=element->rdf_attr[RDF_ATTR_ID];\n \n         if (element->rdf_attr[RDF_ATTR_parseType]) {\n           const char *parse_type=element->rdf_attr[RDF_ATTR_parseType];\n \n           if(!strcasecmp(parse_type, ""literal"")) {\n-            state=RAPIER_STATE_PARSETYPE_LITERAL;\n+            element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;\n             LIBRDF_DEBUG2(rapier_start_element_grammar, ""Set element %s content type to preserved\\n"", element->name->qname);\n-            element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED;\n           } else if (!strcasecmp(parse_type, ""resource"")) {\n-            state=RAPIER_STATE_PARSETYPE_RESOURCE;\n+            element->child_state=RAPIER_STATE_PARSETYPE_RESOURCE;\n           } else {\n             if(rdf_parser->feature_allow_other_parseTypes)\n-              state=RAPIER_STATE_PARSETYPE_OTHER;\n-            else {\n-              state=RAPIER_STATE_PARSETYPE_LITERAL;\n-              element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED;\n-            }\n+              element->child_state=RAPIER_STATE_PARSETYPE_OTHER;\n+            else\n+              element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;\n           }\n-        }\n-        /* else state remains state=RAPIER_STATE_PROPERTYELT \n-         * to handle literal string content\n-         */\n+        } else if(element->rdf_attr[RDF_ATTR_resource]) {\n+          /* Can only be last case */\n+          element->uri=rapier_make_uri(rdf_parser->base_uri,\n+                                       element->rdf_attr[RDF_ATTR_resource]);\n+\n+          /* Store URI of new thing in our parent */\n+          if(element->parent) {\n+            /* Free any existing object URI still around */\n+            if(element->parent->object_uri)\n+              RAPIER_FREE_URI(element->parent->object_uri);\n+            \n+            /* Store our URI in our parent as the object URI *FIXME*  Needed? */\n+            element->parent->object_uri=rapier_copy_uri(element->uri);\n+            \n+            element->parent->content_type = RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE;\n+          }\n+\n+          if(element->rdf_attr[RDF_ATTR_bagID]) {\n+            element->bag_id=element->rdf_attr[RDF_ATTR_bagID];\n+            element->bag_uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->bag_id);\n+          }\n+\n+          rapier_process_property_attributes(rdf_parser, element);\n+\n+          rapier_generate_property(rdf_parser, \n+                                   element->parent, /* subject - parent URI */\n+                                   (void*)element->name->uri, /* predicate - element URI */\n+                                   RAPIER_PREDICATE_TYPE_PREDICATE,\n+                                   (void*)element->uri, 0);\n+\n+          /* Done - wait for end of this element to end in order to \n+           * check the element was empty as expected */\n+          element->content_type = RAPIER_ELEMENT_CONTENT_TYPE_EMPTY;\n+        } else {\n+          /* Otherwise process content in obj (value) state */\n+          element->child_state=RAPIER_STATE_OBJ;\n+          element->content_type = RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN;\n+        } /* end if parseType or resource attribute seen */\n \n         finished=1;\n+\n         break;\n \n+\n       default:\n-        rapier_parser_fatal_error(rdf_parser, ""rapier_start_element_grammar - unexpected parser state %d."", state);\n+        rapier_parser_fatal_error(rdf_parser, ""rapier_start_element_grammar - unexpected parser state %d - %s\\n"", state, rapier_state_as_string(state));\n         finished=1;\n \n     } /* end switch */\n \n     if(state != element->state) {\n       element->state=state;\n-      LIBRDF_DEBUG2(rapier_start_element_grammar, ""moved to state %d\\n"", state);\n+      LIBRDF_DEBUG3(rapier_start_element_grammar, \n+                    ""moved to state %d - %s\\n"",\n+                    state, rapier_state_as_string(state));\n     }\n \n   } /* end while */\n+\n+  LIBRDF_DEBUG3(rapier_start_element_grammar, \n+                ""ending in state %d - %s\\n"",\n+                state, rapier_state_as_string(state));\n }\n \n \n@@ -2794,21 +3069,23 @@ rapier_end_element_grammar(rapier_parser *rdf_parser,\n {\n   rapier_state state;\n   int finished;\n+  const char *el_name=element->name->qname;\n+  int element_in_rdf_ns=(element->name->namespace && \n+                         element->name->namespace->is_rdf_ms);\n+\n \n   state=element->state;\n-  LIBRDF_DEBUG2(rapier_end_element_grammar, ""in state %d\\n"", state);\n+  LIBRDF_DEBUG3(rapier_end_element_grammar, ""starting in state %d - %s\\n"",\n+                state, rapier_state_as_string(state));\n+\n   finished= 0;\n   while(!finished) {\n-    const char *el_name=element->name->qname;\n-    int element_in_rdf_ns=(element->name->namespace && \n-                           element->name->namespace->is_rdf_ms);\n-\n     switch(state) {\n       case RAPIER_STATE_UNKNOWN:\n         finished=1;\n         break;\n \n-      case RAPIER_STATE_IN_RDF:\n+      case RAPIER_STATE_OBJ:\n         if(element_in_rdf_ns && \n           IS_RDF_MS_CONCEPT(el_name, element->name->uri,RDF)) {\n           /* end of RDF - boo hoo */\n@@ -2837,16 +3114,25 @@ rapier_end_element_grammar(rapier_parser *rdf_parser,\n \n       case RAPIER_STATE_DESCRIPTION:\n       case RAPIER_STATE_TYPED_NODE:\n+      case RAPIER_STATE_PARSETYPE_RESOURCE:\n+\n+        /* If there is a parent element containing this element and\n+         * the parent isn\'t a description, create the statement\n+         * between this node using parent property\n+         */\n+        if(state != RAPIER_STATE_DESCRIPTION && \n+           element->parent && \n+           element->parent->uri &&\n+           element->parent->state != RAPIER_STATE_DESCRIPTION) {\n \n-        if(state == RAPIER_STATE_TYPED_NODE &&\n-           element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS) {\n-          rapier_generate_statement(rdf_parser,\n-                                    element->parent->uri, /* subject - parent URI */\n+          rapier_generate_statement(rdf_parser, \n+                                    element->parent->uri, /* subject - parent node URI */\n                                     RAPIER_SUBJECT_TYPE_RESOURCE,\n-                                    element->uri, /* predicate - our URI */\n+                                    element->parent->name->uri, /* predicate - parent property URI */\n                                     RAPIER_PREDICATE_TYPE_PREDICATE,\n-                                    element->object_uri, /* object - contents URI */\n+                                    element->uri, /* object - this node URI */\n                                     RAPIER_OBJECT_TYPE_RESOURCE);\n+\n         }\n \n         finished=1;\n@@ -2860,10 +3146,6 @@ rapier_end_element_grammar(rapier_parser *rdf_parser,\n         finished=1;\n         break;\n \n-      case RAPIER_STATE_MEMBER:\n-        finished=1;\n-        break;\n-\n       case RAPIER_STATE_REFERENCEDITEM:\n         if((element->content_element_seen + element->content_cdata_seen))\n           rapier_parser_warning(rdf_parser, ""Unexpected content in %s with resource attribute - from production 6.29 expected an empty element."", el_name);\n@@ -2888,6 +3170,12 @@ rapier_end_element_grammar(rapier_parser *rdf_parser,\n         finished=1;\n         break;\n \n+\n+      case RAPIER_STATE_PARSETYPE_OTHER:\n+        /* FIXME */\n+\n+        /* FALLTHROUGH */\n+\n       case RAPIER_STATE_PARSETYPE_LITERAL:\n         element->parent->last_ordinal++;\n         rapier_generate_ordinal_property(rdf_parser, \n@@ -2899,53 +3187,135 @@ rapier_end_element_grammar(rapier_parser *rdf_parser,\n         finished=1;\n         break;\n \n-      case RAPIER_STATE_PARSETYPE_RESOURCE:\n-        /* FIXME */\n-        finished=1;\n-        break;\n-\n-      case RAPIER_STATE_PARSETYPE_OTHER:\n-        /* FIXME */\n-        finished=1;\n-        break;\n-\n \n       case RAPIER_STATE_PROPERTYELT:\n+      case RAPIER_STATE_MEMBER:\n         /* This is used inside these: productions\n-         *   6.3 (description), 6.12 (propertyElt),\n-         *   6.13 (typedNode),  6.30 (inlineItem)\n+         *   6.12 (propertyElt) part 1 (element OR literal content),\n+         *                      part 4 (expect no content),\n+         *   6.30 (inlineItem) part 1 (element OR literal content)\n+         *\n+         * and similar parts of 6.28, 6.29 and 6.30 for rdf:li property\n+         *\n+         * The literal content part is handled here.\n+         * The element content is handled in the internal states\n+         * Empty content is checked here.\n          */\n \n-        if(element->content_cdata &&\n-           element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_CDATA)\n-          rapier_generate_property(rdf_parser, \n-                                   element->parent, /* subject - node URI */\n-                                   (void*)element->name->uri, /* predicate - element URI */\n-                                   RAPIER_PREDICATE_TYPE_PREDICATE,\n-                                   (void*)element->content_cdata, 1);\n+        if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN) {\n+          if(element->content_cdata_seen) \n+            element->content_type= RAPIER_ELEMENT_CONTENT_TYPE_LITERAL;\n+          else if (element->content_element_seen) \n+            element->content_type= RAPIER_ELEMENT_CONTENT_TYPE_PROPERTIES;\n+          else\n+            element->content_type= RAPIER_ELEMENT_CONTENT_TYPE_EMPTY;\n+        }\n \n-        if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS) {\n-          rapier_generate_property(rdf_parser, \n-                                   element->parent, /* subject - parent URI */\n-                                   (void*)element->name->uri, /* predicate - element URI */\n-                                   RAPIER_PREDICATE_TYPE_PREDICATE,\n-                                   (void*)element->object_uri, 0);\n+        if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_EMPTY) {\n+          const char *object_id=rapier_generate_id(rdf_parser, 0);\n+          if(object_id) {\n+            element->object_uri=rapier_make_uri_from_id(rdf_parser->base_uri, \n+                                                        object_id);\n+            LIBRDF_FREE(cstring, object_id);\n+          }\n+        }\n+\n+        if(element->parent && \n+           element->parent->state == RAPIER_STATE_DESCRIPTION) {\n+          int object_is_literal=(element->content_cdata != NULL);\n+          rapier_object_type object_type=object_is_literal ? RAPIER_OBJECT_TYPE_LITERAL : RAPIER_OBJECT_TYPE_RESOURCE;\n+          void *object=object_is_literal ? (void*)element->content_cdata : (void*)element->object_uri;\n+\n+          /* If there is a parent Description element (node), generate\n+           * the statement:\n+           *   subject  : parent\n+           *   predicate: ordinal / this property\n+           *   object   : child object (node)\n+           */\n+          if(state == RAPIER_STATE_MEMBER) {\n+            element->parent->last_ordinal++;\n+            rapier_generate_ordinal_property(rdf_parser, \n+                                             element->parent,\n+                                             element->parent->last_ordinal,\n+                                             object, object_type);\n+          } else\n+            rapier_generate_statement(rdf_parser, \n+                                      element->parent->uri,\n+                                      RAPIER_SUBJECT_TYPE_RESOURCE,\n+                                      element->name->uri,\n+                                      RAPIER_PREDICATE_TYPE_PREDICATE,\n+                                      object, object_type);\n+          \n+        } else {\n+          int object_is_literal=(element->content_cdata != NULL);\n+          void *object=object_is_literal ? (void*)element->content_cdata : (void*)element->object_uri;\n+\n+          /* Not child of Description, so process as child of propertyElt */\n+          switch(element->content_type) {\n+            case RAPIER_ELEMENT_CONTENT_TYPE_LITERAL:\n+            case RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE:\n+              if(state == RAPIER_STATE_MEMBER) {\n+                rapier_object_type object_type=object_is_literal ? RAPIER_OBJECT_TYPE_LITERAL : RAPIER_OBJECT_TYPE_RESOURCE;\n+\n+                element->parent->last_ordinal++;\n+                rapier_generate_ordinal_property(rdf_parser, \n+                                                 element->parent,\n+                                                 element->parent->last_ordinal,\n+                                                 object,\n+                                                 object_type);\n+              } else\n+                rapier_generate_property(rdf_parser, \n+                                         element->parent, /* subject - node URI */\n+                                         (void*)element->name->uri, /* predicate - element URI */\n+                                         RAPIER_PREDICATE_TYPE_PREDICATE,\n+                                         object, object_is_literal);\n+              break;\n+              \n+            case RAPIER_ELEMENT_CONTENT_TYPE_EMPTY:\n+              /* empty property of form\n+               * <property rdf:resource=""object-URI""/> \n+               */\n+              if(state == RAPIER_STATE_MEMBER) {\n+                element->parent->last_ordinal++;\n+                rapier_generate_ordinal_property(rdf_parser, \n+                                                 element->parent,\n+                                                 element->parent->last_ordinal,\n+                                                 (void*)element->uri,\n+                                                 RAPIER_OBJECT_TYPE_RESOURCE);\n+              } else\n+                rapier_generate_property(rdf_parser, \n+                                         element->parent, /* subject - node URI */\n+                                         (void*)element->name->uri, /* predicate - element URI */\n+                                         RAPIER_PREDICATE_TYPE_PREDICATE,\n+                                         (void*)element->uri, 0);\n+              break;\n+              \n+            default:\n+              rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar state RAPIER_STATE_PROPERTYELT - unexpected content type %d\\n"", element->content_type);\n+          } /* end switch */\n+          \n         }\n-        \n+\n         finished=1;\n         break;\n \n+\n       default:\n-        rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar - unexpected parser state %d."", state);\n+        rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar - unexpected parser state %d - %s\\n"", state, rapier_state_as_string(state));\n         finished=1;\n \n     } /* end switch */\n \n     if(state != element->state) {\n       element->state=state;\n-      LIBRDF_DEBUG2(rapier_end_element_grammar, ""moved to state %d\\n"", state);\n+      LIBRDF_DEBUG3(rapier_end_element_grammar, ""moved to state %d - %s\\n"",\n+                    state, rapier_state_as_string(state));\n     }\n \n   } /* end while */\n \n+  LIBRDF_DEBUG3(rapier_end_element_grammar, \n+                ""ending in state %d - %s\\n"",\n+                state, rapier_state_as_string(state));\n+\n }\n']",,,"['+ #define LIBRDF_DEBUG4(function, msg, arg1, arg2, arg3) do {fprintf(stderr, ""%s:%d:%s: "" msg, __FILE__, __LINE__, #function, arg1, arg2, arg3);} while(0)', '+ #define LIBRDF_FATAL1(function, msg) do {fprintf(stderr, ""%s:%d:%s: fatal error: "" msg, __FILE__, __LINE__ , #function); abort();} while(0)', '+ #define LIBRDF_FATAL2(function, msg,arg) do {fprintf(stderr, ""%s:%d:%s: fatal error: "" msg, __FILE__, __LINE__ , #function, arg); abort();} while(0)', '+ #ifdef HAVE_PARSER_H', '+ #include <parser.h>', '+ #else', '+ DIE', '+ #define XML_Char xmlChar', '+ #endif', '+   RAPIER_STATE_INVALID = 0,', '+   RAPIER_STATE_UNKNOWN = 1000,', '+   RAPIER_STATE_NOT_USED_1   = 6010,', '+   RAPIER_STATE_OBJ   = 6020,', '+   RAPIER_STATE_PARSETYPE_LITERAL = 6400,', '+   RAPIER_STATE_PARSETYPE_RESOURCE = 6410,', '+   RAPIER_STATE_CONTAINER = 6420,', '+   RAPIER_STATE_PARSETYPE_OTHER = 6430,', '+ static const char * const rapier_state_names[]={', '+   ""object (6.2)"",', '+   ""description (6.3)"",', '+   ""propertyElt (6.12)"",', '+   ""typed_node (6.13)"",', '+   ""sequence (6.25)"",', '+   ""bag (6.26)"",', '+   ""alternative (6.27)"",', '+   ""member (6.28)"",', '+   ""referencedItem (6.29)"",', '+   ""inlineItem (6.30 part 1)"",', '+   NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,', '+   ""parseTypeLiteral (6.30 part 2)"",', '+   ""parseTypeResource (6.30 part 3)"",', '+   ""container (not M&S)"",', '+   ""parseTypeOther (not M&S)"",', '+ };', '+ static const char * rapier_state_as_string(rapier_state state)', '+ {', '+   int offset=(state - 6000)/10;', '+   if(state == RAPIER_STATE_UNKNOWN)', '+     return ""UNKNOWN"";', '+   if(offset<0 || offset > 43)', '+     return ""INVALID"";', '+   if(!rapier_state_names[offset])', '+     return ""NOT-USED"";', '+   return rapier_state_names[offset];', '+ }', '+   RAPIER_ELEMENT_CONTENT_TYPE_EMPTY,', '+   RAPIER_ELEMENT_CONTENT_TYPE_LITERAL,', '+   RAPIER_ELEMENT_CONTENT_TYPE_PROPERTIES,', '+   RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE,', '+   xmlParserCtxtPtr xc;', '+ #define RAPIER_RDF_Alt_URI LIBRDF_MS_Alt_URI', '+ static void rapier_xml_warning(void *context, const char *msg, ...);', '+ static void rapier_xml_error(void *context, const char *msg, ...);', '+ static void rapier_xml_fatal_error(void *context, const char *msg, ...);', '+ static void rapier_xml_validation_error(void *context, const char *msg, ...);', '+ static void rapier_xml_validation_warning(void *context, const char *msg, ...);', '+ static void rapier_xml_set_document_locator (void *ctx, xmlSAXLocatorPtr loc);', '+     LIBRDF_FREE(cstring, (char*)element->id);', '+ #endif', '+       if(rdf_parser->feature_allow_non_ns_attributes && attribute) {', '+     element->content_type=element->parent->content_type;', '+     if(element->parent->content_element_seen == 1 &&', '+        element->parent->content_cdata_seen == 1) {', '+       rapier_parser_warning(rdf_parser, ""element %s has mixed content."",', '+                             element->parent->name->qname);', '+     }', '+     if(element->parent->content_element_seen &&', '+        element->parent->content_cdata_all_whitespace &&', '+        element->parent->content_cdata) {', '+       LIBRDF_FREE(rapier_ns_name_array, element->parent->content_cdata);', '+       element->parent->content_cdata=NULL;', '+       element->parent->content_cdata_length=0;', '+   fprintf(stderr, ""\\nrapier_xml_end_element_handler: End ns-element: "");', '+ #ifdef RAPIER_DEBUG', ""+   fputc('\\n', stderr);"", '+ #endif', '+   LIBRDF_DEBUG3(rapier_xml_cdata_handler, ""in state %d - %s\\n"", state,', '+                 rapier_state_as_string(state));', '+     case RAPIER_STATE_PARSETYPE_OTHER:', '+     case RAPIER_STATE_PARSETYPE_LITERAL:', '+     case RAPIER_STATE_PARSETYPE_RESOURCE:', '+      element->content_type != RAPIER_ELEMENT_CONTENT_TYPE_LITERAL &&', '+      element->content_type != RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED) {', '+     LIBRDF_DEBUG2(rapier_xml_cdata_handler, ""Ignoring whitespace cdata inside element %s\\n"", element->name->qname);', '+ #if 0', '+ #endif', '+   LIBRDF_DEBUG3(rapier_xml_cdata_handler,', '+                 ""ending in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+ #ifdef NEED_EXPAT', '+ rapier_xml_external_entity_ref_handler(void *user_data,', '+           ""rapier_xml_external_entity_ref_handler: base %s systemId %s publicId %s\\n"",', '+           (base ? base : ""(None)""),', '+ #endif', '+ static const char* xml_validation_error_prefix=""XML parser validation error - "";', '+ static const char* xml_validation_warning_prefix=""XML parser validation warning - "";', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_warning(rdf_parser, msg, args);', '+     rapier_parser_warning(rdf_parser, nmsg, args);', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_error(rdf_parser, nmsg, args);', '+     rapier_parser_error(rdf_parser, nmsg, args);', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+     LIBRDF_FREE(cstring,nmsg);', '+   }', '+   va_end(args);', '+ }', '+ static void', '+ rapier_xml_validation_error(void *ctx, const char *msg, ...)', '+ {', '+   va_list args;', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   int length;', '+   char *nmsg;', '+   va_start(args, msg);', '+   length=strlen(xml_validation_error_prefix)+strlen(msg)+1;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+   } else {', '+     strcpy(nmsg, xml_validation_error_prefix);', '+     strcat(nmsg, msg);', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+ static void', '+ rapier_xml_validation_warning(void *ctx, const char *msg, ...)', '+ {', '+   va_list args;', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   int length;', '+   char *nmsg;', '+   va_start(args, msg);', '+   length=strlen(xml_validation_warning_prefix)+strlen(msg)+1;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_warning(rdf_parser, nmsg, args);', '+   } else {', '+     strcpy(nmsg, xml_validation_warning_prefix);', '+     strcat(nmsg, msg);', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+     LIBRDF_FREE(cstring,nmsg);', '+   }', '+   va_end(args);', '+ }', '+ static void', '+ rapier_xml_set_document_locator (void *ctx, xmlSAXLocatorPtr loc)', '+ {', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   locator->line=loc->getLineNumber(rdf_parser->xc);', '+   locator->column=loc->getColumnNumber(rdf_parser->xc);', '+ }', '+   rdf_parser->sax.setDocumentLocator=rapier_xml_set_document_locator;', '+   xmlParserCtxtPtr xc=NULL;', '+     if(!xc) {', '+       fclose(fh);', '+       LIBRDF_FREE(cstring, (void*)filename);', '+       return 1;', '+     }', '+     xc->userData = rdf_parser;', '+     xc->vctxt.userData = rdf_parser;', '+     xc->vctxt.error=rapier_xml_validation_error;', '+     xc->vctxt.warning=rapier_xml_validation_warning;', '+     rdf_parser->xc = xc;', '+   if(rc)', '+     rapier_parser_error(rdf_parser, ""XML Parsing failed"");', '+   xmlFreeParserCtxt(xc);', '+   if(!subject)', '+     LIBRDF_FATAL1(rapier_generate_statement, ""Property has no subject"");', '+   if(!predicate)', '+     LIBRDF_FATAL1(rapier_generate_statement, ""Property has no predicate"");', '+   if(!object)', '+     LIBRDF_FATAL1(rapier_generate_statement, ""Statement has no object"");', '+   if(!element)', '+     LIBRDF_FATAL1(rapier_generate_property, ""Property has no subject"");', '+   if(!element->uri)', '+     LIBRDF_FATAL1(rapier_generate_property, ""Property has no subject URI"");', '+   if(!predicate)', '+     LIBRDF_FATAL1(rapier_generate_property, ""Property has no predicate"");', '+   if(!value)', '+     LIBRDF_FATAL1(rapier_generate_property, ""Property has no object"");', '+   while(tmpid/=10)', '+   librdf_uri *new_uri;', '+   char *qname;', '+   int len;', '+ #endif', '+ #if 0', '+   qname=LIBRDF_MALLOC(cstring, len);', '+   if(!qname)', '+     return NULL;', ""+   *qname='#';"", '+   strcpy(qname+1, id);', '+   new_uri=librdf_new_uri_from_uri_qname(base_uri, qname);', '+   LIBRDF_FREE(cstring, qname);', '+   return new_uri;', '+ #ifndef LIBRDF_INTERNAL', '+ #endif', '+ #if 0', '+   return librdf_new_uri_relative_to_base(base_uri, uri_string);', '+   const char *el_name=element->name->qname;', '+   int element_in_rdf_ns=(element->name->namespace &&', '+                          element->name->namespace->is_rdf_ms);', '+   if(element->parent) {', '+     state=element->parent->child_state;', '+     if(!state) {', '+       state=element->parent->state;', '+       LIBRDF_DEBUG3(rapier_start_element_grammar,', '+                     ""NO CHILD STATE set - taking parent state %d - %s\\n"",', '+                     state, rapier_state_as_string(state));', '+     }', '+   } else', '+   LIBRDF_DEBUG3(rapier_start_element_grammar, ""starting in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+   finished= 0;', '+           element->child_state=RAPIER_STATE_OBJ;', '+         state=RAPIER_STATE_OBJ;', '+       case RAPIER_STATE_OBJ:', '+           }', '+           if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Seq)) {', '+             } else {', '+               if(element->rdf_attr_count -', '+                  (element->rdf_attr[RDF_ATTR_ID] != NULL))', '+                 state=RAPIER_STATE_TYPED_NODE;', '+               else', '+                 state=RAPIER_STATE_SEQ;', '+             }', '+           }', '+           if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Bag)) {', '+             } else {', '+               if(element->rdf_attr_count -', '+                  (element->rdf_attr[RDF_ATTR_ID] != NULL))', '+                 state=RAPIER_STATE_TYPED_NODE;', '+               else', '+                 state=RAPIER_STATE_BAG;', '+             }', '+           }', '+           if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Alt)) {', '+             } else {', '+               if(element->rdf_attr_count -', '+                  (element->rdf_attr[RDF_ATTR_ID] != NULL))', '+                 state=RAPIER_STATE_TYPED_NODE;', '+               else', '+                 state=RAPIER_STATE_ALT;', '+             }', '+           }', '+           if(rdf_parser->container_test_handler) {', '+       case RAPIER_STATE_PARSETYPE_RESOURCE:', '+           element->parent->content_type = RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE;', '+         }', '+         element->child_state=RAPIER_STATE_PROPERTYELT;', '+         element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_PROPERTIES;', '+         if(element->parent) {', '+           if(element->parent->object_uri)', '+             RAPIER_FREE_URI(element->parent->object_uri);', '+           element->parent->content_type = RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE;', '+         }', '+         element->child_state=RAPIER_STATE_MEMBER;', '+             element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;', '+             element->child_state=RAPIER_STATE_PARSETYPE_RESOURCE;', '+               element->child_state=RAPIER_STATE_PARSETYPE_OTHER;', '+               element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;', '+           element->child_state=RAPIER_STATE_INLINEITEM;', '+       case RAPIER_STATE_PARSETYPE_OTHER:', '+       case RAPIER_STATE_PARSETYPE_LITERAL:', '+         if(element_in_rdf_ns &&', '+            IS_RDF_MS_CONCEPT(el_name, element->name->uri, li)) {', '+           state=RAPIER_STATE_MEMBER;', '+           break;', '+         }', '+         element->id=element->rdf_attr[RDF_ATTR_ID];', '+             element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;', '+             element->child_state=RAPIER_STATE_PARSETYPE_RESOURCE;', '+               element->child_state=RAPIER_STATE_PARSETYPE_OTHER;', '+             else', '+               element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;', '+         } else if(element->rdf_attr[RDF_ATTR_resource]) {', '+           element->uri=rapier_make_uri(rdf_parser->base_uri,', '+                                        element->rdf_attr[RDF_ATTR_resource]);', '+           if(element->parent) {', '+             if(element->parent->object_uri)', '+               RAPIER_FREE_URI(element->parent->object_uri);', '+             element->parent->object_uri=rapier_copy_uri(element->uri);', '+             element->parent->content_type = RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE;', '+           }', '+           if(element->rdf_attr[RDF_ATTR_bagID]) {', '+             element->bag_id=element->rdf_attr[RDF_ATTR_bagID];', '+             element->bag_uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->bag_id);', '+           }', '+           rapier_process_property_attributes(rdf_parser, element);', '+           rapier_generate_property(rdf_parser,', '+                                    RAPIER_PREDICATE_TYPE_PREDICATE,', '+                                    (void*)element->uri, 0);', '+           element->content_type = RAPIER_ELEMENT_CONTENT_TYPE_EMPTY;', '+         } else {', '+           element->child_state=RAPIER_STATE_OBJ;', '+           element->content_type = RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN;', '+         rapier_parser_fatal_error(rdf_parser, ""rapier_start_element_grammar - unexpected parser state %d - %s\\n"", state, rapier_state_as_string(state));', '+       LIBRDF_DEBUG3(rapier_start_element_grammar,', '+                     ""moved to state %d - %s\\n"",', '+                     state, rapier_state_as_string(state));', '+   LIBRDF_DEBUG3(rapier_start_element_grammar,', '+                 ""ending in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+   const char *el_name=element->name->qname;', '+   int element_in_rdf_ns=(element->name->namespace &&', '+                          element->name->namespace->is_rdf_ms);', '+   LIBRDF_DEBUG3(rapier_end_element_grammar, ""starting in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+       case RAPIER_STATE_OBJ:', '+       case RAPIER_STATE_PARSETYPE_RESOURCE:', '+         if(state != RAPIER_STATE_DESCRIPTION &&', '+            element->parent &&', '+            element->parent->uri &&', '+            element->parent->state != RAPIER_STATE_DESCRIPTION) {', '+           rapier_generate_statement(rdf_parser,', '+       case RAPIER_STATE_PARSETYPE_OTHER:', '+       case RAPIER_STATE_MEMBER:', '+         if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN) {', '+           if(element->content_cdata_seen)', '+             element->content_type= RAPIER_ELEMENT_CONTENT_TYPE_LITERAL;', '+           else if (element->content_element_seen)', '+             element->content_type= RAPIER_ELEMENT_CONTENT_TYPE_PROPERTIES;', '+           else', '+             element->content_type= RAPIER_ELEMENT_CONTENT_TYPE_EMPTY;', '+         }', '+         if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_EMPTY) {', '+           const char *object_id=rapier_generate_id(rdf_parser, 0);', '+           if(object_id) {', '+             element->object_uri=rapier_make_uri_from_id(rdf_parser->base_uri,', '+                                                         object_id);', '+             LIBRDF_FREE(cstring, object_id);', '+           }', '+         }', '+         if(element->parent &&', '+            element->parent->state == RAPIER_STATE_DESCRIPTION) {', '+           int object_is_literal=(element->content_cdata != NULL);', '+           rapier_object_type object_type=object_is_literal ? RAPIER_OBJECT_TYPE_LITERAL : RAPIER_OBJECT_TYPE_RESOURCE;', '+           void *object=object_is_literal ? (void*)element->content_cdata : (void*)element->object_uri;', '+           if(state == RAPIER_STATE_MEMBER) {', '+             element->parent->last_ordinal++;', '+             rapier_generate_ordinal_property(rdf_parser,', '+                                              element->parent,', '+                                              element->parent->last_ordinal,', '+                                              object, object_type);', '+           } else', '+             rapier_generate_statement(rdf_parser,', '+                                       element->parent->uri,', '+                                       RAPIER_SUBJECT_TYPE_RESOURCE,', '+                                       element->name->uri,', '+                                       RAPIER_PREDICATE_TYPE_PREDICATE,', '+                                       object, object_type);', '+         } else {', '+           int object_is_literal=(element->content_cdata != NULL);', '+           void *object=object_is_literal ? (void*)element->content_cdata : (void*)element->object_uri;', '+           switch(element->content_type) {', '+             case RAPIER_ELEMENT_CONTENT_TYPE_LITERAL:', '+             case RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE:', '+               if(state == RAPIER_STATE_MEMBER) {', '+                 rapier_object_type object_type=object_is_literal ? RAPIER_OBJECT_TYPE_LITERAL : RAPIER_OBJECT_TYPE_RESOURCE;', '+                 element->parent->last_ordinal++;', '+                 rapier_generate_ordinal_property(rdf_parser,', '+                                                  element->parent,', '+                                                  element->parent->last_ordinal,', '+                                                  object,', '+                                                  object_type);', '+               } else', '+                 rapier_generate_property(rdf_parser,', '+                                          RAPIER_PREDICATE_TYPE_PREDICATE,', '+                                          object, object_is_literal);', '+               break;', '+             case RAPIER_ELEMENT_CONTENT_TYPE_EMPTY:', '+               if(state == RAPIER_STATE_MEMBER) {', '+                 element->parent->last_ordinal++;', '+                 rapier_generate_ordinal_property(rdf_parser,', '+                                                  element->parent,', '+                                                  element->parent->last_ordinal,', '+                                                  (void*)element->uri,', '+                                                  RAPIER_OBJECT_TYPE_RESOURCE);', '+               } else', '+                 rapier_generate_property(rdf_parser,', '+                                          RAPIER_PREDICATE_TYPE_PREDICATE,', '+                                          (void*)element->uri, 0);', '+               break;', '+             default:', '+               rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar state RAPIER_STATE_PROPERTYELT - unexpected content type %d\\n"", element->content_type);', '+         rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar - unexpected parser state %d - %s\\n"", state, rapier_state_as_string(state));', '+       LIBRDF_DEBUG3(rapier_end_element_grammar, ""moved to state %d - %s\\n"",', '+                     state, rapier_state_as_string(state));', '+   LIBRDF_DEBUG3(rapier_end_element_grammar,', '+                 ""ending in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '- #define XML_Char xmlChar', '- #include <parser.h>', '-   RAPIER_STATE_UNKNOWN = 0,', '-   RAPIER_STATE_IN_RDF   = 6010,', '-   RAPIER_STATE_NOT_USED_1   = 6020,', '-   RAPIER_STATE_PARSETYPE_LITERAL = 6301,', '-   RAPIER_STATE_PARSETYPE_RESOURCE = 6302,', '-   RAPIER_STATE_CONTAINER = 7000,', '-   RAPIER_STATE_PARSETYPE_OTHER = 7010,', '-   RAPIER_ELEMENT_CONTENT_TYPE_CDATA,', '-   RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS,', '- #define RAPIER_RDF_Alt_URI LIBRDF_MS_alt_URI', '- static void rapier_xml_warning(void *context, rapier_locator *locator, const char *msg, ...);', '- static void rapier_xml_error(void *context, rapier_locator *locator, const char *msg, ...);', '- static void rapier_xml_fatal_error(void *context, rapier_locator *locator, const char *msg, ...);', '-     LIBRDF_FREE(cstring, element->id);', '-       if(rdf_parser->feature_allow_non_ns_attributes &&', '-          attribute && !attribute->namespace &&', '-          element_name->namespace && element_name->namespace->is_rdf_ms) {', '-     if(element->parent->content_type == RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN) {', '-       LIBRDF_DEBUG2(rapier_xml_start_element_handler, ""Set element %s content type to elements\\n"", element->name->qname);', '-       element->parent->content_type=RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS;', '-       if(element->parent->content_element_seen == 1 &&', '-          element->parent->content_cdata_seen == 1) {', '-         rapier_parser_warning(rdf_parser, ""element %s has mixed content."",', '-                               element->parent->name->qname);', '-       }', '-       if(element->parent->content_element_seen &&', '-          element->parent->content_cdata_all_whitespace) {', '-         LIBRDF_FREE(rapier_ns_name_array, element->content_cdata);', '-         element->content_cdata=NULL;', '-         element->content_cdata_length=0;', '-       }', '-   }', '-   fprintf(stderr, ""rapier_xml_end_element_handler: End ns-element: "");', '-   int ignore_all_whitespace=0;', '-   LIBRDF_DEBUG2(rapier_xml_cdata_handler, ""in state %d\\n"", state);', '-     case RAPIER_STATE_PARSETYPE_LITERAL:', '-       break;', '-     case RAPIER_STATE_PARSETYPE_RESOURCE:', '-     case RAPIER_STATE_PARSETYPE_OTHER:', '-   if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN) {', '-     if(!all_whitespace) {', '-       LIBRDF_DEBUG2(rapier_xml_end_element_handler, ""Set element %s content type to cdata\\n"", element->name->qname);', '-       element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_CDATA;', '-     }', '-   }', '-      (ignore_all_whitespace ||', '-       element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS)) {', '-     LIBRDF_DEBUG2(rapier_xml_end_element_handler, ""Ignoring whitespace cdata inside element %s\\n"", element->name->qname);', '- rapier_xml_external_entity_ref_handler(XML_Parser parser,', '-           ""rapier_xml_external_entity_ref_handler: context %s base %s systemId %s publicId %s\\n"",', '-           context, (base ? base : ""(None)""),', '-   msg=(char*)LIBRDF_MALLOC(cstring, length);', '-   if(!msg) {', '-     rapier_parser_warning(parser, msg, args);', '-     rapier_parser_warning(parser, nmsg, args);', '-   msg=(char*)LIBRDF_MALLOC(cstring, length);', '-   if(!msg) {', '-     rapier_parser_error(parser, msg, args);', '-     rapier_parser_error(parser, nmsg, args);', '-   msg=(char*)LIBRDF_MALLOC(cstring, length);', '-   if(!msg) {', '-     rapier_parser_fatal_error(parser, msg, args);', '-     rapier_parser_fatal_error(parser, nmsg, args);', '- #ifdef NEED_LIBXML', '- #include <parserInternals.h>', '- static int myXmlSAXParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename);', '- static int', '- myXmlSAXParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename)', '- {', '-   int ret = 0;', '-   xmlParserCtxtPtr ctxt;', '-   ctxt = xmlCreateFileParserCtxt(filename);', '-   if (ctxt == NULL) return -1;', '-   ctxt->sax = sax;', '-   ctxt->userData = user_data;', '-   xmlParseDocument(ctxt);', '-   if (ctxt->wellFormed)', '-     ret = 0;', '-   else', '-     ret = -1;', '-   if (sax)', '-     ctxt->sax = NULL;', '-   xmlFreeParserCtxt(ctxt);', '-   return ret;', '- }', '- #endif', '-   xmlParserCtxtPtr xc;', '-   if(rc) {', '-     rapier_parser_error(parser, ""XML Parsing failed"");', '-   while(tmpid/10)', '-   FIXME;', '- #ifdef LIBRDF_INTERNAL', '- #else', '-   FIXME;', '-   finished= 0;', '-   if(element->parent)', '-     state=element->parent->state;', '-   else', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-           state=RAPIER_STATE_IN_RDF;', '-         state=RAPIER_STATE_IN_RDF;', '-       case RAPIER_STATE_IN_RDF:', '-           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Seq)) {', '-             } else', '-               state=RAPIER_STATE_SEQ;', '-           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Bag)) {', '-             } else', '-               state=RAPIER_STATE_BAG;', '-           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Alt)) {', '-             } else', '-               state=RAPIER_STATE_ALT;', '-           } else if(rdf_parser->container_test_handler) {', '-         }', '-         state=RAPIER_STATE_PROPERTYELT;', '-         if(element->parent)', '-         state=RAPIER_STATE_MEMBER;', '-             state=RAPIER_STATE_PARSETYPE_LITERAL;', '-             state=RAPIER_STATE_PARSETYPE_LITERAL;', '-               state=RAPIER_STATE_PARSETYPE_OTHER;', '-               state=RAPIER_STATE_PARSETYPE_LITERAL;', '-           state=RAPIER_STATE_INLINEITEM;', '-       case RAPIER_STATE_PARSETYPE_LITERAL:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PARSETYPE_RESOURCE:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PARSETYPE_OTHER:', '-         element->id=element->rdf_attr[RDF_ATTR_ID];', '-         if(element->rdf_attr[RDF_ATTR_resource]) {', '-           element->uri=rapier_make_uri(rdf_parser->base_uri,', '-                                        element->rdf_attr[RDF_ATTR_resource]);', '-           if(element->rdf_attr[RDF_ATTR_bagID]) {', '-             element->bag_id=element->rdf_attr[RDF_ATTR_bagID];', '-             element->bag_uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->bag_id);', '-           }', '-           rapier_process_property_attributes(rdf_parser, element);', '-         }', '-             state=RAPIER_STATE_PARSETYPE_LITERAL;', '-             element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED;', '-             state=RAPIER_STATE_PARSETYPE_RESOURCE;', '-               state=RAPIER_STATE_PARSETYPE_OTHER;', '-             else {', '-               state=RAPIER_STATE_PARSETYPE_LITERAL;', '-               element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED;', '-             }', '-         }', '-         rapier_parser_fatal_error(rdf_parser, ""rapier_start_element_grammar - unexpected parser state %d."", state);', '-       LIBRDF_DEBUG2(rapier_start_element_grammar, ""moved to state %d\\n"", state);', '-   LIBRDF_DEBUG2(rapier_end_element_grammar, ""in state %d\\n"", state);', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-       case RAPIER_STATE_IN_RDF:', '-         if(state == RAPIER_STATE_TYPED_NODE &&', '-            element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS) {', '-           rapier_generate_statement(rdf_parser,', '-       case RAPIER_STATE_MEMBER:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PARSETYPE_RESOURCE:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PARSETYPE_OTHER:', '-         finished=1;', '-         break;', '-         if(element->content_cdata &&', '-            element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_CDATA)', '-           rapier_generate_property(rdf_parser,', '-                                    RAPIER_PREDICATE_TYPE_PREDICATE,', '-                                    (void*)element->content_cdata, 1);', '-         if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS) {', '-           rapier_generate_property(rdf_parser,', '-                                    RAPIER_PREDICATE_TYPE_PREDICATE,', '-                                    (void*)element->object_uri, 0);', '-         rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar - unexpected parser state %d."", state);', '-       LIBRDF_DEBUG2(rapier_end_element_grammar, ""moved to state %d\\n"", state);']","['+ #define librdf_debug4(function, msg, arg1, arg2, arg3) do {fprintf(stderr, ""%s:%d:%s: "" msg, __file__, __line__, #function, arg1, arg2, arg3);} while(0)', '+ #define librdf_fatal1(function, msg) do {fprintf(stderr, ""%s:%d:%s: fatal error: "" msg, __file__, __line__ , #function); abort();} while(0)', '+ #define librdf_fatal2(function, msg,arg) do {fprintf(stderr, ""%s:%d:%s: fatal error: "" msg, __file__, __line__ , #function, arg); abort();} while(0)', '+ #ifdef have_parser_h', '+ #include <parser.h>', '+ #else', '+ die', '+ #define xml_char xmlchar', '+ #endif', '+   rapier_state_invalid = 0,', '+   rapier_state_unknown = 1000,', '+   rapier_state_not_used_1   = 6010,', '+   rapier_state_obj   = 6020,', '+   rapier_state_parsetype_literal = 6400,', '+   rapier_state_parsetype_resource = 6410,', '+   rapier_state_container = 6420,', '+   rapier_state_parsetype_other = 6430,', '+ static const char * const rapier_state_names[]={', '+   ""object (6.2)"",', '+   ""description (6.3)"",', '+   ""propertyelt (6.12)"",', '+   ""typed_node (6.13)"",', '+   ""sequence (6.25)"",', '+   ""bag (6.26)"",', '+   ""alternative (6.27)"",', '+   ""member (6.28)"",', '+   ""referenceditem (6.29)"",', '+   ""inlineitem (6.30 part 1)"",', '+   null,null,null,null,null,null,null,null,null,', '+   ""parsetypeliteral (6.30 part 2)"",', '+   ""parsetyperesource (6.30 part 3)"",', '+   ""container (not m&s)"",', '+   ""parsetypeother (not m&s)"",', '+ };', '+ static const char * rapier_state_as_string(rapier_state state)', '+ {', '+   int offset=(state - 6000)/10;', '+   if(state == rapier_state_unknown)', '+     return ""unknown"";', '+   if(offset<0 || offset > 43)', '+     return ""invalid"";', '+   if(!rapier_state_names[offset])', '+     return ""not-used"";', '+   return rapier_state_names[offset];', '+ }', '+   rapier_element_content_type_empty,', '+   rapier_element_content_type_literal,', '+   rapier_element_content_type_properties,', '+   rapier_element_content_type_resource,', '+   xmlparserctxtptr xc;', '+ #define rapier_rdf_alt_uri librdf_ms_alt_uri', '+ static void rapier_xml_warning(void *context, const char *msg, ...);', '+ static void rapier_xml_error(void *context, const char *msg, ...);', '+ static void rapier_xml_fatal_error(void *context, const char *msg, ...);', '+ static void rapier_xml_validation_error(void *context, const char *msg, ...);', '+ static void rapier_xml_validation_warning(void *context, const char *msg, ...);', '+ static void rapier_xml_set_document_locator (void *ctx, xmlsaxlocatorptr loc);', '+     librdf_free(cstring, (char*)element->id);', '+ #endif', '+       if(rdf_parser->feature_allow_non_ns_attributes && attribute) {', '+     element->content_type=element->parent->content_type;', '+     if(element->parent->content_element_seen == 1 &&', '+        element->parent->content_cdata_seen == 1) {', '+       rapier_parser_warning(rdf_parser, ""element %s has mixed content."",', '+                             element->parent->name->qname);', '+     }', '+     if(element->parent->content_element_seen &&', '+        element->parent->content_cdata_all_whitespace &&', '+        element->parent->content_cdata) {', '+       librdf_free(rapier_ns_name_array, element->parent->content_cdata);', '+       element->parent->content_cdata=null;', '+       element->parent->content_cdata_length=0;', '+   fprintf(stderr, ""\\nrapier_xml_end_element_handler: end ns-element: "");', '+ #ifdef rapier_debug', ""+   fputc('\\n', stderr);"", '+ #endif', '+   librdf_debug3(rapier_xml_cdata_handler, ""in state %d - %s\\n"", state,', '+                 rapier_state_as_string(state));', '+     case rapier_state_parsetype_other:', '+     case rapier_state_parsetype_literal:', '+     case rapier_state_parsetype_resource:', '+      element->content_type != rapier_element_content_type_literal &&', '+      element->content_type != rapier_element_content_type_preserved) {', '+     librdf_debug2(rapier_xml_cdata_handler, ""ignoring whitespace cdata inside element %s\\n"", element->name->qname);', '+ #if 0', '+ #endif', '+   librdf_debug3(rapier_xml_cdata_handler,', '+                 ""ending in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+ #ifdef need_expat', '+ rapier_xml_external_entity_ref_handler(void *user_data,', '+           ""rapier_xml_external_entity_ref_handler: base %s systemid %s publicid %s\\n"",', '+           (base ? base : ""(none)""),', '+ #endif', '+ static const char* xml_validation_error_prefix=""xml parser validation error - "";', '+ static const char* xml_validation_warning_prefix=""xml parser validation warning - "";', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   nmsg=(char*)librdf_malloc(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_warning(rdf_parser, msg, args);', '+     rapier_parser_warning(rdf_parser, nmsg, args);', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   nmsg=(char*)librdf_malloc(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_error(rdf_parser, nmsg, args);', '+     rapier_parser_error(rdf_parser, nmsg, args);', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   nmsg=(char*)librdf_malloc(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+     librdf_free(cstring,nmsg);', '+   }', '+   va_end(args);', '+ }', '+ static void', '+ rapier_xml_validation_error(void *ctx, const char *msg, ...)', '+ {', '+   va_list args;', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   int length;', '+   char *nmsg;', '+   va_start(args, msg);', '+   length=strlen(xml_validation_error_prefix)+strlen(msg)+1;', '+   nmsg=(char*)librdf_malloc(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+   } else {', '+     strcpy(nmsg, xml_validation_error_prefix);', '+     strcat(nmsg, msg);', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+ static void', '+ rapier_xml_validation_warning(void *ctx, const char *msg, ...)', '+ {', '+   va_list args;', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   int length;', '+   char *nmsg;', '+   va_start(args, msg);', '+   length=strlen(xml_validation_warning_prefix)+strlen(msg)+1;', '+   nmsg=(char*)librdf_malloc(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_warning(rdf_parser, nmsg, args);', '+   } else {', '+     strcpy(nmsg, xml_validation_warning_prefix);', '+     strcat(nmsg, msg);', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+     librdf_free(cstring,nmsg);', '+   }', '+   va_end(args);', '+ }', '+ static void', '+ rapier_xml_set_document_locator (void *ctx, xmlsaxlocatorptr loc)', '+ {', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   locator->line=loc->getlinenumber(rdf_parser->xc);', '+   locator->column=loc->getcolumnnumber(rdf_parser->xc);', '+ }', '+   rdf_parser->sax.setdocumentlocator=rapier_xml_set_document_locator;', '+   xmlparserctxtptr xc=null;', '+     if(!xc) {', '+       fclose(fh);', '+       librdf_free(cstring, (void*)filename);', '+       return 1;', '+     }', '+     xc->userdata = rdf_parser;', '+     xc->vctxt.userdata = rdf_parser;', '+     xc->vctxt.error=rapier_xml_validation_error;', '+     xc->vctxt.warning=rapier_xml_validation_warning;', '+     rdf_parser->xc = xc;', '+   if(rc)', '+     rapier_parser_error(rdf_parser, ""xml parsing failed"");', '+   xmlfreeparserctxt(xc);', '+   if(!subject)', '+     librdf_fatal1(rapier_generate_statement, ""property has no subject"");', '+   if(!predicate)', '+     librdf_fatal1(rapier_generate_statement, ""property has no predicate"");', '+   if(!object)', '+     librdf_fatal1(rapier_generate_statement, ""statement has no object"");', '+   if(!element)', '+     librdf_fatal1(rapier_generate_property, ""property has no subject"");', '+   if(!element->uri)', '+     librdf_fatal1(rapier_generate_property, ""property has no subject uri"");', '+   if(!predicate)', '+     librdf_fatal1(rapier_generate_property, ""property has no predicate"");', '+   if(!value)', '+     librdf_fatal1(rapier_generate_property, ""property has no object"");', '+   while(tmpid/=10)', '+   librdf_uri *new_uri;', '+   char *qname;', '+   int len;', '+ #endif', '+ #if 0', '+   qname=librdf_malloc(cstring, len);', '+   if(!qname)', '+     return null;', ""+   *qname='#';"", '+   strcpy(qname+1, id);', '+   new_uri=librdf_new_uri_from_uri_qname(base_uri, qname);', '+   librdf_free(cstring, qname);', '+   return new_uri;', '+ #ifndef librdf_internal', '+ #endif', '+ #if 0', '+   return librdf_new_uri_relative_to_base(base_uri, uri_string);', '+   const char *el_name=element->name->qname;', '+   int element_in_rdf_ns=(element->name->namespace &&', '+                          element->name->namespace->is_rdf_ms);', '+   if(element->parent) {', '+     state=element->parent->child_state;', '+     if(!state) {', '+       state=element->parent->state;', '+       librdf_debug3(rapier_start_element_grammar,', '+                     ""no child state set - taking parent state %d - %s\\n"",', '+                     state, rapier_state_as_string(state));', '+     }', '+   } else', '+   librdf_debug3(rapier_start_element_grammar, ""starting in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+   finished= 0;', '+           element->child_state=rapier_state_obj;', '+         state=rapier_state_obj;', '+       case rapier_state_obj:', '+           }', '+           if(is_rdf_ms_concept(el_name, element->name->uri, seq)) {', '+             } else {', '+               if(element->rdf_attr_count -', '+                  (element->rdf_attr[rdf_attr_id] != null))', '+                 state=rapier_state_typed_node;', '+               else', '+                 state=rapier_state_seq;', '+             }', '+           }', '+           if(is_rdf_ms_concept(el_name, element->name->uri, bag)) {', '+             } else {', '+               if(element->rdf_attr_count -', '+                  (element->rdf_attr[rdf_attr_id] != null))', '+                 state=rapier_state_typed_node;', '+               else', '+                 state=rapier_state_bag;', '+             }', '+           }', '+           if(is_rdf_ms_concept(el_name, element->name->uri, alt)) {', '+             } else {', '+               if(element->rdf_attr_count -', '+                  (element->rdf_attr[rdf_attr_id] != null))', '+                 state=rapier_state_typed_node;', '+               else', '+                 state=rapier_state_alt;', '+             }', '+           }', '+           if(rdf_parser->container_test_handler) {', '+       case rapier_state_parsetype_resource:', '+           element->parent->content_type = rapier_element_content_type_resource;', '+         }', '+         element->child_state=rapier_state_propertyelt;', '+         element->content_type=rapier_element_content_type_properties;', '+         if(element->parent) {', '+           if(element->parent->object_uri)', '+             rapier_free_uri(element->parent->object_uri);', '+           element->parent->content_type = rapier_element_content_type_resource;', '+         }', '+         element->child_state=rapier_state_member;', '+             element->child_state=rapier_state_parsetype_literal;', '+             element->child_state=rapier_state_parsetype_resource;', '+               element->child_state=rapier_state_parsetype_other;', '+               element->child_state=rapier_state_parsetype_literal;', '+           element->child_state=rapier_state_inlineitem;', '+       case rapier_state_parsetype_other:', '+       case rapier_state_parsetype_literal:', '+         if(element_in_rdf_ns &&', '+            is_rdf_ms_concept(el_name, element->name->uri, li)) {', '+           state=rapier_state_member;', '+           break;', '+         }', '+         element->id=element->rdf_attr[rdf_attr_id];', '+             element->child_state=rapier_state_parsetype_literal;', '+             element->child_state=rapier_state_parsetype_resource;', '+               element->child_state=rapier_state_parsetype_other;', '+             else', '+               element->child_state=rapier_state_parsetype_literal;', '+         } else if(element->rdf_attr[rdf_attr_resource]) {', '+           element->uri=rapier_make_uri(rdf_parser->base_uri,', '+                                        element->rdf_attr[rdf_attr_resource]);', '+           if(element->parent) {', '+             if(element->parent->object_uri)', '+               rapier_free_uri(element->parent->object_uri);', '+             element->parent->object_uri=rapier_copy_uri(element->uri);', '+             element->parent->content_type = rapier_element_content_type_resource;', '+           }', '+           if(element->rdf_attr[rdf_attr_bagid]) {', '+             element->bag_id=element->rdf_attr[rdf_attr_bagid];', '+             element->bag_uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->bag_id);', '+           }', '+           rapier_process_property_attributes(rdf_parser, element);', '+           rapier_generate_property(rdf_parser,', '+                                    rapier_predicate_type_predicate,', '+                                    (void*)element->uri, 0);', '+           element->content_type = rapier_element_content_type_empty;', '+         } else {', '+           element->child_state=rapier_state_obj;', '+           element->content_type = rapier_element_content_type_unknown;', '+         rapier_parser_fatal_error(rdf_parser, ""rapier_start_element_grammar - unexpected parser state %d - %s\\n"", state, rapier_state_as_string(state));', '+       librdf_debug3(rapier_start_element_grammar,', '+                     ""moved to state %d - %s\\n"",', '+                     state, rapier_state_as_string(state));', '+   librdf_debug3(rapier_start_element_grammar,', '+                 ""ending in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+   const char *el_name=element->name->qname;', '+   int element_in_rdf_ns=(element->name->namespace &&', '+                          element->name->namespace->is_rdf_ms);', '+   librdf_debug3(rapier_end_element_grammar, ""starting in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+       case rapier_state_obj:', '+       case rapier_state_parsetype_resource:', '+         if(state != rapier_state_description &&', '+            element->parent &&', '+            element->parent->uri &&', '+            element->parent->state != rapier_state_description) {', '+           rapier_generate_statement(rdf_parser,', '+       case rapier_state_parsetype_other:', '+       case rapier_state_member:', '+         if(element->content_type == rapier_element_content_type_unknown) {', '+           if(element->content_cdata_seen)', '+             element->content_type= rapier_element_content_type_literal;', '+           else if (element->content_element_seen)', '+             element->content_type= rapier_element_content_type_properties;', '+           else', '+             element->content_type= rapier_element_content_type_empty;', '+         }', '+         if(element->content_type == rapier_element_content_type_empty) {', '+           const char *object_id=rapier_generate_id(rdf_parser, 0);', '+           if(object_id) {', '+             element->object_uri=rapier_make_uri_from_id(rdf_parser->base_uri,', '+                                                         object_id);', '+             librdf_free(cstring, object_id);', '+           }', '+         }', '+         if(element->parent &&', '+            element->parent->state == rapier_state_description) {', '+           int object_is_literal=(element->content_cdata != null);', '+           rapier_object_type object_type=object_is_literal ? rapier_object_type_literal : rapier_object_type_resource;', '+           void *object=object_is_literal ? (void*)element->content_cdata : (void*)element->object_uri;', '+           if(state == rapier_state_member) {', '+             element->parent->last_ordinal++;', '+             rapier_generate_ordinal_property(rdf_parser,', '+                                              element->parent,', '+                                              element->parent->last_ordinal,', '+                                              object, object_type);', '+           } else', '+             rapier_generate_statement(rdf_parser,', '+                                       element->parent->uri,', '+                                       rapier_subject_type_resource,', '+                                       element->name->uri,', '+                                       rapier_predicate_type_predicate,', '+                                       object, object_type);', '+         } else {', '+           int object_is_literal=(element->content_cdata != null);', '+           void *object=object_is_literal ? (void*)element->content_cdata : (void*)element->object_uri;', '+           switch(element->content_type) {', '+             case rapier_element_content_type_literal:', '+             case rapier_element_content_type_resource:', '+               if(state == rapier_state_member) {', '+                 rapier_object_type object_type=object_is_literal ? rapier_object_type_literal : rapier_object_type_resource;', '+                 element->parent->last_ordinal++;', '+                 rapier_generate_ordinal_property(rdf_parser,', '+                                                  element->parent,', '+                                                  element->parent->last_ordinal,', '+                                                  object,', '+                                                  object_type);', '+               } else', '+                 rapier_generate_property(rdf_parser,', '+                                          rapier_predicate_type_predicate,', '+                                          object, object_is_literal);', '+               break;', '+             case rapier_element_content_type_empty:', '+               if(state == rapier_state_member) {', '+                 element->parent->last_ordinal++;', '+                 rapier_generate_ordinal_property(rdf_parser,', '+                                                  element->parent,', '+                                                  element->parent->last_ordinal,', '+                                                  (void*)element->uri,', '+                                                  rapier_object_type_resource);', '+               } else', '+                 rapier_generate_property(rdf_parser,', '+                                          rapier_predicate_type_predicate,', '+                                          (void*)element->uri, 0);', '+               break;', '+             default:', '+               rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar state rapier_state_propertyelt - unexpected content type %d\\n"", element->content_type);', '+         rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar - unexpected parser state %d - %s\\n"", state, rapier_state_as_string(state));', '+       librdf_debug3(rapier_end_element_grammar, ""moved to state %d - %s\\n"",', '+                     state, rapier_state_as_string(state));', '+   librdf_debug3(rapier_end_element_grammar,', '+                 ""ending in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '- #define xml_char xmlchar', '- #include <parser.h>', '-   rapier_state_unknown = 0,', '-   rapier_state_in_rdf   = 6010,', '-   rapier_state_not_used_1   = 6020,', '-   rapier_state_parsetype_literal = 6301,', '-   rapier_state_parsetype_resource = 6302,', '-   rapier_state_container = 7000,', '-   rapier_state_parsetype_other = 7010,', '-   rapier_element_content_type_cdata,', '-   rapier_element_content_type_elements,', '- #define rapier_rdf_alt_uri librdf_ms_alt_uri', '- static void rapier_xml_warning(void *context, rapier_locator *locator, const char *msg, ...);', '- static void rapier_xml_error(void *context, rapier_locator *locator, const char *msg, ...);', '- static void rapier_xml_fatal_error(void *context, rapier_locator *locator, const char *msg, ...);', '-     librdf_free(cstring, element->id);', '-       if(rdf_parser->feature_allow_non_ns_attributes &&', '-          attribute && !attribute->namespace &&', '-          element_name->namespace && element_name->namespace->is_rdf_ms) {', '-     if(element->parent->content_type == rapier_element_content_type_unknown) {', '-       librdf_debug2(rapier_xml_start_element_handler, ""set element %s content type to elements\\n"", element->name->qname);', '-       element->parent->content_type=rapier_element_content_type_elements;', '-       if(element->parent->content_element_seen == 1 &&', '-          element->parent->content_cdata_seen == 1) {', '-         rapier_parser_warning(rdf_parser, ""element %s has mixed content."",', '-                               element->parent->name->qname);', '-       }', '-       if(element->parent->content_element_seen &&', '-          element->parent->content_cdata_all_whitespace) {', '-         librdf_free(rapier_ns_name_array, element->content_cdata);', '-         element->content_cdata=null;', '-         element->content_cdata_length=0;', '-       }', '-   }', '-   fprintf(stderr, ""rapier_xml_end_element_handler: end ns-element: "");', '-   int ignore_all_whitespace=0;', '-   librdf_debug2(rapier_xml_cdata_handler, ""in state %d\\n"", state);', '-     case rapier_state_parsetype_literal:', '-       break;', '-     case rapier_state_parsetype_resource:', '-     case rapier_state_parsetype_other:', '-   if(element->content_type == rapier_element_content_type_unknown) {', '-     if(!all_whitespace) {', '-       librdf_debug2(rapier_xml_end_element_handler, ""set element %s content type to cdata\\n"", element->name->qname);', '-       element->content_type=rapier_element_content_type_cdata;', '-     }', '-   }', '-      (ignore_all_whitespace ||', '-       element->content_type == rapier_element_content_type_elements)) {', '-     librdf_debug2(rapier_xml_end_element_handler, ""ignoring whitespace cdata inside element %s\\n"", element->name->qname);', '- rapier_xml_external_entity_ref_handler(xml_parser parser,', '-           ""rapier_xml_external_entity_ref_handler: context %s base %s systemid %s publicid %s\\n"",', '-           context, (base ? base : ""(none)""),', '-   msg=(char*)librdf_malloc(cstring, length);', '-   if(!msg) {', '-     rapier_parser_warning(parser, msg, args);', '-     rapier_parser_warning(parser, nmsg, args);', '-   msg=(char*)librdf_malloc(cstring, length);', '-   if(!msg) {', '-     rapier_parser_error(parser, msg, args);', '-     rapier_parser_error(parser, nmsg, args);', '-   msg=(char*)librdf_malloc(cstring, length);', '-   if(!msg) {', '-     rapier_parser_fatal_error(parser, msg, args);', '-     rapier_parser_fatal_error(parser, nmsg, args);', '- #ifdef need_libxml', '- #include <parserinternals.h>', '- static int myxmlsaxparsefile(xmlsaxhandlerptr sax, void *user_data, const char *filename);', '- static int', '- myxmlsaxparsefile(xmlsaxhandlerptr sax, void *user_data, const char *filename)', '- {', '-   int ret = 0;', '-   xmlparserctxtptr ctxt;', '-   ctxt = xmlcreatefileparserctxt(filename);', '-   if (ctxt == null) return -1;', '-   ctxt->sax = sax;', '-   ctxt->userdata = user_data;', '-   xmlparsedocument(ctxt);', '-   if (ctxt->wellformed)', '-     ret = 0;', '-   else', '-     ret = -1;', '-   if (sax)', '-     ctxt->sax = null;', '-   xmlfreeparserctxt(ctxt);', '-   return ret;', '- }', '- #endif', '-   xmlparserctxtptr xc;', '-   if(rc) {', '-     rapier_parser_error(parser, ""xml parsing failed"");', '-   while(tmpid/10)', '-   fixme;', '- #ifdef librdf_internal', '- #else', '-   fixme;', '-   finished= 0;', '-   if(element->parent)', '-     state=element->parent->state;', '-   else', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-           state=rapier_state_in_rdf;', '-         state=rapier_state_in_rdf;', '-       case rapier_state_in_rdf:', '-           } else if(is_rdf_ms_concept(el_name, element->name->uri, seq)) {', '-             } else', '-               state=rapier_state_seq;', '-           } else if(is_rdf_ms_concept(el_name, element->name->uri, bag)) {', '-             } else', '-               state=rapier_state_bag;', '-           } else if(is_rdf_ms_concept(el_name, element->name->uri, alt)) {', '-             } else', '-               state=rapier_state_alt;', '-           } else if(rdf_parser->container_test_handler) {', '-         }', '-         state=rapier_state_propertyelt;', '-         if(element->parent)', '-         state=rapier_state_member;', '-             state=rapier_state_parsetype_literal;', '-             state=rapier_state_parsetype_literal;', '-               state=rapier_state_parsetype_other;', '-               state=rapier_state_parsetype_literal;', '-           state=rapier_state_inlineitem;', '-       case rapier_state_parsetype_literal:', '-         finished=1;', '-         break;', '-       case rapier_state_parsetype_resource:', '-         finished=1;', '-         break;', '-       case rapier_state_parsetype_other:', '-         element->id=element->rdf_attr[rdf_attr_id];', '-         if(element->rdf_attr[rdf_attr_resource]) {', '-           element->uri=rapier_make_uri(rdf_parser->base_uri,', '-                                        element->rdf_attr[rdf_attr_resource]);', '-           if(element->rdf_attr[rdf_attr_bagid]) {', '-             element->bag_id=element->rdf_attr[rdf_attr_bagid];', '-             element->bag_uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->bag_id);', '-           }', '-           rapier_process_property_attributes(rdf_parser, element);', '-         }', '-             state=rapier_state_parsetype_literal;', '-             element->content_type=rapier_element_content_type_preserved;', '-             state=rapier_state_parsetype_resource;', '-               state=rapier_state_parsetype_other;', '-             else {', '-               state=rapier_state_parsetype_literal;', '-               element->content_type=rapier_element_content_type_preserved;', '-             }', '-         }', '-         rapier_parser_fatal_error(rdf_parser, ""rapier_start_element_grammar - unexpected parser state %d."", state);', '-       librdf_debug2(rapier_start_element_grammar, ""moved to state %d\\n"", state);', '-   librdf_debug2(rapier_end_element_grammar, ""in state %d\\n"", state);', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-       case rapier_state_in_rdf:', '-         if(state == rapier_state_typed_node &&', '-            element->content_type == rapier_element_content_type_elements) {', '-           rapier_generate_statement(rdf_parser,', '-       case rapier_state_member:', '-         finished=1;', '-         break;', '-       case rapier_state_parsetype_resource:', '-         finished=1;', '-         break;', '-       case rapier_state_parsetype_other:', '-         finished=1;', '-         break;', '-         if(element->content_cdata &&', '-            element->content_type == rapier_element_content_type_cdata)', '-           rapier_generate_property(rdf_parser,', '-                                    rapier_predicate_type_predicate,', '-                                    (void*)element->content_cdata, 1);', '-         if(element->content_type == rapier_element_content_type_elements) {', '-           rapier_generate_property(rdf_parser,', '-                                    rapier_predicate_type_predicate,', '-                                    (void*)element->object_uri, 0);', '-         rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar - unexpected parser state %d."", state);', '-       librdf_debug2(rapier_end_element_grammar, ""moved to state %d\\n"", state);']","['+ #define LIBRDF_DEBUG4(function, msg, arg1, arg2, arg3) do {fprintf(stderr, ""%s:%d:%s: "" msg, __FILE__, __LINE__, #function, arg1, arg2, arg3);} while(0)', '+ #define LIBRDF_FATAL1(function, msg) do {fprintf(stderr, ""%s:%d:%s: fatal error: "" msg, __FILE__, __LINE__ , #function); abort();} while(0)', '+ #define LIBRDF_FATAL2(function, msg,arg) do {fprintf(stderr, ""%s:%d:%s: fatal error: "" msg, __FILE__, __LINE__ , #function, arg); abort();} while(0)', '+ #ifdef HAVE_PARSER_H', '+ #include <parser.h>', '+ #else', '+ DIE', '+ #define XML_Char xmlChar', '+ #endif', '+   RAPIER_STATE_INVALID = 0,', '+   RAPIER_STATE_UNKNOWN = 1000,', '+   RAPIER_STATE_NOT_USED_1   = 6010,', '+   RAPIER_STATE_OBJ   = 6020,', '+   RAPIER_STATE_PARSETYPE_LITERAL = 6400,', '+   RAPIER_STATE_PARSETYPE_RESOURCE = 6410,', '+   RAPIER_STATE_CONTAINER = 6420,', '+   RAPIER_STATE_PARSETYPE_OTHER = 6430,', '+ static const char * const rapier_state_names[]={', '+   ""object (6.2)"",', '+   ""description (6.3)"",', '+   ""propertyElt (6.12)"",', '+   ""typed_node (6.13)"",', '+   ""sequence (6.25)"",', '+   ""bag (6.26)"",', '+   ""alternative (6.27)"",', '+   ""member (6.28)"",', '+   ""referencedItem (6.29)"",', '+   ""inlineItem (6.30 part 1)"",', '+   NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,', '+   ""parseTypeLiteral (6.30 part 2)"",', '+   ""parseTypeResource (6.30 part 3)"",', '+   ""container (not M&S)"",', '+   ""parseTypeOther (not M&S)"",', '+ };', '+ static const char * rapier_state_as_string(rapier_state state)', '+ {', '+   int offset=(state - 6000)/10;', '+   if(state == RAPIER_STATE_UNKNOWN)', '+     return ""UNKNOWN"";', '+   if(offset<0 || offset > 43)', '+     return ""INVALID"";', '+   if(!rapier_state_names[offset])', '+     return ""NOT-USED"";', '+   return rapier_state_names[offset];', '+ }', '+   RAPIER_ELEMENT_CONTENT_TYPE_EMPTY,', '+   RAPIER_ELEMENT_CONTENT_TYPE_LITERAL,', '+   RAPIER_ELEMENT_CONTENT_TYPE_PROPERTIES,', '+   RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE,', '+   xmlParserCtxtPtr xc;', '+ #define RAPIER_RDF_Alt_URI LIBRDF_MS_Alt_URI', '+ static void rapier_xml_warning(void *context, const char *msg, ...);', '+ static void rapier_xml_error(void *context, const char *msg, ...);', '+ static void rapier_xml_fatal_error(void *context, const char *msg, ...);', '+ static void rapier_xml_validation_error(void *context, const char *msg, ...);', '+ static void rapier_xml_validation_warning(void *context, const char *msg, ...);', '+ static void rapier_xml_set_document_locator (void *ctx, xmlSAXLocatorPtr loc);', '+     LIBRDF_FREE(cstring, (char*)element->id);', '+ #endif', '+       if(rdf_parser->feature_allow_non_ns_attributes && attribute) {', '+     element->content_type=element->parent->content_type;', '+     if(element->parent->content_element_seen == 1 &&', '+        element->parent->content_cdata_seen == 1) {', '+       rapier_parser_warning(rdf_parser, ""element %s has mixed content."",', '+                             element->parent->name->qname);', '+     }', '+     if(element->parent->content_element_seen &&', '+        element->parent->content_cdata_all_whitespace &&', '+        element->parent->content_cdata) {', '+       LIBRDF_FREE(rapier_ns_name_array, element->parent->content_cdata);', '+       element->parent->content_cdata=NULL;', '+       element->parent->content_cdata_length=0;', '+   fprintf(stderr, ""\\nrapier_xml_end_element_handler: End ns-element: "");', '+ #ifdef RAPIER_DEBUG', ""+   fputc('\\n', stderr);"", '+ #endif', '+   LIBRDF_DEBUG3(rapier_xml_cdata_handler, ""in state %d - %s\\n"", state,', '+                 rapier_state_as_string(state));', '+     case RAPIER_STATE_PARSETYPE_OTHER:', '+     case RAPIER_STATE_PARSETYPE_LITERAL:', '+     case RAPIER_STATE_PARSETYPE_RESOURCE:', '+      element->content_type != RAPIER_ELEMENT_CONTENT_TYPE_LITERAL &&', '+      element->content_type != RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED) {', '+     LIBRDF_DEBUG2(rapier_xml_cdata_handler, ""Ignoring whitespace cdata inside element %s\\n"", element->name->qname);', '+ #if 0', '+ #endif', '+   LIBRDF_DEBUG3(rapier_xml_cdata_handler,', '+                 ""ending in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+ #ifdef NEED_EXPAT', '+ rapier_xml_external_entity_ref_handler(void *user_data,', '+           ""rapier_xml_external_entity_ref_handler: base %s systemId %s publicId %s\\n"",', '+           (base ? base : ""(None)""),', '+ #endif', '+ static const char* xml_validation_error_prefix=""XML parser validation error - "";', '+ static const char* xml_validation_warning_prefix=""XML parser validation warning - "";', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_warning(rdf_parser, msg, args);', '+     rapier_parser_warning(rdf_parser, nmsg, args);', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_error(rdf_parser, nmsg, args);', '+     rapier_parser_error(rdf_parser, nmsg, args);', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+     LIBRDF_FREE(cstring,nmsg);', '+   }', '+   va_end(args);', '+ }', '+ static void', '+ rapier_xml_validation_error(void *ctx, const char *msg, ...)', '+ {', '+   va_list args;', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   int length;', '+   char *nmsg;', '+   va_start(args, msg);', '+   length=strlen(xml_validation_error_prefix)+strlen(msg)+1;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+   } else {', '+     strcpy(nmsg, xml_validation_error_prefix);', '+     strcat(nmsg, msg);', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+ static void', '+ rapier_xml_validation_warning(void *ctx, const char *msg, ...)', '+ {', '+   va_list args;', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   int length;', '+   char *nmsg;', '+   va_start(args, msg);', '+   length=strlen(xml_validation_warning_prefix)+strlen(msg)+1;', '+   nmsg=(char*)LIBRDF_MALLOC(cstring, length);', '+   if(!nmsg) {', '+     rapier_parser_warning(rdf_parser, nmsg, args);', '+   } else {', '+     strcpy(nmsg, xml_validation_warning_prefix);', '+     strcat(nmsg, msg);', '+     rapier_parser_fatal_error(rdf_parser, nmsg, args);', '+     LIBRDF_FREE(cstring,nmsg);', '+   }', '+   va_end(args);', '+ }', '+ static void', '+ rapier_xml_set_document_locator (void *ctx, xmlSAXLocatorPtr loc)', '+ {', '+   rapier_parser* rdf_parser=(rapier_parser*)ctx;', '+   locator->line=loc->getLineNumber(rdf_parser->xc);', '+   locator->column=loc->getColumnNumber(rdf_parser->xc);', '+ }', '+   rdf_parser->sax.setDocumentLocator=rapier_xml_set_document_locator;', '+   xmlParserCtxtPtr xc=NULL;', '+     if(!xc) {', '+       fclose(fh);', '+       LIBRDF_FREE(cstring, (void*)filename);', '+       return 1;', '+     }', '+     xc->userData = rdf_parser;', '+     xc->vctxt.userData = rdf_parser;', '+     xc->vctxt.error=rapier_xml_validation_error;', '+     xc->vctxt.warning=rapier_xml_validation_warning;', '+     rdf_parser->xc = xc;', '+   if(rc)', '+     rapier_parser_error(rdf_parser, ""XML Parsing failed"");', '+   xmlFreeParserCtxt(xc);', '+   if(!subject)', '+     LIBRDF_FATAL1(rapier_generate_statement, ""Property has no subject"");', '+   if(!predicate)', '+     LIBRDF_FATAL1(rapier_generate_statement, ""Property has no predicate"");', '+   if(!object)', '+     LIBRDF_FATAL1(rapier_generate_statement, ""Statement has no object"");', '+   if(!element)', '+     LIBRDF_FATAL1(rapier_generate_property, ""Property has no subject"");', '+   if(!element->uri)', '+     LIBRDF_FATAL1(rapier_generate_property, ""Property has no subject URI"");', '+   if(!predicate)', '+     LIBRDF_FATAL1(rapier_generate_property, ""Property has no predicate"");', '+   if(!value)', '+     LIBRDF_FATAL1(rapier_generate_property, ""Property has no object"");', '+   while(tmpid/=10)', '+   librdf_uri *new_uri;', '+   char *qname;', '+   int len;', '+ #endif', '+ #if 0', '+   qname=LIBRDF_MALLOC(cstring, len);', '+   if(!qname)', '+     return NULL;', ""+   *qname='#';"", '+   strcpy(qname+1, id);', '+   new_uri=librdf_new_uri_from_uri_qname(base_uri, qname);', '+   LIBRDF_FREE(cstring, qname);', '+   return new_uri;', '+ #ifndef LIBRDF_INTERNAL', '+ #endif', '+ #if 0', '+   return librdf_new_uri_relative_to_base(base_uri, uri_string);', '+   const char *el_name=element->name->qname;', '+   int element_in_rdf_ns=(element->name->namespace &&', '+                          element->name->namespace->is_rdf_ms);', '+   if(element->parent) {', '+     state=element->parent->child_state;', '+     if(!state) {', '+       state=element->parent->state;', '+       LIBRDF_DEBUG3(rapier_start_element_grammar,', '+                     ""NO CHILD STATE set - taking parent state %d - %s\\n"",', '+                     state, rapier_state_as_string(state));', '+     }', '+   } else', '+   LIBRDF_DEBUG3(rapier_start_element_grammar, ""starting in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+   finished= 0;', '+           element->child_state=RAPIER_STATE_OBJ;', '+         state=RAPIER_STATE_OBJ;', '+       case RAPIER_STATE_OBJ:', '+           }', '+           if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Seq)) {', '+             } else {', '+               if(element->rdf_attr_count -', '+                  (element->rdf_attr[RDF_ATTR_ID] != NULL))', '+                 state=RAPIER_STATE_TYPED_NODE;', '+               else', '+                 state=RAPIER_STATE_SEQ;', '+             }', '+           }', '+           if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Bag)) {', '+             } else {', '+               if(element->rdf_attr_count -', '+                  (element->rdf_attr[RDF_ATTR_ID] != NULL))', '+                 state=RAPIER_STATE_TYPED_NODE;', '+               else', '+                 state=RAPIER_STATE_BAG;', '+             }', '+           }', '+           if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Alt)) {', '+             } else {', '+               if(element->rdf_attr_count -', '+                  (element->rdf_attr[RDF_ATTR_ID] != NULL))', '+                 state=RAPIER_STATE_TYPED_NODE;', '+               else', '+                 state=RAPIER_STATE_ALT;', '+             }', '+           }', '+           if(rdf_parser->container_test_handler) {', '+       case RAPIER_STATE_PARSETYPE_RESOURCE:', '+           element->parent->content_type = RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE;', '+         }', '+         element->child_state=RAPIER_STATE_PROPERTYELT;', '+         element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_PROPERTIES;', '+         if(element->parent) {', '+           if(element->parent->object_uri)', '+             RAPIER_FREE_URI(element->parent->object_uri);', '+           element->parent->content_type = RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE;', '+         }', '+         element->child_state=RAPIER_STATE_MEMBER;', '+             element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;', '+             element->child_state=RAPIER_STATE_PARSETYPE_RESOURCE;', '+               element->child_state=RAPIER_STATE_PARSETYPE_OTHER;', '+               element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;', '+           element->child_state=RAPIER_STATE_INLINEITEM;', '+       case RAPIER_STATE_PARSETYPE_OTHER:', '+       case RAPIER_STATE_PARSETYPE_LITERAL:', '+         if(element_in_rdf_ns &&', '+            IS_RDF_MS_CONCEPT(el_name, element->name->uri, li)) {', '+           state=RAPIER_STATE_MEMBER;', '+           break;', '+         }', '+         element->id=element->rdf_attr[RDF_ATTR_ID];', '+             element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;', '+             element->child_state=RAPIER_STATE_PARSETYPE_RESOURCE;', '+               element->child_state=RAPIER_STATE_PARSETYPE_OTHER;', '+             else', '+               element->child_state=RAPIER_STATE_PARSETYPE_LITERAL;', '+         } else if(element->rdf_attr[RDF_ATTR_resource]) {', '+           element->uri=rapier_make_uri(rdf_parser->base_uri,', '+                                        element->rdf_attr[RDF_ATTR_resource]);', '+           if(element->parent) {', '+             if(element->parent->object_uri)', '+               RAPIER_FREE_URI(element->parent->object_uri);', '+             element->parent->object_uri=rapier_copy_uri(element->uri);', '+             element->parent->content_type = RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE;', '+           }', '+           if(element->rdf_attr[RDF_ATTR_bagID]) {', '+             element->bag_id=element->rdf_attr[RDF_ATTR_bagID];', '+             element->bag_uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->bag_id);', '+           }', '+           rapier_process_property_attributes(rdf_parser, element);', '+           rapier_generate_property(rdf_parser,', '+                                    RAPIER_PREDICATE_TYPE_PREDICATE,', '+                                    (void*)element->uri, 0);', '+           element->content_type = RAPIER_ELEMENT_CONTENT_TYPE_EMPTY;', '+         } else {', '+           element->child_state=RAPIER_STATE_OBJ;', '+           element->content_type = RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN;', '+         rapier_parser_fatal_error(rdf_parser, ""rapier_start_element_grammar - unexpected parser state %d - %s\\n"", state, rapier_state_as_string(state));', '+       LIBRDF_DEBUG3(rapier_start_element_grammar,', '+                     ""moved to state %d - %s\\n"",', '+                     state, rapier_state_as_string(state));', '+   LIBRDF_DEBUG3(rapier_start_element_grammar,', '+                 ""ending in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+   const char *el_name=element->name->qname;', '+   int element_in_rdf_ns=(element->name->namespace &&', '+                          element->name->namespace->is_rdf_ms);', '+   LIBRDF_DEBUG3(rapier_end_element_grammar, ""starting in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));', '+       case RAPIER_STATE_OBJ:', '+       case RAPIER_STATE_PARSETYPE_RESOURCE:', '+         if(state != RAPIER_STATE_DESCRIPTION &&', '+            element->parent &&', '+            element->parent->uri &&', '+            element->parent->state != RAPIER_STATE_DESCRIPTION) {', '+           rapier_generate_statement(rdf_parser,', '+       case RAPIER_STATE_PARSETYPE_OTHER:', '+       case RAPIER_STATE_MEMBER:', '+         if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN) {', '+           if(element->content_cdata_seen)', '+             element->content_type= RAPIER_ELEMENT_CONTENT_TYPE_LITERAL;', '+           else if (element->content_element_seen)', '+             element->content_type= RAPIER_ELEMENT_CONTENT_TYPE_PROPERTIES;', '+           else', '+             element->content_type= RAPIER_ELEMENT_CONTENT_TYPE_EMPTY;', '+         }', '+         if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_EMPTY) {', '+           const char *object_id=rapier_generate_id(rdf_parser, 0);', '+           if(object_id) {', '+             element->object_uri=rapier_make_uri_from_id(rdf_parser->base_uri,', '+                                                         object_id);', '+             LIBRDF_FREE(cstring, object_id);', '+           }', '+         }', '+         if(element->parent &&', '+            element->parent->state == RAPIER_STATE_DESCRIPTION) {', '+           int object_is_literal=(element->content_cdata != NULL);', '+           rapier_object_type object_type=object_is_literal ? RAPIER_OBJECT_TYPE_LITERAL : RAPIER_OBJECT_TYPE_RESOURCE;', '+           void *object=object_is_literal ? (void*)element->content_cdata : (void*)element->object_uri;', '+           if(state == RAPIER_STATE_MEMBER) {', '+             element->parent->last_ordinal++;', '+             rapier_generate_ordinal_property(rdf_parser,', '+                                              element->parent,', '+                                              element->parent->last_ordinal,', '+                                              object, object_type);', '+           } else', '+             rapier_generate_statement(rdf_parser,', '+                                       element->parent->uri,', '+                                       RAPIER_SUBJECT_TYPE_RESOURCE,', '+                                       element->name->uri,', '+                                       RAPIER_PREDICATE_TYPE_PREDICATE,', '+                                       object, object_type);', '+         } else {', '+           int object_is_literal=(element->content_cdata != NULL);', '+           void *object=object_is_literal ? (void*)element->content_cdata : (void*)element->object_uri;', '+           switch(element->content_type) {', '+             case RAPIER_ELEMENT_CONTENT_TYPE_LITERAL:', '+             case RAPIER_ELEMENT_CONTENT_TYPE_RESOURCE:', '+               if(state == RAPIER_STATE_MEMBER) {', '+                 rapier_object_type object_type=object_is_literal ? RAPIER_OBJECT_TYPE_LITERAL : RAPIER_OBJECT_TYPE_RESOURCE;', '+                 element->parent->last_ordinal++;', '+                 rapier_generate_ordinal_property(rdf_parser,', '+                                                  element->parent,', '+                                                  element->parent->last_ordinal,', '+                                                  object,', '+                                                  object_type);', '+               } else', '+                 rapier_generate_property(rdf_parser,', '+                                          RAPIER_PREDICATE_TYPE_PREDICATE,', '+                                          object, object_is_literal);', '+               break;', '+             case RAPIER_ELEMENT_CONTENT_TYPE_EMPTY:', '+               if(state == RAPIER_STATE_MEMBER) {', '+                 element->parent->last_ordinal++;', '+                 rapier_generate_ordinal_property(rdf_parser,', '+                                                  element->parent,', '+                                                  element->parent->last_ordinal,', '+                                                  (void*)element->uri,', '+                                                  RAPIER_OBJECT_TYPE_RESOURCE);', '+               } else', '+                 rapier_generate_property(rdf_parser,', '+                                          RAPIER_PREDICATE_TYPE_PREDICATE,', '+                                          (void*)element->uri, 0);', '+               break;', '+             default:', '+               rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar state RAPIER_STATE_PROPERTYELT - unexpected content type %d\\n"", element->content_type);', '+         rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar - unexpected parser state %d - %s\\n"", state, rapier_state_as_string(state));', '+       LIBRDF_DEBUG3(rapier_end_element_grammar, ""moved to state %d - %s\\n"",', '+                     state, rapier_state_as_string(state));', '+   LIBRDF_DEBUG3(rapier_end_element_grammar,', '+                 ""ending in state %d - %s\\n"",', '+                 state, rapier_state_as_string(state));']","['- #define XML_Char xmlChar', '- #include <parser.h>', '-   RAPIER_STATE_UNKNOWN = 0,', '-   RAPIER_STATE_IN_RDF   = 6010,', '-   RAPIER_STATE_NOT_USED_1   = 6020,', '-   RAPIER_STATE_PARSETYPE_LITERAL = 6301,', '-   RAPIER_STATE_PARSETYPE_RESOURCE = 6302,', '-   RAPIER_STATE_CONTAINER = 7000,', '-   RAPIER_STATE_PARSETYPE_OTHER = 7010,', '-   RAPIER_ELEMENT_CONTENT_TYPE_CDATA,', '-   RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS,', '- #define RAPIER_RDF_Alt_URI LIBRDF_MS_alt_URI', '- static void rapier_xml_warning(void *context, rapier_locator *locator, const char *msg, ...);', '- static void rapier_xml_error(void *context, rapier_locator *locator, const char *msg, ...);', '- static void rapier_xml_fatal_error(void *context, rapier_locator *locator, const char *msg, ...);', '-     LIBRDF_FREE(cstring, element->id);', '-       if(rdf_parser->feature_allow_non_ns_attributes &&', '-          attribute && !attribute->namespace &&', '-          element_name->namespace && element_name->namespace->is_rdf_ms) {', '-     if(element->parent->content_type == RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN) {', '-       LIBRDF_DEBUG2(rapier_xml_start_element_handler, ""Set element %s content type to elements\\n"", element->name->qname);', '-       element->parent->content_type=RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS;', '-       if(element->parent->content_element_seen == 1 &&', '-          element->parent->content_cdata_seen == 1) {', '-         rapier_parser_warning(rdf_parser, ""element %s has mixed content."",', '-                               element->parent->name->qname);', '-       }', '-       if(element->parent->content_element_seen &&', '-          element->parent->content_cdata_all_whitespace) {', '-         LIBRDF_FREE(rapier_ns_name_array, element->content_cdata);', '-         element->content_cdata=NULL;', '-         element->content_cdata_length=0;', '-       }', '-   }', '-   fprintf(stderr, ""rapier_xml_end_element_handler: End ns-element: "");', '-   int ignore_all_whitespace=0;', '-   LIBRDF_DEBUG2(rapier_xml_cdata_handler, ""in state %d\\n"", state);', '-     case RAPIER_STATE_PARSETYPE_LITERAL:', '-       break;', '-     case RAPIER_STATE_PARSETYPE_RESOURCE:', '-     case RAPIER_STATE_PARSETYPE_OTHER:', '-   if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_UNKNOWN) {', '-     if(!all_whitespace) {', '-       LIBRDF_DEBUG2(rapier_xml_end_element_handler, ""Set element %s content type to cdata\\n"", element->name->qname);', '-       element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_CDATA;', '-     }', '-   }', '-      (ignore_all_whitespace ||', '-       element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS)) {', '-     LIBRDF_DEBUG2(rapier_xml_end_element_handler, ""Ignoring whitespace cdata inside element %s\\n"", element->name->qname);', '- rapier_xml_external_entity_ref_handler(XML_Parser parser,', '-           ""rapier_xml_external_entity_ref_handler: context %s base %s systemId %s publicId %s\\n"",', '-           context, (base ? base : ""(None)""),', '-   msg=(char*)LIBRDF_MALLOC(cstring, length);', '-   if(!msg) {', '-     rapier_parser_warning(parser, msg, args);', '-     rapier_parser_warning(parser, nmsg, args);', '-   msg=(char*)LIBRDF_MALLOC(cstring, length);', '-   if(!msg) {', '-     rapier_parser_error(parser, msg, args);', '-     rapier_parser_error(parser, nmsg, args);', '-   msg=(char*)LIBRDF_MALLOC(cstring, length);', '-   if(!msg) {', '-     rapier_parser_fatal_error(parser, msg, args);', '-     rapier_parser_fatal_error(parser, nmsg, args);', '- #ifdef NEED_LIBXML', '- #include <parserInternals.h>', '- static int myXmlSAXParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename);', '- static int', '- myXmlSAXParseFile(xmlSAXHandlerPtr sax, void *user_data, const char *filename)', '- {', '-   int ret = 0;', '-   xmlParserCtxtPtr ctxt;', '-   ctxt = xmlCreateFileParserCtxt(filename);', '-   if (ctxt == NULL) return -1;', '-   ctxt->sax = sax;', '-   ctxt->userData = user_data;', '-   xmlParseDocument(ctxt);', '-   if (ctxt->wellFormed)', '-     ret = 0;', '-   else', '-     ret = -1;', '-   if (sax)', '-     ctxt->sax = NULL;', '-   xmlFreeParserCtxt(ctxt);', '-   return ret;', '- }', '- #endif', '-   xmlParserCtxtPtr xc;', '-   if(rc) {', '-     rapier_parser_error(parser, ""XML Parsing failed"");', '-   while(tmpid/10)', '-   FIXME;', '- #ifdef LIBRDF_INTERNAL', '- #else', '-   FIXME;', '-   finished= 0;', '-   if(element->parent)', '-     state=element->parent->state;', '-   else', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-           state=RAPIER_STATE_IN_RDF;', '-         state=RAPIER_STATE_IN_RDF;', '-       case RAPIER_STATE_IN_RDF:', '-           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Seq)) {', '-             } else', '-               state=RAPIER_STATE_SEQ;', '-           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Bag)) {', '-             } else', '-               state=RAPIER_STATE_BAG;', '-           } else if(IS_RDF_MS_CONCEPT(el_name, element->name->uri, Alt)) {', '-             } else', '-               state=RAPIER_STATE_ALT;', '-           } else if(rdf_parser->container_test_handler) {', '-         }', '-         state=RAPIER_STATE_PROPERTYELT;', '-         if(element->parent)', '-         state=RAPIER_STATE_MEMBER;', '-             state=RAPIER_STATE_PARSETYPE_LITERAL;', '-             state=RAPIER_STATE_PARSETYPE_LITERAL;', '-               state=RAPIER_STATE_PARSETYPE_OTHER;', '-               state=RAPIER_STATE_PARSETYPE_LITERAL;', '-           state=RAPIER_STATE_INLINEITEM;', '-       case RAPIER_STATE_PARSETYPE_LITERAL:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PARSETYPE_RESOURCE:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PARSETYPE_OTHER:', '-         element->id=element->rdf_attr[RDF_ATTR_ID];', '-         if(element->rdf_attr[RDF_ATTR_resource]) {', '-           element->uri=rapier_make_uri(rdf_parser->base_uri,', '-                                        element->rdf_attr[RDF_ATTR_resource]);', '-           if(element->rdf_attr[RDF_ATTR_bagID]) {', '-             element->bag_id=element->rdf_attr[RDF_ATTR_bagID];', '-             element->bag_uri=rapier_make_uri_from_id(rdf_parser->base_uri, element->bag_id);', '-           }', '-           rapier_process_property_attributes(rdf_parser, element);', '-         }', '-             state=RAPIER_STATE_PARSETYPE_LITERAL;', '-             element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED;', '-             state=RAPIER_STATE_PARSETYPE_RESOURCE;', '-               state=RAPIER_STATE_PARSETYPE_OTHER;', '-             else {', '-               state=RAPIER_STATE_PARSETYPE_LITERAL;', '-               element->content_type=RAPIER_ELEMENT_CONTENT_TYPE_PRESERVED;', '-             }', '-         }', '-         rapier_parser_fatal_error(rdf_parser, ""rapier_start_element_grammar - unexpected parser state %d."", state);', '-       LIBRDF_DEBUG2(rapier_start_element_grammar, ""moved to state %d\\n"", state);', '-   LIBRDF_DEBUG2(rapier_end_element_grammar, ""in state %d\\n"", state);', '-     const char *el_name=element->name->qname;', '-     int element_in_rdf_ns=(element->name->namespace &&', '-                            element->name->namespace->is_rdf_ms);', '-       case RAPIER_STATE_IN_RDF:', '-         if(state == RAPIER_STATE_TYPED_NODE &&', '-            element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS) {', '-           rapier_generate_statement(rdf_parser,', '-       case RAPIER_STATE_MEMBER:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PARSETYPE_RESOURCE:', '-         finished=1;', '-         break;', '-       case RAPIER_STATE_PARSETYPE_OTHER:', '-         finished=1;', '-         break;', '-         if(element->content_cdata &&', '-            element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_CDATA)', '-           rapier_generate_property(rdf_parser,', '-                                    RAPIER_PREDICATE_TYPE_PREDICATE,', '-                                    (void*)element->content_cdata, 1);', '-         if(element->content_type == RAPIER_ELEMENT_CONTENT_TYPE_ELEMENTS) {', '-           rapier_generate_property(rdf_parser,', '-                                    RAPIER_PREDICATE_TYPE_PREDICATE,', '-                                    (void*)element->object_uri, 0);', '-         rapier_parser_fatal_error(rdf_parser, ""rapier_end_element_grammar - unexpected parser state %d."", state);', '-       LIBRDF_DEBUG2(rapier_end_element_grammar, ""moved to state %d\\n"", state);']",397,181.0,578.0,0356ae807f03c59393e17cb6c20c7efba6d1197fdajobe/raptor,[]
c3e3c98ec666812daaaca896cf5ef758a8a6df14,php/php-src,ext/standard/exec.c,train,C,1,"['@@ -200,7 +200,7 @@ static void php_exec_ex(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */\n \t}\n \tif (ret_code) {\n \t\tzval_dtor(ret_code);\n-\t\tZVAL_INT(ret_code, ret);\n+\t\tZVAL_LONG(ret_code, ret);\n \t}\n }\n /* }}} */\n@@ -247,7 +247,7 @@ PHPAPI zend_string *php_escape_shell_cmd(char *str)\n \n \tTSRMLS_FETCH();\n \n-\tcmd = STR_ALLOC(2 * l, 0);\n+\tcmd = zend_string_alloc(2 * l, 0);\n \n \tfor (x = 0, y = 0; x < l; x++) {\n \t\tint mb_len = php_mblen(str + x, (l - x));\n@@ -320,7 +320,7 @@ PHPAPI zend_string *php_escape_shell_cmd(char *str)\n \tif ((estimate - y) > 4096) {\n \t\t/* realloc if the estimate was way overill\n \t\t * Arbitrary cutoff point of 4096 */\n-\t\tcmd = STR_REALLOC(cmd, y, 0);\n+\t\tcmd = zend_string_realloc(cmd, y, 0);\n \t}\n \n \tcmd->len = y;\n@@ -339,7 +339,7 @@ PHPAPI zend_string *php_escape_shell_arg(char *str)\n \n \tTSRMLS_FETCH();\n \n-\tcmd = STR_ALLOC(4 * l + 2, 0); /* worst case */\n+\tcmd = zend_string_alloc(4 * l + 2, 0); /* worst case */\n \n #ifdef PHP_WIN32\n \tcmd->val[y++] = \'""\';\n@@ -387,7 +387,7 @@ PHPAPI zend_string *php_escape_shell_arg(char *str)\n \tif ((estimate - y) > 4096) {\n \t\t/* realloc if the estimate was way overill\n \t\t * Arbitrary cutoff point of 4096 */\n-\t\tcmd = STR_REALLOC(cmd, y, 0);\n+\t\tcmd = zend_string_realloc(cmd, y, 0);\n \t}\n \tcmd->len = y;\n \treturn cmd;\n@@ -470,9 +470,9 @@ PHP_FUNCTION(shell_exec)\n    Change the priority of the current process */\n PHP_FUNCTION(proc_nice)\n {\n-\tphp_int_t pri;\n+\tzend_long pri;\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""i"", &pri) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &pri) == FAILURE) {\n \t\tRETURN_FALSE;\n \t}\n \n']",2014-08-25 19:24:55+02:00,master renames phase 1,"[['+ \tcmd = zend_string_alloc(2 * l, 0);', '+ \t\tcmd = zend_string_realloc(cmd, y, 0);', '+ \t\tcmd = zend_string_realloc(cmd, y, 0);', '+ \tzend_long pri;', '+ \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &pri) == FAILURE) {', '- \tcmd = STR_ALLOC(2 * l, 0);', '- \t\tcmd = STR_REALLOC(cmd, y, 0);', '- \t\tcmd = STR_REALLOC(cmd, y, 0);', '- \tphp_int_t pri;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""i"", &pri) == FAILURE) {']]","[['+ \tcmd = zend_string_alloc(2 * l, 0);', '+ \t\tcmd = zend_string_realloc(cmd, y, 0);', '+ \t\tcmd = zend_string_realloc(cmd, y, 0);', '+ \tzend_long pri;', '+ \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""l"", &pri) == failure) {', '- \tcmd = str_alloc(2 * l, 0);', '- \t\tcmd = str_realloc(cmd, y, 0);', '- \t\tcmd = str_realloc(cmd, y, 0);', '- \tphp_int_t pri;', '- \tif (zend_parse_parameters(zend_num_args() tsrmls_cc, ""i"", &pri) == failure) {']]","[['+ \tcmd = zend_string_alloc(2 * l, 0);', '+ \t\tcmd = zend_string_realloc(cmd, y, 0);', '+ \t\tcmd = zend_string_realloc(cmd, y, 0);', '+ \tzend_long pri;', '+ \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &pri) == FAILURE) {']]","[['- \tcmd = STR_ALLOC(2 * l, 0);', '- \t\tcmd = STR_REALLOC(cmd, y, 0);', '- \t\tcmd = STR_REALLOC(cmd, y, 0);', '- \tphp_int_t pri;', '- \tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""i"", &pri) == FAILURE) {']]",5,5.0,10.0,c3e3c98ec666812daaaca896cf5ef758a8a6df14php/php-src,['2871c70efaaaa0f102557a17c727fd4d5204dd4b']
f9b1aa2161e755a5f5b772b5698aab8a63d0bef4,ivmai/bdwgc,malloc.c,train,C,1,"['@@ -108,74 +108,6 @@ out:\n     return((ptr_t)op);\n }\n \n-/* Allocate a composite object of size n bytes.  The caller guarantees\t*/\n-/* that pointers past the first page are not relevant.  Caller holds\t*/\n-/* allocation lock.\t\t\t\t\t\t\t*/\n-ptr_t GC_generic_malloc_inner_ignore_off_page(lb, k)\n-register size_t lb;\n-register int k;\n-{\n-    register struct hblk * h;\n-    register word n_blocks;\n-    register word lw;\n-    register ptr_t op;\n-\n-    if (lb <= HBLKSIZE)\n-        return(GC_generic_malloc_inner((word)lb, k));\n-    n_blocks = divHBLKSZ(ADD_SLOP(lb) + HDR_BYTES + HBLKSIZE-1);\n-    if (!GC_is_initialized) GC_init_inner();\n-    /* Do our share of marking work */\n-    if(GC_incremental && !GC_dont_gc)\n-\tGC_collect_a_little_inner((int)n_blocks);\n-    lw = ROUNDED_UP_WORDS(lb);\n-    while ((h = GC_allochblk(lw, k, IGNORE_OFF_PAGE)) == 0\n-\t   && GC_collect_or_expand(n_blocks, TRUE));\n-    if (h == 0) {\n-\top = 0;\n-    } else {\n-\top = (ptr_t) (h -> hb_body);\n-\tGC_words_wasted += BYTES_TO_WORDS(n_blocks * HBLKSIZE) - lw;\n-    }\n-    GC_words_allocd += lw;\n-    return((ptr_t)op);\n-}\n-\n-ptr_t GC_generic_malloc_ignore_off_page(lb, k)\n-register size_t lb;\n-register int k;\n-{\n-    register ptr_t result;\n-    DCL_LOCK_STATE;\n-    \n-    GC_invoke_finalizers();\n-    DISABLE_SIGNALS();\n-    LOCK();\n-    result = GC_generic_malloc_inner_ignore_off_page(lb,k);\n-    UNLOCK();\n-    ENABLE_SIGNALS();\n-    return(result);\n-}\n-\n-# if defined(__STDC__) || defined(__cplusplus)\n-  void * GC_malloc_ignore_off_page(size_t lb)\n-# else\n-  char * GC_malloc_ignore_off_page(lb)\n-  register size_t lb;\n-# endif\n-{\n-    return((GC_PTR)GC_generic_malloc_ignore_off_page(lb, NORMAL));\n-}\n-\n-# if defined(__STDC__) || defined(__cplusplus)\n-  void * GC_malloc_atomic_ignore_off_page(size_t lb)\n-# else\n-  char * GC_malloc_atomic_ignore_off_page(lb)\n-  register size_t lb;\n-# endif\n-{\n-    return((GC_PTR)GC_generic_malloc_ignore_off_page(lb, PTRFREE));\n-}\n-\n ptr_t GC_generic_malloc(lb, k)\n register word lb;\n register int k;\n@@ -189,111 +121,13 @@ register int k;\n     result = GC_generic_malloc_inner(lb, k);\n     UNLOCK();\n     ENABLE_SIGNALS();\n-    return(result);\n-}   \n-\n-\n-/* Analogous to the above, but assumes a small object size, and \t*/\n-/* bypasses MERGE_SIZES mechanism.  Used by gc_inline.h.\t\t*/\n-ptr_t GC_generic_malloc_words_small(lw, k)\n-register word lw;\n-register int k;\n-{\n-register ptr_t op;\n-register ptr_t *opp;\n-register struct obj_kind * kind = GC_obj_kinds + k;\n-DCL_LOCK_STATE;\n-\n-    GC_invoke_finalizers();\n-    DISABLE_SIGNALS();\n-    LOCK();\n-    opp = &(kind -> ok_freelist[lw]);\n-    if( (op = *opp) == 0 ) {\n-        if (!GC_is_initialized) {\n-            GC_init_inner();\n-        }\n-\tif (kind -> ok_reclaim_list == 0) {\n-\t    if (!GC_alloc_reclaim_list(kind)) goto out;\n-\t}\n-\top = GC_clear_stack(GC_allocobj(lw, k));\n-\tif (op == 0) goto out;\n-    }\n-    *opp = obj_link(op);\n-    obj_link(op) = 0;\n-    GC_words_allocd += lw;\n-    \n-out:\n-    UNLOCK();\n-    ENABLE_SIGNALS();\n-    return((ptr_t)op);\n-}\n-\n-#if defined(THREADS) && !defined(SRC_M3)\n-/* Return a list of 1 or more objects of the indicated size, linked\t*/\n-/* through the first word in the object.  This has the advantage that\t*/\n-/* it acquires the allocation lock only once, and may greatly reduce\t*/\n-/* time wasted contending for the allocation lock.  Typical usage would */\n-/* be in a thread that requires many items of the same size.  It would\t*/\n-/* keep its own free list in thread-local storage, and call\t\t*/\n-/* GC_malloc_many or friends to replenish it.  (We do not round up\t*/\n-/* object sizes, since a call indicates the intention to consume many\t*/\n-/* objects of exactly this size.)\t\t\t\t\t*/\n-/* Note that the client should usually clear the link field.\t\t*/\n-ptr_t GC_generic_malloc_many(lb, k)\n-register word lb;\n-register int k;\n-{\n-ptr_t op;\n-register ptr_t p;\n-ptr_t *opp;\n-word lw;\n-register word my_words_allocd;\n-DCL_LOCK_STATE;\n-\n-    if (!SMALL_OBJ(lb)) {\n-        op = GC_generic_malloc(lb, k);\n-        obj_link(op) = 0;\n-        return(op);\n-    }\n-    lw = ALIGNED_WORDS(lb);\n-    GC_invoke_finalizers();\n-    DISABLE_SIGNALS();\n-    LOCK();\n-    opp = &(GC_obj_kinds[k].ok_freelist[lw]);\n-    if( (op = *opp) == 0 ) {\n-        if (!GC_is_initialized) {\n-            GC_init_inner();\n-        }\n-\top = GC_clear_stack(GC_allocobj(lw, k));\n-\tif (op == 0) goto out;\n-    }\n-    *opp = 0;\n-    my_words_allocd = 0;\n-    for (p = op; p != 0; p = obj_link(p)) {\n-        my_words_allocd += lw;\n-        if (my_words_allocd >= BODY_SZ) {\n-            *opp = obj_link(p);\n-            obj_link(p) = 0;\n-            break;\n-        }\n+    if (0 == result) {\n+        return((*GC_oom_fn)(lb));\n+    } else {\n+        return(result);\n     }\n-    GC_words_allocd += my_words_allocd;\n-    \n-out:\n-    UNLOCK();\n-    ENABLE_SIGNALS();\n-    return(op);\n-\n-}\n-\n-void * GC_malloc_many(size_t lb)\n-{\n-    return(GC_generic_malloc_many(lb, NORMAL));\n-}\n+}   \n \n-/* Note that the ""atomic"" version of this would be unsafe, since the\t*/\n-/* links would not be seen by the collector.\t\t\t\t*/\n-# endif\n \n #define GENERAL_MALLOC(lb,k) \\\n     (GC_PTR)GC_clear_stack(GC_generic_malloc((word)lb, k))\n@@ -396,66 +230,6 @@ DCL_LOCK_STATE;\n   }\n # endif /* REDIRECT_MALLOC */\n \n-/* Allocate lb bytes of pointerful, traced, but not collectable data */\n-# ifdef __STDC__\n-    GC_PTR GC_malloc_uncollectable(size_t lb)\n-# else\n-    GC_PTR GC_malloc_uncollectable(lb)\n-    size_t lb;\n-# endif\n-{\n-register ptr_t op;\n-register ptr_t *opp;\n-register word lw;\n-DCL_LOCK_STATE;\n-\n-    if( SMALL_OBJ(lb) ) {\n-#       ifdef MERGE_SIZES\n-#\t  ifdef ADD_BYTE_AT_END\n-\t    if (lb != 0) lb--;\n-\t    \t  /* We don\'t need the extra byte, since this won\'t be\t*/\n-\t    \t  /* collected anyway.\t\t\t\t\t*/\n-#\t  endif\n-\t  lw = GC_size_map[lb];\n-#\telse\n-\t  lw = ALIGNED_WORDS(lb);\n-#       endif\n-\topp = &(GC_uobjfreelist[lw]);\n-\tFASTLOCK();\n-        if( FASTLOCK_SUCCEEDED() && (op = *opp) != 0 ) {\n-            /* See above comment on signals.\t*/\n-            *opp = obj_link(op);\n-            obj_link(op) = 0;\n-            GC_words_allocd += lw;\n-            GC_set_mark_bit(op);\n-            GC_non_gc_bytes += WORDS_TO_BYTES(lw);\n-            FASTUNLOCK();\n-            return((GC_PTR) op);\n-        }\n-        FASTUNLOCK();\n-        op = (ptr_t)GC_generic_malloc((word)lb, UNCOLLECTABLE);\n-    } else {\n-\top = (ptr_t)GC_generic_malloc((word)lb, UNCOLLECTABLE);\n-    }\n-    /* We don\'t need the lock here, since we have an undisguised \t*/\n-    /* pointer.  We do need to hold the lock while we adjust\t\t*/\n-    /* mark bits.\t\t\t\t\t\t\t*/\n-    {\n-\tregister struct hblk * h;\n-\t\n-\th = HBLKPTR(op);\n-\tlw = HDR(h) -> hb_sz;\n-\t\n-\tDISABLE_SIGNALS();\n-\tLOCK();\n-\tGC_set_mark_bit(op);\n-\tGC_non_gc_bytes += WORDS_TO_BYTES(lw);\n-\tUNLOCK();\n-\tENABLE_SIGNALS();\n-\treturn((GC_PTR) op);\n-    }\n-}\n-\n GC_PTR GC_generic_or_special_malloc(lb,knd)\n word lb;\n int knd;\n@@ -471,6 +245,10 @@ int knd;\n \t    return(GC_malloc((size_t)lb));\n \tcase UNCOLLECTABLE:\n \t    return(GC_malloc_uncollectable((size_t)lb));\n+#       ifdef ATOMIC_UNCOLLECTABLE\n+\t  case AUNCOLLECTABLE:\n+\t    return(GC_malloc_atomic_uncollectable((size_t)lb));\n+#\tendif /* ATOMIC_UNCOLLECTABLE */\n \tdefault:\n \t    return(GC_generic_malloc(lb,knd));\n     }\n@@ -514,7 +292,7 @@ int obj_kind;\n \t  descr = GC_obj_kinds[obj_kind].ok_descriptor;\n           if (GC_obj_kinds[obj_kind].ok_relocate_descr) descr += sz;\n           hhdr -> hb_descr = descr;\n-\t  if (obj_kind == UNCOLLECTABLE) GC_non_gc_bytes += (sz - orig_sz);\n+\t  if (IS_UNCOLLECTABLE(obj_kind)) GC_non_gc_bytes += (sz - orig_sz);\n \t  /* Extra area is already cleared by allochblk. */\n     }\n     if (ADD_SLOP(lb) <= sz) {\n@@ -538,7 +316,9 @@ int obj_kind;\n \t          /* Could also return original object.  But this \t*/\n \t          /* gives the client warning of imminent disaster.\t*/\n \t      BCOPY(p, result, lb);\n-\t      GC_free(p);\n+#\t      ifndef IGNORE_FREE\n+\t        GC_free(p);\n+#\t      endif\n \t      return(result);\n \t}\n     } else {\n@@ -548,7 +328,9 @@ int obj_kind;\n \n \t  if (result == 0) return(0);\n \t  BCOPY(p, result, sz);\n-\t  GC_free(p);\n+#\t  ifndef IGNORE_FREE\n+\t    GC_free(p);\n+#\t  endif\n \t  return(result);\n     }\n }\n@@ -597,7 +379,10 @@ int obj_kind;\n \tGC_mem_freed += sz;\n \t/* A signal here can make GC_mem_freed and GC_non_gc_bytes\t*/\n \t/* inconsistent.  We claim this is benign.\t\t\t*/\n-\tif (knd == UNCOLLECTABLE) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);\n+\tif (IS_UNCOLLECTABLE(knd)) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);\n+\t\t/* Its unnecessary to clear the mark bit.  If the \t*/\n+\t\t/* object is reallocated, it doesn\'t matter.  O.w. the\t*/\n+\t\t/* collector will do it, since it\'s on a free list.\t*/\n \tif (ok -> ok_init) {\n \t    BZERO((word *)p + 1, WORDS_TO_BYTES(sz-1));\n \t}\n@@ -612,7 +397,7 @@ int obj_kind;\n     \tDISABLE_SIGNALS();\n         LOCK();\n         GC_mem_freed += sz;\n-\tif (knd == UNCOLLECTABLE) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);\n+\tif (IS_UNCOLLECTABLE(knd)) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);\n         GC_freehblk(h);\n         UNLOCK();\n         ENABLE_SIGNALS();\n@@ -627,6 +412,8 @@ int obj_kind;\n       GC_PTR p;\n #   endif\n   {\n+#   ifndef IGNORE_FREE\n       GC_free(p);\n+#   endif\n   }\n # endif  /* REDIRECT_MALLOC */\n']",2011-07-26 15:09:22+04:00,gc4.11 tarball import,"[['+     if (0 == result) {', '+         return((*GC_oom_fn)(lb));', '+     } else {', '+         return(result);', '+ }', '+ #       ifdef ATOMIC_UNCOLLECTABLE', '+ \t  case AUNCOLLECTABLE:', '+ \t    return(GC_malloc_atomic_uncollectable((size_t)lb));', '+ \t  if (IS_UNCOLLECTABLE(obj_kind)) GC_non_gc_bytes += (sz - orig_sz);', '+ #\t      ifndef IGNORE_FREE', '+ \t        GC_free(p);', '+ #\t      endif', '+ #\t  ifndef IGNORE_FREE', '+ \t    GC_free(p);', '+ #\t  endif', '+ \tif (IS_UNCOLLECTABLE(knd)) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);', '+ \tif (IS_UNCOLLECTABLE(knd)) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);', '+ #   ifndef IGNORE_FREE', '+ #   endif', '- ptr_t GC_generic_malloc_inner_ignore_off_page(lb, k)', '- register size_t lb;', '- register int k;', '- {', '-     register struct hblk * h;', '-     register word n_blocks;', '-     register word lw;', '-     register ptr_t op;', '- ', '-     if (lb <= HBLKSIZE)', '-         return(GC_generic_malloc_inner((word)lb, k));', '-     n_blocks = divHBLKSZ(ADD_SLOP(lb) + HDR_BYTES + HBLKSIZE-1);', '-     if (!GC_is_initialized) GC_init_inner();', '-     if(GC_incremental && !GC_dont_gc)', '- \tGC_collect_a_little_inner((int)n_blocks);', '-     lw = ROUNDED_UP_WORDS(lb);', '-     while ((h = GC_allochblk(lw, k, IGNORE_OFF_PAGE)) == 0', '- \t   && GC_collect_or_expand(n_blocks, TRUE));', '-     if (h == 0) {', '- \top = 0;', '-     } else {', '- \top = (ptr_t) (h -> hb_body);', '- \tGC_words_wasted += BYTES_TO_WORDS(n_blocks * HBLKSIZE) - lw;', '-     }', '-     GC_words_allocd += lw;', '-     return((ptr_t)op);', '- }', '- ', '- ptr_t GC_generic_malloc_ignore_off_page(lb, k)', '- register size_t lb;', '- register int k;', '- {', '-     register ptr_t result;', '-     DCL_LOCK_STATE;', '- ', '-     GC_invoke_finalizers();', '-     DISABLE_SIGNALS();', '-     LOCK();', '-     result = GC_generic_malloc_inner_ignore_off_page(lb,k);', '-     UNLOCK();', '-     ENABLE_SIGNALS();', '-     return(result);', '- }', '- ', '- # if defined(__STDC__) || defined(__cplusplus)', '-   void * GC_malloc_ignore_off_page(size_t lb)', '- # else', '-   char * GC_malloc_ignore_off_page(lb)', '-   register size_t lb;', '- # endif', '- {', '-     return((GC_PTR)GC_generic_malloc_ignore_off_page(lb, NORMAL));', '- }', '- ', '- # if defined(__STDC__) || defined(__cplusplus)', '-   void * GC_malloc_atomic_ignore_off_page(size_t lb)', '- # else', '-   char * GC_malloc_atomic_ignore_off_page(lb)', '-   register size_t lb;', '- # endif', '- {', '-     return((GC_PTR)GC_generic_malloc_ignore_off_page(lb, PTRFREE));', '- }', '- ', '-     return(result);', '- }', '- ', '- ', '- ptr_t GC_generic_malloc_words_small(lw, k)', '- register word lw;', '- register int k;', '- {', '- register ptr_t op;', '- register ptr_t *opp;', '- register struct obj_kind * kind = GC_obj_kinds + k;', '- DCL_LOCK_STATE;', '- ', '-     GC_invoke_finalizers();', '-     DISABLE_SIGNALS();', '-     LOCK();', '-     opp = &(kind -> ok_freelist[lw]);', '-     if( (op = *opp) == 0 ) {', '-         if (!GC_is_initialized) {', '-             GC_init_inner();', '-         }', '- \tif (kind -> ok_reclaim_list == 0) {', '- \t    if (!GC_alloc_reclaim_list(kind)) goto out;', '- \t}', '- \top = GC_clear_stack(GC_allocobj(lw, k));', '- \tif (op == 0) goto out;', '-     }', '-     *opp = obj_link(op);', '-     obj_link(op) = 0;', '-     GC_words_allocd += lw;', '- ', '- out:', '-     UNLOCK();', '-     ENABLE_SIGNALS();', '-     return((ptr_t)op);', '- }', '- ', '- #if defined(THREADS) && !defined(SRC_M3)', '- ptr_t GC_generic_malloc_many(lb, k)', '- register word lb;', '- register int k;', '- {', '- ptr_t op;', '- register ptr_t p;', '- ptr_t *opp;', '- word lw;', '- register word my_words_allocd;', '- DCL_LOCK_STATE;', '- ', '-     if (!SMALL_OBJ(lb)) {', '-         op = GC_generic_malloc(lb, k);', '-         obj_link(op) = 0;', '-         return(op);', '-     }', '-     lw = ALIGNED_WORDS(lb);', '-     GC_invoke_finalizers();', '-     DISABLE_SIGNALS();', '-     LOCK();', '-     opp = &(GC_obj_kinds[k].ok_freelist[lw]);', '-     if( (op = *opp) == 0 ) {', '-         if (!GC_is_initialized) {', '-             GC_init_inner();', '-         }', '- \top = GC_clear_stack(GC_allocobj(lw, k));', '- \tif (op == 0) goto out;', '-     }', '-     *opp = 0;', '-     my_words_allocd = 0;', '-     for (p = op; p != 0; p = obj_link(p)) {', '-         my_words_allocd += lw;', '-         if (my_words_allocd >= BODY_SZ) {', '-             *opp = obj_link(p);', '-             obj_link(p) = 0;', '-             break;', '-         }', '-     GC_words_allocd += my_words_allocd;', '- ', '- out:', '-     UNLOCK();', '-     ENABLE_SIGNALS();', '-     return(op);', '- ', '- }', '- ', '- void * GC_malloc_many(size_t lb)', '- {', '-     return(GC_generic_malloc_many(lb, NORMAL));', '- }', '- # endif', '- # ifdef __STDC__', '-     GC_PTR GC_malloc_uncollectable(size_t lb)', '- # else', '-     GC_PTR GC_malloc_uncollectable(lb)', '-     size_t lb;', '- # endif', '- {', '- register ptr_t op;', '- register ptr_t *opp;', '- register word lw;', '- DCL_LOCK_STATE;', '- ', '-     if( SMALL_OBJ(lb) ) {', '- #       ifdef MERGE_SIZES', '- #\t  ifdef ADD_BYTE_AT_END', '- \t    if (lb != 0) lb--;', '- #\t  endif', '- \t  lw = GC_size_map[lb];', '- #\telse', '- \t  lw = ALIGNED_WORDS(lb);', '- #       endif', '- \topp = &(GC_uobjfreelist[lw]);', '- \tFASTLOCK();', '-         if( FASTLOCK_SUCCEEDED() && (op = *opp) != 0 ) {', '-             *opp = obj_link(op);', '-             obj_link(op) = 0;', '-             GC_words_allocd += lw;', '-             GC_set_mark_bit(op);', '-             GC_non_gc_bytes += WORDS_TO_BYTES(lw);', '-             FASTUNLOCK();', '-             return((GC_PTR) op);', '-         }', '-         FASTUNLOCK();', '-         op = (ptr_t)GC_generic_malloc((word)lb, UNCOLLECTABLE);', '-     } else {', '- \top = (ptr_t)GC_generic_malloc((word)lb, UNCOLLECTABLE);', '-     }', '-     {', '- \tregister struct hblk * h;', '- ', '- \th = HBLKPTR(op);', '- \tlw = HDR(h) -> hb_sz;', '- ', '- \tDISABLE_SIGNALS();', '- \tLOCK();', '- \tGC_set_mark_bit(op);', '- \tGC_non_gc_bytes += WORDS_TO_BYTES(lw);', '- \tUNLOCK();', '- \tENABLE_SIGNALS();', '- \treturn((GC_PTR) op);', '-     }', '- }', '- ', '- \t  if (obj_kind == UNCOLLECTABLE) GC_non_gc_bytes += (sz - orig_sz);', '- \t      GC_free(p);', '- \t  GC_free(p);', '- \tif (knd == UNCOLLECTABLE) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);', '- \tif (knd == UNCOLLECTABLE) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);']]","[['+     if (0 == result) {', '+         return((*gc_oom_fn)(lb));', '+     } else {', '+         return(result);', '+ }', '+ #       ifdef atomic_uncollectable', '+ \t  case auncollectable:', '+ \t    return(gc_malloc_atomic_uncollectable((size_t)lb));', '+ \t  if (is_uncollectable(obj_kind)) gc_non_gc_bytes += (sz - orig_sz);', '+ #\t      ifndef ignore_free', '+ \t        gc_free(p);', '+ #\t      endif', '+ #\t  ifndef ignore_free', '+ \t    gc_free(p);', '+ #\t  endif', '+ \tif (is_uncollectable(knd)) gc_non_gc_bytes -= words_to_bytes(sz);', '+ \tif (is_uncollectable(knd)) gc_non_gc_bytes -= words_to_bytes(sz);', '+ #   ifndef ignore_free', '+ #   endif', '- ptr_t gc_generic_malloc_inner_ignore_off_page(lb, k)', '- register size_t lb;', '- register int k;', '- {', '-     register struct hblk * h;', '-     register word n_blocks;', '-     register word lw;', '-     register ptr_t op;', '- ', '-     if (lb <= hblksize)', '-         return(gc_generic_malloc_inner((word)lb, k));', '-     n_blocks = divhblksz(add_slop(lb) + hdr_bytes + hblksize-1);', '-     if (!gc_is_initialized) gc_init_inner();', '-     if(gc_incremental && !gc_dont_gc)', '- \tgc_collect_a_little_inner((int)n_blocks);', '-     lw = rounded_up_words(lb);', '-     while ((h = gc_allochblk(lw, k, ignore_off_page)) == 0', '- \t   && gc_collect_or_expand(n_blocks, true));', '-     if (h == 0) {', '- \top = 0;', '-     } else {', '- \top = (ptr_t) (h -> hb_body);', '- \tgc_words_wasted += bytes_to_words(n_blocks * hblksize) - lw;', '-     }', '-     gc_words_allocd += lw;', '-     return((ptr_t)op);', '- }', '- ', '- ptr_t gc_generic_malloc_ignore_off_page(lb, k)', '- register size_t lb;', '- register int k;', '- {', '-     register ptr_t result;', '-     dcl_lock_state;', '- ', '-     gc_invoke_finalizers();', '-     disable_signals();', '-     lock();', '-     result = gc_generic_malloc_inner_ignore_off_page(lb,k);', '-     unlock();', '-     enable_signals();', '-     return(result);', '- }', '- ', '- # if defined(__stdc__) || defined(__cplusplus)', '-   void * gc_malloc_ignore_off_page(size_t lb)', '- # else', '-   char * gc_malloc_ignore_off_page(lb)', '-   register size_t lb;', '- # endif', '- {', '-     return((gc_ptr)gc_generic_malloc_ignore_off_page(lb, normal));', '- }', '- ', '- # if defined(__stdc__) || defined(__cplusplus)', '-   void * gc_malloc_atomic_ignore_off_page(size_t lb)', '- # else', '-   char * gc_malloc_atomic_ignore_off_page(lb)', '-   register size_t lb;', '- # endif', '- {', '-     return((gc_ptr)gc_generic_malloc_ignore_off_page(lb, ptrfree));', '- }', '- ', '-     return(result);', '- }', '- ', '- ', '- ptr_t gc_generic_malloc_words_small(lw, k)', '- register word lw;', '- register int k;', '- {', '- register ptr_t op;', '- register ptr_t *opp;', '- register struct obj_kind * kind = gc_obj_kinds + k;', '- dcl_lock_state;', '- ', '-     gc_invoke_finalizers();', '-     disable_signals();', '-     lock();', '-     opp = &(kind -> ok_freelist[lw]);', '-     if( (op = *opp) == 0 ) {', '-         if (!gc_is_initialized) {', '-             gc_init_inner();', '-         }', '- \tif (kind -> ok_reclaim_list == 0) {', '- \t    if (!gc_alloc_reclaim_list(kind)) goto out;', '- \t}', '- \top = gc_clear_stack(gc_allocobj(lw, k));', '- \tif (op == 0) goto out;', '-     }', '-     *opp = obj_link(op);', '-     obj_link(op) = 0;', '-     gc_words_allocd += lw;', '- ', '- out:', '-     unlock();', '-     enable_signals();', '-     return((ptr_t)op);', '- }', '- ', '- #if defined(threads) && !defined(src_m3)', '- ptr_t gc_generic_malloc_many(lb, k)', '- register word lb;', '- register int k;', '- {', '- ptr_t op;', '- register ptr_t p;', '- ptr_t *opp;', '- word lw;', '- register word my_words_allocd;', '- dcl_lock_state;', '- ', '-     if (!small_obj(lb)) {', '-         op = gc_generic_malloc(lb, k);', '-         obj_link(op) = 0;', '-         return(op);', '-     }', '-     lw = aligned_words(lb);', '-     gc_invoke_finalizers();', '-     disable_signals();', '-     lock();', '-     opp = &(gc_obj_kinds[k].ok_freelist[lw]);', '-     if( (op = *opp) == 0 ) {', '-         if (!gc_is_initialized) {', '-             gc_init_inner();', '-         }', '- \top = gc_clear_stack(gc_allocobj(lw, k));', '- \tif (op == 0) goto out;', '-     }', '-     *opp = 0;', '-     my_words_allocd = 0;', '-     for (p = op; p != 0; p = obj_link(p)) {', '-         my_words_allocd += lw;', '-         if (my_words_allocd >= body_sz) {', '-             *opp = obj_link(p);', '-             obj_link(p) = 0;', '-             break;', '-         }', '-     gc_words_allocd += my_words_allocd;', '- ', '- out:', '-     unlock();', '-     enable_signals();', '-     return(op);', '- ', '- }', '- ', '- void * gc_malloc_many(size_t lb)', '- {', '-     return(gc_generic_malloc_many(lb, normal));', '- }', '- # endif', '- # ifdef __stdc__', '-     gc_ptr gc_malloc_uncollectable(size_t lb)', '- # else', '-     gc_ptr gc_malloc_uncollectable(lb)', '-     size_t lb;', '- # endif', '- {', '- register ptr_t op;', '- register ptr_t *opp;', '- register word lw;', '- dcl_lock_state;', '- ', '-     if( small_obj(lb) ) {', '- #       ifdef merge_sizes', '- #\t  ifdef add_byte_at_end', '- \t    if (lb != 0) lb--;', '- #\t  endif', '- \t  lw = gc_size_map[lb];', '- #\telse', '- \t  lw = aligned_words(lb);', '- #       endif', '- \topp = &(gc_uobjfreelist[lw]);', '- \tfastlock();', '-         if( fastlock_succeeded() && (op = *opp) != 0 ) {', '-             *opp = obj_link(op);', '-             obj_link(op) = 0;', '-             gc_words_allocd += lw;', '-             gc_set_mark_bit(op);', '-             gc_non_gc_bytes += words_to_bytes(lw);', '-             fastunlock();', '-             return((gc_ptr) op);', '-         }', '-         fastunlock();', '-         op = (ptr_t)gc_generic_malloc((word)lb, uncollectable);', '-     } else {', '- \top = (ptr_t)gc_generic_malloc((word)lb, uncollectable);', '-     }', '-     {', '- \tregister struct hblk * h;', '- ', '- \th = hblkptr(op);', '- \tlw = hdr(h) -> hb_sz;', '- ', '- \tdisable_signals();', '- \tlock();', '- \tgc_set_mark_bit(op);', '- \tgc_non_gc_bytes += words_to_bytes(lw);', '- \tunlock();', '- \tenable_signals();', '- \treturn((gc_ptr) op);', '-     }', '- }', '- ', '- \t  if (obj_kind == uncollectable) gc_non_gc_bytes += (sz - orig_sz);', '- \t      gc_free(p);', '- \t  gc_free(p);', '- \tif (knd == uncollectable) gc_non_gc_bytes -= words_to_bytes(sz);', '- \tif (knd == uncollectable) gc_non_gc_bytes -= words_to_bytes(sz);']]","[['+     if (0 == result) {', '+         return((*GC_oom_fn)(lb));', '+     } else {', '+         return(result);', '+ }', '+ #       ifdef ATOMIC_UNCOLLECTABLE', '+ \t  case AUNCOLLECTABLE:', '+ \t    return(GC_malloc_atomic_uncollectable((size_t)lb));', '+ \t  if (IS_UNCOLLECTABLE(obj_kind)) GC_non_gc_bytes += (sz - orig_sz);', '+ #\t      ifndef IGNORE_FREE', '+ \t        GC_free(p);', '+ #\t      endif', '+ #\t  ifndef IGNORE_FREE', '+ \t    GC_free(p);', '+ #\t  endif', '+ \tif (IS_UNCOLLECTABLE(knd)) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);', '+ \tif (IS_UNCOLLECTABLE(knd)) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);', '+ #   ifndef IGNORE_FREE', '+ #   endif']]","[['- ptr_t GC_generic_malloc_inner_ignore_off_page(lb, k)', '- register size_t lb;', '- register int k;', '- {', '-     register struct hblk * h;', '-     register word n_blocks;', '-     register word lw;', '-     register ptr_t op;', '- ', '-     if (lb <= HBLKSIZE)', '-         return(GC_generic_malloc_inner((word)lb, k));', '-     n_blocks = divHBLKSZ(ADD_SLOP(lb) + HDR_BYTES + HBLKSIZE-1);', '-     if (!GC_is_initialized) GC_init_inner();', '-     if(GC_incremental && !GC_dont_gc)', '- \tGC_collect_a_little_inner((int)n_blocks);', '-     lw = ROUNDED_UP_WORDS(lb);', '-     while ((h = GC_allochblk(lw, k, IGNORE_OFF_PAGE)) == 0', '- \t   && GC_collect_or_expand(n_blocks, TRUE));', '-     if (h == 0) {', '- \top = 0;', '-     } else {', '- \top = (ptr_t) (h -> hb_body);', '- \tGC_words_wasted += BYTES_TO_WORDS(n_blocks * HBLKSIZE) - lw;', '-     }', '-     GC_words_allocd += lw;', '-     return((ptr_t)op);', '- }', '- ', '- ptr_t GC_generic_malloc_ignore_off_page(lb, k)', '- register size_t lb;', '- register int k;', '- {', '-     register ptr_t result;', '-     DCL_LOCK_STATE;', '- ', '-     GC_invoke_finalizers();', '-     DISABLE_SIGNALS();', '-     LOCK();', '-     result = GC_generic_malloc_inner_ignore_off_page(lb,k);', '-     UNLOCK();', '-     ENABLE_SIGNALS();', '-     return(result);', '- }', '- ', '- # if defined(__STDC__) || defined(__cplusplus)', '-   void * GC_malloc_ignore_off_page(size_t lb)', '- # else', '-   char * GC_malloc_ignore_off_page(lb)', '-   register size_t lb;', '- # endif', '- {', '-     return((GC_PTR)GC_generic_malloc_ignore_off_page(lb, NORMAL));', '- }', '- ', '- # if defined(__STDC__) || defined(__cplusplus)', '-   void * GC_malloc_atomic_ignore_off_page(size_t lb)', '- # else', '-   char * GC_malloc_atomic_ignore_off_page(lb)', '-   register size_t lb;', '- # endif', '- {', '-     return((GC_PTR)GC_generic_malloc_ignore_off_page(lb, PTRFREE));', '- }', '- ', '-     return(result);', '- }', '- ', '- ', '- ptr_t GC_generic_malloc_words_small(lw, k)', '- register word lw;', '- register int k;', '- {', '- register ptr_t op;', '- register ptr_t *opp;', '- register struct obj_kind * kind = GC_obj_kinds + k;', '- DCL_LOCK_STATE;', '- ', '-     GC_invoke_finalizers();', '-     DISABLE_SIGNALS();', '-     LOCK();', '-     opp = &(kind -> ok_freelist[lw]);', '-     if( (op = *opp) == 0 ) {', '-         if (!GC_is_initialized) {', '-             GC_init_inner();', '-         }', '- \tif (kind -> ok_reclaim_list == 0) {', '- \t    if (!GC_alloc_reclaim_list(kind)) goto out;', '- \t}', '- \top = GC_clear_stack(GC_allocobj(lw, k));', '- \tif (op == 0) goto out;', '-     }', '-     *opp = obj_link(op);', '-     obj_link(op) = 0;', '-     GC_words_allocd += lw;', '- ', '- out:', '-     UNLOCK();', '-     ENABLE_SIGNALS();', '-     return((ptr_t)op);', '- }', '- ', '- #if defined(THREADS) && !defined(SRC_M3)', '- ptr_t GC_generic_malloc_many(lb, k)', '- register word lb;', '- register int k;', '- {', '- ptr_t op;', '- register ptr_t p;', '- ptr_t *opp;', '- word lw;', '- register word my_words_allocd;', '- DCL_LOCK_STATE;', '- ', '-     if (!SMALL_OBJ(lb)) {', '-         op = GC_generic_malloc(lb, k);', '-         obj_link(op) = 0;', '-         return(op);', '-     }', '-     lw = ALIGNED_WORDS(lb);', '-     GC_invoke_finalizers();', '-     DISABLE_SIGNALS();', '-     LOCK();', '-     opp = &(GC_obj_kinds[k].ok_freelist[lw]);', '-     if( (op = *opp) == 0 ) {', '-         if (!GC_is_initialized) {', '-             GC_init_inner();', '-         }', '- \top = GC_clear_stack(GC_allocobj(lw, k));', '- \tif (op == 0) goto out;', '-     }', '-     *opp = 0;', '-     my_words_allocd = 0;', '-     for (p = op; p != 0; p = obj_link(p)) {', '-         my_words_allocd += lw;', '-         if (my_words_allocd >= BODY_SZ) {', '-             *opp = obj_link(p);', '-             obj_link(p) = 0;', '-             break;', '-         }', '-     GC_words_allocd += my_words_allocd;', '- ', '- out:', '-     UNLOCK();', '-     ENABLE_SIGNALS();', '-     return(op);', '- ', '- }', '- ', '- void * GC_malloc_many(size_t lb)', '- {', '-     return(GC_generic_malloc_many(lb, NORMAL));', '- }', '- # endif', '- # ifdef __STDC__', '-     GC_PTR GC_malloc_uncollectable(size_t lb)', '- # else', '-     GC_PTR GC_malloc_uncollectable(lb)', '-     size_t lb;', '- # endif', '- {', '- register ptr_t op;', '- register ptr_t *opp;', '- register word lw;', '- DCL_LOCK_STATE;', '- ', '-     if( SMALL_OBJ(lb) ) {', '- #       ifdef MERGE_SIZES', '- #\t  ifdef ADD_BYTE_AT_END', '- \t    if (lb != 0) lb--;', '- #\t  endif', '- \t  lw = GC_size_map[lb];', '- #\telse', '- \t  lw = ALIGNED_WORDS(lb);', '- #       endif', '- \topp = &(GC_uobjfreelist[lw]);', '- \tFASTLOCK();', '-         if( FASTLOCK_SUCCEEDED() && (op = *opp) != 0 ) {', '-             *opp = obj_link(op);', '-             obj_link(op) = 0;', '-             GC_words_allocd += lw;', '-             GC_set_mark_bit(op);', '-             GC_non_gc_bytes += WORDS_TO_BYTES(lw);', '-             FASTUNLOCK();', '-             return((GC_PTR) op);', '-         }', '-         FASTUNLOCK();', '-         op = (ptr_t)GC_generic_malloc((word)lb, UNCOLLECTABLE);', '-     } else {', '- \top = (ptr_t)GC_generic_malloc((word)lb, UNCOLLECTABLE);', '-     }', '-     {', '- \tregister struct hblk * h;', '- ', '- \th = HBLKPTR(op);', '- \tlw = HDR(h) -> hb_sz;', '- ', '- \tDISABLE_SIGNALS();', '- \tLOCK();', '- \tGC_set_mark_bit(op);', '- \tGC_non_gc_bytes += WORDS_TO_BYTES(lw);', '- \tUNLOCK();', '- \tENABLE_SIGNALS();', '- \treturn((GC_PTR) op);', '-     }', '- }', '- ', '- \t  if (obj_kind == UNCOLLECTABLE) GC_non_gc_bytes += (sz - orig_sz);', '- \t      GC_free(p);', '- \t  GC_free(p);', '- \tif (knd == UNCOLLECTABLE) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);', '- \tif (knd == UNCOLLECTABLE) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);']]",19,211.0,230.0,f9b1aa2161e755a5f5b772b5698aab8a63d0bef4ivmai/bdwgc,"['be9df82919960214ee4b9d3313523bff44fd99e1', 'be9df82919960214ee4b9d3313523bff44fd99e1']"
7718dd67f2ac6e5a0761ab165de2f7146ea123b3,vadz/libtiff,libtiff/tif_predict.c,train,C,1,"['@@ -40,6 +40,7 @@ static\tvoid swabHorAcc16(TIFF*, tidata_t, tsize_t);\n static\tvoid horDiff8(TIFF*, tidata_t, tsize_t);\n static\tvoid horDiff16(TIFF*, tidata_t, tsize_t);\n static\tvoid fpAcc(TIFF*, tidata_t, tsize_t);\n+static\tvoid fpDiff(TIFF*, tidata_t, tsize_t);\n static\tint PredictorDecodeRow(TIFF*, tidata_t, tsize_t, tsample_t);\n static\tint PredictorDecodeTile(TIFF*, tidata_t, tsize_t, tsample_t);\n static\tint PredictorEncodeRow(TIFF*, tidata_t, tsize_t, tsample_t);\n@@ -168,15 +169,30 @@ PredictorSetupEncode(TIFF* tif)\n \tTIFFDirectory* td = &tif->tif_dir;\n \n \tif (!(*sp->setupencode)(tif) || !PredictorSetup(tif))\n-\t\treturn (0);\n+\t\treturn 0;\n+\n \tif (sp->predictor == 2) {\n \t\tswitch (td->td_bitspersample) {\n-\t\tcase 8:  sp->pfunc = horDiff8; break;\n-\t\tcase 16: sp->pfunc = horDiff16; break;\n+\t\t\tcase 8:  sp->pfunc = horDiff8; break;\n+\t\t\tcase 16: sp->pfunc = horDiff16; break;\n \t\t}\n \t\t/*\n-\t\t * Override default encoding method with\n-\t\t * one that does the predictor stuff.\n+\t\t * Override default encoding method with one that does the\n+\t\t * predictor stuff.\n+\t\t */\n+\t\tsp->coderow = tif->tif_encoderow;\n+\t\ttif->tif_encoderow = PredictorEncodeRow;\n+\t\tsp->codestrip = tif->tif_encodestrip;\n+\t\ttif->tif_encodestrip = PredictorEncodeTile;\n+\t\tsp->codetile = tif->tif_encodetile;\n+\t\ttif->tif_encodetile = PredictorEncodeTile;\n+\t}\n+\t\n+\telse if (sp->predictor == 3) {\n+\t\tsp->pfunc = fpDiff;\n+\t\t/*\n+\t\t * Override default encoding method with one that does the\n+\t\t * predictor stuff.\n \t\t */\n \t\tsp->coderow = tif->tif_encoderow;\n \t\ttif->tif_encoderow = PredictorEncodeRow;\n@@ -185,7 +201,8 @@ PredictorSetupEncode(TIFF* tif)\n \t\tsp->codetile = tif->tif_encodetile;\n \t\ttif->tif_encodetile = PredictorEncodeTile;\n \t}\n-\treturn (1);\n+\n+\treturn 1;\n }\n \n #define REPEAT4(n, op)\t\t\\\n@@ -233,7 +250,8 @@ horAcc8(TIFF* tif, tidata_t cp0, tsize_t cc)\n \t\t\t} while ((int32) cc > 0);\n \t\t} else  {\n \t\t\tdo {\n-\t\t\t\tREPEAT4(stride, cp[stride] = (char) (cp[stride] + *cp); cp++)\n+\t\t\t\tREPEAT4(stride, cp[stride] =\n+\t\t\t\t\t(char) (cp[stride] + *cp); cp++)\n \t\t\t\tcc -= stride;\n \t\t\t} while ((int32) cc > 0);\n \t\t}\n@@ -299,11 +317,10 @@ fpAcc(TIFF* tif, tidata_t cp0, tsize_t cc)\n \tfor (count = 0; count < wc; count++) {\n \t\tuint32 byte;\n \t\tfor (byte = 0; byte < bps; byte++) {\n-\t\t\ttmp[bps * count + byte] =\n-\t\t\t\tcp[(bps - byte - 1) * wc + count];\n+\t\t\tcp[bps * count + byte] =\n+\t\t\t\ttmp[(bps - byte - 1) * wc + count];\n \t\t}\n \t}\n-\t_TIFFmemcpy(cp0, tmp, cc);\n \t_TIFFfree(tmp);\n }\n \n@@ -416,6 +433,38 @@ horDiff16(TIFF* tif, tidata_t cp0, tsize_t cc)\n \t}\n }\n \n+/*\n+ * Floating point predictor differencing routine.\n+ */\n+static void\n+fpDiff(TIFF* tif, tidata_t cp0, tsize_t cc)\n+{\n+\ttsize_t stride = PredictorState(tif)->stride;\n+\tuint32 bps = tif->tif_dir.td_bitspersample / 8;\n+\ttsize_t wc = cc / bps;\n+\ttsize_t count;\n+\tuint8 *cp = (uint8 *) cp0;\n+\tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);\n+\n+\tif (!tmp)\n+\t\treturn;\n+\n+\t_TIFFmemcpy(tmp, cp0, cc);\n+\tfor (count = 0; count < wc; count++) {\n+\t\tuint32 byte;\n+\t\tfor (byte = 0; byte < bps; byte++) {\n+\t\t\tcp[(bps - byte - 1) * wc + count] =\n+\t\t\t\ttmp[bps * count + byte];\n+\t\t}\n+\t}\n+\t_TIFFfree(tmp);\n+\n+\tcp = (uint8 *) cp0;\n+\tcp += cc - stride - 1;\n+\tfor (count = cc; count > stride; count -= stride)\n+\t\tREPEAT4(stride, cp[stride] -= cp[0]; cp--)\n+}\n+\n static int\n PredictorEncodeRow(TIFF* tif, tidata_t bp, tsize_t cc, tsample_t s)\n {\n']",2005-04-14 20:35:02+00:00,"Added ability to encode floating point predictor, as per TIFF Technical Note
3.","[['+ static\tvoid fpDiff(TIFF*, tidata_t, tsize_t);', '+ \t\treturn 0;', '+ ', '+ \t\t\tcase 8:  sp->pfunc = horDiff8; break;', '+ \t\t\tcase 16: sp->pfunc = horDiff16; break;', '+ \t\tsp->coderow = tif->tif_encoderow;', '+ \t\ttif->tif_encoderow = PredictorEncodeRow;', '+ \t\tsp->codestrip = tif->tif_encodestrip;', '+ \t\ttif->tif_encodestrip = PredictorEncodeTile;', '+ \t\tsp->codetile = tif->tif_encodetile;', '+ \t\ttif->tif_encodetile = PredictorEncodeTile;', '+ \t}', '+ ', '+ \telse if (sp->predictor == 3) {', '+ \t\tsp->pfunc = fpDiff;', '+ ', '+ \treturn 1;', '+ \t\t\t\tREPEAT4(stride, cp[stride] =', '+ \t\t\t\t\t(char) (cp[stride] + *cp); cp++)', '+ \t\t\tcp[bps * count + byte] =', '+ \t\t\t\ttmp[(bps - byte - 1) * wc + count];', '+ static void', '+ fpDiff(TIFF* tif, tidata_t cp0, tsize_t cc)', '+ {', '+ \ttsize_t stride = PredictorState(tif)->stride;', '+ \tuint32 bps = tif->tif_dir.td_bitspersample / 8;', '+ \ttsize_t wc = cc / bps;', '+ \ttsize_t count;', '+ \tuint8 *cp = (uint8 *) cp0;', '+ \tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);', '+ ', '+ \tif (!tmp)', '+ \t\treturn;', '+ ', '+ \t_TIFFmemcpy(tmp, cp0, cc);', '+ \tfor (count = 0; count < wc; count++) {', '+ \t\tuint32 byte;', '+ \t\tfor (byte = 0; byte < bps; byte++) {', '+ \t\t\tcp[(bps - byte - 1) * wc + count] =', '+ \t\t\t\ttmp[bps * count + byte];', '+ \t\t}', '+ \t}', '+ \t_TIFFfree(tmp);', '+ ', '+ \tcp = (uint8 *) cp0;', '+ \tcp += cc - stride - 1;', '+ \tfor (count = cc; count > stride; count -= stride)', '+ \t\tREPEAT4(stride, cp[stride] -= cp[0]; cp--)', '+ }', '+ ', '- \t\treturn (0);', '- \t\tcase 8:  sp->pfunc = horDiff8; break;', '- \t\tcase 16: sp->pfunc = horDiff16; break;', '- \treturn (1);', '- \t\t\t\tREPEAT4(stride, cp[stride] = (char) (cp[stride] + *cp); cp++)', '- \t\t\ttmp[bps * count + byte] =', '- \t\t\t\tcp[(bps - byte - 1) * wc + count];', '- \t_TIFFmemcpy(cp0, tmp, cc);']]","[['+ static\tvoid fpdiff(tiff*, tidata_t, tsize_t);', '+ \t\treturn 0;', '+ ', '+ \t\t\tcase 8:  sp->pfunc = hordiff8; break;', '+ \t\t\tcase 16: sp->pfunc = hordiff16; break;', '+ \t\tsp->coderow = tif->tif_encoderow;', '+ \t\ttif->tif_encoderow = predictorencoderow;', '+ \t\tsp->codestrip = tif->tif_encodestrip;', '+ \t\ttif->tif_encodestrip = predictorencodetile;', '+ \t\tsp->codetile = tif->tif_encodetile;', '+ \t\ttif->tif_encodetile = predictorencodetile;', '+ \t}', '+ ', '+ \telse if (sp->predictor == 3) {', '+ \t\tsp->pfunc = fpdiff;', '+ ', '+ \treturn 1;', '+ \t\t\t\trepeat4(stride, cp[stride] =', '+ \t\t\t\t\t(char) (cp[stride] + *cp); cp++)', '+ \t\t\tcp[bps * count + byte] =', '+ \t\t\t\ttmp[(bps - byte - 1) * wc + count];', '+ static void', '+ fpdiff(tiff* tif, tidata_t cp0, tsize_t cc)', '+ {', '+ \ttsize_t stride = predictorstate(tif)->stride;', '+ \tuint32 bps = tif->tif_dir.td_bitspersample / 8;', '+ \ttsize_t wc = cc / bps;', '+ \ttsize_t count;', '+ \tuint8 *cp = (uint8 *) cp0;', '+ \tuint8 *tmp = (uint8 *)_tiffmalloc(cc);', '+ ', '+ \tif (!tmp)', '+ \t\treturn;', '+ ', '+ \t_tiffmemcpy(tmp, cp0, cc);', '+ \tfor (count = 0; count < wc; count++) {', '+ \t\tuint32 byte;', '+ \t\tfor (byte = 0; byte < bps; byte++) {', '+ \t\t\tcp[(bps - byte - 1) * wc + count] =', '+ \t\t\t\ttmp[bps * count + byte];', '+ \t\t}', '+ \t}', '+ \t_tifffree(tmp);', '+ ', '+ \tcp = (uint8 *) cp0;', '+ \tcp += cc - stride - 1;', '+ \tfor (count = cc; count > stride; count -= stride)', '+ \t\trepeat4(stride, cp[stride] -= cp[0]; cp--)', '+ }', '+ ', '- \t\treturn (0);', '- \t\tcase 8:  sp->pfunc = hordiff8; break;', '- \t\tcase 16: sp->pfunc = hordiff16; break;', '- \treturn (1);', '- \t\t\t\trepeat4(stride, cp[stride] = (char) (cp[stride] + *cp); cp++)', '- \t\t\ttmp[bps * count + byte] =', '- \t\t\t\tcp[(bps - byte - 1) * wc + count];', '- \t_tiffmemcpy(cp0, tmp, cc);']]","[['+ static\tvoid fpDiff(TIFF*, tidata_t, tsize_t);', '+ \t\treturn 0;', '+ ', '+ \t\t\tcase 8:  sp->pfunc = horDiff8; break;', '+ \t\t\tcase 16: sp->pfunc = horDiff16; break;', '+ \t\tsp->coderow = tif->tif_encoderow;', '+ \t\ttif->tif_encoderow = PredictorEncodeRow;', '+ \t\tsp->codestrip = tif->tif_encodestrip;', '+ \t\ttif->tif_encodestrip = PredictorEncodeTile;', '+ \t\tsp->codetile = tif->tif_encodetile;', '+ \t\ttif->tif_encodetile = PredictorEncodeTile;', '+ \t}', '+ ', '+ \telse if (sp->predictor == 3) {', '+ \t\tsp->pfunc = fpDiff;', '+ ', '+ \treturn 1;', '+ \t\t\t\tREPEAT4(stride, cp[stride] =', '+ \t\t\t\t\t(char) (cp[stride] + *cp); cp++)', '+ \t\t\tcp[bps * count + byte] =', '+ \t\t\t\ttmp[(bps - byte - 1) * wc + count];', '+ static void', '+ fpDiff(TIFF* tif, tidata_t cp0, tsize_t cc)', '+ {', '+ \ttsize_t stride = PredictorState(tif)->stride;', '+ \tuint32 bps = tif->tif_dir.td_bitspersample / 8;', '+ \ttsize_t wc = cc / bps;', '+ \ttsize_t count;', '+ \tuint8 *cp = (uint8 *) cp0;', '+ \tuint8 *tmp = (uint8 *)_TIFFmalloc(cc);', '+ ', '+ \tif (!tmp)', '+ \t\treturn;', '+ ', '+ \t_TIFFmemcpy(tmp, cp0, cc);', '+ \tfor (count = 0; count < wc; count++) {', '+ \t\tuint32 byte;', '+ \t\tfor (byte = 0; byte < bps; byte++) {', '+ \t\t\tcp[(bps - byte - 1) * wc + count] =', '+ \t\t\t\ttmp[bps * count + byte];', '+ \t\t}', '+ \t}', '+ \t_TIFFfree(tmp);', '+ ', '+ \tcp = (uint8 *) cp0;', '+ \tcp += cc - stride - 1;', '+ \tfor (count = cc; count > stride; count -= stride)', '+ \t\tREPEAT4(stride, cp[stride] -= cp[0]; cp--)', '+ }', '+ ']]","[['- \t\treturn (0);', '- \t\tcase 8:  sp->pfunc = horDiff8; break;', '- \t\tcase 16: sp->pfunc = horDiff16; break;', '- \treturn (1);', '- \t\t\t\tREPEAT4(stride, cp[stride] = (char) (cp[stride] + *cp); cp++)', '- \t\t\ttmp[bps * count + byte] =', '- \t\t\t\tcp[(bps - byte - 1) * wc + count];', '- \t_TIFFmemcpy(cp0, tmp, cc);']]",50,8.0,58.0,7718dd67f2ac6e5a0761ab165de2f7146ea123b3vadz/libtiff,['3ca657a8793dd011bf869695d72ad31c779c3cc1']
e1791bb11ae85366dfb4d0173a8d7b5751a7a407,OpenVPN/openvpn,openvpn.c,train,C,0,"['@@ -149,7 +149,8 @@ main (int argc, char *argv[])\n #ifdef ENABLE_PLUGIN\n \t  /* plugins may contribute options configuration */\n \t  init_verb_mute (&c, IVM_LEVEL_1);\n-\t  open_plugins (&c, true);\n+\t  init_plugins (&c);\n+\t  open_plugins (&c, true, OPENVPN_PLUGIN_INIT_PRE_CONFIG_PARSE);\n #endif\n \n \t  /* init verbosity and mute levels */\n']",,,"['+ \t  init_plugins (&c);', '+ \t  open_plugins (&c, true, OPENVPN_PLUGIN_INIT_PRE_CONFIG_PARSE);', '- \t  open_plugins (&c, true);']","['+ \t  init_plugins (&c);', '+ \t  open_plugins (&c, true, openvpn_plugin_init_pre_config_parse);', '- \t  open_plugins (&c, true);']","['+ \t  init_plugins (&c);', '+ \t  open_plugins (&c, true, OPENVPN_PLUGIN_INIT_PRE_CONFIG_PARSE);']","['- \t  open_plugins (&c, true);']",2,1.0,3.0,e1791bb11ae85366dfb4d0173a8d7b5751a7a407OpenVPN/openvpn,[]
8bc0db989ccc07083a52c81de0dbad8598813a7f,file/file,src/readelf.c,test,C,1,"['@@ -39,7 +39,7 @@\n #include ""readelf.h""\n \n #ifndef lint\n-FILE_RCSID(""@(#)$Id: readelf.c,v 1.36 2003/11/18 19:42:33 christos Exp $"")\n+FILE_RCSID(""@(#)$Id: readelf.c,v 1.37 2004/03/22 18:44:01 christos Exp $"")\n #endif\n \n #ifdef\tELFCORE\n@@ -48,7 +48,7 @@ private int dophn_core(struct magic_set *, int, int, int, off_t, int, size_t);\n private int dophn_exec(struct magic_set *, int, int, int, off_t, int, size_t);\n private int doshn(struct magic_set *, int, int, int, off_t, int, size_t);\n private size_t donote(struct magic_set *, unsigned char *, size_t, size_t, int,\n-    int, int);\n+    int, size_t);\n \n #define\tELF_ALIGN(a)\t((((a) + align - 1) / align) * align)\n \n@@ -142,7 +142,7 @@ getu64(int swap, uint64_t value)\n #define ph_offset\t(class == ELFCLASS32\t\t\\\n \t\t\t ? getu32(swap, ph32.p_offset)\t\\\n \t\t\t : getu64(swap, ph64.p_offset))\n-#define ph_align\t(int)((class == ELFCLASS32\t\\\n+#define ph_align\t(size_t)((class == ELFCLASS32\t\\\n \t\t\t ? (off_t) (ph32.p_align ? \t\\\n \t\t\t    getu32(swap, ph32.p_align) : 4) \\\n \t\t\t : (off_t) (ph64.p_align ?\t\\\n@@ -222,7 +222,8 @@ dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,\n \tssize_t bufsize;\n \n \tif (size != ph_size) {\n-\t\tfile_printf(ms, "", corrupted program header size"");\n+\t\tif (file_printf(ms, "", corrupted program header size"") == -1)\n+\t\t\treturn -1;\n \t\treturn 0;\n \t}\n \t/*\n@@ -269,7 +270,7 @@ dophn_core(struct magic_set *ms, int class, int swap, int fd, off_t off,\n \n private size_t\n donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n-    int class, int swap, int align)\n+    int class, int swap, size_t align)\n {\n \tElf32_Nhdr nh32;\n \tElf64_Nhdr nh64;\n@@ -277,6 +278,7 @@ donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n #ifdef ELFCORE\n \tint os_style = -1;\n #endif\n+\tuint32_t namesz, descsz;\n \n \tif (class == ELFCLASS32)\n \t\tmemcpy(&nh32, &nbuf[offset], sizeof(nh32));\n@@ -284,29 +286,45 @@ donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n \t\tmemcpy(&nh64, &nbuf[offset], sizeof(nh64));\n \toffset += nh_size;\n \n-\tif ((nh_namesz == 0) && (nh_descsz == 0)) {\n+\tnamesz = nh_namesz;\n+\tdescsz = nh_descsz;\n+\tif ((namesz == 0) && (descsz == 0)) {\n \t\t/*\n \t\t * We\'re out of note headers.\n \t\t */\n \t\treturn offset;\n \t}\n \n+\tif (namesz & 0x80000000) {\n+\t    (void)file_printf(ms, "", bad note name size 0x%lx"",\n+\t\t(unsigned long)namesz);\n+\t    return offset;\n+\t}\n+\n+\tif (descsz & 0x80000000) {\n+\t    (void)file_printf(ms, "", bad note description size 0x%lx"",\n+\t\t(unsigned long)descsz);\n+\t    return offset;\n+\t}\n+\n+\n \tnoff = offset;\n-\tdoff = ELF_ALIGN(offset + nh_namesz);\n+\tdoff = ELF_ALIGN(offset + namesz);\n \n-\tif (offset + nh_namesz >= size) {\n+\tif (offset + namesz >= size) {\n \t\t/*\n \t\t * We\'re past the end of the buffer.\n \t\t */\n \t\treturn doff;\n \t}\n \n-\toffset = ELF_ALIGN(doff + nh_descsz);\n-\tif (offset + nh_descsz >= size)\n+\toffset = ELF_ALIGN(doff + descsz);\n+\tif (offset + descsz >= size) {\n \t\treturn offset;\n+\t}\n \n-\tif (nh_namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&\n-\t    nh_type == NT_GNU_VERSION && nh_descsz == 16) {\n+\tif (namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&\n+\t    nh_type == NT_GNU_VERSION && descsz == 16) {\n \t\tuint32_t desc[4];\n \t\t(void)memcpy(desc, &nbuf[doff], sizeof(desc));\n \n@@ -335,8 +353,8 @@ donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n \t\treturn size;\n \t}\n \n-\tif (nh_namesz == 7 && strcmp((char *)&nbuf[noff], ""NetBSD"") == 0 &&\n-\t    nh_type == NT_NETBSD_VERSION && nh_descsz == 4) {\n+\tif (namesz == 7 && strcmp((char *)&nbuf[noff], ""NetBSD"") == 0 &&\n+\t    nh_type == NT_NETBSD_VERSION && descsz == 4) {\n \t\tuint32_t desc;\n \t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n \t\tdesc = getu32(swap, desc);\n@@ -377,8 +395,8 @@ donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n \t\treturn size;\n \t}\n \n-\tif (nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0 &&\n-\t    nh_type == NT_FREEBSD_VERSION && nh_descsz == 4) {\n+\tif (namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0 &&\n+\t    nh_type == NT_FREEBSD_VERSION && descsz == 4) {\n \t\tuint32_t desc;\n \t\t(void)memcpy(&desc, &nbuf[doff], sizeof(desc));\n \t\tdesc = getu32(swap, desc);\n@@ -399,8 +417,8 @@ donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n \t\treturn size;\n \t}\n \n-\tif (nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""OpenBSD"") == 0 &&\n-\t    nh_type == NT_OPENBSD_VERSION && nh_descsz == 4) {\n+\tif (namesz == 8 && strcmp((char *)&nbuf[noff], ""OpenBSD"") == 0 &&\n+\t    nh_type == NT_OPENBSD_VERSION && descsz == 4) {\n \t\tif (file_printf(ms, "", for OpenBSD"") == -1)\n \t\t\treturn size;\n \t\t/* Content of note is always 0 */\n@@ -421,16 +439,16 @@ donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n \t * doesn\'t include the terminating null in the\n \t * name....\n \t */\n-\tif ((nh_namesz == 4 && strncmp((char *)&nbuf[noff], ""CORE"", 4) == 0) ||\n-\t    (nh_namesz == 5 && strcmp((char *)&nbuf[noff], ""CORE"") == 0)) {\n+\tif ((namesz == 4 && strncmp((char *)&nbuf[noff], ""CORE"", 4) == 0) ||\n+\t    (namesz == 5 && strcmp((char *)&nbuf[noff], ""CORE"") == 0)) {\n \t\tos_style = OS_STYLE_SVR4;\n \t} \n \n-\tif ((nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0)) {\n+\tif ((namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0)) {\n \t\tos_style = OS_STYLE_FREEBSD;\n \t}\n \n-\tif ((nh_namesz >= 11 && strncmp((char *)&nbuf[noff], ""NetBSD-CORE"", 11)\n+\tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], ""NetBSD-CORE"", 11)\n \t    == 0)) {\n \t\tos_style = OS_STYLE_NETBSD;\n \t}\n@@ -490,7 +508,7 @@ donote(struct magic_set *ms, unsigned char *nbuf, size_t offset, size_t size,\n \t\t\t\t * if we are, this obviously\n \t\t\t\t * isn\'t the right offset.\n \t\t\t\t */\n-\t\t\t\tif (reloffset >= nh_descsz)\n+\t\t\t\tif (reloffset >= descsz)\n \t\t\t\t\tgoto tryanother;\n \n \t\t\t\tc = nbuf[noffset];\n@@ -543,7 +561,8 @@ doshn(struct magic_set *ms, int class, int swap, int fd, off_t off, int num,\n \tElf64_Shdr sh64;\n \n \tif (size != sh_size) {\n-\t\tfile_printf(ms, "", corrupted section header size"");\n+\t\tif (file_printf(ms, "", corrupted section header size"") == -1)\n+\t\t\treturn -1;\n \t\treturn 0;\n \t}\n \n@@ -583,11 +602,12 @@ dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,\n \tconst char *shared_libraries = """";\n \tunsigned char nbuf[BUFSIZ];\n \tint bufsize;\n-\tsize_t offset;\n+\tsize_t offset, align;\n \toff_t savedoffset;\n \n \tif (size != ph_size) {\n-\t\tfile_printf(ms, "", corrupted program header size"");\n+\t\tif (file_printf(ms, "", corrupted program header size"") == -1)\n+\t\t    return -1;\n \t\treturn 0;\n \t}\n \tif (lseek(fd, off, SEEK_SET) == (off_t)-1) {\n@@ -613,6 +633,13 @@ dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,\n \t\t\tshared_libraries = "" (uses shared libs)"";\n \t\t\tbreak;\n \t\tcase PT_NOTE:\n+\t\t\tif ((align = ph_align) & 0x80000000) {\n+\t\t\t\tif (file_printf(ms, \n+\t\t\t\t    "", invalid note alignment 0x%lx"",\n+\t\t\t\t    (unsigned long)align) == -1)\n+\t\t\t\t\treturn -1;\n+\t\t\t\talign = 4;\n+\t\t\t}\n \t\t\t/*\n \t\t\t * This is a PT_NOTE section; loop through all the notes\n \t\t\t * in the section.\n@@ -632,7 +659,7 @@ dophn_exec(struct magic_set *ms, int class, int swap, int fd, off_t off,\n \t\t\t\tif (offset >= (size_t)bufsize)\n \t\t\t\t\tbreak;\n \t\t\t\toffset = donote(ms, nbuf, offset,\n-\t\t\t\t    (size_t)bufsize, class, swap, ph_align);\n+\t\t\t\t    (size_t)bufsize, class, swap, align);\n \t\t\t}\n \t\t\tif (lseek(fd, savedoffset + offset, SEEK_SET)\n \t\t\t    == (off_t)-1) {\n']",2004-03-22 18:44:01+00:00,"Avoid infinite loops caused by bad elf alignments of name and description
sizes. Mikael Magnusson <mmikael@comhem.se>","[['+ FILE_RCSID(""@(#)$Id: readelf.c,v 1.37 2004/03/22 18:44:01 christos Exp $"")', '+     int, size_t);', '+ #define ph_align\t(size_t)((class == ELFCLASS32\t\\', '+ \t\tif (file_printf(ms, "", corrupted program header size"") == -1)', '+ \t\t\treturn -1;', '+     int class, int swap, size_t align)', '+ \tuint32_t namesz, descsz;', '+ \tnamesz = nh_namesz;', '+ \tdescsz = nh_descsz;', '+ \tif ((namesz == 0) && (descsz == 0)) {', '+ \tif (namesz & 0x80000000) {', '+ \t    (void)file_printf(ms, "", bad note name size 0x%lx"",', '+ \t\t(unsigned long)namesz);', '+ \t    return offset;', '+ \t}', '+ ', '+ \tif (descsz & 0x80000000) {', '+ \t    (void)file_printf(ms, "", bad note description size 0x%lx"",', '+ \t\t(unsigned long)descsz);', '+ \t    return offset;', '+ \t}', '+ ', '+ ', '+ \tdoff = ELF_ALIGN(offset + namesz);', '+ \tif (offset + namesz >= size) {', '+ \toffset = ELF_ALIGN(doff + descsz);', '+ \tif (offset + descsz >= size) {', '+ \t}', '+ \tif (namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&', '+ \t    nh_type == NT_GNU_VERSION && descsz == 16) {', '+ \tif (namesz == 7 && strcmp((char *)&nbuf[noff], ""NetBSD"") == 0 &&', '+ \t    nh_type == NT_NETBSD_VERSION && descsz == 4) {', '+ \tif (namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0 &&', '+ \t    nh_type == NT_FREEBSD_VERSION && descsz == 4) {', '+ \tif (namesz == 8 && strcmp((char *)&nbuf[noff], ""OpenBSD"") == 0 &&', '+ \t    nh_type == NT_OPENBSD_VERSION && descsz == 4) {', '+ \tif ((namesz == 4 && strncmp((char *)&nbuf[noff], ""CORE"", 4) == 0) ||', '+ \t    (namesz == 5 && strcmp((char *)&nbuf[noff], ""CORE"") == 0)) {', '+ \tif ((namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0)) {', '+ \tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], ""NetBSD-CORE"", 11)', '+ \t\t\t\tif (reloffset >= descsz)', '+ \t\tif (file_printf(ms, "", corrupted section header size"") == -1)', '+ \t\t\treturn -1;', '+ \tsize_t offset, align;', '+ \t\tif (file_printf(ms, "", corrupted program header size"") == -1)', '+ \t\t    return -1;', '+ \t\t\tif ((align = ph_align) & 0x80000000) {', '+ \t\t\t\tif (file_printf(ms,', '+ \t\t\t\t    "", invalid note alignment 0x%lx"",', '+ \t\t\t\t    (unsigned long)align) == -1)', '+ \t\t\t\t\treturn -1;', '+ \t\t\t\talign = 4;', '+ \t\t\t}', '+ \t\t\t\t    (size_t)bufsize, class, swap, align);', '- FILE_RCSID(""@(#)$Id: readelf.c,v 1.36 2003/11/18 19:42:33 christos Exp $"")', '-     int, int);', '- #define ph_align\t(int)((class == ELFCLASS32\t\\', '- \t\tfile_printf(ms, "", corrupted program header size"");', '-     int class, int swap, int align)', '- \tif ((nh_namesz == 0) && (nh_descsz == 0)) {', '- \tdoff = ELF_ALIGN(offset + nh_namesz);', '- \tif (offset + nh_namesz >= size) {', '- \toffset = ELF_ALIGN(doff + nh_descsz);', '- \tif (offset + nh_descsz >= size)', '- \tif (nh_namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&', '- \t    nh_type == NT_GNU_VERSION && nh_descsz == 16) {', '- \tif (nh_namesz == 7 && strcmp((char *)&nbuf[noff], ""NetBSD"") == 0 &&', '- \t    nh_type == NT_NETBSD_VERSION && nh_descsz == 4) {', '- \tif (nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0 &&', '- \t    nh_type == NT_FREEBSD_VERSION && nh_descsz == 4) {', '- \tif (nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""OpenBSD"") == 0 &&', '- \t    nh_type == NT_OPENBSD_VERSION && nh_descsz == 4) {', '- \tif ((nh_namesz == 4 && strncmp((char *)&nbuf[noff], ""CORE"", 4) == 0) ||', '- \t    (nh_namesz == 5 && strcmp((char *)&nbuf[noff], ""CORE"") == 0)) {', '- \tif ((nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0)) {', '- \tif ((nh_namesz >= 11 && strncmp((char *)&nbuf[noff], ""NetBSD-CORE"", 11)', '- \t\t\t\tif (reloffset >= nh_descsz)', '- \t\tfile_printf(ms, "", corrupted section header size"");', '- \tsize_t offset;', '- \t\tfile_printf(ms, "", corrupted program header size"");', '- \t\t\t\t    (size_t)bufsize, class, swap, ph_align);']]","[['+ file_rcsid(""@(#)$id: readelf.c,v 1.37 2004/03/22 18:44:01 christos exp $"")', '+     int, size_t);', '+ #define ph_align\t(size_t)((class == elfclass32\t\\', '+ \t\tif (file_printf(ms, "", corrupted program header size"") == -1)', '+ \t\t\treturn -1;', '+     int class, int swap, size_t align)', '+ \tuint32_t namesz, descsz;', '+ \tnamesz = nh_namesz;', '+ \tdescsz = nh_descsz;', '+ \tif ((namesz == 0) && (descsz == 0)) {', '+ \tif (namesz & 0x80000000) {', '+ \t    (void)file_printf(ms, "", bad note name size 0x%lx"",', '+ \t\t(unsigned long)namesz);', '+ \t    return offset;', '+ \t}', '+ ', '+ \tif (descsz & 0x80000000) {', '+ \t    (void)file_printf(ms, "", bad note description size 0x%lx"",', '+ \t\t(unsigned long)descsz);', '+ \t    return offset;', '+ \t}', '+ ', '+ ', '+ \tdoff = elf_align(offset + namesz);', '+ \tif (offset + namesz >= size) {', '+ \toffset = elf_align(doff + descsz);', '+ \tif (offset + descsz >= size) {', '+ \t}', '+ \tif (namesz == 4 && strcmp((char *)&nbuf[noff], ""gnu"") == 0 &&', '+ \t    nh_type == nt_gnu_version && descsz == 16) {', '+ \tif (namesz == 7 && strcmp((char *)&nbuf[noff], ""netbsd"") == 0 &&', '+ \t    nh_type == nt_netbsd_version && descsz == 4) {', '+ \tif (namesz == 8 && strcmp((char *)&nbuf[noff], ""freebsd"") == 0 &&', '+ \t    nh_type == nt_freebsd_version && descsz == 4) {', '+ \tif (namesz == 8 && strcmp((char *)&nbuf[noff], ""openbsd"") == 0 &&', '+ \t    nh_type == nt_openbsd_version && descsz == 4) {', '+ \tif ((namesz == 4 && strncmp((char *)&nbuf[noff], ""core"", 4) == 0) ||', '+ \t    (namesz == 5 && strcmp((char *)&nbuf[noff], ""core"") == 0)) {', '+ \tif ((namesz == 8 && strcmp((char *)&nbuf[noff], ""freebsd"") == 0)) {', '+ \tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], ""netbsd-core"", 11)', '+ \t\t\t\tif (reloffset >= descsz)', '+ \t\tif (file_printf(ms, "", corrupted section header size"") == -1)', '+ \t\t\treturn -1;', '+ \tsize_t offset, align;', '+ \t\tif (file_printf(ms, "", corrupted program header size"") == -1)', '+ \t\t    return -1;', '+ \t\t\tif ((align = ph_align) & 0x80000000) {', '+ \t\t\t\tif (file_printf(ms,', '+ \t\t\t\t    "", invalid note alignment 0x%lx"",', '+ \t\t\t\t    (unsigned long)align) == -1)', '+ \t\t\t\t\treturn -1;', '+ \t\t\t\talign = 4;', '+ \t\t\t}', '+ \t\t\t\t    (size_t)bufsize, class, swap, align);', '- file_rcsid(""@(#)$id: readelf.c,v 1.36 2003/11/18 19:42:33 christos exp $"")', '-     int, int);', '- #define ph_align\t(int)((class == elfclass32\t\\', '- \t\tfile_printf(ms, "", corrupted program header size"");', '-     int class, int swap, int align)', '- \tif ((nh_namesz == 0) && (nh_descsz == 0)) {', '- \tdoff = elf_align(offset + nh_namesz);', '- \tif (offset + nh_namesz >= size) {', '- \toffset = elf_align(doff + nh_descsz);', '- \tif (offset + nh_descsz >= size)', '- \tif (nh_namesz == 4 && strcmp((char *)&nbuf[noff], ""gnu"") == 0 &&', '- \t    nh_type == nt_gnu_version && nh_descsz == 16) {', '- \tif (nh_namesz == 7 && strcmp((char *)&nbuf[noff], ""netbsd"") == 0 &&', '- \t    nh_type == nt_netbsd_version && nh_descsz == 4) {', '- \tif (nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""freebsd"") == 0 &&', '- \t    nh_type == nt_freebsd_version && nh_descsz == 4) {', '- \tif (nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""openbsd"") == 0 &&', '- \t    nh_type == nt_openbsd_version && nh_descsz == 4) {', '- \tif ((nh_namesz == 4 && strncmp((char *)&nbuf[noff], ""core"", 4) == 0) ||', '- \t    (nh_namesz == 5 && strcmp((char *)&nbuf[noff], ""core"") == 0)) {', '- \tif ((nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""freebsd"") == 0)) {', '- \tif ((nh_namesz >= 11 && strncmp((char *)&nbuf[noff], ""netbsd-core"", 11)', '- \t\t\t\tif (reloffset >= nh_descsz)', '- \t\tfile_printf(ms, "", corrupted section header size"");', '- \tsize_t offset;', '- \t\tfile_printf(ms, "", corrupted program header size"");', '- \t\t\t\t    (size_t)bufsize, class, swap, ph_align);']]","[['+ FILE_RCSID(""@(#)$Id: readelf.c,v 1.37 2004/03/22 18:44:01 christos Exp $"")', '+     int, size_t);', '+ #define ph_align\t(size_t)((class == ELFCLASS32\t\\', '+ \t\tif (file_printf(ms, "", corrupted program header size"") == -1)', '+ \t\t\treturn -1;', '+     int class, int swap, size_t align)', '+ \tuint32_t namesz, descsz;', '+ \tnamesz = nh_namesz;', '+ \tdescsz = nh_descsz;', '+ \tif ((namesz == 0) && (descsz == 0)) {', '+ \tif (namesz & 0x80000000) {', '+ \t    (void)file_printf(ms, "", bad note name size 0x%lx"",', '+ \t\t(unsigned long)namesz);', '+ \t    return offset;', '+ \t}', '+ ', '+ \tif (descsz & 0x80000000) {', '+ \t    (void)file_printf(ms, "", bad note description size 0x%lx"",', '+ \t\t(unsigned long)descsz);', '+ \t    return offset;', '+ \t}', '+ ', '+ ', '+ \tdoff = ELF_ALIGN(offset + namesz);', '+ \tif (offset + namesz >= size) {', '+ \toffset = ELF_ALIGN(doff + descsz);', '+ \tif (offset + descsz >= size) {', '+ \t}', '+ \tif (namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&', '+ \t    nh_type == NT_GNU_VERSION && descsz == 16) {', '+ \tif (namesz == 7 && strcmp((char *)&nbuf[noff], ""NetBSD"") == 0 &&', '+ \t    nh_type == NT_NETBSD_VERSION && descsz == 4) {', '+ \tif (namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0 &&', '+ \t    nh_type == NT_FREEBSD_VERSION && descsz == 4) {', '+ \tif (namesz == 8 && strcmp((char *)&nbuf[noff], ""OpenBSD"") == 0 &&', '+ \t    nh_type == NT_OPENBSD_VERSION && descsz == 4) {', '+ \tif ((namesz == 4 && strncmp((char *)&nbuf[noff], ""CORE"", 4) == 0) ||', '+ \t    (namesz == 5 && strcmp((char *)&nbuf[noff], ""CORE"") == 0)) {', '+ \tif ((namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0)) {', '+ \tif ((namesz >= 11 && strncmp((char *)&nbuf[noff], ""NetBSD-CORE"", 11)', '+ \t\t\t\tif (reloffset >= descsz)', '+ \t\tif (file_printf(ms, "", corrupted section header size"") == -1)', '+ \t\t\treturn -1;', '+ \tsize_t offset, align;', '+ \t\tif (file_printf(ms, "", corrupted program header size"") == -1)', '+ \t\t    return -1;', '+ \t\t\tif ((align = ph_align) & 0x80000000) {', '+ \t\t\t\tif (file_printf(ms,', '+ \t\t\t\t    "", invalid note alignment 0x%lx"",', '+ \t\t\t\t    (unsigned long)align) == -1)', '+ \t\t\t\t\treturn -1;', '+ \t\t\t\talign = 4;', '+ \t\t\t}', '+ \t\t\t\t    (size_t)bufsize, class, swap, align);']]","[['- FILE_RCSID(""@(#)$Id: readelf.c,v 1.36 2003/11/18 19:42:33 christos Exp $"")', '-     int, int);', '- #define ph_align\t(int)((class == ELFCLASS32\t\\', '- \t\tfile_printf(ms, "", corrupted program header size"");', '-     int class, int swap, int align)', '- \tif ((nh_namesz == 0) && (nh_descsz == 0)) {', '- \tdoff = ELF_ALIGN(offset + nh_namesz);', '- \tif (offset + nh_namesz >= size) {', '- \toffset = ELF_ALIGN(doff + nh_descsz);', '- \tif (offset + nh_descsz >= size)', '- \tif (nh_namesz == 4 && strcmp((char *)&nbuf[noff], ""GNU"") == 0 &&', '- \t    nh_type == NT_GNU_VERSION && nh_descsz == 16) {', '- \tif (nh_namesz == 7 && strcmp((char *)&nbuf[noff], ""NetBSD"") == 0 &&', '- \t    nh_type == NT_NETBSD_VERSION && nh_descsz == 4) {', '- \tif (nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0 &&', '- \t    nh_type == NT_FREEBSD_VERSION && nh_descsz == 4) {', '- \tif (nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""OpenBSD"") == 0 &&', '- \t    nh_type == NT_OPENBSD_VERSION && nh_descsz == 4) {', '- \tif ((nh_namesz == 4 && strncmp((char *)&nbuf[noff], ""CORE"", 4) == 0) ||', '- \t    (nh_namesz == 5 && strcmp((char *)&nbuf[noff], ""CORE"") == 0)) {', '- \tif ((nh_namesz == 8 && strcmp((char *)&nbuf[noff], ""FreeBSD"") == 0)) {', '- \tif ((nh_namesz >= 11 && strncmp((char *)&nbuf[noff], ""NetBSD-CORE"", 11)', '- \t\t\t\tif (reloffset >= nh_descsz)', '- \t\tfile_printf(ms, "", corrupted section header size"");', '- \tsize_t offset;', '- \t\tfile_printf(ms, "", corrupted program header size"");', '- \t\t\t\t    (size_t)bufsize, class, swap, ph_align);']]",54,27.0,81.0,8bc0db989ccc07083a52c81de0dbad8598813a7ffile/file,"['d7cdad007c507e6c79f51f058dd77fab70ceb9f6', '39c7ac1106be844a5296d3eb5971946cc09ffda0']"
2196d0457488720ebc588652c8a769cb2db78572,LibRaw/LibRaw,dcraw.c,train,C++,0,"['@@ -3654,7 +3654,7 @@ void CLASS hat_transform (float *temp, float *base, int st, int size, int sc)\n     temp[i] = 2*base[st*i] + base[st*(i-sc)] + base[st*(2*size-2-(i+sc))];\n }\n \n-#ifndef _OPENMP || defined(__APPLE__) || defined(__MACOSX__)\n+#if !defined(_OPENMP) || defined(__APPLE__) || defined(__MACOSX__)\n void CLASS wavelet_denoise()\n {\n   float *fimg=0, *temp, thold, mul[2], avg, diff;\n@@ -9483,6 +9483,7 @@ void CLASS write_ppm_tiff()\n   }\n   free (ppm);\n }\n+\n //@end COMMON\n \n int CLASS main (int argc, const char **argv)\n']",,,"['+ #if !defined(_OPENMP) || defined(__APPLE__) || defined(__MACOSX__)', '- #ifndef _OPENMP || defined(__APPLE__) || defined(__MACOSX__)']","['+ #if !defined(_openmp) || defined(__apple__) || defined(__macosx__)', '- #ifndef _openmp || defined(__apple__) || defined(__macosx__)']",['+ #if !defined(_OPENMP) || defined(__APPLE__) || defined(__MACOSX__)'],['- #ifndef _OPENMP || defined(__APPLE__) || defined(__MACOSX__)'],1,1.0,2.0,2196d0457488720ebc588652c8a769cb2db78572LibRaw/LibRaw,[]
b7effd4e8338f6ed5bda630ad7ed0809bf458648,FFmpeg/FFmpeg,libavformat/ape.c,train,C,1,"['@@ -162,11 +162,11 @@ static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n     /* TODO: Skip any leading junk such as id3v2 tags */\n     ape->junklength = 0;\n \n-    tag = get_le32(pb);\n+    tag = avio_rl32(pb);\n     if (tag != MKTAG(\'M\', \'A\', \'C\', \' \'))\n         return -1;\n \n-    ape->fileversion = get_le16(pb);\n+    ape->fileversion = avio_rl16(pb);\n \n     if (ape->fileversion < APE_MIN_VERSION || ape->fileversion > APE_MAX_VERSION) {\n         av_log(s, AV_LOG_ERROR, ""Unsupported file version - %d.%02d\\n"", ape->fileversion / 1000, (ape->fileversion % 1000) / 10);\n@@ -174,15 +174,15 @@ static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n     }\n \n     if (ape->fileversion >= 3980) {\n-        ape->padding1             = get_le16(pb);\n-        ape->descriptorlength     = get_le32(pb);\n-        ape->headerlength         = get_le32(pb);\n-        ape->seektablelength      = get_le32(pb);\n-        ape->wavheaderlength      = get_le32(pb);\n-        ape->audiodatalength      = get_le32(pb);\n-        ape->audiodatalength_high = get_le32(pb);\n-        ape->wavtaillength        = get_le32(pb);\n-        get_buffer(pb, ape->md5, 16);\n+        ape->padding1             = avio_rl16(pb);\n+        ape->descriptorlength     = avio_rl32(pb);\n+        ape->headerlength         = avio_rl32(pb);\n+        ape->seektablelength      = avio_rl32(pb);\n+        ape->wavheaderlength      = avio_rl32(pb);\n+        ape->audiodatalength      = avio_rl32(pb);\n+        ape->audiodatalength_high = avio_rl32(pb);\n+        ape->wavtaillength        = avio_rl32(pb);\n+        avio_read(pb, ape->md5, 16);\n \n         /* Skip any unknown bytes at the end of the descriptor.\n            This is for future compatibility */\n@@ -190,26 +190,26 @@ static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n             url_fseek(pb, ape->descriptorlength - 52, SEEK_CUR);\n \n         /* Read header data */\n-        ape->compressiontype      = get_le16(pb);\n-        ape->formatflags          = get_le16(pb);\n-        ape->blocksperframe       = get_le32(pb);\n-        ape->finalframeblocks     = get_le32(pb);\n-        ape->totalframes          = get_le32(pb);\n-        ape->bps                  = get_le16(pb);\n-        ape->channels             = get_le16(pb);\n-        ape->samplerate           = get_le32(pb);\n+        ape->compressiontype      = avio_rl16(pb);\n+        ape->formatflags          = avio_rl16(pb);\n+        ape->blocksperframe       = avio_rl32(pb);\n+        ape->finalframeblocks     = avio_rl32(pb);\n+        ape->totalframes          = avio_rl32(pb);\n+        ape->bps                  = avio_rl16(pb);\n+        ape->channels             = avio_rl16(pb);\n+        ape->samplerate           = avio_rl32(pb);\n     } else {\n         ape->descriptorlength = 0;\n         ape->headerlength = 32;\n \n-        ape->compressiontype      = get_le16(pb);\n-        ape->formatflags          = get_le16(pb);\n-        ape->channels             = get_le16(pb);\n-        ape->samplerate           = get_le32(pb);\n-        ape->wavheaderlength      = get_le32(pb);\n-        ape->wavtaillength        = get_le32(pb);\n-        ape->totalframes          = get_le32(pb);\n-        ape->finalframeblocks     = get_le32(pb);\n+        ape->compressiontype      = avio_rl16(pb);\n+        ape->formatflags          = avio_rl16(pb);\n+        ape->channels             = avio_rl16(pb);\n+        ape->samplerate           = avio_rl32(pb);\n+        ape->wavheaderlength      = avio_rl32(pb);\n+        ape->wavtaillength        = avio_rl32(pb);\n+        ape->totalframes          = avio_rl32(pb);\n+        ape->finalframeblocks     = avio_rl32(pb);\n \n         if (ape->formatflags & MAC_FORMAT_FLAG_HAS_PEAK_LEVEL) {\n             url_fseek(pb, 4, SEEK_CUR); /* Skip the peak level */\n@@ -217,7 +217,7 @@ static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n         }\n \n         if (ape->formatflags & MAC_FORMAT_FLAG_HAS_SEEK_ELEMENTS) {\n-            ape->seektablelength = get_le32(pb);\n+            ape->seektablelength = avio_rl32(pb);\n             ape->headerlength += 4;\n             ape->seektablelength *= sizeof(int32_t);\n         } else\n@@ -260,7 +260,7 @@ static int ape_read_header(AVFormatContext * s, AVFormatParameters * ap)\n     if (ape->seektablelength > 0) {\n         ape->seektable = av_malloc(ape->seektablelength);\n         for (i = 0; i < ape->seektablelength / sizeof(uint32_t); i++)\n-            ape->seektable[i] = get_le32(pb);\n+            ape->seektable[i] = avio_rl32(pb);\n     }\n \n     ape->frames[0].pos     = ape->firstframe;\n@@ -355,7 +355,7 @@ static int ape_read_packet(AVFormatContext * s, AVPacket * pkt)\n \n     AV_WL32(pkt->data    , nblocks);\n     AV_WL32(pkt->data + 4, ape->frames[ape->currentframe].skip);\n-    ret = get_buffer(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);\n+    ret = avio_read(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);\n \n     pkt->pts = ape->frames[ape->currentframe].pts;\n     pkt->stream_index = 0;\n']",2011-02-21 11:23:22-05:00,"avio: avio_ prefixes for get_* functions

In the name of consistency:
get_byte           -> avio_r8
get_<type>         -> avio_r<type>
get_buffer         -> avio_read

get_partial_buffer will be made private later

get_strz is left out becase I want to change it later to return
something useful.

Signed-off-by: Ronald S. Bultje <rsbultje@gmail.com>","[['+     tag = avio_rl32(pb);', '+     ape->fileversion = avio_rl16(pb);', '+         ape->padding1             = avio_rl16(pb);', '+         ape->descriptorlength     = avio_rl32(pb);', '+         ape->headerlength         = avio_rl32(pb);', '+         ape->seektablelength      = avio_rl32(pb);', '+         ape->wavheaderlength      = avio_rl32(pb);', '+         ape->audiodatalength      = avio_rl32(pb);', '+         ape->audiodatalength_high = avio_rl32(pb);', '+         ape->wavtaillength        = avio_rl32(pb);', '+         avio_read(pb, ape->md5, 16);', '+         ape->compressiontype      = avio_rl16(pb);', '+         ape->formatflags          = avio_rl16(pb);', '+         ape->blocksperframe       = avio_rl32(pb);', '+         ape->finalframeblocks     = avio_rl32(pb);', '+         ape->totalframes          = avio_rl32(pb);', '+         ape->bps                  = avio_rl16(pb);', '+         ape->channels             = avio_rl16(pb);', '+         ape->samplerate           = avio_rl32(pb);', '+         ape->compressiontype      = avio_rl16(pb);', '+         ape->formatflags          = avio_rl16(pb);', '+         ape->channels             = avio_rl16(pb);', '+         ape->samplerate           = avio_rl32(pb);', '+         ape->wavheaderlength      = avio_rl32(pb);', '+         ape->wavtaillength        = avio_rl32(pb);', '+         ape->totalframes          = avio_rl32(pb);', '+         ape->finalframeblocks     = avio_rl32(pb);', '+             ape->seektablelength = avio_rl32(pb);', '+             ape->seektable[i] = avio_rl32(pb);', '+     ret = avio_read(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);', '-     tag = get_le32(pb);', '-     ape->fileversion = get_le16(pb);', '-         ape->padding1             = get_le16(pb);', '-         ape->descriptorlength     = get_le32(pb);', '-         ape->headerlength         = get_le32(pb);', '-         ape->seektablelength      = get_le32(pb);', '-         ape->wavheaderlength      = get_le32(pb);', '-         ape->audiodatalength      = get_le32(pb);', '-         ape->audiodatalength_high = get_le32(pb);', '-         ape->wavtaillength        = get_le32(pb);', '-         get_buffer(pb, ape->md5, 16);', '-         ape->compressiontype      = get_le16(pb);', '-         ape->formatflags          = get_le16(pb);', '-         ape->blocksperframe       = get_le32(pb);', '-         ape->finalframeblocks     = get_le32(pb);', '-         ape->totalframes          = get_le32(pb);', '-         ape->bps                  = get_le16(pb);', '-         ape->channels             = get_le16(pb);', '-         ape->samplerate           = get_le32(pb);', '-         ape->compressiontype      = get_le16(pb);', '-         ape->formatflags          = get_le16(pb);', '-         ape->channels             = get_le16(pb);', '-         ape->samplerate           = get_le32(pb);', '-         ape->wavheaderlength      = get_le32(pb);', '-         ape->wavtaillength        = get_le32(pb);', '-         ape->totalframes          = get_le32(pb);', '-         ape->finalframeblocks     = get_le32(pb);', '-             ape->seektablelength = get_le32(pb);', '-             ape->seektable[i] = get_le32(pb);', '-     ret = get_buffer(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);']]","[['+     tag = avio_rl32(pb);', '+     ape->fileversion = avio_rl16(pb);', '+         ape->padding1             = avio_rl16(pb);', '+         ape->descriptorlength     = avio_rl32(pb);', '+         ape->headerlength         = avio_rl32(pb);', '+         ape->seektablelength      = avio_rl32(pb);', '+         ape->wavheaderlength      = avio_rl32(pb);', '+         ape->audiodatalength      = avio_rl32(pb);', '+         ape->audiodatalength_high = avio_rl32(pb);', '+         ape->wavtaillength        = avio_rl32(pb);', '+         avio_read(pb, ape->md5, 16);', '+         ape->compressiontype      = avio_rl16(pb);', '+         ape->formatflags          = avio_rl16(pb);', '+         ape->blocksperframe       = avio_rl32(pb);', '+         ape->finalframeblocks     = avio_rl32(pb);', '+         ape->totalframes          = avio_rl32(pb);', '+         ape->bps                  = avio_rl16(pb);', '+         ape->channels             = avio_rl16(pb);', '+         ape->samplerate           = avio_rl32(pb);', '+         ape->compressiontype      = avio_rl16(pb);', '+         ape->formatflags          = avio_rl16(pb);', '+         ape->channels             = avio_rl16(pb);', '+         ape->samplerate           = avio_rl32(pb);', '+         ape->wavheaderlength      = avio_rl32(pb);', '+         ape->wavtaillength        = avio_rl32(pb);', '+         ape->totalframes          = avio_rl32(pb);', '+         ape->finalframeblocks     = avio_rl32(pb);', '+             ape->seektablelength = avio_rl32(pb);', '+             ape->seektable[i] = avio_rl32(pb);', '+     ret = avio_read(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);', '-     tag = get_le32(pb);', '-     ape->fileversion = get_le16(pb);', '-         ape->padding1             = get_le16(pb);', '-         ape->descriptorlength     = get_le32(pb);', '-         ape->headerlength         = get_le32(pb);', '-         ape->seektablelength      = get_le32(pb);', '-         ape->wavheaderlength      = get_le32(pb);', '-         ape->audiodatalength      = get_le32(pb);', '-         ape->audiodatalength_high = get_le32(pb);', '-         ape->wavtaillength        = get_le32(pb);', '-         get_buffer(pb, ape->md5, 16);', '-         ape->compressiontype      = get_le16(pb);', '-         ape->formatflags          = get_le16(pb);', '-         ape->blocksperframe       = get_le32(pb);', '-         ape->finalframeblocks     = get_le32(pb);', '-         ape->totalframes          = get_le32(pb);', '-         ape->bps                  = get_le16(pb);', '-         ape->channels             = get_le16(pb);', '-         ape->samplerate           = get_le32(pb);', '-         ape->compressiontype      = get_le16(pb);', '-         ape->formatflags          = get_le16(pb);', '-         ape->channels             = get_le16(pb);', '-         ape->samplerate           = get_le32(pb);', '-         ape->wavheaderlength      = get_le32(pb);', '-         ape->wavtaillength        = get_le32(pb);', '-         ape->totalframes          = get_le32(pb);', '-         ape->finalframeblocks     = get_le32(pb);', '-             ape->seektablelength = get_le32(pb);', '-             ape->seektable[i] = get_le32(pb);', '-     ret = get_buffer(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);']]","[['+     tag = avio_rl32(pb);', '+     ape->fileversion = avio_rl16(pb);', '+         ape->padding1             = avio_rl16(pb);', '+         ape->descriptorlength     = avio_rl32(pb);', '+         ape->headerlength         = avio_rl32(pb);', '+         ape->seektablelength      = avio_rl32(pb);', '+         ape->wavheaderlength      = avio_rl32(pb);', '+         ape->audiodatalength      = avio_rl32(pb);', '+         ape->audiodatalength_high = avio_rl32(pb);', '+         ape->wavtaillength        = avio_rl32(pb);', '+         avio_read(pb, ape->md5, 16);', '+         ape->compressiontype      = avio_rl16(pb);', '+         ape->formatflags          = avio_rl16(pb);', '+         ape->blocksperframe       = avio_rl32(pb);', '+         ape->finalframeblocks     = avio_rl32(pb);', '+         ape->totalframes          = avio_rl32(pb);', '+         ape->bps                  = avio_rl16(pb);', '+         ape->channels             = avio_rl16(pb);', '+         ape->samplerate           = avio_rl32(pb);', '+         ape->compressiontype      = avio_rl16(pb);', '+         ape->formatflags          = avio_rl16(pb);', '+         ape->channels             = avio_rl16(pb);', '+         ape->samplerate           = avio_rl32(pb);', '+         ape->wavheaderlength      = avio_rl32(pb);', '+         ape->wavtaillength        = avio_rl32(pb);', '+         ape->totalframes          = avio_rl32(pb);', '+         ape->finalframeblocks     = avio_rl32(pb);', '+             ape->seektablelength = avio_rl32(pb);', '+             ape->seektable[i] = avio_rl32(pb);', '+     ret = avio_read(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);']]","[['-     tag = get_le32(pb);', '-     ape->fileversion = get_le16(pb);', '-         ape->padding1             = get_le16(pb);', '-         ape->descriptorlength     = get_le32(pb);', '-         ape->headerlength         = get_le32(pb);', '-         ape->seektablelength      = get_le32(pb);', '-         ape->wavheaderlength      = get_le32(pb);', '-         ape->audiodatalength      = get_le32(pb);', '-         ape->audiodatalength_high = get_le32(pb);', '-         ape->wavtaillength        = get_le32(pb);', '-         get_buffer(pb, ape->md5, 16);', '-         ape->compressiontype      = get_le16(pb);', '-         ape->formatflags          = get_le16(pb);', '-         ape->blocksperframe       = get_le32(pb);', '-         ape->finalframeblocks     = get_le32(pb);', '-         ape->totalframes          = get_le32(pb);', '-         ape->bps                  = get_le16(pb);', '-         ape->channels             = get_le16(pb);', '-         ape->samplerate           = get_le32(pb);', '-         ape->compressiontype      = get_le16(pb);', '-         ape->formatflags          = get_le16(pb);', '-         ape->channels             = get_le16(pb);', '-         ape->samplerate           = get_le32(pb);', '-         ape->wavheaderlength      = get_le32(pb);', '-         ape->wavtaillength        = get_le32(pb);', '-         ape->totalframes          = get_le32(pb);', '-         ape->finalframeblocks     = get_le32(pb);', '-             ape->seektablelength = get_le32(pb);', '-             ape->seektable[i] = get_le32(pb);', '-     ret = get_buffer(s->pb, pkt->data + extra_size, ape->frames[ape->currentframe].size);']]",30,30.0,60.0,b7effd4e8338f6ed5bda630ad7ed0809bf458648FFmpeg/FFmpeg,['8312e3fc9041027a33c8bc667bb99740fdf41dd5']
d87bfc277858543ff14cd43f4222c66362464094,inspircd/inspircd,src/modules/m_sasl.cpp,train,C++,1,"['@@ -52,7 +52,7 @@ class SaslAuthenticator\n \tbool state_announced;\n \n  public:\n-\tSaslAuthenticator(User *user_, std::string method, Module *ctor)\n+\tSaslAuthenticator(User* user_, const std::string& method)\n \t\t: user(user_), state(SASL_INIT), state_announced(false)\n \t{\n \t\tparameterlist params;\n@@ -195,7 +195,7 @@ class CommandAuthenticate : public Command\n \n \t\t\tSaslAuthenticator *sasl = authExt.get(user);\n \t\t\tif (!sasl)\n-\t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0], creator));\n+\t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0]));\n \t\t\telse if (sasl->SendClientMessage(parameters) == false)\t// IAL abort extension --nenolod\n \t\t\t{\n \t\t\t\tsasl->AnnounceState();\n']",2013-06-05 23:11:50+02:00,Remove unnecessary string copies and dead code,"[['+ \tSaslAuthenticator(User* user_, const std::string& method)', '+ \t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0]));', '- \tSaslAuthenticator(User *user_, std::string method, Module *ctor)', '- \t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0], creator));']]","[['+ \tsaslauthenticator(user* user_, const std::string& method)', '+ \t\t\t\tauthext.set(user, new saslauthenticator(user, parameters[0]));', '- \tsaslauthenticator(user *user_, std::string method, module *ctor)', '- \t\t\t\tauthext.set(user, new saslauthenticator(user, parameters[0], creator));']]","[['+ \tSaslAuthenticator(User* user_, const std::string& method)', '+ \t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0]));']]","[['- \tSaslAuthenticator(User *user_, std::string method, Module *ctor)', '- \t\t\t\tauthExt.set(user, new SaslAuthenticator(user, parameters[0], creator));']]",2,2.0,4.0,d87bfc277858543ff14cd43f4222c66362464094inspircd/inspircd,['74fafb7f11b06747f69f182ad5e3769b665eea7a']
014ac7aa42b1ad1c62fa15366bc8fc2b3ef97488,inspircd/inspircd,modules.cpp,train,C++,0,"['@@ -30,6 +30,9 @@ void Module::OnUserConnect(userrec* user) { }\n void Module::OnUserQuit(userrec* user) { }\n void Module::OnUserJoin(userrec* user, chanrec* channel) { }\n void Module::OnUserPart(userrec* user, chanrec* channel) { }\n+void Module::OnPacketTransmit(char *p) { }\n+void Module::OnPacketReceive(char *p) { }\n+void Module::OnRehash() { }\n Version Module::GetVersion() { return Version(1,0,0,0); }\n \n // server is a wrapper class that provides methods to all of the C-style\n@@ -49,9 +52,9 @@ void Server::SendOpers(string s)\n \tWriteOpers(""%s"",s.c_str());\n }\n \n-void Server::Debug(string s)\n+void Server::Log(int level, string s)\n {\n-\tdebug(""%s"",s.c_str());\n+\tlog(level,""%s"",s.c_str());\n }\n \n void Server::Send(int Socket, string s)\n@@ -214,3 +217,9 @@ int FileReader::FileSize()\n }\n \n \n+vector<Module*> modules(255);\n+vector<ircd_module*> factory(255);\n+\n+int MODCOUNT  = -1;\n+\n+\n']",,,"['+ void Module::OnPacketTransmit(char *p) { }', '+ void Module::OnPacketReceive(char *p) { }', '+ void Module::OnRehash() { }', '+ void Server::Log(int level, string s)', '+ \tlog(level,""%s"",s.c_str());', '+ vector<Module*> modules(255);', '+ vector<ircd_module*> factory(255);', '+ int MODCOUNT  = -1;', '- void Server::Debug(string s)', '- \tdebug(""%s"",s.c_str());']","['+ void module::onpackettransmit(char *p) { }', '+ void module::onpacketreceive(char *p) { }', '+ void module::onrehash() { }', '+ void server::log(int level, string s)', '+ \tlog(level,""%s"",s.c_str());', '+ vector<module*> modules(255);', '+ vector<ircd_module*> factory(255);', '+ int modcount  = -1;', '- void server::debug(string s)', '- \tdebug(""%s"",s.c_str());']","['+ void Module::OnPacketTransmit(char *p) { }', '+ void Module::OnPacketReceive(char *p) { }', '+ void Module::OnRehash() { }', '+ void Server::Log(int level, string s)', '+ \tlog(level,""%s"",s.c_str());', '+ vector<Module*> modules(255);', '+ vector<ircd_module*> factory(255);', '+ int MODCOUNT  = -1;']","['- void Server::Debug(string s)', '- \tdebug(""%s"",s.c_str());']",8,2.0,10.0,014ac7aa42b1ad1c62fa15366bc8fc2b3ef97488inspircd/inspircd,[]
1aec04dbf8a24b8a6ba64c4f74efa0628e36db0b,file/file,src/cdf.c,train,C,1,"['@@ -35,7 +35,7 @@\n #include ""file.h""\n \n #ifndef lint\n-FILE_RCSID(""@(#)$File: cdf.c,v 1.48 2012/02/17 05:27:45 christos Exp $"")\n+FILE_RCSID(""@(#)$File: cdf.c,v 1.49 2012/02/20 20:04:37 christos Exp $"")\n #endif\n \n #include <assert.h>\n@@ -75,6 +75,7 @@ static union {\n #define CDF_TOLE2(x)\t((uint16_t)(NEED_SWAP ? _cdf_tole2(x) : (uint16_t)(x)))\n #define CDF_GETUINT32(x, y)\tcdf_getuint32(x, y)\n \n+\n /*\n  * swap a short\n  */\n@@ -351,13 +352,13 @@ ssize_t\n cdf_read_short_sector(const cdf_stream_t *sst, void *buf, size_t offs,\n     size_t len, const cdf_header_t *h, cdf_secid_t id)\n {\n-\tsize_t ss = CDF_SEC_SIZE(h);\n+\tsize_t ss = CDF_SHORT_SEC_SIZE(h);\n \tsize_t pos = CDF_SHORT_SEC_POS(h, id);\n \tassert(ss == len);\n-\tif (pos > ss * sst->sst_len) {\n+\tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {\n \t\tDPRINTF((""Out of bounds read %"" SIZE_T_FORMAT ""u > %""\n \t\t    SIZE_T_FORMAT ""u\\n"",\n-\t\t    pos, ss * sst->sst_len));\n+\t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));\n \t\treturn -1;\n \t}\n \t(void)memcpy(((char *)buf) + offs,\n@@ -529,7 +530,7 @@ cdf_read_short_sector_chain(const cdf_header_t *h,\n     const cdf_sat_t *ssat, const cdf_stream_t *sst,\n     cdf_secid_t sid, size_t len, cdf_stream_t *scn)\n {\n-\tsize_t ss = CDF_SEC_SIZE(h), i, j;\n+\tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;\n \tscn->sst_len = cdf_count_chain(ssat, sid, CDF_SEC_SIZE(h));\n \tscn->sst_dirlen = len;\n \n@@ -798,18 +799,18 @@ cdf_read_property_info(const cdf_stream_t *sst, const cdf_header_t *h,\n \tif (cdf_check_stream_offset(sst, h, e, 0, __LINE__) == -1)\n \t\tgoto out;\n \tfor (i = 0; i < sh.sh_properties; i++) {\n+\t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);\n \t\tq = (const uint8_t *)(const void *)\n-\t\t    ((const char *)(const void *)p +\n-\t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);\n+\t\t    ((const char *)(const void *)p + ofs\n+\t\t    - 2 * sizeof(uint32_t));\n \t\tif (q > e) {\n \t\t\tDPRINTF((""Ran of the end %p > %p\\n"", q, e));\n \t\t\tgoto out;\n \t\t}\n \t\tinp[i].pi_id = CDF_GETUINT32(p, i << 1);\n \t\tinp[i].pi_type = CDF_GETUINT32(q, 0);\n-\t\tDPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\\n"", i,\n-\t\t    inp[i].pi_id, inp[i].pi_type, q - p,\n-\t\t    CDF_GETUINT32(p, (i << 1) + 1)));\n+\t\tDPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\\n"",\n+\t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));\n \t\tif (inp[i].pi_type & CDF_VECTOR) {\n \t\t\tnelements = CDF_GETUINT32(q, 1);\n \t\t\to = 2;\n']",2012-02-20 22:35:29+00:00,Fix bounds checks again.,"[['+ FILE_RCSID(""@(#)$File: cdf.c,v 1.49 2012/02/20 20:04:37 christos Exp $"")', '+ ', '+ \tsize_t ss = CDF_SHORT_SEC_SIZE(h);', '+ \tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {', '+ \t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));', '+ \tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;', '+ \t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);', '+ \t\t    ((const char *)(const void *)p + ofs', '+ \t\t    - 2 * sizeof(uint32_t));', '+ \t\tDPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\\n"",', '+ \t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));', '- FILE_RCSID(""@(#)$File: cdf.c,v 1.48 2012/02/17 05:27:45 christos Exp $"")', '- \tsize_t ss = CDF_SEC_SIZE(h);', '- \tif (pos > ss * sst->sst_len) {', '- \t\t    pos, ss * sst->sst_len));', '- \tsize_t ss = CDF_SEC_SIZE(h), i, j;', '- \t\t    ((const char *)(const void *)p +', '- \t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);', '- \t\tDPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\\n"", i,', '- \t\t    inp[i].pi_id, inp[i].pi_type, q - p,', '- \t\t    CDF_GETUINT32(p, (i << 1) + 1)));']]","[['+ file_rcsid(""@(#)$file: cdf.c,v 1.49 2012/02/20 20:04:37 christos exp $"")', '+ ', '+ \tsize_t ss = cdf_short_sec_size(h);', '+ \tif (pos > cdf_sec_size(h) * sst->sst_len) {', '+ \t\t    pos, cdf_sec_size(h) * sst->sst_len));', '+ \tsize_t ss = cdf_short_sec_size(h), i, j;', '+ \t\tsize_t ofs = cdf_getuint32(p, (i << 1) + 1);', '+ \t\t    ((const char *)(const void *)p + ofs', '+ \t\t    - 2 * sizeof(uint32_t));', '+ \t\tdprintf((""%"" size_t_format ""u) id=%x type=%x offs=0x%tx,0x%x\\n"",', '+ \t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));', '- file_rcsid(""@(#)$file: cdf.c,v 1.48 2012/02/17 05:27:45 christos exp $"")', '- \tsize_t ss = cdf_sec_size(h);', '- \tif (pos > ss * sst->sst_len) {', '- \t\t    pos, ss * sst->sst_len));', '- \tsize_t ss = cdf_sec_size(h), i, j;', '- \t\t    ((const char *)(const void *)p +', '- \t\t    cdf_getuint32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);', '- \t\tdprintf((""%"" size_t_format ""u) id=%x type=%x offs=0x%tx,0x%x\\n"", i,', '- \t\t    inp[i].pi_id, inp[i].pi_type, q - p,', '- \t\t    cdf_getuint32(p, (i << 1) + 1)));']]","[['+ FILE_RCSID(""@(#)$File: cdf.c,v 1.49 2012/02/20 20:04:37 christos Exp $"")', '+ ', '+ \tsize_t ss = CDF_SHORT_SEC_SIZE(h);', '+ \tif (pos > CDF_SEC_SIZE(h) * sst->sst_len) {', '+ \t\t    pos, CDF_SEC_SIZE(h) * sst->sst_len));', '+ \tsize_t ss = CDF_SHORT_SEC_SIZE(h), i, j;', '+ \t\tsize_t ofs = CDF_GETUINT32(p, (i << 1) + 1);', '+ \t\t    ((const char *)(const void *)p + ofs', '+ \t\t    - 2 * sizeof(uint32_t));', '+ \t\tDPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\\n"",', '+ \t\t    i, inp[i].pi_id, inp[i].pi_type, q - p, offs));']]","[['- FILE_RCSID(""@(#)$File: cdf.c,v 1.48 2012/02/17 05:27:45 christos Exp $"")', '- \tsize_t ss = CDF_SEC_SIZE(h);', '- \tif (pos > ss * sst->sst_len) {', '- \t\t    pos, ss * sst->sst_len));', '- \tsize_t ss = CDF_SEC_SIZE(h), i, j;', '- \t\t    ((const char *)(const void *)p +', '- \t\t    CDF_GETUINT32(p, (i << 1) + 1)) - 2 * sizeof(uint32_t);', '- \t\tDPRINTF((""%"" SIZE_T_FORMAT ""u) id=%x type=%x offs=0x%tx,0x%x\\n"", i,', '- \t\t    inp[i].pi_id, inp[i].pi_type, q - p,', '- \t\t    CDF_GETUINT32(p, (i << 1) + 1)));']]",11,10.0,21.0,1aec04dbf8a24b8a6ba64c4f74efa0628e36db0bfile/file,['93e063ee374b6a75729df9e7201fb511e47e259d']
